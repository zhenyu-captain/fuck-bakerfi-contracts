/home/mi/miniconda3/envs/bakerfi/lib/python3.11/site-packages/slither/utils/output.py:10: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  from pkg_resources import require
'npx hardhat clean' running (wd: /home/mi/fuck-bakerfi-contracts/b-pre-mitigation)
'npx hardhat clean --global' running (wd: /home/mi/fuck-bakerfi-contracts/b-pre-mitigation)
'npx hardhat compile --force' running (wd: /home/mi/fuck-bakerfi-contracts/b-pre-mitigation)
INFO:Printers:Contract IIrm
	Function IIrm.borrowRate(MarketParams,Market) (*)
	Function IIrm.borrowRateView(MarketParams,Market) (*)
Contract IMorphoBase
	Function IMorphoBase.DOMAIN_SEPARATOR() (*)
	Function IMorphoBase.owner() (*)
	Function IMorphoBase.feeRecipient() (*)
	Function IMorphoBase.isIrmEnabled(address) (*)
	Function IMorphoBase.isLltvEnabled(uint256) (*)
	Function IMorphoBase.isAuthorized(address,address) (*)
	Function IMorphoBase.nonce(address) (*)
	Function IMorphoBase.setOwner(address) (*)
	Function IMorphoBase.enableIrm(address) (*)
	Function IMorphoBase.enableLltv(uint256) (*)
	Function IMorphoBase.setFee(MarketParams,uint256) (*)
	Function IMorphoBase.setFeeRecipient(address) (*)
	Function IMorphoBase.createMarket(MarketParams) (*)
	Function IMorphoBase.supply(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.withdraw(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.borrow(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.repay(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.supplyCollateral(MarketParams,uint256,address,bytes) (*)
	Function IMorphoBase.withdrawCollateral(MarketParams,uint256,address,address) (*)
	Function IMorphoBase.liquidate(MarketParams,address,uint256,uint256,bytes) (*)
	Function IMorphoBase.flashLoan(address,uint256,bytes) (*)
	Function IMorphoBase.setAuthorization(address,bool) (*)
	Function IMorphoBase.setAuthorizationWithSig(Authorization,Signature) (*)
	Function IMorphoBase.accrueInterest(MarketParams) (*)
	Function IMorphoBase.extSloads(bytes32[]) (*)
Contract IMorphoStaticTyping
	Function IMorphoBase.DOMAIN_SEPARATOR() (*)
	Function IMorphoBase.owner() (*)
	Function IMorphoBase.feeRecipient() (*)
	Function IMorphoBase.isIrmEnabled(address) (*)
	Function IMorphoBase.isLltvEnabled(uint256) (*)
	Function IMorphoBase.isAuthorized(address,address) (*)
	Function IMorphoBase.nonce(address) (*)
	Function IMorphoBase.setOwner(address) (*)
	Function IMorphoBase.enableIrm(address) (*)
	Function IMorphoBase.enableLltv(uint256) (*)
	Function IMorphoBase.setFee(MarketParams,uint256) (*)
	Function IMorphoBase.setFeeRecipient(address) (*)
	Function IMorphoBase.createMarket(MarketParams) (*)
	Function IMorphoBase.supply(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.withdraw(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.borrow(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.repay(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.supplyCollateral(MarketParams,uint256,address,bytes) (*)
	Function IMorphoBase.withdrawCollateral(MarketParams,uint256,address,address) (*)
	Function IMorphoBase.liquidate(MarketParams,address,uint256,uint256,bytes) (*)
	Function IMorphoBase.flashLoan(address,uint256,bytes) (*)
	Function IMorphoBase.setAuthorization(address,bool) (*)
	Function IMorphoBase.setAuthorizationWithSig(Authorization,Signature) (*)
	Function IMorphoBase.accrueInterest(MarketParams) (*)
	Function IMorphoBase.extSloads(bytes32[]) (*)
	Function IMorphoStaticTyping.position(Id,address) (*)
	Function IMorphoStaticTyping.market(Id) (*)
	Function IMorphoStaticTyping.idToMarketParams(Id) (*)
Contract IMorpho
	Function IMorphoBase.DOMAIN_SEPARATOR() (*)
	Function IMorphoBase.owner() (*)
	Function IMorphoBase.feeRecipient() (*)
	Function IMorphoBase.isIrmEnabled(address) (*)
	Function IMorphoBase.isLltvEnabled(uint256) (*)
	Function IMorphoBase.isAuthorized(address,address) (*)
	Function IMorphoBase.nonce(address) (*)
	Function IMorphoBase.setOwner(address) (*)
	Function IMorphoBase.enableIrm(address) (*)
	Function IMorphoBase.enableLltv(uint256) (*)
	Function IMorphoBase.setFee(MarketParams,uint256) (*)
	Function IMorphoBase.setFeeRecipient(address) (*)
	Function IMorphoBase.createMarket(MarketParams) (*)
	Function IMorphoBase.supply(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.withdraw(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.borrow(MarketParams,uint256,uint256,address,address) (*)
	Function IMorphoBase.repay(MarketParams,uint256,uint256,address,bytes) (*)
	Function IMorphoBase.supplyCollateral(MarketParams,uint256,address,bytes) (*)
	Function IMorphoBase.withdrawCollateral(MarketParams,uint256,address,address) (*)
	Function IMorphoBase.liquidate(MarketParams,address,uint256,uint256,bytes) (*)
	Function IMorphoBase.flashLoan(address,uint256,bytes) (*)
	Function IMorphoBase.setAuthorization(address,bool) (*)
	Function IMorphoBase.setAuthorizationWithSig(Authorization,Signature) (*)
	Function IMorphoBase.accrueInterest(MarketParams) (*)
	Function IMorphoBase.extSloads(bytes32[]) (*)
	Function IMorpho.position(Id,address) (*)
	Function IMorpho.market(Id) (*)
	Function IMorpho.idToMarketParams(Id) (*)
Contract ErrorsLib
	Function ErrorsLib.slitherConstructorConstantVariables() (*)
		Expression: NOT_OWNER = not owner
		IRs:
			NOT_OWNER(string) := not owner(string)
		Expression: MAX_LLTV_EXCEEDED = max LLTV exceeded
		IRs:
			MAX_LLTV_EXCEEDED(string) := max LLTV exceeded(string)
		Expression: MAX_FEE_EXCEEDED = max fee exceeded
		IRs:
			MAX_FEE_EXCEEDED(string) := max fee exceeded(string)
		Expression: ALREADY_SET = already set
		IRs:
			ALREADY_SET(string) := already set(string)
		Expression: IRM_NOT_ENABLED = IRM not enabled
		IRs:
			IRM_NOT_ENABLED(string) := IRM not enabled(string)
		Expression: LLTV_NOT_ENABLED = LLTV not enabled
		IRs:
			LLTV_NOT_ENABLED(string) := LLTV not enabled(string)
		Expression: MARKET_ALREADY_CREATED = market already created
		IRs:
			MARKET_ALREADY_CREATED(string) := market already created(string)
		Expression: NO_CODE = no code
		IRs:
			NO_CODE(string) := no code(string)
		Expression: MARKET_NOT_CREATED = market not created
		IRs:
			MARKET_NOT_CREATED(string) := market not created(string)
		Expression: INCONSISTENT_INPUT = inconsistent input
		IRs:
			INCONSISTENT_INPUT(string) := inconsistent input(string)
		Expression: ZERO_ASSETS = zero assets
		IRs:
			ZERO_ASSETS(string) := zero assets(string)
		Expression: ZERO_ADDRESS = zero address
		IRs:
			ZERO_ADDRESS(string) := zero address(string)
		Expression: UNAUTHORIZED = unauthorized
		IRs:
			UNAUTHORIZED(string) := unauthorized(string)
		Expression: INSUFFICIENT_COLLATERAL = insufficient collateral
		IRs:
			INSUFFICIENT_COLLATERAL(string) := insufficient collateral(string)
		Expression: INSUFFICIENT_LIQUIDITY = insufficient liquidity
		IRs:
			INSUFFICIENT_LIQUIDITY(string) := insufficient liquidity(string)
		Expression: HEALTHY_POSITION = position is healthy
		IRs:
			HEALTHY_POSITION(string) := position is healthy(string)
		Expression: INVALID_SIGNATURE = invalid signature
		IRs:
			INVALID_SIGNATURE(string) := invalid signature(string)
		Expression: SIGNATURE_EXPIRED = signature expired
		IRs:
			SIGNATURE_EXPIRED(string) := signature expired(string)
		Expression: INVALID_NONCE = invalid nonce
		IRs:
			INVALID_NONCE(string) := invalid nonce(string)
		Expression: TRANSFER_REVERTED = transfer reverted
		IRs:
			TRANSFER_REVERTED(string) := transfer reverted(string)
		Expression: TRANSFER_RETURNED_FALSE = transfer returned false
		IRs:
			TRANSFER_RETURNED_FALSE(string) := transfer returned false(string)
		Expression: TRANSFER_FROM_REVERTED = transferFrom reverted
		IRs:
			TRANSFER_FROM_REVERTED(string) := transferFrom reverted(string)
		Expression: TRANSFER_FROM_RETURNED_FALSE = transferFrom returned false
		IRs:
			TRANSFER_FROM_RETURNED_FALSE(string) := transferFrom returned false(string)
		Expression: MAX_UINT128_EXCEEDED = max uint128 exceeded
		IRs:
			MAX_UINT128_EXCEEDED(string) := max uint128 exceeded(string)
Contract MarketParamsLib
	Function MarketParamsLib.id(MarketParams) (*)
		Expression: marketParamsId = keccak256(uint256,uint256)(marketParams,MARKET_PARAMS_BYTES_LENGTH)
		IRs:
			TMP_0(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(marketParams,MARKET_PARAMS_BYTES_LENGTH)
			marketParamsId(Id) := TMP_0(uint256)
	Function MarketParamsLib.slitherConstructorConstantVariables() (*)
		Expression: MARKET_PARAMS_BYTES_LENGTH = 5 * 32
		IRs:
			TMP_1(uint256) = 5 (c)* 32
			MARKET_PARAMS_BYTES_LENGTH(uint256) := TMP_1(uint256)
Contract MathLib
	Function MathLib.wMulDown(uint256,uint256) (*)
		Expression: mulDivDown(x,y,WAD)
		IRs:
			TMP_2(uint256) = INTERNAL_CALL, MathLib.mulDivDown(uint256,uint256,uint256)(x,y,WAD)
			RETURN TMP_2
	Function MathLib.wDivDown(uint256,uint256) (*)
		Expression: mulDivDown(x,WAD,y)
		IRs:
			TMP_3(uint256) = INTERNAL_CALL, MathLib.mulDivDown(uint256,uint256,uint256)(x,WAD,y)
			RETURN TMP_3
	Function MathLib.wDivUp(uint256,uint256) (*)
		Expression: mulDivUp(x,WAD,y)
		IRs:
			TMP_4(uint256) = INTERNAL_CALL, MathLib.mulDivUp(uint256,uint256,uint256)(x,WAD,y)
			RETURN TMP_4
	Function MathLib.mulDivDown(uint256,uint256,uint256) (*)
		Expression: (x * y) / d
		IRs:
			TMP_5(uint256) = x (c)* y
			TMP_6(uint256) = TMP_5 (c)/ d
			RETURN TMP_6
	Function MathLib.mulDivUp(uint256,uint256,uint256) (*)
		Expression: (x * y + (d - 1)) / d
		IRs:
			TMP_7(uint256) = x (c)* y
			TMP_8(uint256) = d (c)- 1
			TMP_9(uint256) = TMP_7 (c)+ TMP_8
			TMP_10(uint256) = TMP_9 (c)/ d
			RETURN TMP_10
	Function MathLib.wTaylorCompounded(uint256,uint256) (*)
		Expression: firstTerm = x * n
		IRs:
			TMP_11(uint256) = x (c)* n
			firstTerm(uint256) := TMP_11(uint256)
		Expression: secondTerm = mulDivDown(firstTerm,firstTerm,2 * WAD)
		IRs:
			TMP_12(uint256) = 2 (c)* WAD
			TMP_13(uint256) = INTERNAL_CALL, MathLib.mulDivDown(uint256,uint256,uint256)(firstTerm,firstTerm,TMP_12)
			secondTerm(uint256) := TMP_13(uint256)
		Expression: thirdTerm = mulDivDown(secondTerm,firstTerm,3 * WAD)
		IRs:
			TMP_14(uint256) = 3 (c)* WAD
			TMP_15(uint256) = INTERNAL_CALL, MathLib.mulDivDown(uint256,uint256,uint256)(secondTerm,firstTerm,TMP_14)
			thirdTerm(uint256) := TMP_15(uint256)
		Expression: firstTerm + secondTerm + thirdTerm
		IRs:
			TMP_16(uint256) = firstTerm (c)+ secondTerm
			TMP_17(uint256) = TMP_16 (c)+ thirdTerm
			RETURN TMP_17
Contract SharesMathLib
	Function SharesMathLib.toSharesDown(uint256,uint256,uint256) (*)
		Expression: assets.mulDivDown(totalShares + VIRTUAL_SHARES,totalAssets + VIRTUAL_ASSETS)
		IRs:
			TMP_18(uint256) = totalShares (c)+ VIRTUAL_SHARES
			TMP_19(uint256) = totalAssets (c)+ VIRTUAL_ASSETS
			TMP_20(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.mulDivDown(uint256,uint256,uint256), arguments:['assets', 'TMP_18', 'TMP_19'] 
			RETURN TMP_20
	Function SharesMathLib.toAssetsDown(uint256,uint256,uint256) (*)
		Expression: shares.mulDivDown(totalAssets + VIRTUAL_ASSETS,totalShares + VIRTUAL_SHARES)
		IRs:
			TMP_21(uint256) = totalAssets (c)+ VIRTUAL_ASSETS
			TMP_22(uint256) = totalShares (c)+ VIRTUAL_SHARES
			TMP_23(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.mulDivDown(uint256,uint256,uint256), arguments:['shares', 'TMP_21', 'TMP_22'] 
			RETURN TMP_23
	Function SharesMathLib.toSharesUp(uint256,uint256,uint256) (*)
		Expression: assets.mulDivUp(totalShares + VIRTUAL_SHARES,totalAssets + VIRTUAL_ASSETS)
		IRs:
			TMP_24(uint256) = totalShares (c)+ VIRTUAL_SHARES
			TMP_25(uint256) = totalAssets (c)+ VIRTUAL_ASSETS
			TMP_26(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.mulDivUp(uint256,uint256,uint256), arguments:['assets', 'TMP_24', 'TMP_25'] 
			RETURN TMP_26
	Function SharesMathLib.toAssetsUp(uint256,uint256,uint256) (*)
		Expression: shares.mulDivUp(totalAssets + VIRTUAL_ASSETS,totalShares + VIRTUAL_SHARES)
		IRs:
			TMP_27(uint256) = totalAssets (c)+ VIRTUAL_ASSETS
			TMP_28(uint256) = totalShares (c)+ VIRTUAL_SHARES
			TMP_29(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.mulDivUp(uint256,uint256,uint256), arguments:['shares', 'TMP_27', 'TMP_28'] 
			RETURN TMP_29
	Function SharesMathLib.slitherConstructorConstantVariables() (*)
		Expression: VIRTUAL_SHARES = 1e6
		IRs:
			VIRTUAL_SHARES(uint256) := 1000000(uint256)
		Expression: VIRTUAL_ASSETS = 1
		IRs:
			VIRTUAL_ASSETS(uint256) := 1(uint256)
Contract UtilsLib
	Function UtilsLib.exactlyOneZero(uint256,uint256) (*)
		Expression: z = ! x ^ ! y
		IRs:
			TMP_30 = UnaryType.BANG x 
			TMP_31 = UnaryType.BANG y 
			TMP_32(uint256) = TMP_30 ^ TMP_31
			z(bool) := TMP_32(uint256)
	Function UtilsLib.min(uint256,uint256) (*)
		Expression: z = x ^ x ^ y * y < x
		IRs:
			TMP_33(uint256) = x ^ y
			TMP_34(bool) = y < x
			TMP_35(uint256) = TMP_33 * TMP_34
			TMP_36(uint256) = x ^ TMP_35
			z(uint256) := TMP_36(uint256)
	Function UtilsLib.toUint128(uint256) (*)
		Expression: require(bool,string)(x <= type()(uint128).max,ErrorsLib.MAX_UINT128_EXCEEDED)
		IRs:
			TMP_38(uint128) := 340282366920938463463374607431768211455(uint128)
			TMP_39(bool) = x <= TMP_38
			REF_4(string) -> ErrorsLib.MAX_UINT128_EXCEEDED
			TMP_40(None) = SOLIDITY_CALL require(bool,string)(TMP_39,REF_4)
		Expression: uint128(x)
		IRs:
			TMP_41 = CONVERT x to uint128
			RETURN TMP_41
	Function UtilsLib.zeroFloorSub(uint256,uint256) (*)
		Expression: z = x > y * x - y
		IRs:
			TMP_42(bool) = x > y
			TMP_43(uint256) = x - y
			TMP_44(bool) = TMP_42 * TMP_43
			z(uint256) := TMP_44(bool)
Contract MorphoBalancesLib
	Function MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams) (*)
		Expression: id = marketParams.id()
		IRs:
			TMP_45(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['marketParams'] 
			id(Id) := TMP_45(Id)
		Expression: market = morpho.market(id)
		IRs:
			TMP_46(Market) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:market, arguments:['id']  
			market(Market) := TMP_46(Market)
		Expression: elapsed = block.timestamp - market.lastUpdate
		IRs:
			REF_7(uint128) -> market.lastUpdate
			TMP_47(uint256) = block.timestamp (c)- REF_7
			elapsed(uint256) := TMP_47(uint256)
		Expression: elapsed != 0 && market.totalBorrowAssets != 0 && marketParams.irm != address(0)
		IRs:
			TMP_48(bool) = elapsed != 0
			REF_8(uint128) -> market.totalBorrowAssets
			TMP_49(bool) = REF_8 != 0
			TMP_50(bool) = TMP_48 && TMP_49
			REF_9(address) -> marketParams.irm
			TMP_51 = CONVERT 0 to address
			TMP_52(bool) = REF_9 != TMP_51
			TMP_53(bool) = TMP_50 && TMP_52
			CONDITION TMP_53
		Expression: borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams,market)
		IRs:
			REF_10(address) -> marketParams.irm
			TMP_54 = CONVERT REF_10 to IIrm
			TMP_55(uint256) = HIGH_LEVEL_CALL, dest:TMP_54(IIrm), function:borrowRateView, arguments:['marketParams', 'market']  
			borrowRate(uint256) := TMP_55(uint256)
		Expression: interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed))
		IRs:
			REF_12(uint128) -> market.totalBorrowAssets
			TMP_56(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.wTaylorCompounded(uint256,uint256), arguments:['borrowRate', 'elapsed'] 
			TMP_57(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.wMulDown(uint256,uint256), arguments:['REF_12', 'TMP_56'] 
			interest(uint256) := TMP_57(uint256)
		Expression: market.totalBorrowAssets += interest.toUint128()
		IRs:
			REF_15(uint128) -> market.totalBorrowAssets
			TMP_58(uint128) = LIBRARY_CALL, dest:UtilsLib, function:UtilsLib.toUint128(uint256), arguments:['interest'] 
			REF_15(-> market) = REF_15 (c)+ TMP_58
		Expression: market.totalSupplyAssets += interest.toUint128()
		IRs:
			REF_17(uint128) -> market.totalSupplyAssets
			TMP_59(uint128) = LIBRARY_CALL, dest:UtilsLib, function:UtilsLib.toUint128(uint256), arguments:['interest'] 
			REF_17(-> market) = REF_17 (c)+ TMP_59
		Expression: market.fee != 0
		IRs:
			REF_19(uint128) -> market.fee
			TMP_60(bool) = REF_19 != 0
			CONDITION TMP_60
		Expression: feeAmount = interest.wMulDown(market.fee)
		IRs:
			REF_21(uint128) -> market.fee
			TMP_61(uint256) = LIBRARY_CALL, dest:MathLib, function:MathLib.wMulDown(uint256,uint256), arguments:['interest', 'REF_21'] 
			feeAmount(uint256) := TMP_61(uint256)
		Expression: feeShares = feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount,market.totalSupplyShares)
		IRs:
			REF_23(uint128) -> market.totalSupplyAssets
			TMP_62(uint128) = REF_23 (c)- feeAmount
			REF_24(uint128) -> market.totalSupplyShares
			TMP_63(uint256) = LIBRARY_CALL, dest:SharesMathLib, function:SharesMathLib.toSharesDown(uint256,uint256,uint256), arguments:['feeAmount', 'TMP_62', 'REF_24'] 
			feeShares(uint256) := TMP_63(uint256)
		Expression: market.totalSupplyShares += feeShares.toUint128()
		IRs:
			REF_25(uint128) -> market.totalSupplyShares
			TMP_64(uint128) = LIBRARY_CALL, dest:UtilsLib, function:UtilsLib.toUint128(uint256), arguments:['feeShares'] 
			REF_25(-> market) = REF_25 (c)+ TMP_64
		Expression: (market.totalSupplyAssets,market.totalSupplyShares,market.totalBorrowAssets,market.totalBorrowShares)
		IRs:
			REF_27(uint128) -> market.totalSupplyAssets
			REF_28(uint128) -> market.totalSupplyShares
			REF_29(uint128) -> market.totalBorrowAssets
			REF_30(uint128) -> market.totalBorrowShares
			RETURN REF_27,REF_28,REF_29,REF_30
	Function MorphoBalancesLib.expectedTotalSupplyAssets(IMorpho,MarketParams) (*)
		Expression: (totalSupplyAssets,None,None,None) = expectedMarketBalances(morpho,marketParams)
		IRs:
			TUPLE_0(uint256,uint256,uint256,uint256) = INTERNAL_CALL, MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams)(morpho,marketParams)
			totalSupplyAssets(uint256)= UNPACK TUPLE_0 index: 0 
	Function MorphoBalancesLib.expectedTotalBorrowAssets(IMorpho,MarketParams) (*)
		Expression: (None,None,totalBorrowAssets,None) = expectedMarketBalances(morpho,marketParams)
		IRs:
			TUPLE_1(uint256,uint256,uint256,uint256) = INTERNAL_CALL, MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams)(morpho,marketParams)
			totalBorrowAssets(uint256)= UNPACK TUPLE_1 index: 2 
	Function MorphoBalancesLib.expectedTotalSupplyShares(IMorpho,MarketParams) (*)
		Expression: (None,totalSupplyShares,None,None) = expectedMarketBalances(morpho,marketParams)
		IRs:
			TUPLE_2(uint256,uint256,uint256,uint256) = INTERNAL_CALL, MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams)(morpho,marketParams)
			totalSupplyShares(uint256)= UNPACK TUPLE_2 index: 1 
	Function MorphoBalancesLib.expectedSupplyAssets(IMorpho,MarketParams,address) (*)
		Expression: id = marketParams.id()
		IRs:
			TMP_65(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['marketParams'] 
			id(Id) := TMP_65(Id)
		Expression: supplyShares = morpho.supplyShares(id,user)
		IRs:
			TMP_66(uint256) = LIBRARY_CALL, dest:MorphoLib, function:MorphoLib.supplyShares(IMorpho,Id,address), arguments:['morpho', 'id', 'user'] 
			supplyShares(uint256) := TMP_66(uint256)
		Expression: (totalSupplyAssets,totalSupplyShares) = expectedMarketBalances(morpho,marketParams)
		IRs:
			TUPLE_3(uint256,uint256,uint256,uint256) = INTERNAL_CALL, MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams)(morpho,marketParams)
			totalSupplyAssets(uint256)= UNPACK TUPLE_3 index: 0 
			totalSupplyShares(uint256)= UNPACK TUPLE_3 index: 1 
		Expression: supplyShares.toAssetsDown(totalSupplyAssets,totalSupplyShares)
		IRs:
			TMP_67(uint256) = LIBRARY_CALL, dest:SharesMathLib, function:SharesMathLib.toAssetsDown(uint256,uint256,uint256), arguments:['supplyShares', 'totalSupplyAssets', 'totalSupplyShares'] 
			RETURN TMP_67
	Function MorphoBalancesLib.expectedBorrowAssets(IMorpho,MarketParams,address) (*)
		Expression: id = marketParams.id()
		IRs:
			TMP_68(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['marketParams'] 
			id(Id) := TMP_68(Id)
		Expression: borrowShares = morpho.borrowShares(id,user)
		IRs:
			TMP_69(uint256) = LIBRARY_CALL, dest:MorphoLib, function:MorphoLib.borrowShares(IMorpho,Id,address), arguments:['morpho', 'id', 'user'] 
			borrowShares(uint256) := TMP_69(uint256)
		Expression: (totalBorrowAssets,totalBorrowShares) = expectedMarketBalances(morpho,marketParams)
		IRs:
			TUPLE_4(uint256,uint256,uint256,uint256) = INTERNAL_CALL, MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams)(morpho,marketParams)
			totalBorrowAssets(uint256)= UNPACK TUPLE_4 index: 2 
			totalBorrowShares(uint256)= UNPACK TUPLE_4 index: 3 
		Expression: borrowShares.toAssetsUp(totalBorrowAssets,totalBorrowShares)
		IRs:
			TMP_70(uint256) = LIBRARY_CALL, dest:SharesMathLib, function:SharesMathLib.toAssetsUp(uint256,uint256,uint256), arguments:['borrowShares', 'totalBorrowAssets', 'totalBorrowShares'] 
			RETURN TMP_70
Contract MorphoLib
	Function MorphoLib.supplyShares(IMorpho,Id,address) (*)
		Expression: slot = _array(MorphoStorageLib.positionSupplySharesSlot(id,user))
		IRs:
			TMP_71(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.positionSupplySharesSlot(Id,address), arguments:['id', 'user'] 
			TMP_72(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_71)
			slot(bytes32[]) = ['TMP_72(bytes32[])']
		Expression: uint256(morpho.extSloads(slot)[0])
		IRs:
			TMP_73(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_39(bytes32) -> TMP_73[0]
			TMP_74 = CONVERT REF_39 to uint256
			RETURN TMP_74
	Function MorphoLib.borrowShares(IMorpho,Id,address) (*)
		Expression: slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id,user))
		IRs:
			TMP_75(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.positionBorrowSharesAndCollateralSlot(Id,address), arguments:['id', 'user'] 
			TMP_76(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_75)
			slot(bytes32[]) = ['TMP_76(bytes32[])']
		Expression: uint128(uint256(morpho.extSloads(slot)[0]))
		IRs:
			TMP_77(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_42(bytes32) -> TMP_77[0]
			TMP_78 = CONVERT REF_42 to uint256
			TMP_79 = CONVERT TMP_78 to uint128
			RETURN TMP_79
	Function MorphoLib.collateral(IMorpho,Id,address) (*)
		Expression: slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id,user))
		IRs:
			TMP_80(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.positionBorrowSharesAndCollateralSlot(Id,address), arguments:['id', 'user'] 
			TMP_81(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_80)
			slot(bytes32[]) = ['TMP_81(bytes32[])']
		Expression: uint256(morpho.extSloads(slot)[0] >> 128)
		IRs:
			TMP_82(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_45(bytes32) -> TMP_82[0]
			TMP_83(bytes32) = REF_45 >> 128
			TMP_84 = CONVERT TMP_83 to uint256
			RETURN TMP_84
	Function MorphoLib.totalSupplyAssets(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id))
		IRs:
			TMP_85(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(Id), arguments:['id'] 
			TMP_86(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_85)
			slot(bytes32[]) = ['TMP_86(bytes32[])']
		Expression: uint128(uint256(morpho.extSloads(slot)[0]))
		IRs:
			TMP_87(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_48(bytes32) -> TMP_87[0]
			TMP_88 = CONVERT REF_48 to uint256
			TMP_89 = CONVERT TMP_88 to uint128
			RETURN TMP_89
	Function MorphoLib.totalSupplyShares(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id))
		IRs:
			TMP_90(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(Id), arguments:['id'] 
			TMP_91(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_90)
			slot(bytes32[]) = ['TMP_91(bytes32[])']
		Expression: uint256(morpho.extSloads(slot)[0] >> 128)
		IRs:
			TMP_92(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_51(bytes32) -> TMP_92[0]
			TMP_93(bytes32) = REF_51 >> 128
			TMP_94 = CONVERT TMP_93 to uint256
			RETURN TMP_94
	Function MorphoLib.totalBorrowAssets(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id))
		IRs:
			TMP_95(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(Id), arguments:['id'] 
			TMP_96(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_95)
			slot(bytes32[]) = ['TMP_96(bytes32[])']
		Expression: uint128(uint256(morpho.extSloads(slot)[0]))
		IRs:
			TMP_97(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_54(bytes32) -> TMP_97[0]
			TMP_98 = CONVERT REF_54 to uint256
			TMP_99 = CONVERT TMP_98 to uint128
			RETURN TMP_99
	Function MorphoLib.totalBorrowShares(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id))
		IRs:
			TMP_100(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(Id), arguments:['id'] 
			TMP_101(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_100)
			slot(bytes32[]) = ['TMP_101(bytes32[])']
		Expression: uint256(morpho.extSloads(slot)[0] >> 128)
		IRs:
			TMP_102(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_57(bytes32) -> TMP_102[0]
			TMP_103(bytes32) = REF_57 >> 128
			TMP_104 = CONVERT TMP_103 to uint256
			RETURN TMP_104
	Function MorphoLib.lastUpdate(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id))
		IRs:
			TMP_105(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketLastUpdateAndFeeSlot(Id), arguments:['id'] 
			TMP_106(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_105)
			slot(bytes32[]) = ['TMP_106(bytes32[])']
		Expression: uint128(uint256(morpho.extSloads(slot)[0]))
		IRs:
			TMP_107(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_60(bytes32) -> TMP_107[0]
			TMP_108 = CONVERT REF_60 to uint256
			TMP_109 = CONVERT TMP_108 to uint128
			RETURN TMP_109
	Function MorphoLib.fee(IMorpho,Id) (*)
		Expression: slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id))
		IRs:
			TMP_110(bytes32) = LIBRARY_CALL, dest:MorphoStorageLib, function:MorphoStorageLib.marketLastUpdateAndFeeSlot(Id), arguments:['id'] 
			TMP_111(bytes32[]) = INTERNAL_CALL, MorphoLib._array(bytes32)(TMP_110)
			slot(bytes32[]) = ['TMP_111(bytes32[])']
		Expression: uint256(morpho.extSloads(slot)[0] >> 128)
		IRs:
			TMP_112(bytes32[]) = HIGH_LEVEL_CALL, dest:morpho(IMorpho), function:extSloads, arguments:['slot']  
			REF_63(bytes32) -> TMP_112[0]
			TMP_113(bytes32) = REF_63 >> 128
			TMP_114 = CONVERT TMP_113 to uint256
			RETURN TMP_114
	Function MorphoLib._array(bytes32) (*)
		Expression: res = new bytes32[](1)
		IRs:
			TMP_116(bytes32[])  = new bytes32[](1)
			res(bytes32[]) = ['TMP_116(bytes32[])']
		Expression: res[0] = x
		IRs:
			REF_64(bytes32) -> res[0]
			REF_64(bytes32) (->res) := x(bytes32)
		Expression: res
		IRs:
			RETURN res
Contract MorphoStorageLib
	Function MorphoStorageLib.ownerSlot() (*)
		Expression: bytes32(OWNER_SLOT)
		IRs:
			TMP_117 = CONVERT OWNER_SLOT to bytes32
			RETURN TMP_117
	Function MorphoStorageLib.feeRecipientSlot() (*)
		Expression: bytes32(FEE_RECIPIENT_SLOT)
		IRs:
			TMP_118 = CONVERT FEE_RECIPIENT_SLOT to bytes32
			RETURN TMP_118
	Function MorphoStorageLib.positionSupplySharesSlot(Id,address) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(user,keccak256(bytes)(abi.encode(id,POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET)
		IRs:
			TMP_119(bytes) = SOLIDITY_CALL abi.encode()(id,POSITION_SLOT)
			TMP_120(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_119)
			TMP_121(bytes) = SOLIDITY_CALL abi.encode()(user,TMP_120)
			TMP_122(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_121)
			TMP_123 = CONVERT TMP_122 to uint256
			TMP_124(uint256) = TMP_123 (c)+ SUPPLY_SHARES_OFFSET
			TMP_125 = CONVERT TMP_124 to bytes32
			RETURN TMP_125
	Function MorphoStorageLib.positionBorrowSharesAndCollateralSlot(Id,address) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(user,keccak256(bytes)(abi.encode(id,POSITION_SLOT))))) + BORROW_SHARES_AND_COLLATERAL_OFFSET)
		IRs:
			TMP_126(bytes) = SOLIDITY_CALL abi.encode()(id,POSITION_SLOT)
			TMP_127(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_126)
			TMP_128(bytes) = SOLIDITY_CALL abi.encode()(user,TMP_127)
			TMP_129(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_128)
			TMP_130 = CONVERT TMP_129 to uint256
			TMP_131(uint256) = TMP_130 (c)+ BORROW_SHARES_AND_COLLATERAL_OFFSET
			TMP_132 = CONVERT TMP_131 to bytes32
			RETURN TMP_132
	Function MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET)
		IRs:
			TMP_133(bytes) = SOLIDITY_CALL abi.encode()(id,MARKET_SLOT)
			TMP_134(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_133)
			TMP_135 = CONVERT TMP_134 to uint256
			TMP_136(uint256) = TMP_135 (c)+ TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET
			TMP_137 = CONVERT TMP_136 to bytes32
			RETURN TMP_137
	Function MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET)
		IRs:
			TMP_138(bytes) = SOLIDITY_CALL abi.encode()(id,MARKET_SLOT)
			TMP_139(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_138)
			TMP_140 = CONVERT TMP_139 to uint256
			TMP_141(uint256) = TMP_140 (c)+ TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET
			TMP_142 = CONVERT TMP_141 to bytes32
			RETURN TMP_142
	Function MorphoStorageLib.marketLastUpdateAndFeeSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET)
		IRs:
			TMP_143(bytes) = SOLIDITY_CALL abi.encode()(id,MARKET_SLOT)
			TMP_144(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_143)
			TMP_145 = CONVERT TMP_144 to uint256
			TMP_146(uint256) = TMP_145 (c)+ LAST_UPDATE_AND_FEE_OFFSET
			TMP_147 = CONVERT TMP_146 to bytes32
			RETURN TMP_147
	Function MorphoStorageLib.isIrmEnabledSlot(address) (*)
		Expression: keccak256(bytes)(abi.encode(irm,IS_IRM_ENABLED_SLOT))
		IRs:
			TMP_148(bytes) = SOLIDITY_CALL abi.encode()(irm,IS_IRM_ENABLED_SLOT)
			TMP_149(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_148)
			RETURN TMP_149
	Function MorphoStorageLib.isLltvEnabledSlot(uint256) (*)
		Expression: keccak256(bytes)(abi.encode(lltv,IS_LLTV_ENABLED_SLOT))
		IRs:
			TMP_150(bytes) = SOLIDITY_CALL abi.encode()(lltv,IS_LLTV_ENABLED_SLOT)
			TMP_151(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_150)
			RETURN TMP_151
	Function MorphoStorageLib.isAuthorizedSlot(address,address) (*)
		Expression: keccak256(bytes)(abi.encode(authorizee,keccak256(bytes)(abi.encode(authorizer,IS_AUTHORIZED_SLOT))))
		IRs:
			TMP_152(bytes) = SOLIDITY_CALL abi.encode()(authorizer,IS_AUTHORIZED_SLOT)
			TMP_153(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_152)
			TMP_154(bytes) = SOLIDITY_CALL abi.encode()(authorizee,TMP_153)
			TMP_155(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_154)
			RETURN TMP_155
	Function MorphoStorageLib.nonceSlot(address) (*)
		Expression: keccak256(bytes)(abi.encode(authorizer,NONCE_SLOT))
		IRs:
			TMP_156(bytes) = SOLIDITY_CALL abi.encode()(authorizer,NONCE_SLOT)
			TMP_157(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_156)
			RETURN TMP_157
	Function MorphoStorageLib.idToLoanTokenSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET)
		IRs:
			TMP_158(bytes) = SOLIDITY_CALL abi.encode()(id,ID_TO_MARKET_PARAMS_SLOT)
			TMP_159(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_158)
			TMP_160 = CONVERT TMP_159 to uint256
			TMP_161(uint256) = TMP_160 (c)+ LOAN_TOKEN_OFFSET
			TMP_162 = CONVERT TMP_161 to bytes32
			RETURN TMP_162
	Function MorphoStorageLib.idToCollateralTokenSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET)
		IRs:
			TMP_163(bytes) = SOLIDITY_CALL abi.encode()(id,ID_TO_MARKET_PARAMS_SLOT)
			TMP_164(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_163)
			TMP_165 = CONVERT TMP_164 to uint256
			TMP_166(uint256) = TMP_165 (c)+ COLLATERAL_TOKEN_OFFSET
			TMP_167 = CONVERT TMP_166 to bytes32
			RETURN TMP_167
	Function MorphoStorageLib.idToOracleSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET)
		IRs:
			TMP_168(bytes) = SOLIDITY_CALL abi.encode()(id,ID_TO_MARKET_PARAMS_SLOT)
			TMP_169(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_168)
			TMP_170 = CONVERT TMP_169 to uint256
			TMP_171(uint256) = TMP_170 (c)+ ORACLE_OFFSET
			TMP_172 = CONVERT TMP_171 to bytes32
			RETURN TMP_172
	Function MorphoStorageLib.idToIrmSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET)
		IRs:
			TMP_173(bytes) = SOLIDITY_CALL abi.encode()(id,ID_TO_MARKET_PARAMS_SLOT)
			TMP_174(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_173)
			TMP_175 = CONVERT TMP_174 to uint256
			TMP_176(uint256) = TMP_175 (c)+ IRM_OFFSET
			TMP_177 = CONVERT TMP_176 to bytes32
			RETURN TMP_177
	Function MorphoStorageLib.idToLltvSlot(Id) (*)
		Expression: bytes32(uint256(keccak256(bytes)(abi.encode(id,ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET)
		IRs:
			TMP_178(bytes) = SOLIDITY_CALL abi.encode()(id,ID_TO_MARKET_PARAMS_SLOT)
			TMP_179(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_178)
			TMP_180 = CONVERT TMP_179 to uint256
			TMP_181(uint256) = TMP_180 (c)+ LLTV_OFFSET
			TMP_182 = CONVERT TMP_181 to bytes32
			RETURN TMP_182
	Function MorphoStorageLib.slitherConstructorConstantVariables() (*)
		Expression: OWNER_SLOT = 0
		IRs:
			OWNER_SLOT(uint256) := 0(uint256)
		Expression: FEE_RECIPIENT_SLOT = 1
		IRs:
			FEE_RECIPIENT_SLOT(uint256) := 1(uint256)
		Expression: POSITION_SLOT = 2
		IRs:
			POSITION_SLOT(uint256) := 2(uint256)
		Expression: MARKET_SLOT = 3
		IRs:
			MARKET_SLOT(uint256) := 3(uint256)
		Expression: IS_IRM_ENABLED_SLOT = 4
		IRs:
			IS_IRM_ENABLED_SLOT(uint256) := 4(uint256)
		Expression: IS_LLTV_ENABLED_SLOT = 5
		IRs:
			IS_LLTV_ENABLED_SLOT(uint256) := 5(uint256)
		Expression: IS_AUTHORIZED_SLOT = 6
		IRs:
			IS_AUTHORIZED_SLOT(uint256) := 6(uint256)
		Expression: NONCE_SLOT = 7
		IRs:
			NONCE_SLOT(uint256) := 7(uint256)
		Expression: ID_TO_MARKET_PARAMS_SLOT = 8
		IRs:
			ID_TO_MARKET_PARAMS_SLOT(uint256) := 8(uint256)
		Expression: LOAN_TOKEN_OFFSET = 0
		IRs:
			LOAN_TOKEN_OFFSET(uint256) := 0(uint256)
		Expression: COLLATERAL_TOKEN_OFFSET = 1
		IRs:
			COLLATERAL_TOKEN_OFFSET(uint256) := 1(uint256)
		Expression: ORACLE_OFFSET = 2
		IRs:
			ORACLE_OFFSET(uint256) := 2(uint256)
		Expression: IRM_OFFSET = 3
		IRs:
			IRM_OFFSET(uint256) := 3(uint256)
		Expression: LLTV_OFFSET = 4
		IRs:
			LLTV_OFFSET(uint256) := 4(uint256)
		Expression: SUPPLY_SHARES_OFFSET = 0
		IRs:
			SUPPLY_SHARES_OFFSET(uint256) := 0(uint256)
		Expression: BORROW_SHARES_AND_COLLATERAL_OFFSET = 1
		IRs:
			BORROW_SHARES_AND_COLLATERAL_OFFSET(uint256) := 1(uint256)
		Expression: TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0
		IRs:
			TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET(uint256) := 0(uint256)
		Expression: TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1
		IRs:
			TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET(uint256) := 1(uint256)
		Expression: LAST_UPDATE_AND_FEE_OFFSET = 2
		IRs:
			LAST_UPDATE_AND_FEE_OFFSET(uint256) := 2(uint256)
Contract AccessControlUpgradeable
	Function ERC165Upgradeable.__ERC165_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.__ERC165_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165Upgradeable).interfaceId
		IRs:
			TMP_185(type(IERC165Upgradeable)) = SOLIDITY_CALL type()(IERC165Upgradeable)
			REF_82(bytes4) (->None) := 33540519(bytes4)
			TMP_186(bool) = interfaceId == REF_82
			RETURN TMP_186
	Function IERC165Upgradeable.supportsInterface(bytes4) 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_187 = UnaryType.BANG _initializing 
			TMP_188(None) = SOLIDITY_CALL require(bool,string)(TMP_187,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_190(uint8) := 255(uint8)
			TMP_191(bool) = _initialized != TMP_190
			CONDITION TMP_191
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_193(uint8) := 255(uint8)
			_initialized(uint8) := TMP_193(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_195(uint8) := 255(uint8)
			Emit Initialized(TMP_195)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function IAccessControlUpgradeable.hasRole(bytes32,address) 
	Function IAccessControlUpgradeable.getRoleAdmin(bytes32) 
	Function IAccessControlUpgradeable.grantRole(bytes32,address) 
	Function IAccessControlUpgradeable.revokeRole(bytes32,address) 
	Function IAccessControlUpgradeable.renounceRole(bytes32,address) 
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function AccessControlUpgradeable.__AccessControl_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.__AccessControl_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_201(type(IAccessControlUpgradeable)) = SOLIDITY_CALL type()(IAccessControlUpgradeable)
			REF_83(bytes4) (->None) := 2036718347(bytes4)
			TMP_202(bool) = interfaceId == REF_83
			TMP_203(bool) = INTERNAL_CALL, ERC165Upgradeable.supportsInterface(bytes4)(interfaceId)
			TMP_204(bool) = TMP_202 || TMP_203
			RETURN TMP_204
	Function AccessControlUpgradeable.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_84(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_85(mapping(address => bool)) -> REF_84.members
			REF_86(bool) -> REF_85[account]
			RETURN REF_86
	Function AccessControlUpgradeable._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_205(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32,address)(role,TMP_205)
	Function AccessControlUpgradeable._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_207(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_208 = UnaryType.BANG TMP_207 
			CONDITION TMP_208
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))
		IRs:
			TMP_209(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(address), arguments:['account'] 
			TMP_210 = CONVERT role to uint256
			TMP_211(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(uint256,uint256), arguments:['TMP_210', '32'] 
			TMP_212(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_209, is missing role ,TMP_211)
			TMP_213 = CONVERT TMP_212 to string
			TMP_214(None) = SOLIDITY_CALL revert(string)(TMP_213)
	Function AccessControlUpgradeable.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_90(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_91(bytes32) -> REF_90.adminRole
			RETURN REF_91
	Function AccessControlUpgradeable.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_216(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_216)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_218(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_218)
	Function AccessControlUpgradeable.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_221(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_221)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_223(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_223)
	Function AccessControlUpgradeable.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_225(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_226(bool) = account == TMP_225
			TMP_227(None) = SOLIDITY_CALL require(bool,string)(TMP_226,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_230(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_230(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_92(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_93(bytes32) -> REF_92.adminRole
			REF_93(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControlUpgradeable._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_232(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_233 = UnaryType.BANG TMP_232 
			CONDITION TMP_233
		Expression: _roles[role].members[account] = true
		IRs:
			REF_94(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_95(mapping(address => bool)) -> REF_94.members
			REF_96(bool) -> REF_95[account]
			REF_96(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_234(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleGranted(role,account,TMP_234)
	Function AccessControlUpgradeable._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_236(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			CONDITION TMP_236
		Expression: _roles[role].members[account] = false
		IRs:
			REF_97(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_98(mapping(address => bool)) -> REF_97.members
			REF_99(bool) -> REF_98[account]
			REF_99(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_237(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleRevoked(role,account,TMP_237)
	Function AccessControlUpgradeable.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_239 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_239(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_240(bool) = _initialized < 1
			TMP_241(bool) = isTopLevelCall && TMP_240
			TMP_242 = CONVERT this to address
			TMP_243(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_242'] 
			TMP_244 = UnaryType.BANG TMP_243 
			TMP_245(bool) = _initialized == 1
			TMP_246(bool) = TMP_244 && TMP_245
			TMP_247(bool) = TMP_241 || TMP_246
			TMP_248(None) = SOLIDITY_CALL require(bool,string)(TMP_247,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_250 = UnaryType.BANG _initializing 
			TMP_251(bool) = _initialized < version
			TMP_252(bool) = TMP_250 && TMP_251
			TMP_253(None) = SOLIDITY_CALL require(bool,string)(TMP_252,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_255(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier AccessControlUpgradeable.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32)(role)
Contract IAccessControlUpgradeable
	Function IAccessControlUpgradeable.hasRole(bytes32,address) (*)
	Function IAccessControlUpgradeable.getRoleAdmin(bytes32) (*)
	Function IAccessControlUpgradeable.grantRole(bytes32,address) (*)
	Function IAccessControlUpgradeable.revokeRole(bytes32,address) (*)
	Function IAccessControlUpgradeable.renounceRole(bytes32,address) (*)
Contract Ownable2StepUpgradeable
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_259(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_259)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_262(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_263(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_264(bool) = TMP_262 == TMP_263
			TMP_265(None) = SOLIDITY_CALL require(bool,string)(TMP_264,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_266 = CONVERT 0 to address
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_266)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) 
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_269 = CONVERT 0 to address
			TMP_270(bool) = newOwner != TMP_269
			TMP_271(None) = SOLIDITY_CALL require(bool,string)(TMP_270,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) 
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_277 = UnaryType.BANG _initializing 
			TMP_278(None) = SOLIDITY_CALL require(bool,string)(TMP_277,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_280(uint8) := 255(uint8)
			TMP_281(bool) = _initialized != TMP_280
			CONDITION TMP_281
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_283(uint8) := 255(uint8)
			_initialized(uint8) := TMP_283(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_285(uint8) := 255(uint8)
			Emit Initialized(TMP_285)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function Ownable2StepUpgradeable.__Ownable2Step_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.pendingOwner() (*)
		Expression: _pendingOwner
		IRs:
			RETURN _pendingOwner
	Function Ownable2StepUpgradeable.transferOwnership(address) (*)
		Expression: _pendingOwner = newOwner
		IRs:
			_pendingOwner(address) := newOwner(address)
		Expression: OwnershipTransferStarted(owner(),newOwner)
		IRs:
			TMP_290(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			Emit OwnershipTransferStarted(TMP_290,newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable._transferOwnership(address) (*)
		Expression: delete _pendingOwner
		IRs:
			_pendingOwner = delete _pendingOwner 
		Expression: super._transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
	Function Ownable2StepUpgradeable.acceptOwnership() (*)
		Expression: sender = _msgSender()
		IRs:
			TMP_294(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			sender(address) := TMP_294(address)
		Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)
		IRs:
			TMP_295(address) = INTERNAL_CALL, Ownable2StepUpgradeable.pendingOwner()()
			TMP_296(bool) = TMP_295 == sender
			TMP_297(None) = SOLIDITY_CALL require(bool,string)(TMP_296,Ownable2Step: caller is not the new owner)
		Expression: _transferOwnership(sender)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(sender)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_300 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_300(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_301(bool) = _initialized < 1
			TMP_302(bool) = isTopLevelCall && TMP_301
			TMP_303 = CONVERT this to address
			TMP_304(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_303'] 
			TMP_305 = UnaryType.BANG TMP_304 
			TMP_306(bool) = _initialized == 1
			TMP_307(bool) = TMP_305 && TMP_306
			TMP_308(bool) = TMP_302 || TMP_307
			TMP_309(None) = SOLIDITY_CALL require(bool,string)(TMP_308,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_311 = UnaryType.BANG _initializing 
			TMP_312(bool) = _initialized < version
			TMP_313(bool) = TMP_311 && TMP_312
			TMP_314(None) = SOLIDITY_CALL require(bool,string)(TMP_313,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_316(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract OwnableUpgradeable
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_319 = UnaryType.BANG _initializing 
			TMP_320(None) = SOLIDITY_CALL require(bool,string)(TMP_319,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_322(uint8) := 255(uint8)
			TMP_323(bool) = _initialized != TMP_322
			CONDITION TMP_323
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_325(uint8) := 255(uint8)
			_initialized(uint8) := TMP_325(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_327(uint8) := 255(uint8)
			Emit Initialized(TMP_327)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_331(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_331)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_334(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_335(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_336(bool) = TMP_334 == TMP_335
			TMP_337(None) = SOLIDITY_CALL require(bool,string)(TMP_336,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_338 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_338)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_341 = CONVERT 0 to address
			TMP_342(bool) = newOwner != TMP_341
			TMP_343(None) = SOLIDITY_CALL require(bool,string)(TMP_342,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_347 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_347(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_348(bool) = _initialized < 1
			TMP_349(bool) = isTopLevelCall && TMP_348
			TMP_350 = CONVERT this to address
			TMP_351(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_350'] 
			TMP_352 = UnaryType.BANG TMP_351 
			TMP_353(bool) = _initialized == 1
			TMP_354(bool) = TMP_352 && TMP_353
			TMP_355(bool) = TMP_349 || TMP_354
			TMP_356(None) = SOLIDITY_CALL require(bool,string)(TMP_355,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_358 = UnaryType.BANG _initializing 
			TMP_359(bool) = _initialized < version
			TMP_360(bool) = TMP_358 && TMP_359
			TMP_361(None) = SOLIDITY_CALL require(bool,string)(TMP_360,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_363(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
Contract IERC3156FlashBorrowerUpgradeable
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) (*)
Contract IERC3156FlashLenderUpgradeable
	Function IERC3156FlashLenderUpgradeable.maxFlashLoan(address) (*)
	Function IERC3156FlashLenderUpgradeable.flashFee(address,uint256) (*)
	Function IERC3156FlashLenderUpgradeable.flashLoan(IERC3156FlashBorrowerUpgradeable,address,uint256,bytes) (*)
Contract IERC4626Upgradeable
	Function IERC20MetadataUpgradeable.name() (*)
	Function IERC20MetadataUpgradeable.symbol() (*)
	Function IERC20MetadataUpgradeable.decimals() (*)
	Function IERC20Upgradeable.totalSupply() (*)
	Function IERC20Upgradeable.balanceOf(address) (*)
	Function IERC20Upgradeable.transfer(address,uint256) (*)
	Function IERC20Upgradeable.allowance(address,address) (*)
	Function IERC20Upgradeable.approve(address,uint256) (*)
	Function IERC20Upgradeable.transferFrom(address,address,uint256) (*)
	Function IERC4626Upgradeable.asset() (*)
	Function IERC4626Upgradeable.totalAssets() (*)
	Function IERC4626Upgradeable.convertToShares(uint256) (*)
	Function IERC4626Upgradeable.convertToAssets(uint256) (*)
	Function IERC4626Upgradeable.maxDeposit(address) (*)
	Function IERC4626Upgradeable.previewDeposit(uint256) (*)
	Function IERC4626Upgradeable.deposit(uint256,address) (*)
	Function IERC4626Upgradeable.maxMint(address) (*)
	Function IERC4626Upgradeable.previewMint(uint256) (*)
	Function IERC4626Upgradeable.mint(uint256,address) (*)
	Function IERC4626Upgradeable.maxWithdraw(address) (*)
	Function IERC4626Upgradeable.previewWithdraw(uint256) (*)
	Function IERC4626Upgradeable.withdraw(uint256,address,address) (*)
	Function IERC4626Upgradeable.maxRedeem(address) (*)
	Function IERC4626Upgradeable.previewRedeem(uint256) (*)
	Function IERC4626Upgradeable.redeem(uint256,address,address) (*)
Contract IERC5267Upgradeable
	Function IERC5267Upgradeable.eip712Domain() (*)
Contract Initializable
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_365 = UnaryType.BANG _initializing 
			TMP_366(None) = SOLIDITY_CALL require(bool,string)(TMP_365,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_368(uint8) := 255(uint8)
			TMP_369(bool) = _initialized != TMP_368
			CONDITION TMP_369
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_371(uint8) := 255(uint8)
			_initialized(uint8) := TMP_371(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_373(uint8) := 255(uint8)
			Emit Initialized(TMP_373)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_375 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_375(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_376(bool) = _initialized < 1
			TMP_377(bool) = isTopLevelCall && TMP_376
			TMP_378 = CONVERT this to address
			TMP_379(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_378'] 
			TMP_380 = UnaryType.BANG TMP_379 
			TMP_381(bool) = _initialized == 1
			TMP_382(bool) = TMP_380 && TMP_381
			TMP_383(bool) = TMP_377 || TMP_382
			TMP_384(None) = SOLIDITY_CALL require(bool,string)(TMP_383,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_386 = UnaryType.BANG _initializing 
			TMP_387(bool) = _initialized < version
			TMP_388(bool) = TMP_386 && TMP_387
			TMP_389(None) = SOLIDITY_CALL require(bool,string)(TMP_388,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_391(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract PausableUpgradeable
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_394 = UnaryType.BANG _initializing 
			TMP_395(None) = SOLIDITY_CALL require(bool,string)(TMP_394,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_397(uint8) := 255(uint8)
			TMP_398(bool) = _initialized != TMP_397
			CONDITION TMP_398
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_400(uint8) := 255(uint8)
			_initialized(uint8) := TMP_400(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_402(uint8) := 255(uint8)
			Emit Initialized(TMP_402)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function PausableUpgradeable.__Pausable_init() (*)
		Expression: __Pausable_init_unchained()
		IRs:
			INTERNAL_CALL, PausableUpgradeable.__Pausable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.__Pausable_init_unchained() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.paused() (*)
		Expression: _paused
		IRs:
			RETURN _paused
	Function PausableUpgradeable._requireNotPaused() (*)
		Expression: require(bool,string)(! paused(),Pausable: paused)
		IRs:
			TMP_407(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_408 = UnaryType.BANG TMP_407 
			TMP_409(None) = SOLIDITY_CALL require(bool,string)(TMP_408,Pausable: paused)
	Function PausableUpgradeable._requirePaused() (*)
		Expression: require(bool,string)(paused(),Pausable: not paused)
		IRs:
			TMP_410(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_411(None) = SOLIDITY_CALL require(bool,string)(TMP_410,Pausable: not paused)
	Function PausableUpgradeable._pause() (*)
		Expression: _paused = true
		IRs:
			_paused(bool) := True(bool)
		Expression: Paused(_msgSender())
		IRs:
			TMP_412(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Paused(TMP_412)
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function PausableUpgradeable._unpause() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: Unpaused(_msgSender())
		IRs:
			TMP_415(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Unpaused(TMP_415)
		Expression: whenPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenPaused()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_418 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_418(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_419(bool) = _initialized < 1
			TMP_420(bool) = isTopLevelCall && TMP_419
			TMP_421 = CONVERT this to address
			TMP_422(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_421'] 
			TMP_423 = UnaryType.BANG TMP_422 
			TMP_424(bool) = _initialized == 1
			TMP_425(bool) = TMP_423 && TMP_424
			TMP_426(bool) = TMP_420 || TMP_425
			TMP_427(None) = SOLIDITY_CALL require(bool,string)(TMP_426,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_429 = UnaryType.BANG _initializing 
			TMP_430(bool) = _initialized < version
			TMP_431(bool) = TMP_429 && TMP_430
			TMP_432(None) = SOLIDITY_CALL require(bool,string)(TMP_431,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_434(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier PausableUpgradeable.whenNotPaused()
		Expression: _requireNotPaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requireNotPaused()()
	Modifier PausableUpgradeable.whenPaused()
		Expression: _requirePaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requirePaused()()
Contract ReentrancyGuardUpgradeable
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_437 = UnaryType.BANG _initializing 
			TMP_438(None) = SOLIDITY_CALL require(bool,string)(TMP_437,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_440(uint8) := 255(uint8)
			TMP_441(bool) = _initialized != TMP_440
			CONDITION TMP_441
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_443(uint8) := 255(uint8)
			_initialized(uint8) := TMP_443(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_445(uint8) := 255(uint8)
			Emit Initialized(TMP_445)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_450(bool) = _status != _ENTERED
			TMP_451(None) = SOLIDITY_CALL require(bool,string)(TMP_450,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_452(bool) = _status == _ENTERED
			RETURN TMP_452
	Function ReentrancyGuardUpgradeable.slitherConstructorConstantVariables() (*)
		Expression: _NOT_ENTERED = 1
		IRs:
			_NOT_ENTERED(uint256) := 1(uint256)
		Expression: _ENTERED = 2
		IRs:
			_ENTERED(uint256) := 2(uint256)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_453 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_453(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_454(bool) = _initialized < 1
			TMP_455(bool) = isTopLevelCall && TMP_454
			TMP_456 = CONVERT this to address
			TMP_457(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_456'] 
			TMP_458 = UnaryType.BANG TMP_457 
			TMP_459(bool) = _initialized == 1
			TMP_460(bool) = TMP_458 && TMP_459
			TMP_461(bool) = TMP_455 || TMP_460
			TMP_462(None) = SOLIDITY_CALL require(bool,string)(TMP_461,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_464 = UnaryType.BANG _initializing 
			TMP_465(bool) = _initialized < version
			TMP_466(bool) = TMP_464 && TMP_465
			TMP_467(None) = SOLIDITY_CALL require(bool,string)(TMP_466,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_469(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
Contract ERC20Upgradeable
	Function IERC20MetadataUpgradeable.name() 
	Function IERC20MetadataUpgradeable.symbol() 
	Function IERC20MetadataUpgradeable.decimals() 
	Function IERC20Upgradeable.totalSupply() 
	Function IERC20Upgradeable.balanceOf(address) 
	Function IERC20Upgradeable.transfer(address,uint256) 
	Function IERC20Upgradeable.allowance(address,address) 
	Function IERC20Upgradeable.approve(address,uint256) 
	Function IERC20Upgradeable.transferFrom(address,address,uint256) 
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_474 = UnaryType.BANG _initializing 
			TMP_475(None) = SOLIDITY_CALL require(bool,string)(TMP_474,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_477(uint8) := 255(uint8)
			TMP_478(bool) = _initialized != TMP_477
			CONDITION TMP_478
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_480(uint8) := 255(uint8)
			_initialized(uint8) := TMP_480(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_482(uint8) := 255(uint8)
			Emit Initialized(TMP_482)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ERC20Upgradeable.__ERC20_init(string,string) (*)
		Expression: __ERC20_init_unchained(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init_unchained(string,string)(name_,symbol_)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20Upgradeable.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20Upgradeable.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20Upgradeable.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20Upgradeable.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_106(uint256) -> _balances[account]
			RETURN REF_106
	Function ERC20Upgradeable.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_487(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_487(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_107(mapping(address => uint256)) -> _allowances[owner]
			REF_108(uint256) -> REF_107[spender]
			RETURN REF_108
	Function ERC20Upgradeable.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_489(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_489(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_491(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			spender(address) := TMP_491(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_494(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_494(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_495(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			TMP_496(uint256) = TMP_495 (c)+ addedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_496)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_498(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_498(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_499(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_499(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_500(bool) = currentAllowance >= subtractedValue
			TMP_501(None) = SOLIDITY_CALL require(bool,string)(TMP_500,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_502(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_502)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_504 = CONVERT 0 to address
			TMP_505(bool) = from != TMP_504
			TMP_506(None) = SOLIDITY_CALL require(bool,string)(TMP_505,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_507 = CONVERT 0 to address
			TMP_508(bool) = to != TMP_507
			TMP_509(None) = SOLIDITY_CALL require(bool,string)(TMP_508,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_109(uint256) -> _balances[from]
			fromBalance(uint256) := REF_109(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_511(bool) = fromBalance >= amount
			TMP_512(None) = SOLIDITY_CALL require(bool,string)(TMP_511,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_110(uint256) -> _balances[from]
			TMP_513(uint256) = fromBalance - amount
			REF_110(uint256) (->_balances) := TMP_513(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_111(uint256) -> _balances[to]
			REF_111(-> _balances) = REF_111 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20Upgradeable._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_516 = CONVERT 0 to address
			TMP_517(bool) = account != TMP_516
			TMP_518(None) = SOLIDITY_CALL require(bool,string)(TMP_517,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_519 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(TMP_519,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_112(uint256) -> _balances[account]
			REF_112(-> _balances) = REF_112 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_521 = CONVERT 0 to address
			Emit Transfer(TMP_521,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_523 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(TMP_523,account,amount)
	Function ERC20Upgradeable._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_525 = CONVERT 0 to address
			TMP_526(bool) = account != TMP_525
			TMP_527(None) = SOLIDITY_CALL require(bool,string)(TMP_526,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_528 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(account,TMP_528,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_113(uint256) -> _balances[account]
			accountBalance(uint256) := REF_113(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_530(bool) = accountBalance >= amount
			TMP_531(None) = SOLIDITY_CALL require(bool,string)(TMP_530,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_114(uint256) -> _balances[account]
			TMP_532(uint256) = accountBalance - amount
			REF_114(uint256) (->_balances) := TMP_532(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_533 = CONVERT 0 to address
			Emit Transfer(account,TMP_533,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_535 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(account,TMP_535,amount)
	Function ERC20Upgradeable._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_537 = CONVERT 0 to address
			TMP_538(bool) = owner != TMP_537
			TMP_539(None) = SOLIDITY_CALL require(bool,string)(TMP_538,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_540 = CONVERT 0 to address
			TMP_541(bool) = spender != TMP_540
			TMP_542(None) = SOLIDITY_CALL require(bool,string)(TMP_541,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_115(mapping(address => uint256)) -> _allowances[owner]
			REF_116(uint256) -> REF_115[spender]
			REF_116(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20Upgradeable._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_544(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_544(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_546(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_547(bool) = currentAllowance != TMP_546
			CONDITION TMP_547
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_548(bool) = currentAllowance >= amount
			TMP_549(None) = SOLIDITY_CALL require(bool,string)(TMP_548,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_550(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_550)
	Function ERC20Upgradeable._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20Upgradeable._afterTokenTransfer(address,address,uint256) (*)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_552 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_552(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_553(bool) = _initialized < 1
			TMP_554(bool) = isTopLevelCall && TMP_553
			TMP_555 = CONVERT this to address
			TMP_556(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_555'] 
			TMP_557 = UnaryType.BANG TMP_556 
			TMP_558(bool) = _initialized == 1
			TMP_559(bool) = TMP_557 && TMP_558
			TMP_560(bool) = TMP_554 || TMP_559
			TMP_561(None) = SOLIDITY_CALL require(bool,string)(TMP_560,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_563 = UnaryType.BANG _initializing 
			TMP_564(bool) = _initialized < version
			TMP_565(bool) = TMP_563 && TMP_564
			TMP_566(None) = SOLIDITY_CALL require(bool,string)(TMP_565,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_568(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract IERC20Upgradeable
	Function IERC20Upgradeable.totalSupply() (*)
	Function IERC20Upgradeable.balanceOf(address) (*)
	Function IERC20Upgradeable.transfer(address,uint256) (*)
	Function IERC20Upgradeable.allowance(address,address) (*)
	Function IERC20Upgradeable.approve(address,uint256) (*)
	Function IERC20Upgradeable.transferFrom(address,address,uint256) (*)
Contract ERC20PermitUpgradeable
	Function EIP712Upgradeable.__EIP712_init(string,string) (*)
		Expression: __EIP712_init_unchained(name,version)
		IRs:
			INTERNAL_CALL, EIP712Upgradeable.__EIP712_init_unchained(string,string)(name,version)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable.__EIP712_init_unchained(string,string) (*)
		Expression: _name = name
		IRs:
			_name(string) := name(string)
		Expression: _version = version
		IRs:
			_version(string) := version(string)
		Expression: _hashedName = 0
		IRs:
			_hashedName(bytes32) := 0(uint256)
		Expression: _hashedVersion = 0
		IRs:
			_hashedVersion(bytes32) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable._domainSeparatorV4() (*)
		Expression: _buildDomainSeparator()
		IRs:
			TMP_572(bytes32) = INTERNAL_CALL, EIP712Upgradeable._buildDomainSeparator()()
			RETURN TMP_572
	Function EIP712Upgradeable._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_EIP712NameHash(),_EIP712VersionHash(),block.chainid,address(this)))
		IRs:
			TMP_573(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712NameHash()()
			TMP_574(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712VersionHash()()
			TMP_575 = CONVERT this to address
			TMP_576(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,TMP_573,TMP_574,block.chainid,TMP_575)
			TMP_577(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_576)
			RETURN TMP_577
	Function EIP712Upgradeable._hashTypedDataV4(bytes32) (*)
		Expression: ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_578(bytes32) = INTERNAL_CALL, EIP712Upgradeable._domainSeparatorV4()()
			TMP_579(bytes32) = LIBRARY_CALL, dest:ECDSAUpgradeable, function:ECDSAUpgradeable.toTypedDataHash(bytes32,bytes32), arguments:['TMP_578', 'structHash'] 
			RETURN TMP_579
	Function EIP712Upgradeable.eip712Domain() (*)
		Expression: require(bool,string)(_hashedName == 0 && _hashedVersion == 0,EIP712: Uninitialized)
		IRs:
			TMP_580(bool) = _hashedName == 0
			TMP_581(bool) = _hashedVersion == 0
			TMP_582(bool) = TMP_580 && TMP_581
			TMP_583(None) = SOLIDITY_CALL require(bool,string)(TMP_582,EIP712: Uninitialized)
		Expression: (,_EIP712Name(),_EIP712Version(),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_584(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			TMP_585(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			TMP_586 = CONVERT this to address
			TMP_587 = CONVERT 0 to bytes32
			TMP_589(uint256[])  = new uint256[](0)
			RETURN ,TMP_584,TMP_585,block.chainid,TMP_586,TMP_587,TMP_589
	Function EIP712Upgradeable._EIP712Name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function EIP712Upgradeable._EIP712Version() (*)
		Expression: _version
		IRs:
			RETURN _version
	Function EIP712Upgradeable._EIP712NameHash() (*)
		Expression: name = _EIP712Name()
		IRs:
			TMP_590(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			name(string) := TMP_590(string)
		Expression: bytes(name).length > 0
		IRs:
			TMP_591 = CONVERT name to bytes
			REF_120 -> LENGTH TMP_591
			TMP_592(bool) = REF_120 > 0
			CONDITION TMP_592
		Expression: keccak256(bytes)(bytes(name))
		IRs:
			TMP_593 = CONVERT name to bytes
			TMP_594(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_593)
			RETURN TMP_594
		Expression: hashedName = _hashedName
		IRs:
			hashedName(bytes32) := _hashedName(bytes32)
		Expression: hashedName != 0
		IRs:
			TMP_595(bool) = hashedName != 0
			CONDITION TMP_595
		Expression: hashedName
		IRs:
			RETURN hashedName
		Expression: keccak256(bytes)()
		IRs:
			TMP_596(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_596
	Function EIP712Upgradeable._EIP712VersionHash() (*)
		Expression: version = _EIP712Version()
		IRs:
			TMP_597(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			version(string) := TMP_597(string)
		Expression: bytes(version).length > 0
		IRs:
			TMP_598 = CONVERT version to bytes
			REF_121 -> LENGTH TMP_598
			TMP_599(bool) = REF_121 > 0
			CONDITION TMP_599
		Expression: keccak256(bytes)(bytes(version))
		IRs:
			TMP_600 = CONVERT version to bytes
			TMP_601(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_600)
			RETURN TMP_601
		Expression: hashedVersion = _hashedVersion
		IRs:
			hashedVersion(bytes32) := _hashedVersion(bytes32)
		Expression: hashedVersion != 0
		IRs:
			TMP_602(bool) = hashedVersion != 0
			CONDITION TMP_602
		Expression: hashedVersion
		IRs:
			RETURN hashedVersion
		Expression: keccak256(bytes)()
		IRs:
			TMP_603(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_603
	Function IERC5267Upgradeable.eip712Domain() 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_604 = UnaryType.BANG _initializing 
			TMP_605(None) = SOLIDITY_CALL require(bool,string)(TMP_604,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_607(uint8) := 255(uint8)
			TMP_608(bool) = _initialized != TMP_607
			CONDITION TMP_608
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_610(uint8) := 255(uint8)
			_initialized(uint8) := TMP_610(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_612(uint8) := 255(uint8)
			Emit Initialized(TMP_612)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function IERC20PermitUpgradeable.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20PermitUpgradeable.nonces(address) 
	Function IERC20PermitUpgradeable.DOMAIN_SEPARATOR() 
	Function ERC20Upgradeable.__ERC20_init(string,string) (*)
		Expression: __ERC20_init_unchained(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init_unchained(string,string)(name_,symbol_)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20Upgradeable.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20Upgradeable.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20Upgradeable.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20Upgradeable.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_122(uint256) -> _balances[account]
			RETURN REF_122
	Function ERC20Upgradeable.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_617(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_617(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_123(mapping(address => uint256)) -> _allowances[owner]
			REF_124(uint256) -> REF_123[spender]
			RETURN REF_124
	Function ERC20Upgradeable.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_619(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_619(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_621(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			spender(address) := TMP_621(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_624(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_624(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_625(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			TMP_626(uint256) = TMP_625 (c)+ addedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_626)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_628(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_628(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_629(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_629(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_630(bool) = currentAllowance >= subtractedValue
			TMP_631(None) = SOLIDITY_CALL require(bool,string)(TMP_630,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_632(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_632)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_634 = CONVERT 0 to address
			TMP_635(bool) = from != TMP_634
			TMP_636(None) = SOLIDITY_CALL require(bool,string)(TMP_635,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_637 = CONVERT 0 to address
			TMP_638(bool) = to != TMP_637
			TMP_639(None) = SOLIDITY_CALL require(bool,string)(TMP_638,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_125(uint256) -> _balances[from]
			fromBalance(uint256) := REF_125(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_641(bool) = fromBalance >= amount
			TMP_642(None) = SOLIDITY_CALL require(bool,string)(TMP_641,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_126(uint256) -> _balances[from]
			TMP_643(uint256) = fromBalance - amount
			REF_126(uint256) (->_balances) := TMP_643(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_127(uint256) -> _balances[to]
			REF_127(-> _balances) = REF_127 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20Upgradeable._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_646 = CONVERT 0 to address
			TMP_647(bool) = account != TMP_646
			TMP_648(None) = SOLIDITY_CALL require(bool,string)(TMP_647,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_649 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(TMP_649,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_128(uint256) -> _balances[account]
			REF_128(-> _balances) = REF_128 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_651 = CONVERT 0 to address
			Emit Transfer(TMP_651,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_653 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(TMP_653,account,amount)
	Function ERC20Upgradeable._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_655 = CONVERT 0 to address
			TMP_656(bool) = account != TMP_655
			TMP_657(None) = SOLIDITY_CALL require(bool,string)(TMP_656,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_658 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(account,TMP_658,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_129(uint256) -> _balances[account]
			accountBalance(uint256) := REF_129(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_660(bool) = accountBalance >= amount
			TMP_661(None) = SOLIDITY_CALL require(bool,string)(TMP_660,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_130(uint256) -> _balances[account]
			TMP_662(uint256) = accountBalance - amount
			REF_130(uint256) (->_balances) := TMP_662(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_663 = CONVERT 0 to address
			Emit Transfer(account,TMP_663,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_665 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(account,TMP_665,amount)
	Function ERC20Upgradeable._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_667 = CONVERT 0 to address
			TMP_668(bool) = owner != TMP_667
			TMP_669(None) = SOLIDITY_CALL require(bool,string)(TMP_668,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_670 = CONVERT 0 to address
			TMP_671(bool) = spender != TMP_670
			TMP_672(None) = SOLIDITY_CALL require(bool,string)(TMP_671,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_131(mapping(address => uint256)) -> _allowances[owner]
			REF_132(uint256) -> REF_131[spender]
			REF_132(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20Upgradeable._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_674(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_674(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_676(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_677(bool) = currentAllowance != TMP_676
			CONDITION TMP_677
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_678(bool) = currentAllowance >= amount
			TMP_679(None) = SOLIDITY_CALL require(bool,string)(TMP_678,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_680(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_680)
	Function ERC20Upgradeable._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20Upgradeable._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20MetadataUpgradeable.name() 
	Function IERC20MetadataUpgradeable.symbol() 
	Function IERC20MetadataUpgradeable.decimals() 
	Function IERC20Upgradeable.totalSupply() 
	Function IERC20Upgradeable.balanceOf(address) 
	Function IERC20Upgradeable.transfer(address,uint256) 
	Function IERC20Upgradeable.allowance(address,address) 
	Function IERC20Upgradeable.approve(address,uint256) 
	Function IERC20Upgradeable.transferFrom(address,address,uint256) 
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20PermitUpgradeable.__ERC20Permit_init(string) (*)
		Expression: __EIP712_init_unchained(name,1)
		IRs:
			INTERNAL_CALL, EIP712Upgradeable.__EIP712_init_unchained(string,string)(name,1)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20PermitUpgradeable.__ERC20Permit_init_unchained(string) (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20PermitUpgradeable.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_687(bool) = block.timestamp <= deadline
			TMP_688(None) = SOLIDITY_CALL require(bool,string)(TMP_687,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_689(uint256) = INTERNAL_CALL, ERC20PermitUpgradeable._useNonce(address)(owner)
			TMP_690(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_689,deadline)
			TMP_691(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_690)
			structHash(bytes32) := TMP_691(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_692(bytes32) = INTERNAL_CALL, EIP712Upgradeable._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_692(bytes32)
		Expression: signer = ECDSAUpgradeable.recover(hash,v,r,s)
		IRs:
			TMP_693(address) = LIBRARY_CALL, dest:ECDSAUpgradeable, function:ECDSAUpgradeable.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_693(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_694(bool) = signer == owner
			TMP_695(None) = SOLIDITY_CALL require(bool,string)(TMP_694,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,value)
	Function ERC20PermitUpgradeable.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_135(CountersUpgradeable.Counter) -> _nonces[owner]
			TMP_697(uint256) = LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.current(CountersUpgradeable.Counter), arguments:['REF_135'] 
			RETURN TMP_697
	Function ERC20PermitUpgradeable.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_698(bytes32) = INTERNAL_CALL, EIP712Upgradeable._domainSeparatorV4()()
			RETURN TMP_698
	Function ERC20PermitUpgradeable._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_137(CountersUpgradeable.Counter) -> _nonces[owner]
			nonce(CountersUpgradeable.Counter) := REF_137(CountersUpgradeable.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_699(uint256) = LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.current(CountersUpgradeable.Counter), arguments:['nonce'] 
			current(uint256) := TMP_699(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.increment(CountersUpgradeable.Counter), arguments:['nonce'] 
	Function ERC20PermitUpgradeable.slitherConstructorConstantVariables() (*)
		Expression: _PERMIT_TYPEHASH = keccak256(bytes)(Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline))
		IRs:
			TMP_701(bytes32) = SOLIDITY_CALL keccak256(bytes)(Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline))
			_PERMIT_TYPEHASH(bytes32) := TMP_701(bytes32)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_702 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_702(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_703(bool) = _initialized < 1
			TMP_704(bool) = isTopLevelCall && TMP_703
			TMP_705 = CONVERT this to address
			TMP_706(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_705'] 
			TMP_707 = UnaryType.BANG TMP_706 
			TMP_708(bool) = _initialized == 1
			TMP_709(bool) = TMP_707 && TMP_708
			TMP_710(bool) = TMP_704 || TMP_709
			TMP_711(None) = SOLIDITY_CALL require(bool,string)(TMP_710,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_713 = UnaryType.BANG _initializing 
			TMP_714(bool) = _initialized < version
			TMP_715(bool) = TMP_713 && TMP_714
			TMP_716(None) = SOLIDITY_CALL require(bool,string)(TMP_715,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_718(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract IERC20MetadataUpgradeable
	Function IERC20Upgradeable.totalSupply() (*)
	Function IERC20Upgradeable.balanceOf(address) (*)
	Function IERC20Upgradeable.transfer(address,uint256) (*)
	Function IERC20Upgradeable.allowance(address,address) (*)
	Function IERC20Upgradeable.approve(address,uint256) (*)
	Function IERC20Upgradeable.transferFrom(address,address,uint256) (*)
	Function IERC20MetadataUpgradeable.name() (*)
	Function IERC20MetadataUpgradeable.symbol() (*)
	Function IERC20MetadataUpgradeable.decimals() (*)
Contract IERC20PermitUpgradeable
	Function IERC20PermitUpgradeable.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
	Function IERC20PermitUpgradeable.nonces(address) (*)
	Function IERC20PermitUpgradeable.DOMAIN_SEPARATOR() (*)
Contract SafeERC20Upgradeable
	Function SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable,address,uint256) (*)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value))
		IRs:
			REF_143(bytes4) (->None) := 2835717307(uint256)
			TMP_719(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_143,to,value)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_719)
	Function SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256) (*)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value))
		IRs:
			REF_146(bytes4) (->None) := 599290589(uint256)
			TMP_721(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_146,from,to,value)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_721)
	Function SafeERC20Upgradeable.safeApprove(IERC20Upgradeable,address,uint256) (*)
		Expression: require(bool,string)((value == 0) || (token.allowance(address(this),spender) == 0),SafeERC20: approve from non-zero to non-zero allowance)
		IRs:
			TMP_723(bool) = value == 0
			TMP_724 = CONVERT this to address
			TMP_725(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20Upgradeable), function:allowance, arguments:['TMP_724', 'spender']  
			TMP_726(bool) = TMP_725 == 0
			TMP_727(bool) = TMP_723 || TMP_726
			TMP_728(None) = SOLIDITY_CALL require(bool,string)(TMP_727,SafeERC20: approve from non-zero to non-zero allowance)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value))
		IRs:
			REF_150(bytes4) (->None) := 157198259(uint256)
			TMP_729(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_150,spender,value)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_729)
	Function SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable,address,uint256) (*)
		Expression: oldAllowance = token.allowance(address(this),spender)
		IRs:
			TMP_731 = CONVERT this to address
			TMP_732(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20Upgradeable), function:allowance, arguments:['TMP_731', 'spender']  
			oldAllowance(uint256) := TMP_732(uint256)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance + value))
		IRs:
			REF_154(bytes4) (->None) := 157198259(uint256)
			TMP_733(uint256) = oldAllowance (c)+ value
			TMP_734(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_154,spender,TMP_733)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_734)
	Function SafeERC20Upgradeable.safeDecreaseAllowance(IERC20Upgradeable,address,uint256) (*)
		Expression: oldAllowance = token.allowance(address(this),spender)
		IRs:
			TMP_736 = CONVERT this to address
			TMP_737(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20Upgradeable), function:allowance, arguments:['TMP_736', 'spender']  
			oldAllowance(uint256) := TMP_737(uint256)
		Expression: require(bool,string)(oldAllowance >= value,SafeERC20: decreased allowance below zero)
		IRs:
			TMP_738(bool) = oldAllowance >= value
			TMP_739(None) = SOLIDITY_CALL require(bool,string)(TMP_738,SafeERC20: decreased allowance below zero)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance - value))
		IRs:
			REF_158(bytes4) (->None) := 157198259(uint256)
			TMP_740(uint256) = oldAllowance - value
			TMP_741(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_158,spender,TMP_740)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_741)
	Function SafeERC20Upgradeable.forceApprove(IERC20Upgradeable,address,uint256) (*)
		Expression: approvalCall = abi.encodeWithSelector(token.approve.selector,spender,value)
		IRs:
			REF_161(bytes4) (->None) := 157198259(uint256)
			TMP_743(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_161,spender,value)
			approvalCall(bytes) := TMP_743(bytes)
		Expression: ! _callOptionalReturnBool(token,approvalCall)
		IRs:
			TMP_744(bool) = INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturnBool(IERC20Upgradeable,bytes)(token,approvalCall)
			TMP_745 = UnaryType.BANG TMP_744 
			CONDITION TMP_745
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,0))
		IRs:
			REF_164(bytes4) (->None) := 157198259(uint256)
			TMP_746(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_164,spender,0)
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,TMP_746)
		Expression: _callOptionalReturn(token,approvalCall)
		IRs:
			INTERNAL_CALL, SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes)(token,approvalCall)
	Function SafeERC20Upgradeable.safePermit(IERC20PermitUpgradeable,address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: nonceBefore = token.nonces(owner)
		IRs:
			TMP_749(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20PermitUpgradeable), function:nonces, arguments:['owner']  
			nonceBefore(uint256) := TMP_749(uint256)
		Expression: token.permit(owner,spender,value,deadline,v,r,s)
		IRs:
			HIGH_LEVEL_CALL, dest:token(IERC20PermitUpgradeable), function:permit, arguments:['owner', 'spender', 'value', 'deadline', 'v', 'r', 's']  
		Expression: nonceAfter = token.nonces(owner)
		IRs:
			TMP_751(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20PermitUpgradeable), function:nonces, arguments:['owner']  
			nonceAfter(uint256) := TMP_751(uint256)
		Expression: require(bool,string)(nonceAfter == nonceBefore + 1,SafeERC20: permit did not succeed)
		IRs:
			TMP_752(uint256) = nonceBefore (c)+ 1
			TMP_753(bool) = nonceAfter == TMP_752
			TMP_754(None) = SOLIDITY_CALL require(bool,string)(TMP_753,SafeERC20: permit did not succeed)
	Function SafeERC20Upgradeable._callOptionalReturn(IERC20Upgradeable,bytes) (*)
		Expression: returndata = address(token).functionCall(data,SafeERC20: low-level call failed)
		IRs:
			TMP_755 = CONVERT token to address
			TMP_756(bytes) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.functionCall(address,bytes,string), arguments:['TMP_755', 'data', 'SafeERC20: low-level call failed'] 
			returndata(bytes) := TMP_756(bytes)
		Expression: require(bool,string)(returndata.length == 0 || abi.decode(returndata,(bool)),SafeERC20: ERC20 operation did not succeed)
		IRs:
			REF_169 -> LENGTH returndata
			TMP_757(bool) = REF_169 == 0
			TMP_758(bool) = SOLIDITY_CALL abi.decode()(returndata,bool)
			TMP_759(bool) = TMP_757 || TMP_758
			TMP_760(None) = SOLIDITY_CALL require(bool,string)(TMP_759,SafeERC20: ERC20 operation did not succeed)
	Function SafeERC20Upgradeable._callOptionalReturnBool(IERC20Upgradeable,bytes) (*)
		Expression: (success,returndata) = address(token).call(data)
		IRs:
			TMP_761 = CONVERT token to address
			TUPLE_5(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_761, function:call, arguments:['data']  
			success(bool)= UNPACK TUPLE_5 index: 0 
			returndata(bytes)= UNPACK TUPLE_5 index: 1 
		Expression: success && (returndata.length == 0 || abi.decode(returndata,(bool))) && AddressUpgradeable.isContract(address(token))
		IRs:
			REF_172 -> LENGTH returndata
			TMP_762(bool) = REF_172 == 0
			TMP_763(bool) = SOLIDITY_CALL abi.decode()(returndata,bool)
			TMP_764(bool) = TMP_762 || TMP_763
			TMP_765(bool) = success && TMP_764
			TMP_766 = CONVERT token to address
			TMP_767(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_766'] 
			TMP_768(bool) = TMP_765 && TMP_767
			RETURN TMP_768
Contract AddressUpgradeable
	Function AddressUpgradeable.isContract(address) (*)
		Expression: account.code.length > 0
		IRs:
			TMP_769(bytes) = SOLIDITY_CALL code(address)(account)
			REF_175 -> LENGTH TMP_769
			TMP_770(bool) = REF_175 > 0
			RETURN TMP_770
	Function AddressUpgradeable.sendValue(address,uint256) (*)
		Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)
		IRs:
			TMP_771 = CONVERT this to address
			TMP_772(uint256) = SOLIDITY_CALL balance(address)(TMP_771)
			TMP_773(bool) = TMP_772 >= amount
			TMP_774(None) = SOLIDITY_CALL require(bool,string)(TMP_773,Address: insufficient balance)
		Expression: (success) = recipient.call{value: amount}()
		IRs:
			TUPLE_6(bool,bytes) = LOW_LEVEL_CALL, dest:recipient, function:call, arguments:[''] value:amount 
			success(bool)= UNPACK TUPLE_6 index: 0 
		Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)
		IRs:
			TMP_775(None) = SOLIDITY_CALL require(bool,string)(success,Address: unable to send value, recipient may have reverted)
	Function AddressUpgradeable.functionCall(address,bytes) (*)
		Expression: functionCallWithValue(target,data,0,Address: low-level call failed)
		IRs:
			TMP_776(bytes) = INTERNAL_CALL, AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string)(target,data,0,Address: low-level call failed)
			RETURN TMP_776
	Function AddressUpgradeable.functionCall(address,bytes,string) (*)
		Expression: functionCallWithValue(target,data,0,errorMessage)
		IRs:
			TMP_777(bytes) = INTERNAL_CALL, AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string)(target,data,0,errorMessage)
			RETURN TMP_777
	Function AddressUpgradeable.functionCallWithValue(address,bytes,uint256) (*)
		Expression: functionCallWithValue(target,data,value,Address: low-level call with value failed)
		IRs:
			TMP_778(bytes) = INTERNAL_CALL, AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string)(target,data,value,Address: low-level call with value failed)
			RETURN TMP_778
	Function AddressUpgradeable.functionCallWithValue(address,bytes,uint256,string) (*)
		Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)
		IRs:
			TMP_779 = CONVERT this to address
			TMP_780(uint256) = SOLIDITY_CALL balance(address)(TMP_779)
			TMP_781(bool) = TMP_780 >= value
			TMP_782(None) = SOLIDITY_CALL require(bool,string)(TMP_781,Address: insufficient balance for call)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_7(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_7 index: 0 
			returndata(bytes)= UNPACK TUPLE_7 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_783(bytes) = INTERNAL_CALL, AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_783
	Function AddressUpgradeable.functionStaticCall(address,bytes) (*)
		Expression: functionStaticCall(target,data,Address: low-level static call failed)
		IRs:
			TMP_784(bytes) = INTERNAL_CALL, AddressUpgradeable.functionStaticCall(address,bytes,string)(target,data,Address: low-level static call failed)
			RETURN TMP_784
	Function AddressUpgradeable.functionStaticCall(address,bytes,string) (*)
		Expression: (success,returndata) = target.staticcall(data)
		IRs:
			TUPLE_8(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:staticcall, arguments:['data']  
			success(bool)= UNPACK TUPLE_8 index: 0 
			returndata(bytes)= UNPACK TUPLE_8 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_785(bytes) = INTERNAL_CALL, AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_785
	Function AddressUpgradeable.functionDelegateCall(address,bytes) (*)
		Expression: functionDelegateCall(target,data,Address: low-level delegate call failed)
		IRs:
			TMP_786(bytes) = INTERNAL_CALL, AddressUpgradeable.functionDelegateCall(address,bytes,string)(target,data,Address: low-level delegate call failed)
			RETURN TMP_786
	Function AddressUpgradeable.functionDelegateCall(address,bytes,string) (*)
		Expression: (success,returndata) = target.delegatecall(data)
		IRs:
			TUPLE_9(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:delegatecall, arguments:['data']  
			success(bool)= UNPACK TUPLE_9 index: 0 
			returndata(bytes)= UNPACK TUPLE_9 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_787(bytes) = INTERNAL_CALL, AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_787
	Function AddressUpgradeable.verifyCallResultFromTarget(address,bool,bytes,string) (*)
		Expression: success
		IRs:
			CONDITION success
		Expression: returndata.length == 0
		IRs:
			REF_180 -> LENGTH returndata
			TMP_788(bool) = REF_180 == 0
			CONDITION TMP_788
		Expression: require(bool,string)(isContract(target),Address: call to non-contract)
		IRs:
			TMP_789(bool) = INTERNAL_CALL, AddressUpgradeable.isContract(address)(target)
			TMP_790(None) = SOLIDITY_CALL require(bool,string)(TMP_789,Address: call to non-contract)
		Expression: returndata
		IRs:
			RETURN returndata
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, AddressUpgradeable._revert(bytes,string)(returndata,errorMessage)
	Function AddressUpgradeable.verifyCallResult(bool,bytes,string) (*)
		Expression: success
		IRs:
			CONDITION success
		Expression: returndata
		IRs:
			RETURN returndata
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, AddressUpgradeable._revert(bytes,string)(returndata,errorMessage)
	Function AddressUpgradeable._revert(bytes,string) (*)
		Expression: returndata.length > 0
		IRs:
			REF_181 -> LENGTH returndata
			TMP_793(bool) = REF_181 > 0
			CONDITION TMP_793
		Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)
		IRs:
			TMP_794(uint256) = SOLIDITY_CALL mload(uint256)(returndata)
			returndata_size__revert_asm_0(uint256) := TMP_794(uint256)
		Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)
		IRs:
			TMP_795(uint256) = 32 + returndata
			TMP_796(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_795,returndata_size__revert_asm_0)
		Expression: revert(string)(errorMessage)
		IRs:
			TMP_797(None) = SOLIDITY_CALL revert(string)(errorMessage)
Contract ContextUpgradeable
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_798 = UnaryType.BANG _initializing 
			TMP_799(None) = SOLIDITY_CALL require(bool,string)(TMP_798,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_801(uint8) := 255(uint8)
			TMP_802(bool) = _initialized != TMP_801
			CONDITION TMP_802
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_804(uint8) := 255(uint8)
			_initialized(uint8) := TMP_804(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_806(uint8) := 255(uint8)
			Emit Initialized(TMP_806)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_810 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_810(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_811(bool) = _initialized < 1
			TMP_812(bool) = isTopLevelCall && TMP_811
			TMP_813 = CONVERT this to address
			TMP_814(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_813'] 
			TMP_815 = UnaryType.BANG TMP_814 
			TMP_816(bool) = _initialized == 1
			TMP_817(bool) = TMP_815 && TMP_816
			TMP_818(bool) = TMP_812 || TMP_817
			TMP_819(None) = SOLIDITY_CALL require(bool,string)(TMP_818,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_821 = UnaryType.BANG _initializing 
			TMP_822(bool) = _initialized < version
			TMP_823(bool) = TMP_821 && TMP_822
			TMP_824(None) = SOLIDITY_CALL require(bool,string)(TMP_823,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_826(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract CountersUpgradeable
	Function CountersUpgradeable.current(CountersUpgradeable.Counter) (*)
		Expression: counter._value
		IRs:
			REF_183(uint256) -> counter._value
			RETURN REF_183
	Function CountersUpgradeable.increment(CountersUpgradeable.Counter) (*)
		Expression: counter._value += 1
		IRs:
			REF_184(uint256) -> counter._value
			REF_184(-> counter) = REF_184 + 1
	Function CountersUpgradeable.decrement(CountersUpgradeable.Counter) (*)
		Expression: value = counter._value
		IRs:
			REF_185(uint256) -> counter._value
			value(uint256) := REF_185(uint256)
		Expression: require(bool,string)(value > 0,Counter: decrement overflow)
		IRs:
			TMP_827(bool) = value > 0
			TMP_828(None) = SOLIDITY_CALL require(bool,string)(TMP_827,Counter: decrement overflow)
		Expression: counter._value = value - 1
		IRs:
			REF_186(uint256) -> counter._value
			TMP_829(uint256) = value - 1
			REF_186(uint256) (->counter) := TMP_829(uint256)
	Function CountersUpgradeable.reset(CountersUpgradeable.Counter) (*)
		Expression: counter._value = 0
		IRs:
			REF_187(uint256) -> counter._value
			REF_187(uint256) (->counter) := 0(uint256)
Contract StringsUpgradeable
	Function StringsUpgradeable.toString(uint256) (*)
		Expression: length = MathUpgradeable.log10(value) + 1
		IRs:
			TMP_830(uint256) = LIBRARY_CALL, dest:MathUpgradeable, function:MathUpgradeable.log10(uint256), arguments:['value'] 
			TMP_831(uint256) = TMP_830 + 1
			length(uint256) := TMP_831(uint256)
		Expression: buffer = new string(length)
		IRs:
			TMP_833 = new string(length)
			buffer(string) := TMP_833(string)
		Expression: ptr = buffer + 32 + length
		IRs:
			TMP_834(uint256) = 32 + length
			TMP_835(string) = buffer + TMP_834
			ptr(uint256) := TMP_835(string)
		Expression: true
		IRs:
			CONDITION True
		Expression: ptr --
		IRs:
			TMP_836(uint256) := ptr(uint256)
			ptr(uint256) = ptr - 1
		Expression: mstore8(uint256,uint256)(ptr,byte(uint256,uint256)(value % 10,_SYMBOLS))
		IRs:
			TMP_837(uint256) = value % 10
			TMP_838(uint256) = SOLIDITY_CALL byte(uint256,uint256)(TMP_837,_SYMBOLS)
			TMP_839(None) = SOLIDITY_CALL mstore8(uint256,uint256)(ptr,TMP_838)
		Expression: value /= 10
		IRs:
			value(uint256) = value / 10
		Expression: value == 0
		IRs:
			TMP_840(bool) = value == 0
			CONDITION TMP_840
		Expression: buffer
		IRs:
			RETURN buffer
	Function StringsUpgradeable.toString(int256) (*)
		Expression: value < 0
		IRs:
			TMP_841(bool) = value < 0
			CONDITION TMP_841
		Expression: string(abi.encodePacked(-,toString(SignedMathUpgradeable.abs(value))))
		IRs:
			TMP_842(uint256) = LIBRARY_CALL, dest:SignedMathUpgradeable, function:SignedMathUpgradeable.abs(int256), arguments:['value'] 
			TMP_843(string) = INTERNAL_CALL, StringsUpgradeable.toString(uint256)(TMP_842)
			TMP_844(bytes) = SOLIDITY_CALL abi.encodePacked()(-,TMP_843)
			TMP_845 = CONVERT TMP_844 to string
			RETURN TMP_845
		Expression: string(abi.encodePacked(,toString(SignedMathUpgradeable.abs(value))))
		IRs:
			TMP_846(uint256) = LIBRARY_CALL, dest:SignedMathUpgradeable, function:SignedMathUpgradeable.abs(int256), arguments:['value'] 
			TMP_847(string) = INTERNAL_CALL, StringsUpgradeable.toString(uint256)(TMP_846)
			TMP_848(bytes) = SOLIDITY_CALL abi.encodePacked()(,TMP_847)
			TMP_849 = CONVERT TMP_848 to string
			RETURN TMP_849
	Function StringsUpgradeable.toHexString(uint256) (*)
		Expression: toHexString(value,MathUpgradeable.log256(value) + 1)
		IRs:
			TMP_850(uint256) = LIBRARY_CALL, dest:MathUpgradeable, function:MathUpgradeable.log256(uint256), arguments:['value'] 
			TMP_851(uint256) = TMP_850 + 1
			TMP_852(string) = INTERNAL_CALL, StringsUpgradeable.toHexString(uint256,uint256)(value,TMP_851)
			RETURN TMP_852
	Function StringsUpgradeable.toHexString(uint256,uint256) (*)
		Expression: buffer = new bytes(2 * length + 2)
		IRs:
			TMP_854(uint256) = 2 (c)* length
			TMP_855(uint256) = TMP_854 (c)+ 2
			TMP_856 = new bytes(TMP_855)
			buffer(bytes) := TMP_856(bytes)
		Expression: buffer[0] = 0
		IRs:
			REF_194(string) -> buffer[0]
			REF_194(string) (->buffer) := 0(string)
		Expression: buffer[1] = x
		IRs:
			REF_195(string) -> buffer[1]
			REF_195(string) (->buffer) := x(string)
		Expression: i = 2 * length + 1
		IRs:
			TMP_857(uint256) = 2 (c)* length
			TMP_858(uint256) = TMP_857 (c)+ 1
			i(uint256) := TMP_858(uint256)
		Expression: i > 1
		IRs:
			TMP_859(bool) = i > 1
			CONDITION TMP_859
		Expression: buffer[i] = _SYMBOLS[value & 0xf]
		IRs:
			REF_196(None) -> buffer[i]
			TMP_860(uint256) = value & 15
			REF_197(None) -> _SYMBOLS[TMP_860]
			REF_196(None) (->buffer) := REF_197(None)
		Expression: value >>= 4
		IRs:
			value(uint256) = value >> 4
		Expression: -- i
		IRs:
			i(uint256) = i (c)- 1
		Expression: require(bool,string)(value == 0,Strings: hex length insufficient)
		IRs:
			TMP_861(bool) = value == 0
			TMP_862(None) = SOLIDITY_CALL require(bool,string)(TMP_861,Strings: hex length insufficient)
		Expression: string(buffer)
		IRs:
			TMP_863 = CONVERT buffer to string
			RETURN TMP_863
	Function StringsUpgradeable.toHexString(address) (*)
		Expression: toHexString(uint256(uint160(addr)),_ADDRESS_LENGTH)
		IRs:
			TMP_864 = CONVERT addr to uint160
			TMP_865 = CONVERT TMP_864 to uint256
			TMP_866(string) = INTERNAL_CALL, StringsUpgradeable.toHexString(uint256,uint256)(TMP_865,_ADDRESS_LENGTH)
			RETURN TMP_866
	Function StringsUpgradeable.equal(string,string) (*)
		Expression: keccak256(bytes)(bytes(a)) == keccak256(bytes)(bytes(b))
		IRs:
			TMP_867 = CONVERT a to bytes
			TMP_868(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_867)
			TMP_869 = CONVERT b to bytes
			TMP_870(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_869)
			TMP_871(bool) = TMP_868 == TMP_870
			RETURN TMP_871
	Function StringsUpgradeable.slitherConstructorConstantVariables() (*)
		Expression: _SYMBOLS = 0123456789abcdef
		IRs:
			_SYMBOLS(bytes16) := 0123456789abcdef(string)
		Expression: _ADDRESS_LENGTH = 20
		IRs:
			_ADDRESS_LENGTH(uint8) := 20(uint256)
Contract ECDSAUpgradeable
	Function ECDSAUpgradeable._throwError(ECDSAUpgradeable.RecoverError) (*)
		Expression: error == RecoverError.NoError
		IRs:
			REF_198(ECDSAUpgradeable.RecoverError) -> RecoverError.NoError
			TMP_872(bool) = error == REF_198
			CONDITION TMP_872
		Expression: error == RecoverError.InvalidSignature
		IRs:
			REF_199(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignature
			TMP_873(bool) = error == REF_199
			CONDITION TMP_873
		Expression: revert(string)(ECDSA: invalid signature)
		IRs:
			TMP_874(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature)
		Expression: error == RecoverError.InvalidSignatureLength
		IRs:
			REF_200(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignatureLength
			TMP_875(bool) = error == REF_200
			CONDITION TMP_875
		Expression: revert(string)(ECDSA: invalid signature length)
		IRs:
			TMP_876(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature length)
		Expression: error == RecoverError.InvalidSignatureS
		IRs:
			REF_201(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignatureS
			TMP_877(bool) = error == REF_201
			CONDITION TMP_877
		Expression: revert(string)(ECDSA: invalid signature 's' value)
		IRs:
			TMP_878(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature 's' value)
	Function ECDSAUpgradeable.tryRecover(bytes32,bytes) (*)
		Expression: signature.length == 65
		IRs:
			REF_202 -> LENGTH signature
			TMP_879(bool) = REF_202 == 65
			CONDITION TMP_879
		Expression: r = mload(uint256)(signature + 0x20)
		IRs:
			TMP_880(bytes) = signature + 32
			TMP_881(uint256) = SOLIDITY_CALL mload(uint256)(TMP_880)
			r(bytes32) := TMP_881(uint256)
		Expression: s = mload(uint256)(signature + 0x40)
		IRs:
			TMP_882(bytes) = signature + 64
			TMP_883(uint256) = SOLIDITY_CALL mload(uint256)(TMP_882)
			s(bytes32) := TMP_883(uint256)
		Expression: v = byte(uint256,uint256)(0,mload(uint256)(signature + 0x60))
		IRs:
			TMP_884(bytes) = signature + 96
			TMP_885(uint256) = SOLIDITY_CALL mload(uint256)(TMP_884)
			TMP_886(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_885)
			v(uint8) := TMP_886(uint256)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_10(address,ECDSAUpgradeable.RecoverError) = INTERNAL_CALL, ECDSAUpgradeable.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			RETURN TUPLE_10
		Expression: (address(0),RecoverError.InvalidSignatureLength)
		IRs:
			TMP_887 = CONVERT 0 to address
			REF_203(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignatureLength
			RETURN TMP_887,REF_203
	Function ECDSAUpgradeable.recover(bytes32,bytes) (*)
		Expression: (recovered,error) = tryRecover(hash,signature)
		IRs:
			TUPLE_11(address,ECDSAUpgradeable.RecoverError) = INTERNAL_CALL, ECDSAUpgradeable.tryRecover(bytes32,bytes)(hash,signature)
			recovered(address)= UNPACK TUPLE_11 index: 0 
			error(ECDSAUpgradeable.RecoverError)= UNPACK TUPLE_11 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSAUpgradeable._throwError(ECDSAUpgradeable.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSAUpgradeable.tryRecover(bytes32,bytes32,bytes32) (*)
		Expression: s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
		IRs:
			TMP_889 = CONVERT 57896044618658097711785492504343953926634992332820282019728792003956564819967 to bytes32
			TMP_890(bytes32) = vs & TMP_889
			s(bytes32) := TMP_890(bytes32)
		Expression: v = uint8((uint256(vs) >> 255) + 27)
		IRs:
			TMP_891 = CONVERT vs to uint256
			TMP_892(uint256) = TMP_891 >> 255
			TMP_893(uint256) = TMP_892 (c)+ 27
			TMP_894 = CONVERT TMP_893 to uint8
			v(uint8) := TMP_894(uint8)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_12(address,ECDSAUpgradeable.RecoverError) = INTERNAL_CALL, ECDSAUpgradeable.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			RETURN TUPLE_12
	Function ECDSAUpgradeable.recover(bytes32,bytes32,bytes32) (*)
		Expression: (recovered,error) = tryRecover(hash,r,vs)
		IRs:
			TUPLE_13(address,ECDSAUpgradeable.RecoverError) = INTERNAL_CALL, ECDSAUpgradeable.tryRecover(bytes32,bytes32,bytes32)(hash,r,vs)
			recovered(address)= UNPACK TUPLE_13 index: 0 
			error(ECDSAUpgradeable.RecoverError)= UNPACK TUPLE_13 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSAUpgradeable._throwError(ECDSAUpgradeable.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSAUpgradeable.tryRecover(bytes32,uint8,bytes32,bytes32) (*)
		Expression: uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
		IRs:
			TMP_896 = CONVERT s to uint256
			TMP_897(bool) = TMP_896 > 57896044618658097711785492504343953926418782139537452191302581570759080747168
			CONDITION TMP_897
		Expression: (address(0),RecoverError.InvalidSignatureS)
		IRs:
			TMP_898 = CONVERT 0 to address
			REF_204(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignatureS
			RETURN TMP_898,REF_204
		Expression: signer = ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
		IRs:
			TMP_899(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			signer(address) := TMP_899(address)
		Expression: signer == address(0)
		IRs:
			TMP_900 = CONVERT 0 to address
			TMP_901(bool) = signer == TMP_900
			CONDITION TMP_901
		Expression: (address(0),RecoverError.InvalidSignature)
		IRs:
			TMP_902 = CONVERT 0 to address
			REF_205(ECDSAUpgradeable.RecoverError) -> RecoverError.InvalidSignature
			RETURN TMP_902,REF_205
		Expression: (signer,RecoverError.NoError)
		IRs:
			REF_206(ECDSAUpgradeable.RecoverError) -> RecoverError.NoError
			RETURN signer,REF_206
	Function ECDSAUpgradeable.recover(bytes32,uint8,bytes32,bytes32) (*)
		Expression: (recovered,error) = tryRecover(hash,v,r,s)
		IRs:
			TUPLE_14(address,ECDSAUpgradeable.RecoverError) = INTERNAL_CALL, ECDSAUpgradeable.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			recovered(address)= UNPACK TUPLE_14 index: 0 
			error(ECDSAUpgradeable.RecoverError)= UNPACK TUPLE_14 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSAUpgradeable._throwError(ECDSAUpgradeable.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSAUpgradeable.toEthSignedMessageHash(bytes32) (*)
		Expression: mstore(uint256,uint256)(0x00,Ethereum Signed Message:
32)
		IRs:
			TMP_904(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,Ethereum Signed Message:
32)
		Expression: mstore(uint256,uint256)(0x1c,hash)
		IRs:
			TMP_905(None) = SOLIDITY_CALL mstore(uint256,uint256)(28,hash)
		Expression: message = keccak256(uint256,uint256)(0x00,0x3c)
		IRs:
			TMP_906(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,60)
			message(bytes32) := TMP_906(uint256)
	Function ECDSAUpgradeable.toEthSignedMessageHash(bytes) (*)
		Expression: keccak256(bytes)(abi.encodePacked(Ethereum Signed Message:
,StringsUpgradeable.toString(s.length),s))
		IRs:
			REF_209 -> LENGTH s
			TMP_907(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toString(uint256), arguments:['REF_209'] 
			TMP_908(bytes) = SOLIDITY_CALL abi.encodePacked()(Ethereum Signed Message:
,TMP_907,s)
			TMP_909(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_908)
			RETURN TMP_909
	Function ECDSAUpgradeable.toTypedDataHash(bytes32,bytes32) (*)
		Expression: ptr_toTypedDataHash_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_910(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_toTypedDataHash_asm_0(uint256) := TMP_910(uint256)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,)
		IRs:
			TMP_911(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x02,domainSeparator)
		IRs:
			TMP_912(uint256) = ptr_toTypedDataHash_asm_0 + 2
			TMP_913(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_912,domainSeparator)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x22,structHash)
		IRs:
			TMP_914(uint256) = ptr_toTypedDataHash_asm_0 + 34
			TMP_915(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_914,structHash)
		Expression: data = keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,0x42)
		IRs:
			TMP_916(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,66)
			data(bytes32) := TMP_916(uint256)
	Function ECDSAUpgradeable.toDataWithIntendedValidatorHash(address,bytes) (*)
		Expression: keccak256(bytes)(abi.encodePacked( ,validator,data))
		IRs:
			TMP_917(bytes) = SOLIDITY_CALL abi.encodePacked()( ,validator,data)
			TMP_918(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_917)
			RETURN TMP_918
Contract EIP712Upgradeable
	Function IERC5267Upgradeable.eip712Domain() 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_919 = UnaryType.BANG _initializing 
			TMP_920(None) = SOLIDITY_CALL require(bool,string)(TMP_919,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_922(uint8) := 255(uint8)
			TMP_923(bool) = _initialized != TMP_922
			CONDITION TMP_923
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_925(uint8) := 255(uint8)
			_initialized(uint8) := TMP_925(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_927(uint8) := 255(uint8)
			Emit Initialized(TMP_927)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function EIP712Upgradeable.__EIP712_init(string,string) (*)
		Expression: __EIP712_init_unchained(name,version)
		IRs:
			INTERNAL_CALL, EIP712Upgradeable.__EIP712_init_unchained(string,string)(name,version)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable.__EIP712_init_unchained(string,string) (*)
		Expression: _name = name
		IRs:
			_name(string) := name(string)
		Expression: _version = version
		IRs:
			_version(string) := version(string)
		Expression: _hashedName = 0
		IRs:
			_hashedName(bytes32) := 0(uint256)
		Expression: _hashedVersion = 0
		IRs:
			_hashedVersion(bytes32) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable._domainSeparatorV4() (*)
		Expression: _buildDomainSeparator()
		IRs:
			TMP_932(bytes32) = INTERNAL_CALL, EIP712Upgradeable._buildDomainSeparator()()
			RETURN TMP_932
	Function EIP712Upgradeable._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_EIP712NameHash(),_EIP712VersionHash(),block.chainid,address(this)))
		IRs:
			TMP_933(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712NameHash()()
			TMP_934(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712VersionHash()()
			TMP_935 = CONVERT this to address
			TMP_936(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,TMP_933,TMP_934,block.chainid,TMP_935)
			TMP_937(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_936)
			RETURN TMP_937
	Function EIP712Upgradeable._hashTypedDataV4(bytes32) (*)
		Expression: ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_938(bytes32) = INTERNAL_CALL, EIP712Upgradeable._domainSeparatorV4()()
			TMP_939(bytes32) = LIBRARY_CALL, dest:ECDSAUpgradeable, function:ECDSAUpgradeable.toTypedDataHash(bytes32,bytes32), arguments:['TMP_938', 'structHash'] 
			RETURN TMP_939
	Function EIP712Upgradeable.eip712Domain() (*)
		Expression: require(bool,string)(_hashedName == 0 && _hashedVersion == 0,EIP712: Uninitialized)
		IRs:
			TMP_940(bool) = _hashedName == 0
			TMP_941(bool) = _hashedVersion == 0
			TMP_942(bool) = TMP_940 && TMP_941
			TMP_943(None) = SOLIDITY_CALL require(bool,string)(TMP_942,EIP712: Uninitialized)
		Expression: (,_EIP712Name(),_EIP712Version(),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_944(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			TMP_945(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			TMP_946 = CONVERT this to address
			TMP_947 = CONVERT 0 to bytes32
			TMP_949(uint256[])  = new uint256[](0)
			RETURN ,TMP_944,TMP_945,block.chainid,TMP_946,TMP_947,TMP_949
	Function EIP712Upgradeable._EIP712Name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function EIP712Upgradeable._EIP712Version() (*)
		Expression: _version
		IRs:
			RETURN _version
	Function EIP712Upgradeable._EIP712NameHash() (*)
		Expression: name = _EIP712Name()
		IRs:
			TMP_950(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			name(string) := TMP_950(string)
		Expression: bytes(name).length > 0
		IRs:
			TMP_951 = CONVERT name to bytes
			REF_213 -> LENGTH TMP_951
			TMP_952(bool) = REF_213 > 0
			CONDITION TMP_952
		Expression: keccak256(bytes)(bytes(name))
		IRs:
			TMP_953 = CONVERT name to bytes
			TMP_954(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_953)
			RETURN TMP_954
		Expression: hashedName = _hashedName
		IRs:
			hashedName(bytes32) := _hashedName(bytes32)
		Expression: hashedName != 0
		IRs:
			TMP_955(bool) = hashedName != 0
			CONDITION TMP_955
		Expression: hashedName
		IRs:
			RETURN hashedName
		Expression: keccak256(bytes)()
		IRs:
			TMP_956(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_956
	Function EIP712Upgradeable._EIP712VersionHash() (*)
		Expression: version = _EIP712Version()
		IRs:
			TMP_957(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			version(string) := TMP_957(string)
		Expression: bytes(version).length > 0
		IRs:
			TMP_958 = CONVERT version to bytes
			REF_214 -> LENGTH TMP_958
			TMP_959(bool) = REF_214 > 0
			CONDITION TMP_959
		Expression: keccak256(bytes)(bytes(version))
		IRs:
			TMP_960 = CONVERT version to bytes
			TMP_961(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_960)
			RETURN TMP_961
		Expression: hashedVersion = _hashedVersion
		IRs:
			hashedVersion(bytes32) := _hashedVersion(bytes32)
		Expression: hashedVersion != 0
		IRs:
			TMP_962(bool) = hashedVersion != 0
			CONDITION TMP_962
		Expression: hashedVersion
		IRs:
			RETURN hashedVersion
		Expression: keccak256(bytes)()
		IRs:
			TMP_963(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_963
	Function EIP712Upgradeable.slitherConstructorConstantVariables() (*)
		Expression: _TYPE_HASH = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_964(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			_TYPE_HASH(bytes32) := TMP_964(bytes32)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_965 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_965(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_966(bool) = _initialized < 1
			TMP_967(bool) = isTopLevelCall && TMP_966
			TMP_968 = CONVERT this to address
			TMP_969(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_968'] 
			TMP_970 = UnaryType.BANG TMP_969 
			TMP_971(bool) = _initialized == 1
			TMP_972(bool) = TMP_970 && TMP_971
			TMP_973(bool) = TMP_967 || TMP_972
			TMP_974(None) = SOLIDITY_CALL require(bool,string)(TMP_973,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_976 = UnaryType.BANG _initializing 
			TMP_977(bool) = _initialized < version
			TMP_978(bool) = TMP_976 && TMP_977
			TMP_979(None) = SOLIDITY_CALL require(bool,string)(TMP_978,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_981(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract ERC165Upgradeable
	Function IERC165Upgradeable.supportsInterface(bytes4) 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_982 = UnaryType.BANG _initializing 
			TMP_983(None) = SOLIDITY_CALL require(bool,string)(TMP_982,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_985(uint8) := 255(uint8)
			TMP_986(bool) = _initialized != TMP_985
			CONDITION TMP_986
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_988(uint8) := 255(uint8)
			_initialized(uint8) := TMP_988(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_990(uint8) := 255(uint8)
			Emit Initialized(TMP_990)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ERC165Upgradeable.__ERC165_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.__ERC165_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IERC165Upgradeable).interfaceId
		IRs:
			TMP_994(type(IERC165Upgradeable)) = SOLIDITY_CALL type()(IERC165Upgradeable)
			REF_216(bytes4) (->None) := 33540519(bytes4)
			TMP_995(bool) = interfaceId == REF_216
			RETURN TMP_995
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_996 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_996(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_997(bool) = _initialized < 1
			TMP_998(bool) = isTopLevelCall && TMP_997
			TMP_999 = CONVERT this to address
			TMP_1000(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_999'] 
			TMP_1001 = UnaryType.BANG TMP_1000 
			TMP_1002(bool) = _initialized == 1
			TMP_1003(bool) = TMP_1001 && TMP_1002
			TMP_1004(bool) = TMP_998 || TMP_1003
			TMP_1005(None) = SOLIDITY_CALL require(bool,string)(TMP_1004,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_1007 = UnaryType.BANG _initializing 
			TMP_1008(bool) = _initialized < version
			TMP_1009(bool) = TMP_1007 && TMP_1008
			TMP_1010(None) = SOLIDITY_CALL require(bool,string)(TMP_1009,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_1012(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract IERC165Upgradeable
	Function IERC165Upgradeable.supportsInterface(bytes4) (*)
Contract MathUpgradeable
	Function MathUpgradeable.max(uint256,uint256) (*)
		Expression: a > b
		IRs:
			TMP_1013(bool) = a > b
			CONDITION TMP_1013
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function MathUpgradeable.min(uint256,uint256) (*)
		Expression: a < b
		IRs:
			TMP_1014(bool) = a < b
			CONDITION TMP_1014
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function MathUpgradeable.average(uint256,uint256) (*)
		Expression: (a & b) + (a ^ b) / 2
		IRs:
			TMP_1015(uint256) = a & b
			TMP_1016(uint256) = a ^ b
			TMP_1017(uint256) = TMP_1016 (c)/ 2
			TMP_1018(uint256) = TMP_1015 (c)+ TMP_1017
			RETURN TMP_1018
	Function MathUpgradeable.ceilDiv(uint256,uint256) (*)
		Expression: a == 0
		IRs:
			TMP_1019(bool) = a == 0
			CONDITION TMP_1019
		Expression: 0
		IRs:
			RETURN 0
		Expression: (a - 1) / b + 1
		IRs:
			TMP_1020(uint256) = a (c)- 1
			TMP_1021(uint256) = TMP_1020 (c)/ b
			TMP_1022(uint256) = TMP_1021 (c)+ 1
			RETURN TMP_1022
	Function MathUpgradeable.mulDiv(uint256,uint256,uint256) (*)
		Expression: mm_mulDiv_asm_0 = mulmod(uint256,uint256,uint256)(x,y,~ 0)
		IRs:
			TMP_1023 = UnaryType.TILD 0 
			TMP_1024(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,TMP_1023)
			mm_mulDiv_asm_0(uint256) := TMP_1024(uint256)
		Expression: prod0 = x * y
		IRs:
			TMP_1025(uint256) = x * y
			prod0(uint256) := TMP_1025(uint256)
		Expression: prod1 = mm_mulDiv_asm_0 - prod0 - mm_mulDiv_asm_0 < prod0
		IRs:
			TMP_1026(uint256) = mm_mulDiv_asm_0 - prod0
			TMP_1027(bool) = mm_mulDiv_asm_0 < prod0
			TMP_1028(uint256) = TMP_1026 - TMP_1027
			prod1(uint256) := TMP_1028(uint256)
		Expression: prod1 == 0
		IRs:
			TMP_1029(bool) = prod1 == 0
			CONDITION TMP_1029
		Expression: prod0 / denominator
		IRs:
			TMP_1030(uint256) = prod0 / denominator
			RETURN TMP_1030
		Expression: require(bool,string)(denominator > prod1,Math: mulDiv overflow)
		IRs:
			TMP_1031(bool) = denominator > prod1
			TMP_1032(None) = SOLIDITY_CALL require(bool,string)(TMP_1031,Math: mulDiv overflow)
		Expression: remainder = mulmod(uint256,uint256,uint256)(x,y,denominator)
		IRs:
			TMP_1033(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,denominator)
			remainder(uint256) := TMP_1033(uint256)
		Expression: prod1 = prod1 - remainder > prod0
		IRs:
			TMP_1034(bool) = remainder > prod0
			TMP_1035(uint256) = prod1 - TMP_1034
			prod1(uint256) := TMP_1035(uint256)
		Expression: prod0 = prod0 - remainder
		IRs:
			TMP_1036(uint256) = prod0 - remainder
			prod0(uint256) := TMP_1036(uint256)
		Expression: twos = denominator & (~ denominator + 1)
		IRs:
			TMP_1037 = UnaryType.TILD denominator 
			TMP_1038(uint256) = TMP_1037 + 1
			TMP_1039(uint256) = denominator & TMP_1038
			twos(uint256) := TMP_1039(uint256)
		Expression: denominator = denominator / twos
		IRs:
			TMP_1040(uint256) = denominator / twos
			denominator(uint256) := TMP_1040(uint256)
		Expression: prod0 = prod0 / twos
		IRs:
			TMP_1041(uint256) = prod0 / twos
			prod0(uint256) := TMP_1041(uint256)
		Expression: twos = 0 - twos / twos + 1
		IRs:
			TMP_1042(uint256) = 0 - twos
			TMP_1043(uint256) = TMP_1042 / twos
			TMP_1044(uint256) = TMP_1043 + 1
			twos(uint256) := TMP_1044(uint256)
		Expression: prod0 |= prod1 * twos
		IRs:
			TMP_1045(uint256) = prod1 * twos
			prod0(uint256) = prod0 | TMP_1045
		Expression: inverse = (3 * denominator) ^ 2
		IRs:
			TMP_1046(uint256) = 3 * denominator
			TMP_1047(uint256) = TMP_1046 ^ 2
			inverse(uint256) := TMP_1047(uint256)
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1048(uint256) = denominator * inverse
			TMP_1049(uint256) = 2 - TMP_1048
			inverse(uint256) = inverse * TMP_1049
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1050(uint256) = denominator * inverse
			TMP_1051(uint256) = 2 - TMP_1050
			inverse(uint256) = inverse * TMP_1051
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1052(uint256) = denominator * inverse
			TMP_1053(uint256) = 2 - TMP_1052
			inverse(uint256) = inverse * TMP_1053
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1054(uint256) = denominator * inverse
			TMP_1055(uint256) = 2 - TMP_1054
			inverse(uint256) = inverse * TMP_1055
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1056(uint256) = denominator * inverse
			TMP_1057(uint256) = 2 - TMP_1056
			inverse(uint256) = inverse * TMP_1057
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_1058(uint256) = denominator * inverse
			TMP_1059(uint256) = 2 - TMP_1058
			inverse(uint256) = inverse * TMP_1059
		Expression: result = prod0 * inverse
		IRs:
			TMP_1060(uint256) = prod0 * inverse
			result(uint256) := TMP_1060(uint256)
		Expression: result
		IRs:
			RETURN result
	Function MathUpgradeable.mulDiv(uint256,uint256,uint256,MathUpgradeable.Rounding) (*)
		Expression: result = mulDiv(x,y,denominator)
		IRs:
			TMP_1061(uint256) = INTERNAL_CALL, MathUpgradeable.mulDiv(uint256,uint256,uint256)(x,y,denominator)
			result(uint256) := TMP_1061(uint256)
		Expression: rounding == Rounding.Up && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0
		IRs:
			REF_218(MathUpgradeable.Rounding) -> Rounding.Up
			TMP_1062(bool) = rounding == REF_218
			TMP_1063(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,denominator)
			TMP_1064(bool) = TMP_1063 > 0
			TMP_1065(bool) = TMP_1062 && TMP_1064
			CONDITION TMP_1065
		Expression: result += 1
		IRs:
			result(uint256) = result (c)+ 1
		Expression: result
		IRs:
			RETURN result
	Function MathUpgradeable.sqrt(uint256) (*)
		Expression: a == 0
		IRs:
			TMP_1066(bool) = a == 0
			CONDITION TMP_1066
		Expression: 0
		IRs:
			RETURN 0
		Expression: result = 1 << (log2(a) >> 1)
		IRs:
			TMP_1067(uint256) = INTERNAL_CALL, MathUpgradeable.log2(uint256)(a)
			TMP_1068(uint256) = TMP_1067 >> 1
			TMP_1069(uint256) = 1 << TMP_1068
			result(uint256) := TMP_1069(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1070(uint256) = a / result
			TMP_1071(uint256) = result + TMP_1070
			TMP_1072(uint256) = TMP_1071 >> 1
			result(uint256) := TMP_1072(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1073(uint256) = a / result
			TMP_1074(uint256) = result + TMP_1073
			TMP_1075(uint256) = TMP_1074 >> 1
			result(uint256) := TMP_1075(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1076(uint256) = a / result
			TMP_1077(uint256) = result + TMP_1076
			TMP_1078(uint256) = TMP_1077 >> 1
			result(uint256) := TMP_1078(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1079(uint256) = a / result
			TMP_1080(uint256) = result + TMP_1079
			TMP_1081(uint256) = TMP_1080 >> 1
			result(uint256) := TMP_1081(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1082(uint256) = a / result
			TMP_1083(uint256) = result + TMP_1082
			TMP_1084(uint256) = TMP_1083 >> 1
			result(uint256) := TMP_1084(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1085(uint256) = a / result
			TMP_1086(uint256) = result + TMP_1085
			TMP_1087(uint256) = TMP_1086 >> 1
			result(uint256) := TMP_1087(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_1088(uint256) = a / result
			TMP_1089(uint256) = result + TMP_1088
			TMP_1090(uint256) = TMP_1089 >> 1
			result(uint256) := TMP_1090(uint256)
		Expression: min(result,a / result)
		IRs:
			TMP_1091(uint256) = a / result
			TMP_1092(uint256) = INTERNAL_CALL, MathUpgradeable.min(uint256,uint256)(result,TMP_1091)
			RETURN TMP_1092
	Function MathUpgradeable.sqrt(uint256,MathUpgradeable.Rounding) (*)
		Expression: result = sqrt(a)
		IRs:
			TMP_1093(uint256) = INTERNAL_CALL, MathUpgradeable.sqrt(uint256)(a)
			result(uint256) := TMP_1093(uint256)
		Expression: rounding == Rounding.Up && result * result < a
		IRs:
			REF_219(MathUpgradeable.Rounding) -> Rounding.Up
			TMP_1094(bool) = rounding == REF_219
			TMP_1095(uint256) = result * result
			TMP_1096(bool) = TMP_1095 < a
			TMP_1097(bool) = TMP_1094 && TMP_1096
			CONDITION TMP_1097
		Expression: result + 1
		IRs:
			TMP_1098(uint256) = result + 1
			RETURN TMP_1098
		Expression: result + 0
		IRs:
			TMP_1099(uint256) = result + 0
			RETURN TMP_1099
	Function MathUpgradeable.log2(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_1100(uint256) = value >> 128
			TMP_1101(bool) = TMP_1100 > 0
			CONDITION TMP_1101
		Expression: value >>= 128
		IRs:
			value(uint256) = value >> 128
		Expression: result += 128
		IRs:
			result(uint256) = result + 128
		Expression: value >> 64 > 0
		IRs:
			TMP_1102(uint256) = value >> 64
			TMP_1103(bool) = TMP_1102 > 0
			CONDITION TMP_1103
		Expression: value >>= 64
		IRs:
			value(uint256) = value >> 64
		Expression: result += 64
		IRs:
			result(uint256) = result + 64
		Expression: value >> 32 > 0
		IRs:
			TMP_1104(uint256) = value >> 32
			TMP_1105(bool) = TMP_1104 > 0
			CONDITION TMP_1105
		Expression: value >>= 32
		IRs:
			value(uint256) = value >> 32
		Expression: result += 32
		IRs:
			result(uint256) = result + 32
		Expression: value >> 16 > 0
		IRs:
			TMP_1106(uint256) = value >> 16
			TMP_1107(bool) = TMP_1106 > 0
			CONDITION TMP_1107
		Expression: value >>= 16
		IRs:
			value(uint256) = value >> 16
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >> 8 > 0
		IRs:
			TMP_1108(uint256) = value >> 8
			TMP_1109(bool) = TMP_1108 > 0
			CONDITION TMP_1109
		Expression: value >>= 8
		IRs:
			value(uint256) = value >> 8
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >> 4 > 0
		IRs:
			TMP_1110(uint256) = value >> 4
			TMP_1111(bool) = TMP_1110 > 0
			CONDITION TMP_1111
		Expression: value >>= 4
		IRs:
			value(uint256) = value >> 4
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >> 2 > 0
		IRs:
			TMP_1112(uint256) = value >> 2
			TMP_1113(bool) = TMP_1112 > 0
			CONDITION TMP_1113
		Expression: value >>= 2
		IRs:
			value(uint256) = value >> 2
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >> 1 > 0
		IRs:
			TMP_1114(uint256) = value >> 1
			TMP_1115(bool) = TMP_1114 > 0
			CONDITION TMP_1115
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function MathUpgradeable.log2(uint256,MathUpgradeable.Rounding) (*)
		Expression: result = log2(value)
		IRs:
			TMP_1116(uint256) = INTERNAL_CALL, MathUpgradeable.log2(uint256)(value)
			result(uint256) := TMP_1116(uint256)
		Expression: rounding == Rounding.Up && 1 << result < value
		IRs:
			REF_220(MathUpgradeable.Rounding) -> Rounding.Up
			TMP_1117(bool) = rounding == REF_220
			TMP_1118(uint256) = 1 << result
			TMP_1119(bool) = TMP_1118 < value
			TMP_1120(bool) = TMP_1117 && TMP_1119
			CONDITION TMP_1120
		Expression: result + 1
		IRs:
			TMP_1121(uint256) = result + 1
			RETURN TMP_1121
		Expression: result + 0
		IRs:
			TMP_1122(uint256) = result + 0
			RETURN TMP_1122
	Function MathUpgradeable.log10(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >= 10 ** 64
		IRs:
			TMP_1123(uint256) = 10 ** 64
			TMP_1124(bool) = value >= TMP_1123
			CONDITION TMP_1124
		Expression: value /= 10 ** 64
		IRs:
			TMP_1125(uint256) = 10 ** 64
			value(uint256) = value / TMP_1125
		Expression: result += 64
		IRs:
			result(uint256) = result + 64
		Expression: value >= 10 ** 32
		IRs:
			TMP_1126(uint256) = 10 ** 32
			TMP_1127(bool) = value >= TMP_1126
			CONDITION TMP_1127
		Expression: value /= 10 ** 32
		IRs:
			TMP_1128(uint256) = 10 ** 32
			value(uint256) = value / TMP_1128
		Expression: result += 32
		IRs:
			result(uint256) = result + 32
		Expression: value >= 10 ** 16
		IRs:
			TMP_1129(uint256) = 10 ** 16
			TMP_1130(bool) = value >= TMP_1129
			CONDITION TMP_1130
		Expression: value /= 10 ** 16
		IRs:
			TMP_1131(uint256) = 10 ** 16
			value(uint256) = value / TMP_1131
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >= 10 ** 8
		IRs:
			TMP_1132(uint256) = 10 ** 8
			TMP_1133(bool) = value >= TMP_1132
			CONDITION TMP_1133
		Expression: value /= 10 ** 8
		IRs:
			TMP_1134(uint256) = 10 ** 8
			value(uint256) = value / TMP_1134
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >= 10 ** 4
		IRs:
			TMP_1135(uint256) = 10 ** 4
			TMP_1136(bool) = value >= TMP_1135
			CONDITION TMP_1136
		Expression: value /= 10 ** 4
		IRs:
			TMP_1137(uint256) = 10 ** 4
			value(uint256) = value / TMP_1137
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >= 10 ** 2
		IRs:
			TMP_1138(uint256) = 10 ** 2
			TMP_1139(bool) = value >= TMP_1138
			CONDITION TMP_1139
		Expression: value /= 10 ** 2
		IRs:
			TMP_1140(uint256) = 10 ** 2
			value(uint256) = value / TMP_1140
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >= 10 ** 1
		IRs:
			TMP_1141(uint256) = 10 ** 1
			TMP_1142(bool) = value >= TMP_1141
			CONDITION TMP_1142
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function MathUpgradeable.log10(uint256,MathUpgradeable.Rounding) (*)
		Expression: result = log10(value)
		IRs:
			TMP_1143(uint256) = INTERNAL_CALL, MathUpgradeable.log10(uint256)(value)
			result(uint256) := TMP_1143(uint256)
		Expression: rounding == Rounding.Up && 10 ** result < value
		IRs:
			REF_221(MathUpgradeable.Rounding) -> Rounding.Up
			TMP_1144(bool) = rounding == REF_221
			TMP_1145(uint256) = 10 ** result
			TMP_1146(bool) = TMP_1145 < value
			TMP_1147(bool) = TMP_1144 && TMP_1146
			CONDITION TMP_1147
		Expression: result + 1
		IRs:
			TMP_1148(uint256) = result + 1
			RETURN TMP_1148
		Expression: result + 0
		IRs:
			TMP_1149(uint256) = result + 0
			RETURN TMP_1149
	Function MathUpgradeable.log256(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_1150(uint256) = value >> 128
			TMP_1151(bool) = TMP_1150 > 0
			CONDITION TMP_1151
		Expression: value >>= 128
		IRs:
			value(uint256) = value >> 128
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >> 64 > 0
		IRs:
			TMP_1152(uint256) = value >> 64
			TMP_1153(bool) = TMP_1152 > 0
			CONDITION TMP_1153
		Expression: value >>= 64
		IRs:
			value(uint256) = value >> 64
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >> 32 > 0
		IRs:
			TMP_1154(uint256) = value >> 32
			TMP_1155(bool) = TMP_1154 > 0
			CONDITION TMP_1155
		Expression: value >>= 32
		IRs:
			value(uint256) = value >> 32
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >> 16 > 0
		IRs:
			TMP_1156(uint256) = value >> 16
			TMP_1157(bool) = TMP_1156 > 0
			CONDITION TMP_1157
		Expression: value >>= 16
		IRs:
			value(uint256) = value >> 16
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >> 8 > 0
		IRs:
			TMP_1158(uint256) = value >> 8
			TMP_1159(bool) = TMP_1158 > 0
			CONDITION TMP_1159
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function MathUpgradeable.log256(uint256,MathUpgradeable.Rounding) (*)
		Expression: result = log256(value)
		IRs:
			TMP_1160(uint256) = INTERNAL_CALL, MathUpgradeable.log256(uint256)(value)
			result(uint256) := TMP_1160(uint256)
		Expression: rounding == Rounding.Up && 1 << (result << 3) < value
		IRs:
			REF_222(MathUpgradeable.Rounding) -> Rounding.Up
			TMP_1161(bool) = rounding == REF_222
			TMP_1162(uint256) = result << 3
			TMP_1163(uint256) = 1 << TMP_1162
			TMP_1164(bool) = TMP_1163 < value
			TMP_1165(bool) = TMP_1161 && TMP_1164
			CONDITION TMP_1165
		Expression: result + 1
		IRs:
			TMP_1166(uint256) = result + 1
			RETURN TMP_1166
		Expression: result + 0
		IRs:
			TMP_1167(uint256) = result + 0
			RETURN TMP_1167
Contract SignedMathUpgradeable
	Function SignedMathUpgradeable.max(int256,int256) (*)
		Expression: a > b
		IRs:
			TMP_1168(bool) = a > b
			CONDITION TMP_1168
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function SignedMathUpgradeable.min(int256,int256) (*)
		Expression: a < b
		IRs:
			TMP_1169(bool) = a < b
			CONDITION TMP_1169
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function SignedMathUpgradeable.average(int256,int256) (*)
		Expression: x = (a & b) + ((a ^ b) >> 1)
		IRs:
			TMP_1170(int256) = a & b
			TMP_1171(int256) = a ^ b
			TMP_1172(int256) = TMP_1171 >> 1
			TMP_1173(int256) = TMP_1170 (c)+ TMP_1172
			x(int256) := TMP_1173(int256)
		Expression: x + (int256(uint256(x) >> 255) & (a ^ b))
		IRs:
			TMP_1174 = CONVERT x to uint256
			TMP_1175(uint256) = TMP_1174 >> 255
			TMP_1176 = CONVERT TMP_1175 to int256
			TMP_1177(int256) = a ^ b
			TMP_1178(int256) = TMP_1176 & TMP_1177
			TMP_1179(int256) = x (c)+ TMP_1178
			RETURN TMP_1179
	Function SignedMathUpgradeable.abs(int256) (*)
		Expression: n >= 0
		IRs:
			TMP_1180(bool) = n >= 0
			CONDITION TMP_1180
		Expression: uint256(n)
		IRs:
			TMP_1181 = CONVERT n to uint256
			RETURN TMP_1181
		Expression: uint256(- n)
		IRs:
			TMP_1182(int256) = 0 - n
			TMP_1183 = CONVERT TMP_1182 to uint256
			RETURN TMP_1183
Contract AccessControl
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_1184(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_223(bytes4) (->None) := 33540519(bytes4)
			TMP_1185(bool) = interfaceId == REF_223
			RETURN TMP_1185
	Function IERC165.supportsInterface(bytes4) 
	Function IAccessControl.hasRole(bytes32,address) 
	Function IAccessControl.getRoleAdmin(bytes32) 
	Function IAccessControl.grantRole(bytes32,address) 
	Function IAccessControl.revokeRole(bytes32,address) 
	Function IAccessControl.renounceRole(bytes32,address) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function AccessControl.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IAccessControl).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1186(type(IAccessControl)) = SOLIDITY_CALL type()(IAccessControl)
			REF_224(bytes4) (->None) := 2036718347(bytes4)
			TMP_1187(bool) = interfaceId == REF_224
			TMP_1188(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_1189(bool) = TMP_1187 || TMP_1188
			RETURN TMP_1189
	Function AccessControl.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_225(AccessControl.RoleData) -> _roles[role]
			REF_226(mapping(address => bool)) -> REF_225.members
			REF_227(bool) -> REF_226[account]
			RETURN REF_227
	Function AccessControl._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_1190(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, AccessControl._checkRole(bytes32,address)(role,TMP_1190)
	Function AccessControl._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_1192(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_1193 = UnaryType.BANG TMP_1192 
			CONDITION TMP_1193
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,Strings.toHexString(account), is missing role ,Strings.toHexString(uint256(role),32))))
		IRs:
			TMP_1194(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(address), arguments:['account'] 
			TMP_1195 = CONVERT role to uint256
			TMP_1196(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(uint256,uint256), arguments:['TMP_1195', '32'] 
			TMP_1197(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_1194, is missing role ,TMP_1196)
			TMP_1198 = CONVERT TMP_1197 to string
			TMP_1199(None) = SOLIDITY_CALL revert(string)(TMP_1198)
	Function AccessControl.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_231(AccessControl.RoleData) -> _roles[role]
			REF_232(bytes32) -> REF_231.adminRole
			RETURN REF_232
	Function AccessControl.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1201(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1201)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1203(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1203)
	Function AccessControl.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1206(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1206)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1208(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1208)
	Function AccessControl.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_1210(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1211(bool) = account == TMP_1210
			TMP_1212(None) = SOLIDITY_CALL require(bool,string)(TMP_1211,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
	Function AccessControl._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
	Function AccessControl._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_1215(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_1215(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_233(AccessControl.RoleData) -> _roles[role]
			REF_234(bytes32) -> REF_233.adminRole
			REF_234(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControl._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_1217(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_1218 = UnaryType.BANG TMP_1217 
			CONDITION TMP_1218
		Expression: _roles[role].members[account] = true
		IRs:
			REF_235(AccessControl.RoleData) -> _roles[role]
			REF_236(mapping(address => bool)) -> REF_235.members
			REF_237(bool) -> REF_236[account]
			REF_237(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_1219(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleGranted(role,account,TMP_1219)
	Function AccessControl._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_1221(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			CONDITION TMP_1221
		Expression: _roles[role].members[account] = false
		IRs:
			REF_238(AccessControl.RoleData) -> _roles[role]
			REF_239(mapping(address => bool)) -> REF_238.members
			REF_240(bool) -> REF_239[account]
			REF_240(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_1222(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleRevoked(role,account,TMP_1222)
	Function AccessControl.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
	Modifier AccessControl.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControl._checkRole(bytes32)(role)
Contract IAccessControl
	Function IAccessControl.hasRole(bytes32,address) (*)
	Function IAccessControl.getRoleAdmin(bytes32) (*)
	Function IAccessControl.grantRole(bytes32,address) (*)
	Function IAccessControl.revokeRole(bytes32,address) (*)
	Function IAccessControl.renounceRole(bytes32,address) (*)
Contract Ownable
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_1225(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_1225)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_1227(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_1228(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1229(bool) = TMP_1227 == TMP_1228
			TMP_1230(None) = SOLIDITY_CALL require(bool,string)(TMP_1229,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_1231 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_1231)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_1234 = CONVERT 0 to address
			TMP_1235(bool) = newOwner != TMP_1234
			TMP_1236(None) = SOLIDITY_CALL require(bool,string)(TMP_1235,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract Governor
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_1241(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_1241(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_1242(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_1242(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_1243 = CONVERT name to bytes
			TMP_1244(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1243)
			_hashedName(bytes32) := TMP_1244(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_1245 = CONVERT version to bytes
			TMP_1246(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1245)
			_hashedVersion(bytes32) := TMP_1246(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_1247(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_1247(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_1248 = CONVERT this to address
			_cachedThis(address) := TMP_1248(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_1249 = CONVERT this to address
			TMP_1250(bool) = TMP_1249 == _cachedThis
			TMP_1251(bool) = block.chainid == _cachedChainId
			TMP_1252(bool) = TMP_1250 && TMP_1251
			CONDITION TMP_1252
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_1253(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_1253
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_1254 = CONVERT this to address
			TMP_1255(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_1254)
			TMP_1256(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1255)
			RETURN TMP_1256
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_1257(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1258(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_1257', 'structHash'] 
			RETURN TMP_1258
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_1259(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_1260(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_1261 = CONVERT this to address
			TMP_1262 = CONVERT 0 to bytes32
			TMP_1264(uint256[])  = new uint256[](0)
			RETURN ,TMP_1259,TMP_1260,block.chainid,TMP_1261,TMP_1262,TMP_1264
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_1265(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_247(bytes4) (->None) := 33540519(bytes4)
			TMP_1266(bool) = interfaceId == REF_247
			RETURN TMP_1266
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1267(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1267)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1269(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1269)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_1271(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1272 = CONVERT this to address
			TMP_1273(bool) = TMP_1271 == TMP_1272
			TMP_1274(None) = SOLIDITY_CALL require(bool,string)(TMP_1273,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) (*)
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_248(function(None,None,None,None) returns(None)) -> this.cancel
			REF_249(None) -> REF_248.selector
			REF_250(function(None) returns(None)) -> this.proposalProposer
			REF_251(None) -> REF_250.selector
			TMP_1275(None) = REF_249 ^ REF_251
			governorCancelId(bytes4) := TMP_1275(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_252(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_253(None) -> REF_252.selector
			REF_254(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_255(None) -> REF_254.selector
			TMP_1276(None) = REF_253 ^ REF_255
			REF_256(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_257(None) -> REF_256.selector
			TMP_1277(None) = TMP_1276 ^ REF_257
			governorParamsId(bytes4) := TMP_1277(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_1278(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_258(bytes4) (->None) := 4078917331(bytes4)
			TMP_1279(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_259(bytes4) (->None) := 3660085789(bytes4)
			TMP_1280(bytes4) = REF_258 ^ REF_259
			TMP_1281(bytes4) = TMP_1280 ^ governorCancelId
			TMP_1282(bytes4) = TMP_1281 ^ governorParamsId
			governor43Id(bytes4) := TMP_1282(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_1283(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_260(bytes4) (->None) := 4078917331(bytes4)
			TMP_1284(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_261(bytes4) (->None) := 3660085789(bytes4)
			TMP_1285(bytes4) = REF_260 ^ REF_261
			TMP_1286(bytes4) = TMP_1285 ^ governorCancelId
			governor46Id(bytes4) := TMP_1286(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1287(bool) = interfaceId == governor43Id
			TMP_1288(bool) = interfaceId == governor46Id
			TMP_1289(bool) = TMP_1287 || TMP_1288
			TMP_1290(bool) = interfaceId == governorCancelId
			TMP_1291(bool) = TMP_1289 || TMP_1290
			TMP_1292(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_262(bytes4) (->None) := 1339874119(bytes4)
			TMP_1293(bool) = interfaceId == REF_262
			TMP_1294(bool) = TMP_1291 || TMP_1293
			TMP_1295(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_1296(bool) = TMP_1294 || TMP_1295
			RETURN TMP_1296
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_1297(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_1298(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1297)
			TMP_1299 = CONVERT TMP_1298 to uint256
			RETURN TMP_1299
	Function Governor.state(uint256) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_264(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_264(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_265(bool) -> proposal.executed
			CONDITION REF_265
		Expression: ProposalState.Executed
		IRs:
			REF_266(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_266
		Expression: proposal.canceled
		IRs:
			REF_267(bool) -> proposal.canceled
			CONDITION REF_267
		Expression: ProposalState.Canceled
		IRs:
			REF_268(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_268
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_1300(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_1300(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_1301(bool) = snapshot == 0
			CONDITION TMP_1301
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_1302(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1303(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1303(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_1304(bool) = snapshot >= currentTimepoint
			CONDITION TMP_1304
		Expression: ProposalState.Pending
		IRs:
			REF_269(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_269
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_1305(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_1305(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_1306(bool) = deadline >= currentTimepoint
			CONDITION TMP_1306
		Expression: ProposalState.Active
		IRs:
			REF_270(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_270
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_1307(bool) = INTERNAL_CALL, Governor._quorumReached(uint256)(proposalId)
			TMP_1308(bool) = INTERNAL_CALL, Governor._voteSucceeded(uint256)(proposalId)
			TMP_1309(bool) = TMP_1307 && TMP_1308
			CONDITION TMP_1309
		Expression: ProposalState.Succeeded
		IRs:
			REF_271(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_271
		Expression: ProposalState.Defeated
		IRs:
			REF_272(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_272
	Function Governor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_273(Governor.ProposalCore) -> _proposals[proposalId]
			REF_274(uint64) -> REF_273.voteStart
			RETURN REF_274
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_275(Governor.ProposalCore) -> _proposals[proposalId]
			REF_276(uint64) -> REF_275.voteEnd
			RETURN REF_276
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_277(Governor.ProposalCore) -> _proposals[proposalId]
			REF_278(address) -> REF_277.proposer
			RETURN REF_278
	Function Governor._quorumReached(uint256) (*)
	Function Governor._voteSucceeded(uint256) (*)
	Function Governor._getVotes(address,uint256,bytes) (*)
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) (*)
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) (*)
		Expression: proposer = _msgSender()
		IRs:
			TMP_1310(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_1310(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_1311(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_1312(None) = SOLIDITY_CALL require(bool,string)(TMP_1311,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1313(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1313(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_1314(uint256) = currentTimepoint (c)- 1
			TMP_1315(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_1314)
			TMP_1316(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_1317(bool) = TMP_1315 >= TMP_1316
			TMP_1318(None) = SOLIDITY_CALL require(bool,string)(TMP_1317,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_1319 = CONVERT description to bytes
			TMP_1320(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1319)
			TMP_1321(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_1320)
			proposalId(uint256) := TMP_1321(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_279 -> LENGTH targets
			REF_280 -> LENGTH values
			TMP_1322(bool) = REF_279 == REF_280
			TMP_1323(None) = SOLIDITY_CALL require(bool,string)(TMP_1322,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_281 -> LENGTH targets
			REF_282 -> LENGTH calldatas
			TMP_1324(bool) = REF_281 == REF_282
			TMP_1325(None) = SOLIDITY_CALL require(bool,string)(TMP_1324,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_283 -> LENGTH targets
			TMP_1326(bool) = REF_283 > 0
			TMP_1327(None) = SOLIDITY_CALL require(bool,string)(TMP_1326,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_284(Governor.ProposalCore) -> _proposals[proposalId]
			REF_285(uint64) -> REF_284.voteStart
			TMP_1328(bool) = REF_285 == 0
			TMP_1329(None) = SOLIDITY_CALL require(bool,string)(TMP_1328,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_1330(uint256) = INTERNAL_CALL, IGovernor.votingDelay()()
			TMP_1331(uint256) = currentTimepoint (c)+ TMP_1330
			snapshot(uint256) := TMP_1331(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_1332(uint256) = INTERNAL_CALL, IGovernor.votingPeriod()()
			TMP_1333(uint256) = snapshot (c)+ TMP_1332
			deadline(uint256) := TMP_1333(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_286(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_1334(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_1335(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_1336(Governor.ProposalCore) = new ProposalCore(TMP_1334,proposer,0,TMP_1335,0,False,False)
			REF_286(Governor.ProposalCore) (->_proposals) := TMP_1336(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_289 -> LENGTH targets
			TMP_1338(string[])  = new string[](REF_289)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_1338,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1340(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1340(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1341(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1341(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_290(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_1342(bool) = currentState == REF_290
			REF_291(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_1343(bool) = currentState == REF_291
			TMP_1344(bool) = TMP_1342 || TMP_1343
			TMP_1345(None) = SOLIDITY_CALL require(bool,string)(TMP_1344,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_292(Governor.ProposalCore) -> _proposals[proposalId]
			REF_293(bool) -> REF_292.executed
			REF_293(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1350(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1350(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_1351(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_294(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_1352(bool) = TMP_1351 == REF_294
			TMP_1353(None) = SOLIDITY_CALL require(bool,string)(TMP_1352,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_1354(address) = INTERNAL_CALL, Context._msgSender()()
			REF_295(Governor.ProposalCore) -> _proposals[proposalId]
			REF_296(address) -> REF_295.proposer
			TMP_1355(bool) = TMP_1354 == REF_296
			TMP_1356(None) = SOLIDITY_CALL require(bool,string)(TMP_1355,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1357(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_1357
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_297 -> LENGTH targets
			TMP_1358(bool) = i < REF_297
			CONDITION TMP_1358
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_298(address) -> targets[i]
			REF_300(bytes) -> calldatas[i]
			REF_301(uint256) -> values[i]
			TUPLE_15(bool,bytes) = LOW_LEVEL_CALL, dest:REF_298, function:call, arguments:['REF_300'] value:REF_301 
			success(bool)= UNPACK TUPLE_15 index: 0 
			returndata(bytes)= UNPACK TUPLE_15 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_1359(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1360(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1361 = CONVERT this to address
			TMP_1362(bool) = TMP_1360 != TMP_1361
			CONDITION TMP_1362
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_303 -> LENGTH targets
			TMP_1363(bool) = i < REF_303
			CONDITION TMP_1363
		Expression: targets[i] == address(this)
		IRs:
			REF_304(address) -> targets[i]
			TMP_1364 = CONVERT this to address
			TMP_1365(bool) = REF_304 == TMP_1364
			CONDITION TMP_1365
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_306(bytes) -> calldatas[i]
			TMP_1366(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_306)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_1366'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1368(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1369 = CONVERT this to address
			TMP_1370(bool) = TMP_1368 != TMP_1369
			CONDITION TMP_1370
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_1371(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_1372 = UnaryType.BANG TMP_1371 
			CONDITION TMP_1372
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1374(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1374(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1375(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1375(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_309(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_1376(bool) = currentState != REF_309
			REF_310(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_1377(bool) = currentState != REF_310
			TMP_1378(bool) = TMP_1376 && TMP_1377
			REF_311(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_1379(bool) = currentState != REF_311
			TMP_1380(bool) = TMP_1378 && TMP_1379
			TMP_1381(None) = SOLIDITY_CALL require(bool,string)(TMP_1380,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_312(Governor.ProposalCore) -> _proposals[proposalId]
			REF_313(bool) -> REF_312.canceled
			REF_313(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_1383(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_1384(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,TMP_1383)
			RETURN TMP_1384
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_1385(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_1385
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1386(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1386(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_1387(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_1387
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1388(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1388(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_1389(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_1389
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1390(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1390(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_1391(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_1391
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_1392(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_1393(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1392)
			TMP_1394(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_1393)
			TMP_1395(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_1394', 'v', 'r', 's'] 
			voter(address) := TMP_1395(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_1396(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_1396
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_1397 = CONVERT reason to bytes
			TMP_1398(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1397)
			TMP_1399(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_1400(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_1398,TMP_1399)
			TMP_1401(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1400)
			TMP_1402(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_1401)
			TMP_1403(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_1402', 'v', 'r', 's'] 
			voter(address) := TMP_1403(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_1404(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_1404
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_1405(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_1406(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_1405)
			RETURN TMP_1406
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_318(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_318(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_1407(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_319(IGovernor.ProposalState) -> ProposalState.Active
			TMP_1408(bool) = TMP_1407 == REF_319
			TMP_1409(None) = SOLIDITY_CALL require(bool,string)(TMP_1408,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_320(uint64) -> proposal.voteStart
			TMP_1410(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,REF_320,params)
			weight(uint256) := TMP_1410(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, Governor._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_321 -> LENGTH params
			TMP_1412(bool) = REF_321 == 0
			CONDITION TMP_1412
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_16(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_16 index: 0 
			returndata(bytes)= UNPACK TUPLE_16 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_1415(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() (*)
		Expression: address(this)
		IRs:
			TMP_1417 = CONVERT this to address
			RETURN TMP_1417
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_324(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_325(None) -> REF_324.selector
			RETURN REF_325
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_326(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_327(None) -> REF_326.selector
			RETURN REF_327
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_328(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_329(None) -> REF_328.selector
			RETURN REF_329
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_1418 = CONVERT description to bytes
			REF_330 -> LENGTH TMP_1418
			len(uint256) := REF_330(uint256)
		Expression: len < 52
		IRs:
			TMP_1419(bool) = len < 52
			CONDITION TMP_1419
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_1420(uint256) = len - 20
			TMP_1421(string) = description + TMP_1420
			TMP_1422(uint256) = SOLIDITY_CALL mload(uint256)(TMP_1421)
			marker(bytes12) := TMP_1422(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_1423 = CONVERT #proposer=0x to bytes12
			TMP_1424(bool) = marker != TMP_1423
			CONDITION TMP_1424
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_1425(uint256) = len (c)- 40
			i(uint256) := TMP_1425(uint256)
		Expression: i < len
		IRs:
			TMP_1426(bool) = i < len
			CONDITION TMP_1426
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_1427 = CONVERT description to bytes
			REF_331(None) -> TMP_1427[i]
			TUPLE_17(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_331)
			isHex(bool)= UNPACK TUPLE_17 index: 0 
			value(uint8)= UNPACK TUPLE_17 index: 1 
		Expression: ! isHex
		IRs:
			TMP_1428 = UnaryType.BANG isHex 
			CONDITION TMP_1428
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_1429(uint160) = recovered << 4
			TMP_1430(uint160) = TMP_1429 | value
			recovered(uint160) := TMP_1430(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_1431 = CONVERT proposer to uint160
			TMP_1432(bool) = recovered == TMP_1431
			RETURN TMP_1432
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_1433 = CONVERT char to uint8
			c(uint8) := TMP_1433(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_1434(bool) = 47 < c
			TMP_1435(bool) = c < 58
			TMP_1436(bool) = TMP_1434 && TMP_1435
			CONDITION TMP_1436
		Expression: (true,c - 48)
		IRs:
			TMP_1437(uint8) = c - 48
			RETURN True,TMP_1437
		Expression: 64 < c && c < 71
		IRs:
			TMP_1438(bool) = 64 < c
			TMP_1439(bool) = c < 71
			TMP_1440(bool) = TMP_1438 && TMP_1439
			CONDITION TMP_1440
		Expression: (true,c - 55)
		IRs:
			TMP_1441(uint8) = c - 55
			RETURN True,TMP_1441
		Expression: 96 < c && c < 103
		IRs:
			TMP_1442(bool) = 96 < c
			TMP_1443(bool) = c < 103
			TMP_1444(bool) = TMP_1442 && TMP_1443
			CONDITION TMP_1444
		Expression: (true,c - 87)
		IRs:
			TMP_1445(uint8) = c - 87
			RETURN True,TMP_1445
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function Governor.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_1446(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_1446(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_1447(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_1447(bytes32)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_1448(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1449(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1450(bool) = TMP_1448 == TMP_1449
			TMP_1451(None) = SOLIDITY_CALL require(bool,string)(TMP_1450,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_1452(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1453 = CONVERT this to address
			TMP_1454(bool) = TMP_1452 != TMP_1453
			CONDITION TMP_1454
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_1455(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_1456(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1455)
			msgDataHash(bytes32) := TMP_1456(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_1457(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_1458(bool) = TMP_1457 != msgDataHash
			CONDITION TMP_1458
Contract IGovernor
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function IERC165.supportsInterface(bytes4) (*)
	Function IGovernor.name() (*)
	Function IGovernor.version() (*)
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.state(uint256) (*)
	Function IGovernor.proposalSnapshot(uint256) (*)
	Function IGovernor.proposalDeadline(uint256) (*)
	Function IGovernor.proposalProposer(uint256) (*)
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) (*)
	Function IGovernor.getVotesWithParams(address,uint256,bytes) (*)
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) (*)
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.castVote(uint256,uint8) (*)
	Function IGovernor.castVoteWithReason(uint256,uint8,string) (*)
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
Contract TimelockController
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function AccessControl.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IAccessControl).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1459(type(IAccessControl)) = SOLIDITY_CALL type()(IAccessControl)
			REF_333(bytes4) (->None) := 2036718347(bytes4)
			TMP_1460(bool) = interfaceId == REF_333
			TMP_1461(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_1462(bool) = TMP_1460 || TMP_1461
			RETURN TMP_1462
	Function AccessControl.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_334(AccessControl.RoleData) -> _roles[role]
			REF_335(mapping(address => bool)) -> REF_334.members
			REF_336(bool) -> REF_335[account]
			RETURN REF_336
	Function AccessControl._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_1463(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, AccessControl._checkRole(bytes32,address)(role,TMP_1463)
	Function AccessControl._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_1465(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_1466 = UnaryType.BANG TMP_1465 
			CONDITION TMP_1466
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,Strings.toHexString(account), is missing role ,Strings.toHexString(uint256(role),32))))
		IRs:
			TMP_1467(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(address), arguments:['account'] 
			TMP_1468 = CONVERT role to uint256
			TMP_1469(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(uint256,uint256), arguments:['TMP_1468', '32'] 
			TMP_1470(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_1467, is missing role ,TMP_1469)
			TMP_1471 = CONVERT TMP_1470 to string
			TMP_1472(None) = SOLIDITY_CALL revert(string)(TMP_1471)
	Function AccessControl.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_340(AccessControl.RoleData) -> _roles[role]
			REF_341(bytes32) -> REF_340.adminRole
			RETURN REF_341
	Function AccessControl.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1474(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1474)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1476(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1476)
	Function AccessControl.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1479(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1479)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_1481(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_1481)
	Function AccessControl.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_1483(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1484(bool) = account == TMP_1483
			TMP_1485(None) = SOLIDITY_CALL require(bool,string)(TMP_1484,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
	Function AccessControl._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
	Function AccessControl._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_1488(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_1488(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_342(AccessControl.RoleData) -> _roles[role]
			REF_343(bytes32) -> REF_342.adminRole
			REF_343(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControl._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_1490(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_1491 = UnaryType.BANG TMP_1490 
			CONDITION TMP_1491
		Expression: _roles[role].members[account] = true
		IRs:
			REF_344(AccessControl.RoleData) -> _roles[role]
			REF_345(mapping(address => bool)) -> REF_344.members
			REF_346(bool) -> REF_345[account]
			REF_346(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_1492(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleGranted(role,account,TMP_1492)
	Function AccessControl._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_1494(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			CONDITION TMP_1494
		Expression: _roles[role].members[account] = false
		IRs:
			REF_347(AccessControl.RoleData) -> _roles[role]
			REF_348(mapping(address => bool)) -> REF_347.members
			REF_349(bool) -> REF_348[account]
			REF_349(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_1495(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleRevoked(role,account,TMP_1495)
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_1497(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_350(bytes4) (->None) := 33540519(bytes4)
			TMP_1498(bool) = interfaceId == REF_350
			RETURN TMP_1498
	Function IAccessControl.hasRole(bytes32,address) 
	Function IAccessControl.getRoleAdmin(bytes32) 
	Function IAccessControl.grantRole(bytes32,address) 
	Function IAccessControl.revokeRole(bytes32,address) 
	Function IAccessControl.renounceRole(bytes32,address) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function TimelockController.constructor(uint256,address[],address[],address) (*)
		Expression: _setRoleAdmin(TIMELOCK_ADMIN_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(TIMELOCK_ADMIN_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(PROPOSER_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(PROPOSER_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(EXECUTOR_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(EXECUTOR_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(CANCELLER_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(CANCELLER_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setupRole(TIMELOCK_ADMIN_ROLE,address(this))
		IRs:
			TMP_1503 = CONVERT this to address
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(TIMELOCK_ADMIN_ROLE,TMP_1503)
		Expression: admin != address(0)
		IRs:
			TMP_1505 = CONVERT 0 to address
			TMP_1506(bool) = admin != TMP_1505
			CONDITION TMP_1506
		Expression: _setupRole(TIMELOCK_ADMIN_ROLE,admin)
		IRs:
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(TIMELOCK_ADMIN_ROLE,admin)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < proposers.length
		IRs:
			REF_351 -> LENGTH proposers
			TMP_1508(bool) = i < REF_351
			CONDITION TMP_1508
		Expression: _setupRole(PROPOSER_ROLE,proposers[i])
		IRs:
			REF_352(address) -> proposers[i]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(PROPOSER_ROLE,REF_352)
		Expression: _setupRole(CANCELLER_ROLE,proposers[i])
		IRs:
			REF_353(address) -> proposers[i]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(CANCELLER_ROLE,REF_353)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < executors.length
		IRs:
			REF_354 -> LENGTH executors
			TMP_1511(bool) = i_scope_0 < REF_354
			CONDITION TMP_1511
		Expression: _setupRole(EXECUTOR_ROLE,executors[i_scope_0])
		IRs:
			REF_355(address) -> executors[i_scope_0]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(EXECUTOR_ROLE,REF_355)
		Expression: ++ i_scope_0
		IRs:
			i_scope_0(uint256) = i_scope_0 (c)+ 1
		Expression: _minDelay = minDelay
		IRs:
			_minDelay(uint256) := minDelay(uint256)
		Expression: MinDelayChange(0,minDelay)
		IRs:
			Emit MinDelayChange(0,minDelay)
	Function TimelockController.receive() (*)
	Function TimelockController.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1514(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_356(bytes4) (->None) := 1339874119(bytes4)
			TMP_1515(bool) = interfaceId == REF_356
			TMP_1516(bool) = INTERNAL_CALL, AccessControl.supportsInterface(bytes4)(interfaceId)
			TMP_1517(bool) = TMP_1515 || TMP_1516
			RETURN TMP_1517
	Function TimelockController.isOperation(bytes32) (*)
		Expression: getTimestamp(id) > 0
		IRs:
			TMP_1518(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_1519(bool) = TMP_1518 > 0
			RETURN TMP_1519
	Function TimelockController.isOperationPending(bytes32) (*)
		Expression: getTimestamp(id) > _DONE_TIMESTAMP
		IRs:
			TMP_1520(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_1521(bool) = TMP_1520 > _DONE_TIMESTAMP
			RETURN TMP_1521
	Function TimelockController.isOperationReady(bytes32) (*)
		Expression: timestamp = getTimestamp(id)
		IRs:
			TMP_1522(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			timestamp(uint256) := TMP_1522(uint256)
		Expression: timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp
		IRs:
			TMP_1523(bool) = timestamp > _DONE_TIMESTAMP
			TMP_1524(bool) = timestamp <= block.timestamp
			TMP_1525(bool) = TMP_1523 && TMP_1524
			RETURN TMP_1525
	Function TimelockController.isOperationDone(bytes32) (*)
		Expression: getTimestamp(id) == _DONE_TIMESTAMP
		IRs:
			TMP_1526(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_1527(bool) = TMP_1526 == _DONE_TIMESTAMP
			RETURN TMP_1527
	Function TimelockController.getTimestamp(bytes32) (*)
		Expression: _timestamps[id]
		IRs:
			REF_357(uint256) -> _timestamps[id]
			RETURN REF_357
	Function TimelockController.getMinDelay() (*)
		Expression: _minDelay
		IRs:
			RETURN _minDelay
	Function TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32) (*)
		Expression: keccak256(bytes)(abi.encode(target,value,data,predecessor,salt))
		IRs:
			TMP_1528(bytes) = SOLIDITY_CALL abi.encode()(target,value,data,predecessor,salt)
			TMP_1529(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1528)
			RETURN TMP_1529
	Function TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32) (*)
		Expression: keccak256(bytes)(abi.encode(targets,values,payloads,predecessor,salt))
		IRs:
			TMP_1530(bytes) = SOLIDITY_CALL abi.encode()(targets,values,payloads,predecessor,salt)
			TMP_1531(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1530)
			RETURN TMP_1531
	Function TimelockController.schedule(address,uint256,bytes,bytes32,bytes32,uint256) (*)
		Expression: id = hashOperation(target,value,data,predecessor,salt)
		IRs:
			TMP_1532(bytes32) = INTERNAL_CALL, TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32)(target,value,data,predecessor,salt)
			id(bytes32) := TMP_1532(bytes32)
		Expression: _schedule(id,delay)
		IRs:
			INTERNAL_CALL, TimelockController._schedule(bytes32,uint256)(id,delay)
		Expression: CallScheduled(id,0,target,value,data,predecessor,delay)
		IRs:
			Emit CallScheduled(id,0,target,value,data,predecessor,delay)
		Expression: salt != bytes32(0)
		IRs:
			TMP_1535 = CONVERT 0 to bytes32
			TMP_1536(bool) = salt != TMP_1535
			CONDITION TMP_1536
		Expression: CallSalt(id,salt)
		IRs:
			Emit CallSalt(id,salt)
		Expression: onlyRole(PROPOSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(PROPOSER_ROLE)
	Function TimelockController.scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256) (*)
		Expression: require(bool,string)(targets.length == values.length,TimelockController: length mismatch)
		IRs:
			REF_360 -> LENGTH targets
			REF_361 -> LENGTH values
			TMP_1539(bool) = REF_360 == REF_361
			TMP_1540(None) = SOLIDITY_CALL require(bool,string)(TMP_1539,TimelockController: length mismatch)
		Expression: require(bool,string)(targets.length == payloads.length,TimelockController: length mismatch)
		IRs:
			REF_362 -> LENGTH targets
			REF_363 -> LENGTH payloads
			TMP_1541(bool) = REF_362 == REF_363
			TMP_1542(None) = SOLIDITY_CALL require(bool,string)(TMP_1541,TimelockController: length mismatch)
		Expression: id = hashOperationBatch(targets,values,payloads,predecessor,salt)
		IRs:
			TMP_1543(bytes32) = INTERNAL_CALL, TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)(targets,values,payloads,predecessor,salt)
			id(bytes32) := TMP_1543(bytes32)
		Expression: _schedule(id,delay)
		IRs:
			INTERNAL_CALL, TimelockController._schedule(bytes32,uint256)(id,delay)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_364 -> LENGTH targets
			TMP_1545(bool) = i < REF_364
			CONDITION TMP_1545
		Expression: CallScheduled(id,i,targets[i],values[i],payloads[i],predecessor,delay)
		IRs:
			REF_365(address) -> targets[i]
			REF_366(uint256) -> values[i]
			REF_367(bytes) -> payloads[i]
			Emit CallScheduled(id,i,REF_365,REF_366,REF_367,predecessor,delay)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: salt != bytes32(0)
		IRs:
			TMP_1547 = CONVERT 0 to bytes32
			TMP_1548(bool) = salt != TMP_1547
			CONDITION TMP_1548
		Expression: CallSalt(id,salt)
		IRs:
			Emit CallSalt(id,salt)
		Expression: onlyRole(PROPOSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(PROPOSER_ROLE)
	Function TimelockController._schedule(bytes32,uint256) (*)
		Expression: require(bool,string)(! isOperation(id),TimelockController: operation already scheduled)
		IRs:
			TMP_1551(bool) = INTERNAL_CALL, TimelockController.isOperation(bytes32)(id)
			TMP_1552 = UnaryType.BANG TMP_1551 
			TMP_1553(None) = SOLIDITY_CALL require(bool,string)(TMP_1552,TimelockController: operation already scheduled)
		Expression: require(bool,string)(delay >= getMinDelay(),TimelockController: insufficient delay)
		IRs:
			TMP_1554(uint256) = INTERNAL_CALL, TimelockController.getMinDelay()()
			TMP_1555(bool) = delay >= TMP_1554
			TMP_1556(None) = SOLIDITY_CALL require(bool,string)(TMP_1555,TimelockController: insufficient delay)
		Expression: _timestamps[id] = block.timestamp + delay
		IRs:
			REF_368(uint256) -> _timestamps[id]
			TMP_1557(uint256) = block.timestamp (c)+ delay
			REF_368(uint256) (->_timestamps) := TMP_1557(uint256)
	Function TimelockController.cancel(bytes32) (*)
		Expression: require(bool,string)(isOperationPending(id),TimelockController: operation cannot be cancelled)
		IRs:
			TMP_1558(bool) = INTERNAL_CALL, TimelockController.isOperationPending(bytes32)(id)
			TMP_1559(None) = SOLIDITY_CALL require(bool,string)(TMP_1558,TimelockController: operation cannot be cancelled)
		Expression: delete _timestamps[id]
		IRs:
			REF_369(uint256) -> _timestamps[id]
			_timestamps = delete REF_369 
		Expression: Cancelled(id)
		IRs:
			Emit Cancelled(id)
		Expression: onlyRole(CANCELLER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(CANCELLER_ROLE)
	Function TimelockController.execute(address,uint256,bytes,bytes32,bytes32) (*)
		Expression: id = hashOperation(target,value,payload,predecessor,salt)
		IRs:
			TMP_1562(bytes32) = INTERNAL_CALL, TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32)(target,value,payload,predecessor,salt)
			id(bytes32) := TMP_1562(bytes32)
		Expression: _beforeCall(id,predecessor)
		IRs:
			INTERNAL_CALL, TimelockController._beforeCall(bytes32,bytes32)(id,predecessor)
		Expression: _execute(target,value,payload)
		IRs:
			INTERNAL_CALL, TimelockController._execute(address,uint256,bytes)(target,value,payload)
		Expression: CallExecuted(id,0,target,value,payload)
		IRs:
			Emit CallExecuted(id,0,target,value,payload)
		Expression: _afterCall(id)
		IRs:
			INTERNAL_CALL, TimelockController._afterCall(bytes32)(id)
		Expression: onlyRoleOrOpenRole(EXECUTOR_ROLE)
		IRs:
			MODIFIER_CALL, TimelockController.onlyRoleOrOpenRole(bytes32)(EXECUTOR_ROLE)
	Function TimelockController.executeBatch(address[],uint256[],bytes[],bytes32,bytes32) (*)
		Expression: require(bool,string)(targets.length == values.length,TimelockController: length mismatch)
		IRs:
			REF_370 -> LENGTH targets
			REF_371 -> LENGTH values
			TMP_1568(bool) = REF_370 == REF_371
			TMP_1569(None) = SOLIDITY_CALL require(bool,string)(TMP_1568,TimelockController: length mismatch)
		Expression: require(bool,string)(targets.length == payloads.length,TimelockController: length mismatch)
		IRs:
			REF_372 -> LENGTH targets
			REF_373 -> LENGTH payloads
			TMP_1570(bool) = REF_372 == REF_373
			TMP_1571(None) = SOLIDITY_CALL require(bool,string)(TMP_1570,TimelockController: length mismatch)
		Expression: id = hashOperationBatch(targets,values,payloads,predecessor,salt)
		IRs:
			TMP_1572(bytes32) = INTERNAL_CALL, TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)(targets,values,payloads,predecessor,salt)
			id(bytes32) := TMP_1572(bytes32)
		Expression: _beforeCall(id,predecessor)
		IRs:
			INTERNAL_CALL, TimelockController._beforeCall(bytes32,bytes32)(id,predecessor)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_374 -> LENGTH targets
			TMP_1574(bool) = i < REF_374
			CONDITION TMP_1574
		Expression: target = targets[i]
		IRs:
			REF_375(address) -> targets[i]
			target(address) := REF_375(address)
		Expression: value = values[i]
		IRs:
			REF_376(uint256) -> values[i]
			value(uint256) := REF_376(uint256)
		Expression: payload = payloads[i]
		IRs:
			REF_377(bytes) -> payloads[i]
			payload(bytes) := REF_377(bytes)
		Expression: _execute(target,value,payload)
		IRs:
			INTERNAL_CALL, TimelockController._execute(address,uint256,bytes)(target,value,payload)
		Expression: CallExecuted(id,i,target,value,payload)
		IRs:
			Emit CallExecuted(id,i,target,value,payload)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: _afterCall(id)
		IRs:
			INTERNAL_CALL, TimelockController._afterCall(bytes32)(id)
		Expression: onlyRoleOrOpenRole(EXECUTOR_ROLE)
		IRs:
			MODIFIER_CALL, TimelockController.onlyRoleOrOpenRole(bytes32)(EXECUTOR_ROLE)
	Function TimelockController._execute(address,uint256,bytes) (*)
		Expression: (success) = target.call{value: value}(data)
		IRs:
			TUPLE_18(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_18 index: 0 
		Expression: require(bool,string)(success,TimelockController: underlying transaction reverted)
		IRs:
			TMP_1579(None) = SOLIDITY_CALL require(bool,string)(success,TimelockController: underlying transaction reverted)
	Function TimelockController._beforeCall(bytes32,bytes32) (*)
		Expression: require(bool,string)(isOperationReady(id),TimelockController: operation is not ready)
		IRs:
			TMP_1580(bool) = INTERNAL_CALL, TimelockController.isOperationReady(bytes32)(id)
			TMP_1581(None) = SOLIDITY_CALL require(bool,string)(TMP_1580,TimelockController: operation is not ready)
		Expression: require(bool,string)(predecessor == bytes32(0) || isOperationDone(predecessor),TimelockController: missing dependency)
		IRs:
			TMP_1582 = CONVERT 0 to bytes32
			TMP_1583(bool) = predecessor == TMP_1582
			TMP_1584(bool) = INTERNAL_CALL, TimelockController.isOperationDone(bytes32)(predecessor)
			TMP_1585(bool) = TMP_1583 || TMP_1584
			TMP_1586(None) = SOLIDITY_CALL require(bool,string)(TMP_1585,TimelockController: missing dependency)
	Function TimelockController._afterCall(bytes32) (*)
		Expression: require(bool,string)(isOperationReady(id),TimelockController: operation is not ready)
		IRs:
			TMP_1587(bool) = INTERNAL_CALL, TimelockController.isOperationReady(bytes32)(id)
			TMP_1588(None) = SOLIDITY_CALL require(bool,string)(TMP_1587,TimelockController: operation is not ready)
		Expression: _timestamps[id] = _DONE_TIMESTAMP
		IRs:
			REF_379(uint256) -> _timestamps[id]
			REF_379(uint256) (->_timestamps) := _DONE_TIMESTAMP(uint256)
	Function TimelockController.updateDelay(uint256) (*)
		Expression: require(bool,string)(msg.sender == address(this),TimelockController: caller must be timelock)
		IRs:
			TMP_1589 = CONVERT this to address
			TMP_1590(bool) = msg.sender == TMP_1589
			TMP_1591(None) = SOLIDITY_CALL require(bool,string)(TMP_1590,TimelockController: caller must be timelock)
		Expression: MinDelayChange(_minDelay,newDelay)
		IRs:
			Emit MinDelayChange(_minDelay,newDelay)
		Expression: _minDelay = newDelay
		IRs:
			_minDelay(uint256) := newDelay(uint256)
	Function TimelockController.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_380(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_381(None) -> REF_380.selector
			RETURN REF_381
	Function TimelockController.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_382(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_383(None) -> REF_382.selector
			RETURN REF_383
	Function TimelockController.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_384(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_385(None) -> REF_384.selector
			RETURN REF_385
	Function TimelockController.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
		Expression: TIMELOCK_ADMIN_ROLE = keccak256(bytes)(TIMELOCK_ADMIN_ROLE)
		IRs:
			TMP_1593(bytes32) = SOLIDITY_CALL keccak256(bytes)(TIMELOCK_ADMIN_ROLE)
			TIMELOCK_ADMIN_ROLE(bytes32) := TMP_1593(bytes32)
		Expression: PROPOSER_ROLE = keccak256(bytes)(PROPOSER_ROLE)
		IRs:
			TMP_1594(bytes32) = SOLIDITY_CALL keccak256(bytes)(PROPOSER_ROLE)
			PROPOSER_ROLE(bytes32) := TMP_1594(bytes32)
		Expression: EXECUTOR_ROLE = keccak256(bytes)(EXECUTOR_ROLE)
		IRs:
			TMP_1595(bytes32) = SOLIDITY_CALL keccak256(bytes)(EXECUTOR_ROLE)
			EXECUTOR_ROLE(bytes32) := TMP_1595(bytes32)
		Expression: CANCELLER_ROLE = keccak256(bytes)(CANCELLER_ROLE)
		IRs:
			TMP_1596(bytes32) = SOLIDITY_CALL keccak256(bytes)(CANCELLER_ROLE)
			CANCELLER_ROLE(bytes32) := TMP_1596(bytes32)
		Expression: _DONE_TIMESTAMP = uint256(1)
		IRs:
			TMP_1597 = CONVERT 1 to uint256
			_DONE_TIMESTAMP(uint256) := TMP_1597(uint256)
	Modifier AccessControl.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControl._checkRole(bytes32)(role)
	Modifier TimelockController.onlyRoleOrOpenRole(bytes32)
		Expression: ! hasRole(role,address(0))
		IRs:
			TMP_1599 = CONVERT 0 to address
			TMP_1600(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,TMP_1599)
			TMP_1601 = UnaryType.BANG TMP_1600 
			CONDITION TMP_1601
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_1602(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, AccessControl._checkRole(bytes32,address)(role,TMP_1602)
Contract GovernorCompatibilityBravo
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1604(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1604)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1606(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1606)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_1608(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1609 = CONVERT this to address
			TMP_1610(bool) = TMP_1608 == TMP_1609
			TMP_1611(None) = SOLIDITY_CALL require(bool,string)(TMP_1610,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) (*)
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_386(function(None,None,None,None) returns(None)) -> this.cancel
			REF_387(None) -> REF_386.selector
			REF_388(function(None) returns(None)) -> this.proposalProposer
			REF_389(None) -> REF_388.selector
			TMP_1612(None) = REF_387 ^ REF_389
			governorCancelId(bytes4) := TMP_1612(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_390(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_391(None) -> REF_390.selector
			REF_392(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_393(None) -> REF_392.selector
			TMP_1613(None) = REF_391 ^ REF_393
			REF_394(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_395(None) -> REF_394.selector
			TMP_1614(None) = TMP_1613 ^ REF_395
			governorParamsId(bytes4) := TMP_1614(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_1615(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_396(bytes4) (->None) := 4078917331(bytes4)
			TMP_1616(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_397(bytes4) (->None) := 3660085789(bytes4)
			TMP_1617(bytes4) = REF_396 ^ REF_397
			TMP_1618(bytes4) = TMP_1617 ^ governorCancelId
			TMP_1619(bytes4) = TMP_1618 ^ governorParamsId
			governor43Id(bytes4) := TMP_1619(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_1620(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_398(bytes4) (->None) := 4078917331(bytes4)
			TMP_1621(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_399(bytes4) (->None) := 3660085789(bytes4)
			TMP_1622(bytes4) = REF_398 ^ REF_399
			TMP_1623(bytes4) = TMP_1622 ^ governorCancelId
			governor46Id(bytes4) := TMP_1623(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1624(bool) = interfaceId == governor43Id
			TMP_1625(bool) = interfaceId == governor46Id
			TMP_1626(bool) = TMP_1624 || TMP_1625
			TMP_1627(bool) = interfaceId == governorCancelId
			TMP_1628(bool) = TMP_1626 || TMP_1627
			TMP_1629(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_400(bytes4) (->None) := 1339874119(bytes4)
			TMP_1630(bool) = interfaceId == REF_400
			TMP_1631(bool) = TMP_1628 || TMP_1630
			TMP_1632(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_1633(bool) = TMP_1631 || TMP_1632
			RETURN TMP_1633
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_1634(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_1635(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1634)
			TMP_1636 = CONVERT TMP_1635 to uint256
			RETURN TMP_1636
	Function Governor.state(uint256) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_402(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_402(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_403(bool) -> proposal.executed
			CONDITION REF_403
		Expression: ProposalState.Executed
		IRs:
			REF_404(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_404
		Expression: proposal.canceled
		IRs:
			REF_405(bool) -> proposal.canceled
			CONDITION REF_405
		Expression: ProposalState.Canceled
		IRs:
			REF_406(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_406
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_1637(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_1637(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_1638(bool) = snapshot == 0
			CONDITION TMP_1638
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_1639(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1640(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1640(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_1641(bool) = snapshot >= currentTimepoint
			CONDITION TMP_1641
		Expression: ProposalState.Pending
		IRs:
			REF_407(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_407
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_1642(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_1642(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_1643(bool) = deadline >= currentTimepoint
			CONDITION TMP_1643
		Expression: ProposalState.Active
		IRs:
			REF_408(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_408
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_1644(bool) = INTERNAL_CALL, GovernorCompatibilityBravo._quorumReached(uint256)(proposalId)
			TMP_1645(bool) = INTERNAL_CALL, GovernorCompatibilityBravo._voteSucceeded(uint256)(proposalId)
			TMP_1646(bool) = TMP_1644 && TMP_1645
			CONDITION TMP_1646
		Expression: ProposalState.Succeeded
		IRs:
			REF_409(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_409
		Expression: ProposalState.Defeated
		IRs:
			REF_410(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_410
	Function Governor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_411(Governor.ProposalCore) -> _proposals[proposalId]
			REF_412(uint64) -> REF_411.voteStart
			RETURN REF_412
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_413(Governor.ProposalCore) -> _proposals[proposalId]
			REF_414(uint64) -> REF_413.voteEnd
			RETURN REF_414
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_415(Governor.ProposalCore) -> _proposals[proposalId]
			REF_416(address) -> REF_415.proposer
			RETURN REF_416
	Function Governor._quorumReached(uint256) 
	Function Governor._voteSucceeded(uint256) 
	Function Governor._getVotes(address,uint256,bytes) (*)
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) 
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) 
		Expression: proposer = _msgSender()
		IRs:
			TMP_1647(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_1647(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_1648(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_1649(None) = SOLIDITY_CALL require(bool,string)(TMP_1648,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1650(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1650(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_1651(uint256) = currentTimepoint (c)- 1
			TMP_1652(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_1651)
			TMP_1653(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_1654(bool) = TMP_1652 >= TMP_1653
			TMP_1655(None) = SOLIDITY_CALL require(bool,string)(TMP_1654,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_1656 = CONVERT description to bytes
			TMP_1657(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1656)
			TMP_1658(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_1657)
			proposalId(uint256) := TMP_1658(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_417 -> LENGTH targets
			REF_418 -> LENGTH values
			TMP_1659(bool) = REF_417 == REF_418
			TMP_1660(None) = SOLIDITY_CALL require(bool,string)(TMP_1659,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_419 -> LENGTH targets
			REF_420 -> LENGTH calldatas
			TMP_1661(bool) = REF_419 == REF_420
			TMP_1662(None) = SOLIDITY_CALL require(bool,string)(TMP_1661,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_421 -> LENGTH targets
			TMP_1663(bool) = REF_421 > 0
			TMP_1664(None) = SOLIDITY_CALL require(bool,string)(TMP_1663,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_422(Governor.ProposalCore) -> _proposals[proposalId]
			REF_423(uint64) -> REF_422.voteStart
			TMP_1665(bool) = REF_423 == 0
			TMP_1666(None) = SOLIDITY_CALL require(bool,string)(TMP_1665,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_1667(uint256) = INTERNAL_CALL, IGovernor.votingDelay()()
			TMP_1668(uint256) = currentTimepoint (c)+ TMP_1667
			snapshot(uint256) := TMP_1668(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_1669(uint256) = INTERNAL_CALL, IGovernor.votingPeriod()()
			TMP_1670(uint256) = snapshot (c)+ TMP_1669
			deadline(uint256) := TMP_1670(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_424(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_1671(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_1672(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_1673(Governor.ProposalCore) = new ProposalCore(TMP_1671,proposer,0,TMP_1672,0,False,False)
			REF_424(Governor.ProposalCore) (->_proposals) := TMP_1673(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_427 -> LENGTH targets
			TMP_1675(string[])  = new string[](REF_427)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_1675,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1677(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1677(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1678(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1678(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_428(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_1679(bool) = currentState == REF_428
			REF_429(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_1680(bool) = currentState == REF_429
			TMP_1681(bool) = TMP_1679 || TMP_1680
			TMP_1682(None) = SOLIDITY_CALL require(bool,string)(TMP_1681,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_430(Governor.ProposalCore) -> _proposals[proposalId]
			REF_431(bool) -> REF_430.executed
			REF_431(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1687(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1687(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_1688(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_432(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_1689(bool) = TMP_1688 == REF_432
			TMP_1690(None) = SOLIDITY_CALL require(bool,string)(TMP_1689,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_1691(address) = INTERNAL_CALL, Context._msgSender()()
			REF_433(Governor.ProposalCore) -> _proposals[proposalId]
			REF_434(address) -> REF_433.proposer
			TMP_1692(bool) = TMP_1691 == REF_434
			TMP_1693(None) = SOLIDITY_CALL require(bool,string)(TMP_1692,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1694(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_1694
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_435 -> LENGTH targets
			TMP_1695(bool) = i < REF_435
			CONDITION TMP_1695
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_436(address) -> targets[i]
			REF_438(bytes) -> calldatas[i]
			REF_439(uint256) -> values[i]
			TUPLE_19(bool,bytes) = LOW_LEVEL_CALL, dest:REF_436, function:call, arguments:['REF_438'] value:REF_439 
			success(bool)= UNPACK TUPLE_19 index: 0 
			returndata(bytes)= UNPACK TUPLE_19 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_1696(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1697(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1698 = CONVERT this to address
			TMP_1699(bool) = TMP_1697 != TMP_1698
			CONDITION TMP_1699
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_441 -> LENGTH targets
			TMP_1700(bool) = i < REF_441
			CONDITION TMP_1700
		Expression: targets[i] == address(this)
		IRs:
			REF_442(address) -> targets[i]
			TMP_1701 = CONVERT this to address
			TMP_1702(bool) = REF_442 == TMP_1701
			CONDITION TMP_1702
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_444(bytes) -> calldatas[i]
			TMP_1703(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_444)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_1703'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1705(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1706 = CONVERT this to address
			TMP_1707(bool) = TMP_1705 != TMP_1706
			CONDITION TMP_1707
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_1708(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_1709 = UnaryType.BANG TMP_1708 
			CONDITION TMP_1709
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1711(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1711(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1712(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1712(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_447(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_1713(bool) = currentState != REF_447
			REF_448(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_1714(bool) = currentState != REF_448
			TMP_1715(bool) = TMP_1713 && TMP_1714
			REF_449(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_1716(bool) = currentState != REF_449
			TMP_1717(bool) = TMP_1715 && TMP_1716
			TMP_1718(None) = SOLIDITY_CALL require(bool,string)(TMP_1717,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_450(Governor.ProposalCore) -> _proposals[proposalId]
			REF_451(bool) -> REF_450.canceled
			REF_451(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_1720(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_1721(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,TMP_1720)
			RETURN TMP_1721
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_1722(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_1722
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1723(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1723(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_1724(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_1724
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1725(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1725(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_1726(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_1726
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_1727(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_1727(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_1728(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_1728
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_1729(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_1730(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1729)
			TMP_1731(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_1730)
			TMP_1732(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_1731', 'v', 'r', 's'] 
			voter(address) := TMP_1732(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_1733(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_1733
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_1734 = CONVERT reason to bytes
			TMP_1735(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1734)
			TMP_1736(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_1737(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_1735,TMP_1736)
			TMP_1738(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1737)
			TMP_1739(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_1738)
			TMP_1740(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_1739', 'v', 'r', 's'] 
			voter(address) := TMP_1740(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_1741(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_1741
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_1742(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_1743(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_1742)
			RETURN TMP_1743
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_456(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_456(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_1744(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_457(IGovernor.ProposalState) -> ProposalState.Active
			TMP_1745(bool) = TMP_1744 == REF_457
			TMP_1746(None) = SOLIDITY_CALL require(bool,string)(TMP_1745,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_458(uint64) -> proposal.voteStart
			TMP_1747(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,REF_458,params)
			weight(uint256) := TMP_1747(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, GovernorCompatibilityBravo._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_459 -> LENGTH params
			TMP_1749(bool) = REF_459 == 0
			CONDITION TMP_1749
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_20(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_20 index: 0 
			returndata(bytes)= UNPACK TUPLE_20 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_1752(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() (*)
		Expression: address(this)
		IRs:
			TMP_1754 = CONVERT this to address
			RETURN TMP_1754
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_462(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_463(None) -> REF_462.selector
			RETURN REF_463
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_464(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_465(None) -> REF_464.selector
			RETURN REF_465
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_466(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_467(None) -> REF_466.selector
			RETURN REF_467
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_1755 = CONVERT description to bytes
			REF_468 -> LENGTH TMP_1755
			len(uint256) := REF_468(uint256)
		Expression: len < 52
		IRs:
			TMP_1756(bool) = len < 52
			CONDITION TMP_1756
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_1757(uint256) = len - 20
			TMP_1758(string) = description + TMP_1757
			TMP_1759(uint256) = SOLIDITY_CALL mload(uint256)(TMP_1758)
			marker(bytes12) := TMP_1759(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_1760 = CONVERT #proposer=0x to bytes12
			TMP_1761(bool) = marker != TMP_1760
			CONDITION TMP_1761
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_1762(uint256) = len (c)- 40
			i(uint256) := TMP_1762(uint256)
		Expression: i < len
		IRs:
			TMP_1763(bool) = i < len
			CONDITION TMP_1763
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_1764 = CONVERT description to bytes
			REF_469(None) -> TMP_1764[i]
			TUPLE_21(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_469)
			isHex(bool)= UNPACK TUPLE_21 index: 0 
			value(uint8)= UNPACK TUPLE_21 index: 1 
		Expression: ! isHex
		IRs:
			TMP_1765 = UnaryType.BANG isHex 
			CONDITION TMP_1765
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_1766(uint160) = recovered << 4
			TMP_1767(uint160) = TMP_1766 | value
			recovered(uint160) := TMP_1767(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_1768 = CONVERT proposer to uint160
			TMP_1769(bool) = recovered == TMP_1768
			RETURN TMP_1769
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_1770 = CONVERT char to uint8
			c(uint8) := TMP_1770(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_1771(bool) = 47 < c
			TMP_1772(bool) = c < 58
			TMP_1773(bool) = TMP_1771 && TMP_1772
			CONDITION TMP_1773
		Expression: (true,c - 48)
		IRs:
			TMP_1774(uint8) = c - 48
			RETURN True,TMP_1774
		Expression: 64 < c && c < 71
		IRs:
			TMP_1775(bool) = 64 < c
			TMP_1776(bool) = c < 71
			TMP_1777(bool) = TMP_1775 && TMP_1776
			CONDITION TMP_1777
		Expression: (true,c - 55)
		IRs:
			TMP_1778(uint8) = c - 55
			RETURN True,TMP_1778
		Expression: 96 < c && c < 103
		IRs:
			TMP_1779(bool) = 96 < c
			TMP_1780(bool) = c < 103
			TMP_1781(bool) = TMP_1779 && TMP_1780
			CONDITION TMP_1781
		Expression: (true,c - 87)
		IRs:
			TMP_1782(uint8) = c - 87
			RETURN True,TMP_1782
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() 
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) 
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_1783(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_1783(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_1784(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_1784(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_1785 = CONVERT name to bytes
			TMP_1786(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1785)
			_hashedName(bytes32) := TMP_1786(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_1787 = CONVERT version to bytes
			TMP_1788(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1787)
			_hashedVersion(bytes32) := TMP_1788(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_1789(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_1789(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_1790 = CONVERT this to address
			_cachedThis(address) := TMP_1790(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_1791 = CONVERT this to address
			TMP_1792(bool) = TMP_1791 == _cachedThis
			TMP_1793(bool) = block.chainid == _cachedChainId
			TMP_1794(bool) = TMP_1792 && TMP_1793
			CONDITION TMP_1794
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_1795(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_1795
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_1796 = CONVERT this to address
			TMP_1797(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_1796)
			TMP_1798(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1797)
			RETURN TMP_1798
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_1799(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_1800(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_1799', 'structHash'] 
			RETURN TMP_1800
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_1801(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_1802(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_1803 = CONVERT this to address
			TMP_1804 = CONVERT 0 to bytes32
			TMP_1806(uint256[])  = new uint256[](0)
			RETURN ,TMP_1801,TMP_1802,block.chainid,TMP_1803,TMP_1804,TMP_1806
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_1807(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_476(bytes4) (->None) := 33540519(bytes4)
			TMP_1808(bool) = interfaceId == REF_476
			RETURN TMP_1808
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IGovernorCompatibilityBravo.quorumVotes() 
	Function IGovernorCompatibilityBravo.proposals(uint256) 
	Function IGovernorCompatibilityBravo.propose(address[],uint256[],string[],bytes[],string) 
	Function IGovernorCompatibilityBravo.queue(uint256) 
	Function IGovernorCompatibilityBravo.execute(uint256) 
	Function IGovernorCompatibilityBravo.cancel(uint256) 
	Function IGovernorCompatibilityBravo.getActions(uint256) 
	Function IGovernorCompatibilityBravo.getReceipt(uint256,address) 
	Function IGovernorTimelock.timelock() (*)
	Function IGovernorTimelock.proposalEta(uint256) (*)
	Function IGovernorTimelock.queue(address[],uint256[],bytes[],bytes32) (*)
	Function GovernorCompatibilityBravo.COUNTING_MODE() (*)
		Expression: support=bravo&quorum=bravo
		IRs:
			RETURN support=bravo&quorum=bravo
	Function GovernorCompatibilityBravo.propose(address[],uint256[],bytes[],string) (*)
		Expression: _storeProposal(_msgSender(),targets,values,new string[](calldatas.length),calldatas,description)
		IRs:
			TMP_1809(address) = INTERNAL_CALL, Context._msgSender()()
			REF_477 -> LENGTH calldatas
			TMP_1811(string[])  = new string[](REF_477)
			INTERNAL_CALL, GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string)(TMP_1809,targets,values,TMP_1811,calldatas,description)
		Expression: super.propose(targets,values,calldatas,description)
		IRs:
			TMP_1813(uint256) = INTERNAL_CALL, Governor.propose(address[],uint256[],bytes[],string)(targets,values,calldatas,description)
			RETURN TMP_1813
	Function GovernorCompatibilityBravo.propose(address[],uint256[],string[],bytes[],string) (*)
		Expression: require(bool,string)(signatures.length == calldatas.length,GovernorBravo: invalid signatures length)
		IRs:
			REF_478 -> LENGTH signatures
			REF_479 -> LENGTH calldatas
			TMP_1814(bool) = REF_478 == REF_479
			TMP_1815(None) = SOLIDITY_CALL require(bool,string)(TMP_1814,GovernorBravo: invalid signatures length)
		Expression: _storeProposal(_msgSender(),targets,values,signatures,calldatas,description)
		IRs:
			TMP_1816(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string)(TMP_1816,targets,values,signatures,calldatas,description)
		Expression: propose(targets,values,_encodeCalldata(signatures,calldatas),description)
		IRs:
			TMP_1818(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(signatures,calldatas)
			TMP_1819(uint256) = INTERNAL_CALL, GovernorCompatibilityBravo.propose(address[],uint256[],bytes[],string)(targets,values,TMP_1818,description)
			RETURN TMP_1819
	Function GovernorCompatibilityBravo.queue(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_22(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_22 index: 0 
			values(uint256[])= UNPACK TUPLE_22 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_22 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_22 index: 3 
		Expression: queue(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1820(uint256) = INTERNAL_CALL, IGovernorTimelock.queue(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.execute(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_23(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_23 index: 0 
			values(uint256[])= UNPACK TUPLE_23 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_23 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_23 index: 3 
		Expression: execute(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1821(uint256) = INTERNAL_CALL, Governor.execute(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.cancel(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_24(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_24 index: 0 
			values(uint256[])= UNPACK TUPLE_24 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_24 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_24 index: 3 
		Expression: cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1822(uint256) = INTERNAL_CALL, GovernorCompatibilityBravo.cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1823(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1823(uint256)
		Expression: proposer = _proposalDetails[proposalId].proposer
		IRs:
			REF_480(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_481(address) -> REF_480.proposer
			proposer(address) := REF_481(address)
		Expression: require(bool,string)(_msgSender() == proposer || getVotes(proposer,clock() - 1) < proposalThreshold(),GovernorBravo: proposer above threshold)
		IRs:
			TMP_1824(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1825(bool) = TMP_1824 == proposer
			TMP_1826(uint48) = INTERNAL_CALL, IGovernor.clock()()
			TMP_1827(uint48) = TMP_1826 (c)- 1
			TMP_1828(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_1827)
			TMP_1829(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_1830(bool) = TMP_1828 < TMP_1829
			TMP_1831(bool) = TMP_1825 || TMP_1830
			TMP_1832(None) = SOLIDITY_CALL require(bool,string)(TMP_1831,GovernorBravo: proposer above threshold)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1833(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_1833
	Function GovernorCompatibilityBravo._encodeCalldata(string[],bytes[]) (*)
		Expression: fullcalldatas = new bytes[](calldatas.length)
		IRs:
			REF_482 -> LENGTH calldatas
			TMP_1835(bytes[])  = new bytes[](REF_482)
			fullcalldatas(bytes[]) = ['TMP_1835(bytes[])']
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < fullcalldatas.length
		IRs:
			REF_483 -> LENGTH fullcalldatas
			TMP_1836(bool) = i < REF_483
			CONDITION TMP_1836
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: fullcalldatas
		IRs:
			RETURN fullcalldatas
		Expression: bytes(signatures[i]).length == 0
		IRs:
			REF_484(string) -> signatures[i]
			TMP_1837 = CONVERT REF_484 to bytes
			REF_485 -> LENGTH TMP_1837
			TMP_1838(bool) = REF_485 == 0
			CONDITION TMP_1838
		Expression: fullcalldatas[i] = calldatas[i]
		IRs:
			REF_486(bytes) -> fullcalldatas[i]
			REF_487(bytes) -> calldatas[i]
			REF_486(bytes) (->fullcalldatas) := REF_487(bytes)
		Expression: fullcalldatas[i] = abi.encodePacked(bytes4(keccak256(bytes)(bytes(signatures[i]))),calldatas[i])
		IRs:
			REF_488(bytes) -> fullcalldatas[i]
			REF_490(string) -> signatures[i]
			TMP_1839 = CONVERT REF_490 to bytes
			TMP_1840(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1839)
			TMP_1841 = CONVERT TMP_1840 to bytes4
			REF_491(bytes) -> calldatas[i]
			TMP_1842(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_1841,REF_491)
			REF_488(bytes) (->fullcalldatas) := TMP_1842(bytes)
	Function GovernorCompatibilityBravo._getProposalParameters(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_492(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_492(GovernorCompatibilityBravo.ProposalDetails)
		Expression: (details.targets,details.values,_encodeCalldata(details.signatures,details.calldatas),details.descriptionHash)
		IRs:
			REF_493(address[]) -> details.targets
			REF_494(uint256[]) -> details.values
			REF_495(string[]) -> details.signatures
			REF_496(bytes[]) -> details.calldatas
			TMP_1843(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(REF_495,REF_496)
			REF_497(bytes32) -> details.descriptionHash
			RETURN REF_493,REF_494,TMP_1843,REF_497
	Function GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string) (*)
		Expression: descriptionHash = keccak256(bytes)(bytes(description))
		IRs:
			TMP_1844 = CONVERT description to bytes
			TMP_1845(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1844)
			descriptionHash(bytes32) := TMP_1845(bytes32)
		Expression: proposalId = hashProposal(targets,values,_encodeCalldata(signatures,calldatas),descriptionHash)
		IRs:
			TMP_1846(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(signatures,calldatas)
			TMP_1847(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,TMP_1846,descriptionHash)
			proposalId(uint256) := TMP_1847(uint256)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_498(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_498(GovernorCompatibilityBravo.ProposalDetails)
		Expression: details.descriptionHash == bytes32(0)
		IRs:
			REF_499(bytes32) -> details.descriptionHash
			TMP_1848 = CONVERT 0 to bytes32
			TMP_1849(bool) = REF_499 == TMP_1848
			CONDITION TMP_1849
		Expression: details.proposer = proposer
		IRs:
			REF_500(address) -> details.proposer
			REF_500(address) (->details) := proposer(address)
		Expression: details.targets = targets
		IRs:
			REF_501(address[]) -> details.targets
			REF_501(address[]) (->details) := targets(address[])
		Expression: details.values = values
		IRs:
			REF_502(uint256[]) -> details.values
			REF_502(uint256[]) (->details) := values(uint256[])
		Expression: details.signatures = signatures
		IRs:
			REF_503(string[]) -> details.signatures
			REF_503(string[]) (->details) := signatures(string[])
		Expression: details.calldatas = calldatas
		IRs:
			REF_504(bytes[]) -> details.calldatas
			REF_504(bytes[]) (->details) := calldatas(bytes[])
		Expression: details.descriptionHash = descriptionHash
		IRs:
			REF_505(bytes32) -> details.descriptionHash
			REF_505(bytes32) (->details) := descriptionHash(bytes32)
	Function GovernorCompatibilityBravo.proposals(uint256) (*)
		Expression: id = proposalId
		IRs:
			id(uint256) := proposalId(uint256)
		Expression: eta = proposalEta(proposalId)
		IRs:
			TMP_1850(uint256) = INTERNAL_CALL, IGovernorTimelock.proposalEta(uint256)(proposalId)
			eta(uint256) := TMP_1850(uint256)
		Expression: startBlock = proposalSnapshot(proposalId)
		IRs:
			TMP_1851(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			startBlock(uint256) := TMP_1851(uint256)
		Expression: endBlock = proposalDeadline(proposalId)
		IRs:
			TMP_1852(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			endBlock(uint256) := TMP_1852(uint256)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_506(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_506(GovernorCompatibilityBravo.ProposalDetails)
		Expression: proposer = details.proposer
		IRs:
			REF_507(address) -> details.proposer
			proposer(address) := REF_507(address)
		Expression: forVotes = details.forVotes
		IRs:
			REF_508(uint256) -> details.forVotes
			forVotes(uint256) := REF_508(uint256)
		Expression: againstVotes = details.againstVotes
		IRs:
			REF_509(uint256) -> details.againstVotes
			againstVotes(uint256) := REF_509(uint256)
		Expression: abstainVotes = details.abstainVotes
		IRs:
			REF_510(uint256) -> details.abstainVotes
			abstainVotes(uint256) := REF_510(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1853(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1853(IGovernor.ProposalState)
		Expression: canceled = currentState == ProposalState.Canceled
		IRs:
			REF_511(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_1854(bool) = currentState == REF_511
			canceled(bool) := TMP_1854(bool)
		Expression: executed = currentState == ProposalState.Executed
		IRs:
			REF_512(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_1855(bool) = currentState == REF_512
			executed(bool) := TMP_1855(bool)
	Function GovernorCompatibilityBravo.getActions(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_513(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_513(GovernorCompatibilityBravo.ProposalDetails)
		Expression: (details.targets,details.values,details.signatures,details.calldatas)
		IRs:
			REF_514(address[]) -> details.targets
			REF_515(uint256[]) -> details.values
			REF_516(string[]) -> details.signatures
			REF_517(bytes[]) -> details.calldatas
			RETURN REF_514,REF_515,REF_516,REF_517
	Function GovernorCompatibilityBravo.getReceipt(uint256,address) (*)
		Expression: _proposalDetails[proposalId].receipts[voter]
		IRs:
			REF_518(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_519(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> REF_518.receipts
			REF_520(IGovernorCompatibilityBravo.Receipt) -> REF_519[voter]
			RETURN REF_520
	Function GovernorCompatibilityBravo.quorumVotes() (*)
		Expression: quorum(clock() - 1)
		IRs:
			TMP_1856(uint48) = INTERNAL_CALL, IGovernor.clock()()
			TMP_1857(uint48) = TMP_1856 (c)- 1
			TMP_1858(uint256) = INTERNAL_CALL, IGovernor.quorum(uint256)(TMP_1857)
			RETURN TMP_1858
	Function GovernorCompatibilityBravo.hasVoted(uint256,address) (*)
		Expression: _proposalDetails[proposalId].receipts[account].hasVoted
		IRs:
			REF_521(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_522(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> REF_521.receipts
			REF_523(IGovernorCompatibilityBravo.Receipt) -> REF_522[account]
			REF_524(bool) -> REF_523.hasVoted
			RETURN REF_524
	Function GovernorCompatibilityBravo._quorumReached(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_525(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_525(GovernorCompatibilityBravo.ProposalDetails)
		Expression: quorum(proposalSnapshot(proposalId)) <= details.forVotes
		IRs:
			TMP_1859(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			TMP_1860(uint256) = INTERNAL_CALL, IGovernor.quorum(uint256)(TMP_1859)
			REF_526(uint256) -> details.forVotes
			TMP_1861(bool) = TMP_1860 <= REF_526
			RETURN TMP_1861
	Function GovernorCompatibilityBravo._voteSucceeded(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_527(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_527(GovernorCompatibilityBravo.ProposalDetails)
		Expression: details.forVotes > details.againstVotes
		IRs:
			REF_528(uint256) -> details.forVotes
			REF_529(uint256) -> details.againstVotes
			TMP_1862(bool) = REF_528 > REF_529
			RETURN TMP_1862
	Function GovernorCompatibilityBravo._countVote(uint256,address,uint8,uint256,bytes) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_530(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_530(GovernorCompatibilityBravo.ProposalDetails)
		Expression: receipt = details.receipts[account]
		IRs:
			REF_531(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> details.receipts
			REF_532(IGovernorCompatibilityBravo.Receipt) -> REF_531[account]
			receipt(IGovernorCompatibilityBravo.Receipt) := REF_532(IGovernorCompatibilityBravo.Receipt)
		Expression: require(bool,string)(! receipt.hasVoted,GovernorCompatibilityBravo: vote already cast)
		IRs:
			REF_533(bool) -> receipt.hasVoted
			TMP_1863 = UnaryType.BANG REF_533 
			TMP_1864(None) = SOLIDITY_CALL require(bool,string)(TMP_1863,GovernorCompatibilityBravo: vote already cast)
		Expression: receipt.hasVoted = true
		IRs:
			REF_534(bool) -> receipt.hasVoted
			REF_534(bool) (->receipt) := True(bool)
		Expression: receipt.support = support
		IRs:
			REF_535(uint8) -> receipt.support
			REF_535(uint8) (->receipt) := support(uint8)
		Expression: receipt.votes = SafeCast.toUint96(weight)
		IRs:
			REF_536(uint96) -> receipt.votes
			TMP_1865(uint96) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint96(uint256), arguments:['weight'] 
			REF_536(uint96) (->receipt) := TMP_1865(uint96)
		Expression: support == uint8(VoteType.Against)
		IRs:
			REF_538(GovernorCompatibilityBravo.VoteType) -> VoteType.Against
			TMP_1866 = CONVERT REF_538 to uint8
			TMP_1867(bool) = support == TMP_1866
			CONDITION TMP_1867
		Expression: details.againstVotes += weight
		IRs:
			REF_539(uint256) -> details.againstVotes
			REF_539(-> details) = REF_539 (c)+ weight
		Expression: support == uint8(VoteType.For)
		IRs:
			REF_540(GovernorCompatibilityBravo.VoteType) -> VoteType.For
			TMP_1868 = CONVERT REF_540 to uint8
			TMP_1869(bool) = support == TMP_1868
			CONDITION TMP_1869
		Expression: details.forVotes += weight
		IRs:
			REF_541(uint256) -> details.forVotes
			REF_541(-> details) = REF_541 (c)+ weight
		Expression: support == uint8(VoteType.Abstain)
		IRs:
			REF_542(GovernorCompatibilityBravo.VoteType) -> VoteType.Abstain
			TMP_1870 = CONVERT REF_542 to uint8
			TMP_1871(bool) = support == TMP_1870
			CONDITION TMP_1871
		Expression: details.abstainVotes += weight
		IRs:
			REF_543(uint256) -> details.abstainVotes
			REF_543(-> details) = REF_543 (c)+ weight
		Expression: revert(string)(GovernorCompatibilityBravo: invalid vote type)
		IRs:
			TMP_1872(None) = SOLIDITY_CALL revert(string)(GovernorCompatibilityBravo: invalid vote type)
	Function GovernorCompatibilityBravo.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_1873(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_1873(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_1874(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_1874(bytes32)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_1875(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_1876(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1877(bool) = TMP_1875 == TMP_1876
			TMP_1878(None) = SOLIDITY_CALL require(bool,string)(TMP_1877,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_1879(address) = INTERNAL_CALL, Governor._executor()()
			TMP_1880 = CONVERT this to address
			TMP_1881(bool) = TMP_1879 != TMP_1880
			CONDITION TMP_1881
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_1882(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_1883(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1882)
			msgDataHash(bytes32) := TMP_1883(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_1884(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_1885(bool) = TMP_1884 != msgDataHash
			CONDITION TMP_1885
Contract IGovernorCompatibilityBravo
	Function IGovernor.name() (*)
	Function IGovernor.version() (*)
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.state(uint256) (*)
	Function IGovernor.proposalSnapshot(uint256) (*)
	Function IGovernor.proposalDeadline(uint256) (*)
	Function IGovernor.proposalProposer(uint256) (*)
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) (*)
	Function IGovernor.getVotesWithParams(address,uint256,bytes) (*)
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) (*)
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.castVote(uint256,uint8) (*)
	Function IGovernor.castVoteWithReason(uint256,uint8,string) (*)
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function IERC165.supportsInterface(bytes4) (*)
	Function IGovernorCompatibilityBravo.quorumVotes() (*)
	Function IGovernorCompatibilityBravo.proposals(uint256) (*)
	Function IGovernorCompatibilityBravo.propose(address[],uint256[],string[],bytes[],string) (*)
	Function IGovernorCompatibilityBravo.queue(uint256) (*)
	Function IGovernorCompatibilityBravo.execute(uint256) (*)
	Function IGovernorCompatibilityBravo.cancel(uint256) (*)
	Function IGovernorCompatibilityBravo.getActions(uint256) (*)
	Function IGovernorCompatibilityBravo.getReceipt(uint256,address) (*)
Contract GovernorTimelockControl
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1886(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1886)
		Expression: EIP712(name_,version())
		IRs:
			TMP_1888(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_1888)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_1890(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			TMP_1891 = CONVERT this to address
			TMP_1892(bool) = TMP_1890 == TMP_1891
			TMP_1893(None) = SOLIDITY_CALL require(bool,string)(TMP_1892,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) 
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_545(function(None,None,None,None) returns(None)) -> this.cancel
			REF_546(None) -> REF_545.selector
			REF_547(function(None) returns(None)) -> this.proposalProposer
			REF_548(None) -> REF_547.selector
			TMP_1894(None) = REF_546 ^ REF_548
			governorCancelId(bytes4) := TMP_1894(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_549(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_550(None) -> REF_549.selector
			REF_551(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_552(None) -> REF_551.selector
			TMP_1895(None) = REF_550 ^ REF_552
			REF_553(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_554(None) -> REF_553.selector
			TMP_1896(None) = TMP_1895 ^ REF_554
			governorParamsId(bytes4) := TMP_1896(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_1897(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_555(bytes4) (->None) := 4078917331(bytes4)
			TMP_1898(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_556(bytes4) (->None) := 3660085789(bytes4)
			TMP_1899(bytes4) = REF_555 ^ REF_556
			TMP_1900(bytes4) = TMP_1899 ^ governorCancelId
			TMP_1901(bytes4) = TMP_1900 ^ governorParamsId
			governor43Id(bytes4) := TMP_1901(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_1902(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_557(bytes4) (->None) := 4078917331(bytes4)
			TMP_1903(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_558(bytes4) (->None) := 3660085789(bytes4)
			TMP_1904(bytes4) = REF_557 ^ REF_558
			TMP_1905(bytes4) = TMP_1904 ^ governorCancelId
			governor46Id(bytes4) := TMP_1905(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_1906(bool) = interfaceId == governor43Id
			TMP_1907(bool) = interfaceId == governor46Id
			TMP_1908(bool) = TMP_1906 || TMP_1907
			TMP_1909(bool) = interfaceId == governorCancelId
			TMP_1910(bool) = TMP_1908 || TMP_1909
			TMP_1911(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_559(bytes4) (->None) := 1339874119(bytes4)
			TMP_1912(bool) = interfaceId == REF_559
			TMP_1913(bool) = TMP_1910 || TMP_1912
			TMP_1914(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_1915(bool) = TMP_1913 || TMP_1914
			RETURN TMP_1915
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_1916(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_1917(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1916)
			TMP_1918 = CONVERT TMP_1917 to uint256
			RETURN TMP_1918
	Function Governor.state(uint256) 
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_561(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_561(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_562(bool) -> proposal.executed
			CONDITION REF_562
		Expression: ProposalState.Executed
		IRs:
			REF_563(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_563
		Expression: proposal.canceled
		IRs:
			REF_564(bool) -> proposal.canceled
			CONDITION REF_564
		Expression: ProposalState.Canceled
		IRs:
			REF_565(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_565
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_1919(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_1919(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_1920(bool) = snapshot == 0
			CONDITION TMP_1920
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_1921(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1922(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1922(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_1923(bool) = snapshot >= currentTimepoint
			CONDITION TMP_1923
		Expression: ProposalState.Pending
		IRs:
			REF_566(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_566
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_1924(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_1924(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_1925(bool) = deadline >= currentTimepoint
			CONDITION TMP_1925
		Expression: ProposalState.Active
		IRs:
			REF_567(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_567
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_1926(bool) = INTERNAL_CALL, Governor._quorumReached(uint256)(proposalId)
			TMP_1927(bool) = INTERNAL_CALL, Governor._voteSucceeded(uint256)(proposalId)
			TMP_1928(bool) = TMP_1926 && TMP_1927
			CONDITION TMP_1928
		Expression: ProposalState.Succeeded
		IRs:
			REF_568(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_568
		Expression: ProposalState.Defeated
		IRs:
			REF_569(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_569
	Function Governor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_570(Governor.ProposalCore) -> _proposals[proposalId]
			REF_571(uint64) -> REF_570.voteStart
			RETURN REF_571
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_572(Governor.ProposalCore) -> _proposals[proposalId]
			REF_573(uint64) -> REF_572.voteEnd
			RETURN REF_573
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_574(Governor.ProposalCore) -> _proposals[proposalId]
			REF_575(address) -> REF_574.proposer
			RETURN REF_575
	Function Governor._quorumReached(uint256) (*)
	Function Governor._voteSucceeded(uint256) (*)
	Function Governor._getVotes(address,uint256,bytes) (*)
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) (*)
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) (*)
		Expression: proposer = _msgSender()
		IRs:
			TMP_1929(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_1929(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_1930(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_1931(None) = SOLIDITY_CALL require(bool,string)(TMP_1930,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_1932(uint48) = INTERNAL_CALL, IGovernor.clock()()
			currentTimepoint(uint256) := TMP_1932(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_1933(uint256) = currentTimepoint (c)- 1
			TMP_1934(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_1933)
			TMP_1935(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_1936(bool) = TMP_1934 >= TMP_1935
			TMP_1937(None) = SOLIDITY_CALL require(bool,string)(TMP_1936,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_1938 = CONVERT description to bytes
			TMP_1939(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_1938)
			TMP_1940(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_1939)
			proposalId(uint256) := TMP_1940(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_576 -> LENGTH targets
			REF_577 -> LENGTH values
			TMP_1941(bool) = REF_576 == REF_577
			TMP_1942(None) = SOLIDITY_CALL require(bool,string)(TMP_1941,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_578 -> LENGTH targets
			REF_579 -> LENGTH calldatas
			TMP_1943(bool) = REF_578 == REF_579
			TMP_1944(None) = SOLIDITY_CALL require(bool,string)(TMP_1943,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_580 -> LENGTH targets
			TMP_1945(bool) = REF_580 > 0
			TMP_1946(None) = SOLIDITY_CALL require(bool,string)(TMP_1945,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_581(Governor.ProposalCore) -> _proposals[proposalId]
			REF_582(uint64) -> REF_581.voteStart
			TMP_1947(bool) = REF_582 == 0
			TMP_1948(None) = SOLIDITY_CALL require(bool,string)(TMP_1947,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_1949(uint256) = INTERNAL_CALL, IGovernor.votingDelay()()
			TMP_1950(uint256) = currentTimepoint (c)+ TMP_1949
			snapshot(uint256) := TMP_1950(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_1951(uint256) = INTERNAL_CALL, IGovernor.votingPeriod()()
			TMP_1952(uint256) = snapshot (c)+ TMP_1951
			deadline(uint256) := TMP_1952(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_583(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_1953(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_1954(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_1955(Governor.ProposalCore) = new ProposalCore(TMP_1953,proposer,0,TMP_1954,0,False,False)
			REF_583(Governor.ProposalCore) (->_proposals) := TMP_1955(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_586 -> LENGTH targets
			TMP_1957(string[])  = new string[](REF_586)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_1957,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1959(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1959(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1960(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1960(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_587(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_1961(bool) = currentState == REF_587
			REF_588(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_1962(bool) = currentState == REF_588
			TMP_1963(bool) = TMP_1961 || TMP_1962
			TMP_1964(None) = SOLIDITY_CALL require(bool,string)(TMP_1963,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_589(Governor.ProposalCore) -> _proposals[proposalId]
			REF_590(bool) -> REF_589.executed
			REF_590(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1969(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1969(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_1970(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			REF_591(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_1971(bool) = TMP_1970 == REF_591
			TMP_1972(None) = SOLIDITY_CALL require(bool,string)(TMP_1971,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_1973(address) = INTERNAL_CALL, Context._msgSender()()
			REF_592(Governor.ProposalCore) -> _proposals[proposalId]
			REF_593(address) -> REF_592.proposer
			TMP_1974(bool) = TMP_1973 == REF_593
			TMP_1975(None) = SOLIDITY_CALL require(bool,string)(TMP_1974,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1976(uint256) = INTERNAL_CALL, GovernorTimelockControl._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_1976
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) 
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_594 -> LENGTH targets
			TMP_1977(bool) = i < REF_594
			CONDITION TMP_1977
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_595(address) -> targets[i]
			REF_597(bytes) -> calldatas[i]
			REF_598(uint256) -> values[i]
			TUPLE_25(bool,bytes) = LOW_LEVEL_CALL, dest:REF_595, function:call, arguments:['REF_597'] value:REF_598 
			success(bool)= UNPACK TUPLE_25 index: 0 
			returndata(bytes)= UNPACK TUPLE_25 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_1978(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1979(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			TMP_1980 = CONVERT this to address
			TMP_1981(bool) = TMP_1979 != TMP_1980
			CONDITION TMP_1981
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_600 -> LENGTH targets
			TMP_1982(bool) = i < REF_600
			CONDITION TMP_1982
		Expression: targets[i] == address(this)
		IRs:
			REF_601(address) -> targets[i]
			TMP_1983 = CONVERT this to address
			TMP_1984(bool) = REF_601 == TMP_1983
			CONDITION TMP_1984
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_603(bytes) -> calldatas[i]
			TMP_1985(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_603)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_1985'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_1987(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			TMP_1988 = CONVERT this to address
			TMP_1989(bool) = TMP_1987 != TMP_1988
			CONDITION TMP_1989
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_1990(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_1991 = UnaryType.BANG TMP_1990 
			CONDITION TMP_1991
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_1993(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_1993(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_1994(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_1994(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_606(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_1995(bool) = currentState != REF_606
			REF_607(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_1996(bool) = currentState != REF_607
			TMP_1997(bool) = TMP_1995 && TMP_1996
			REF_608(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_1998(bool) = currentState != REF_608
			TMP_1999(bool) = TMP_1997 && TMP_1998
			TMP_2000(None) = SOLIDITY_CALL require(bool,string)(TMP_1999,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_609(Governor.ProposalCore) -> _proposals[proposalId]
			REF_610(bool) -> REF_609.canceled
			REF_610(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_2002(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2003(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,TMP_2002)
			RETURN TMP_2003
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_2004(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_2004
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2005(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2005(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2006(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2006
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2007(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2007(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_2008(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_2008
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2009(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2009(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2010(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2010
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_2011(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_2012(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2011)
			TMP_2013(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2012)
			TMP_2014(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2013', 'v', 'r', 's'] 
			voter(address) := TMP_2014(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2015(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2015
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_2016 = CONVERT reason to bytes
			TMP_2017(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2016)
			TMP_2018(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_2019(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_2017,TMP_2018)
			TMP_2020(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2019)
			TMP_2021(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2020)
			TMP_2022(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2021', 'v', 'r', 's'] 
			voter(address) := TMP_2022(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2023(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2023
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_2024(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2025(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_2024)
			RETURN TMP_2025
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_615(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_615(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_2026(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			REF_616(IGovernor.ProposalState) -> ProposalState.Active
			TMP_2027(bool) = TMP_2026 == REF_616
			TMP_2028(None) = SOLIDITY_CALL require(bool,string)(TMP_2027,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_617(uint64) -> proposal.voteStart
			TMP_2029(uint256) = INTERNAL_CALL, Governor._getVotes(address,uint256,bytes)(account,REF_617,params)
			weight(uint256) := TMP_2029(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, Governor._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_618 -> LENGTH params
			TMP_2031(bool) = REF_618 == 0
			CONDITION TMP_2031
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_26(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_26 index: 0 
			returndata(bytes)= UNPACK TUPLE_26 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_2034(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() 
		Expression: address(this)
		IRs:
			TMP_2036 = CONVERT this to address
			RETURN TMP_2036
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_621(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_622(None) -> REF_621.selector
			RETURN REF_622
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_623(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_624(None) -> REF_623.selector
			RETURN REF_624
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_625(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_626(None) -> REF_625.selector
			RETURN REF_626
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_2037 = CONVERT description to bytes
			REF_627 -> LENGTH TMP_2037
			len(uint256) := REF_627(uint256)
		Expression: len < 52
		IRs:
			TMP_2038(bool) = len < 52
			CONDITION TMP_2038
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_2039(uint256) = len - 20
			TMP_2040(string) = description + TMP_2039
			TMP_2041(uint256) = SOLIDITY_CALL mload(uint256)(TMP_2040)
			marker(bytes12) := TMP_2041(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_2042 = CONVERT #proposer=0x to bytes12
			TMP_2043(bool) = marker != TMP_2042
			CONDITION TMP_2043
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_2044(uint256) = len (c)- 40
			i(uint256) := TMP_2044(uint256)
		Expression: i < len
		IRs:
			TMP_2045(bool) = i < len
			CONDITION TMP_2045
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_2046 = CONVERT description to bytes
			REF_628(None) -> TMP_2046[i]
			TUPLE_27(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_628)
			isHex(bool)= UNPACK TUPLE_27 index: 0 
			value(uint8)= UNPACK TUPLE_27 index: 1 
		Expression: ! isHex
		IRs:
			TMP_2047 = UnaryType.BANG isHex 
			CONDITION TMP_2047
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_2048(uint160) = recovered << 4
			TMP_2049(uint160) = TMP_2048 | value
			recovered(uint160) := TMP_2049(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_2050 = CONVERT proposer to uint160
			TMP_2051(bool) = recovered == TMP_2050
			RETURN TMP_2051
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_2052 = CONVERT char to uint8
			c(uint8) := TMP_2052(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_2053(bool) = 47 < c
			TMP_2054(bool) = c < 58
			TMP_2055(bool) = TMP_2053 && TMP_2054
			CONDITION TMP_2055
		Expression: (true,c - 48)
		IRs:
			TMP_2056(uint8) = c - 48
			RETURN True,TMP_2056
		Expression: 64 < c && c < 71
		IRs:
			TMP_2057(bool) = 64 < c
			TMP_2058(bool) = c < 71
			TMP_2059(bool) = TMP_2057 && TMP_2058
			CONDITION TMP_2059
		Expression: (true,c - 55)
		IRs:
			TMP_2060(uint8) = c - 55
			RETURN True,TMP_2060
		Expression: 96 < c && c < 103
		IRs:
			TMP_2061(bool) = 96 < c
			TMP_2062(bool) = c < 103
			TMP_2063(bool) = TMP_2061 && TMP_2062
			CONDITION TMP_2063
		Expression: (true,c - 87)
		IRs:
			TMP_2064(uint8) = c - 87
			RETURN True,TMP_2064
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_2065(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_2065(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_2066(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_2066(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2067 = CONVERT name to bytes
			TMP_2068(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2067)
			_hashedName(bytes32) := TMP_2068(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2069 = CONVERT version to bytes
			TMP_2070(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2069)
			_hashedVersion(bytes32) := TMP_2070(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_2071(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_2071(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_2072 = CONVERT this to address
			_cachedThis(address) := TMP_2072(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_2073 = CONVERT this to address
			TMP_2074(bool) = TMP_2073 == _cachedThis
			TMP_2075(bool) = block.chainid == _cachedChainId
			TMP_2076(bool) = TMP_2074 && TMP_2075
			CONDITION TMP_2076
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_2077(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_2077
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_2078 = CONVERT this to address
			TMP_2079(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_2078)
			TMP_2080(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2079)
			RETURN TMP_2080
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2081(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2082(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2081', 'structHash'] 
			RETURN TMP_2082
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_2083(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_2084(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_2085 = CONVERT this to address
			TMP_2086 = CONVERT 0 to bytes32
			TMP_2088(uint256[])  = new uint256[](0)
			RETURN ,TMP_2083,TMP_2084,block.chainid,TMP_2085,TMP_2086,TMP_2088
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_2089(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_635(bytes4) (->None) := 33540519(bytes4)
			TMP_2090(bool) = interfaceId == REF_635
			RETURN TMP_2090
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IGovernorTimelock.timelock() 
	Function IGovernorTimelock.proposalEta(uint256) 
	Function IGovernorTimelock.queue(address[],uint256[],bytes[],bytes32) 
	Function GovernorTimelockControl.constructor(TimelockController) (*)
		Expression: _updateTimelock(timelockAddress)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._updateTimelock(TimelockController)(timelockAddress)
	Function GovernorTimelockControl.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IGovernorTimelock).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_2092(type(IGovernorTimelock)) = SOLIDITY_CALL type()(IGovernorTimelock)
			REF_636(bytes4) (->None) := 2641955390(bytes4)
			TMP_2093(bool) = interfaceId == REF_636
			TMP_2094(bool) = INTERNAL_CALL, Governor.supportsInterface(bytes4)(interfaceId)
			TMP_2095(bool) = TMP_2093 || TMP_2094
			RETURN TMP_2095
	Function GovernorTimelockControl.state(uint256) (*)
		Expression: currentState = super.state(proposalId)
		IRs:
			TMP_2096(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_2096(IGovernor.ProposalState)
		Expression: currentState != ProposalState.Succeeded
		IRs:
			REF_637(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_2097(bool) = currentState != REF_637
			CONDITION TMP_2097
		Expression: currentState
		IRs:
			RETURN currentState
		Expression: queueid = _timelockIds[proposalId]
		IRs:
			REF_638(bytes32) -> _timelockIds[proposalId]
			queueid(bytes32) := REF_638(bytes32)
		Expression: queueid == bytes32(0)
		IRs:
			TMP_2098 = CONVERT 0 to bytes32
			TMP_2099(bool) = queueid == TMP_2098
			CONDITION TMP_2099
		Expression: currentState
		IRs:
			RETURN currentState
		Expression: _timelock.isOperationDone(queueid)
		IRs:
			TMP_2100(bool) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:isOperationDone, arguments:['queueid']  
			CONDITION TMP_2100
		Expression: ProposalState.Executed
		IRs:
			REF_640(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_640
		Expression: _timelock.isOperationPending(queueid)
		IRs:
			TMP_2101(bool) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:isOperationPending, arguments:['queueid']  
			CONDITION TMP_2101
		Expression: ProposalState.Queued
		IRs:
			REF_642(IGovernor.ProposalState) -> ProposalState.Queued
			RETURN REF_642
		Expression: ProposalState.Canceled
		IRs:
			REF_643(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_643
	Function GovernorTimelockControl.timelock() (*)
		Expression: address(_timelock)
		IRs:
			TMP_2102 = CONVERT _timelock to address
			RETURN TMP_2102
	Function GovernorTimelockControl.proposalEta(uint256) (*)
		Expression: eta = _timelock.getTimestamp(_timelockIds[proposalId])
		IRs:
			REF_645(bytes32) -> _timelockIds[proposalId]
			TMP_2103(uint256) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:getTimestamp, arguments:['REF_645']  
			eta(uint256) := TMP_2103(uint256)
		Expression: eta == 1
		IRs:
			TMP_2104(bool) = eta == 1
			CONDITION TMP_2104
		Expression: 0
		IRs:
			RETURN 0
		Expression: eta
		IRs:
			RETURN eta
	Function GovernorTimelockControl.queue(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2105(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2105(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Succeeded,Governor: proposal not successful)
		IRs:
			TMP_2106(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			REF_646(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_2107(bool) = TMP_2106 == REF_646
			TMP_2108(None) = SOLIDITY_CALL require(bool,string)(TMP_2107,Governor: proposal not successful)
		Expression: delay = _timelock.getMinDelay()
		IRs:
			TMP_2109(uint256) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:getMinDelay, arguments:[]  
			delay(uint256) := TMP_2109(uint256)
		Expression: _timelockIds[proposalId] = _timelock.hashOperationBatch(targets,values,calldatas,0,descriptionHash)
		IRs:
			REF_648(bytes32) -> _timelockIds[proposalId]
			TMP_2110(bytes32) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:hashOperationBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash']  
			REF_648(bytes32) (->_timelockIds) := TMP_2110(bytes32)
		Expression: _timelock.scheduleBatch(targets,values,calldatas,0,descriptionHash,delay)
		IRs:
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:scheduleBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash', 'delay']  
		Expression: ProposalQueued(proposalId,block.timestamp + delay)
		IRs:
			TMP_2112(uint256) = block.timestamp (c)+ delay
			Emit ProposalQueued(proposalId,TMP_2112)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function GovernorTimelockControl._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _timelock.executeBatch{value: msg.value}(targets,values,calldatas,0,descriptionHash)
		IRs:
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:executeBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash'] value:msg.value 
	Function GovernorTimelockControl._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = super._cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2115(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2115(uint256)
		Expression: _timelockIds[proposalId] != 0
		IRs:
			REF_652(bytes32) -> _timelockIds[proposalId]
			TMP_2116(bool) = REF_652 != 0
			CONDITION TMP_2116
		Expression: _timelock.cancel(_timelockIds[proposalId])
		IRs:
			REF_654(bytes32) -> _timelockIds[proposalId]
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:cancel, arguments:['REF_654']  
		Expression: delete _timelockIds[proposalId]
		IRs:
			REF_655(bytes32) -> _timelockIds[proposalId]
			_timelockIds = delete REF_655 
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function GovernorTimelockControl._executor() (*)
		Expression: address(_timelock)
		IRs:
			TMP_2118 = CONVERT _timelock to address
			RETURN TMP_2118
	Function GovernorTimelockControl.updateTimelock(TimelockController) (*)
		Expression: _updateTimelock(newTimelock)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._updateTimelock(TimelockController)(newTimelock)
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function GovernorTimelockControl._updateTimelock(TimelockController) (*)
		Expression: TimelockChange(address(_timelock),address(newTimelock))
		IRs:
			TMP_2121 = CONVERT _timelock to address
			TMP_2122 = CONVERT newTimelock to address
			Emit TimelockChange(TMP_2121,TMP_2122)
		Expression: _timelock = newTimelock
		IRs:
			_timelock(TimelockController) := newTimelock(TimelockController)
	Function GovernorTimelockControl.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_2124(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_2124(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_2125(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_2125(bytes32)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_2126(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2127(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			TMP_2128(bool) = TMP_2126 == TMP_2127
			TMP_2129(None) = SOLIDITY_CALL require(bool,string)(TMP_2128,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_2130(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			TMP_2131 = CONVERT this to address
			TMP_2132(bool) = TMP_2130 != TMP_2131
			CONDITION TMP_2132
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_2133(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_2134(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2133)
			msgDataHash(bytes32) := TMP_2134(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_2135(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_2136(bool) = TMP_2135 != msgDataHash
			CONDITION TMP_2136
Contract GovernorVotes
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_2137(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_2137)
		Expression: EIP712(name_,version())
		IRs:
			TMP_2139(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_2139)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_2141(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2142 = CONVERT this to address
			TMP_2143(bool) = TMP_2141 == TMP_2142
			TMP_2144(None) = SOLIDITY_CALL require(bool,string)(TMP_2143,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) (*)
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_657(function(None,None,None,None) returns(None)) -> this.cancel
			REF_658(None) -> REF_657.selector
			REF_659(function(None) returns(None)) -> this.proposalProposer
			REF_660(None) -> REF_659.selector
			TMP_2145(None) = REF_658 ^ REF_660
			governorCancelId(bytes4) := TMP_2145(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_661(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_662(None) -> REF_661.selector
			REF_663(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_664(None) -> REF_663.selector
			TMP_2146(None) = REF_662 ^ REF_664
			REF_665(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_666(None) -> REF_665.selector
			TMP_2147(None) = TMP_2146 ^ REF_666
			governorParamsId(bytes4) := TMP_2147(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_2148(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_667(bytes4) (->None) := 4078917331(bytes4)
			TMP_2149(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_668(bytes4) (->None) := 3660085789(bytes4)
			TMP_2150(bytes4) = REF_667 ^ REF_668
			TMP_2151(bytes4) = TMP_2150 ^ governorCancelId
			TMP_2152(bytes4) = TMP_2151 ^ governorParamsId
			governor43Id(bytes4) := TMP_2152(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_2153(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_669(bytes4) (->None) := 4078917331(bytes4)
			TMP_2154(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_670(bytes4) (->None) := 3660085789(bytes4)
			TMP_2155(bytes4) = REF_669 ^ REF_670
			TMP_2156(bytes4) = TMP_2155 ^ governorCancelId
			governor46Id(bytes4) := TMP_2156(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_2157(bool) = interfaceId == governor43Id
			TMP_2158(bool) = interfaceId == governor46Id
			TMP_2159(bool) = TMP_2157 || TMP_2158
			TMP_2160(bool) = interfaceId == governorCancelId
			TMP_2161(bool) = TMP_2159 || TMP_2160
			TMP_2162(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_671(bytes4) (->None) := 1339874119(bytes4)
			TMP_2163(bool) = interfaceId == REF_671
			TMP_2164(bool) = TMP_2161 || TMP_2163
			TMP_2165(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_2166(bool) = TMP_2164 || TMP_2165
			RETURN TMP_2166
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_2167(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_2168(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2167)
			TMP_2169 = CONVERT TMP_2168 to uint256
			RETURN TMP_2169
	Function Governor.state(uint256) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_673(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_673(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_674(bool) -> proposal.executed
			CONDITION REF_674
		Expression: ProposalState.Executed
		IRs:
			REF_675(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_675
		Expression: proposal.canceled
		IRs:
			REF_676(bool) -> proposal.canceled
			CONDITION REF_676
		Expression: ProposalState.Canceled
		IRs:
			REF_677(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_677
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_2170(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_2170(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_2171(bool) = snapshot == 0
			CONDITION TMP_2171
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_2172(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_2173(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_2173(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_2174(bool) = snapshot >= currentTimepoint
			CONDITION TMP_2174
		Expression: ProposalState.Pending
		IRs:
			REF_678(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_678
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_2175(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_2175(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_2176(bool) = deadline >= currentTimepoint
			CONDITION TMP_2176
		Expression: ProposalState.Active
		IRs:
			REF_679(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_679
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_2177(bool) = INTERNAL_CALL, Governor._quorumReached(uint256)(proposalId)
			TMP_2178(bool) = INTERNAL_CALL, Governor._voteSucceeded(uint256)(proposalId)
			TMP_2179(bool) = TMP_2177 && TMP_2178
			CONDITION TMP_2179
		Expression: ProposalState.Succeeded
		IRs:
			REF_680(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_680
		Expression: ProposalState.Defeated
		IRs:
			REF_681(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_681
	Function Governor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_682(Governor.ProposalCore) -> _proposals[proposalId]
			REF_683(uint64) -> REF_682.voteStart
			RETURN REF_683
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_684(Governor.ProposalCore) -> _proposals[proposalId]
			REF_685(uint64) -> REF_684.voteEnd
			RETURN REF_685
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_686(Governor.ProposalCore) -> _proposals[proposalId]
			REF_687(address) -> REF_686.proposer
			RETURN REF_687
	Function Governor._quorumReached(uint256) (*)
	Function Governor._voteSucceeded(uint256) (*)
	Function Governor._getVotes(address,uint256,bytes) 
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) (*)
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) (*)
		Expression: proposer = _msgSender()
		IRs:
			TMP_2180(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_2180(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_2181(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_2182(None) = SOLIDITY_CALL require(bool,string)(TMP_2181,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_2183(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_2183(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_2184(uint256) = currentTimepoint (c)- 1
			TMP_2185(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_2184)
			TMP_2186(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_2187(bool) = TMP_2185 >= TMP_2186
			TMP_2188(None) = SOLIDITY_CALL require(bool,string)(TMP_2187,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_2189 = CONVERT description to bytes
			TMP_2190(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2189)
			TMP_2191(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_2190)
			proposalId(uint256) := TMP_2191(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_688 -> LENGTH targets
			REF_689 -> LENGTH values
			TMP_2192(bool) = REF_688 == REF_689
			TMP_2193(None) = SOLIDITY_CALL require(bool,string)(TMP_2192,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_690 -> LENGTH targets
			REF_691 -> LENGTH calldatas
			TMP_2194(bool) = REF_690 == REF_691
			TMP_2195(None) = SOLIDITY_CALL require(bool,string)(TMP_2194,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_692 -> LENGTH targets
			TMP_2196(bool) = REF_692 > 0
			TMP_2197(None) = SOLIDITY_CALL require(bool,string)(TMP_2196,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_693(Governor.ProposalCore) -> _proposals[proposalId]
			REF_694(uint64) -> REF_693.voteStart
			TMP_2198(bool) = REF_694 == 0
			TMP_2199(None) = SOLIDITY_CALL require(bool,string)(TMP_2198,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_2200(uint256) = INTERNAL_CALL, IGovernor.votingDelay()()
			TMP_2201(uint256) = currentTimepoint (c)+ TMP_2200
			snapshot(uint256) := TMP_2201(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_2202(uint256) = INTERNAL_CALL, IGovernor.votingPeriod()()
			TMP_2203(uint256) = snapshot (c)+ TMP_2202
			deadline(uint256) := TMP_2203(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_695(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_2204(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_2205(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_2206(Governor.ProposalCore) = new ProposalCore(TMP_2204,proposer,0,TMP_2205,0,False,False)
			REF_695(Governor.ProposalCore) (->_proposals) := TMP_2206(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_698 -> LENGTH targets
			TMP_2208(string[])  = new string[](REF_698)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_2208,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2210(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2210(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_2211(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_2211(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_699(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_2212(bool) = currentState == REF_699
			REF_700(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_2213(bool) = currentState == REF_700
			TMP_2214(bool) = TMP_2212 || TMP_2213
			TMP_2215(None) = SOLIDITY_CALL require(bool,string)(TMP_2214,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_701(Governor.ProposalCore) -> _proposals[proposalId]
			REF_702(bool) -> REF_701.executed
			REF_702(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2220(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2220(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_2221(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_703(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_2222(bool) = TMP_2221 == REF_703
			TMP_2223(None) = SOLIDITY_CALL require(bool,string)(TMP_2222,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_2224(address) = INTERNAL_CALL, Context._msgSender()()
			REF_704(Governor.ProposalCore) -> _proposals[proposalId]
			REF_705(address) -> REF_704.proposer
			TMP_2225(bool) = TMP_2224 == REF_705
			TMP_2226(None) = SOLIDITY_CALL require(bool,string)(TMP_2225,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2227(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_2227
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_706 -> LENGTH targets
			TMP_2228(bool) = i < REF_706
			CONDITION TMP_2228
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_707(address) -> targets[i]
			REF_709(bytes) -> calldatas[i]
			REF_710(uint256) -> values[i]
			TUPLE_28(bool,bytes) = LOW_LEVEL_CALL, dest:REF_707, function:call, arguments:['REF_709'] value:REF_710 
			success(bool)= UNPACK TUPLE_28 index: 0 
			returndata(bytes)= UNPACK TUPLE_28 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_2229(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_2230(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2231 = CONVERT this to address
			TMP_2232(bool) = TMP_2230 != TMP_2231
			CONDITION TMP_2232
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_712 -> LENGTH targets
			TMP_2233(bool) = i < REF_712
			CONDITION TMP_2233
		Expression: targets[i] == address(this)
		IRs:
			REF_713(address) -> targets[i]
			TMP_2234 = CONVERT this to address
			TMP_2235(bool) = REF_713 == TMP_2234
			CONDITION TMP_2235
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_715(bytes) -> calldatas[i]
			TMP_2236(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_715)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_2236'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_2238(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2239 = CONVERT this to address
			TMP_2240(bool) = TMP_2238 != TMP_2239
			CONDITION TMP_2240
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_2241(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_2242 = UnaryType.BANG TMP_2241 
			CONDITION TMP_2242
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2244(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2244(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_2245(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_2245(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_718(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_2246(bool) = currentState != REF_718
			REF_719(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_2247(bool) = currentState != REF_719
			TMP_2248(bool) = TMP_2246 && TMP_2247
			REF_720(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_2249(bool) = currentState != REF_720
			TMP_2250(bool) = TMP_2248 && TMP_2249
			TMP_2251(None) = SOLIDITY_CALL require(bool,string)(TMP_2250,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_721(Governor.ProposalCore) -> _proposals[proposalId]
			REF_722(bool) -> REF_721.canceled
			REF_722(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_2253(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2254(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,TMP_2253)
			RETURN TMP_2254
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_2255(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_2255
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2256(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2256(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2257(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2257
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2258(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2258(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_2259(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_2259
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2260(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2260(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2261(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2261
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_2262(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_2263(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2262)
			TMP_2264(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2263)
			TMP_2265(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2264', 'v', 'r', 's'] 
			voter(address) := TMP_2265(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2266(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2266
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_2267 = CONVERT reason to bytes
			TMP_2268(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2267)
			TMP_2269(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_2270(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_2268,TMP_2269)
			TMP_2271(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2270)
			TMP_2272(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2271)
			TMP_2273(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2272', 'v', 'r', 's'] 
			voter(address) := TMP_2273(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2274(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2274
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_2275(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2276(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_2275)
			RETURN TMP_2276
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_727(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_727(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_2277(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_728(IGovernor.ProposalState) -> ProposalState.Active
			TMP_2278(bool) = TMP_2277 == REF_728
			TMP_2279(None) = SOLIDITY_CALL require(bool,string)(TMP_2278,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_729(uint64) -> proposal.voteStart
			TMP_2280(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,REF_729,params)
			weight(uint256) := TMP_2280(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, Governor._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_730 -> LENGTH params
			TMP_2282(bool) = REF_730 == 0
			CONDITION TMP_2282
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_29(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_29 index: 0 
			returndata(bytes)= UNPACK TUPLE_29 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_2285(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() (*)
		Expression: address(this)
		IRs:
			TMP_2287 = CONVERT this to address
			RETURN TMP_2287
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_733(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_734(None) -> REF_733.selector
			RETURN REF_734
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_735(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_736(None) -> REF_735.selector
			RETURN REF_736
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_737(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_738(None) -> REF_737.selector
			RETURN REF_738
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_2288 = CONVERT description to bytes
			REF_739 -> LENGTH TMP_2288
			len(uint256) := REF_739(uint256)
		Expression: len < 52
		IRs:
			TMP_2289(bool) = len < 52
			CONDITION TMP_2289
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_2290(uint256) = len - 20
			TMP_2291(string) = description + TMP_2290
			TMP_2292(uint256) = SOLIDITY_CALL mload(uint256)(TMP_2291)
			marker(bytes12) := TMP_2292(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_2293 = CONVERT #proposer=0x to bytes12
			TMP_2294(bool) = marker != TMP_2293
			CONDITION TMP_2294
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_2295(uint256) = len (c)- 40
			i(uint256) := TMP_2295(uint256)
		Expression: i < len
		IRs:
			TMP_2296(bool) = i < len
			CONDITION TMP_2296
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_2297 = CONVERT description to bytes
			REF_740(None) -> TMP_2297[i]
			TUPLE_30(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_740)
			isHex(bool)= UNPACK TUPLE_30 index: 0 
			value(uint8)= UNPACK TUPLE_30 index: 1 
		Expression: ! isHex
		IRs:
			TMP_2298 = UnaryType.BANG isHex 
			CONDITION TMP_2298
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_2299(uint160) = recovered << 4
			TMP_2300(uint160) = TMP_2299 | value
			recovered(uint160) := TMP_2300(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_2301 = CONVERT proposer to uint160
			TMP_2302(bool) = recovered == TMP_2301
			RETURN TMP_2302
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_2303 = CONVERT char to uint8
			c(uint8) := TMP_2303(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_2304(bool) = 47 < c
			TMP_2305(bool) = c < 58
			TMP_2306(bool) = TMP_2304 && TMP_2305
			CONDITION TMP_2306
		Expression: (true,c - 48)
		IRs:
			TMP_2307(uint8) = c - 48
			RETURN True,TMP_2307
		Expression: 64 < c && c < 71
		IRs:
			TMP_2308(bool) = 64 < c
			TMP_2309(bool) = c < 71
			TMP_2310(bool) = TMP_2308 && TMP_2309
			CONDITION TMP_2310
		Expression: (true,c - 55)
		IRs:
			TMP_2311(uint8) = c - 55
			RETURN True,TMP_2311
		Expression: 96 < c && c < 103
		IRs:
			TMP_2312(bool) = 96 < c
			TMP_2313(bool) = c < 103
			TMP_2314(bool) = TMP_2312 && TMP_2313
			CONDITION TMP_2314
		Expression: (true,c - 87)
		IRs:
			TMP_2315(uint8) = c - 87
			RETURN True,TMP_2315
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() 
	Function IGovernor.CLOCK_MODE() 
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_2316(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_2316(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_2317(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_2317(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2318 = CONVERT name to bytes
			TMP_2319(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2318)
			_hashedName(bytes32) := TMP_2319(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2320 = CONVERT version to bytes
			TMP_2321(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2320)
			_hashedVersion(bytes32) := TMP_2321(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_2322(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_2322(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_2323 = CONVERT this to address
			_cachedThis(address) := TMP_2323(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_2324 = CONVERT this to address
			TMP_2325(bool) = TMP_2324 == _cachedThis
			TMP_2326(bool) = block.chainid == _cachedChainId
			TMP_2327(bool) = TMP_2325 && TMP_2326
			CONDITION TMP_2327
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_2328(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_2328
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_2329 = CONVERT this to address
			TMP_2330(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_2329)
			TMP_2331(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2330)
			RETURN TMP_2331
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2332(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2333(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2332', 'structHash'] 
			RETURN TMP_2333
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_2334(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_2335(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_2336 = CONVERT this to address
			TMP_2337 = CONVERT 0 to bytes32
			TMP_2339(uint256[])  = new uint256[](0)
			RETURN ,TMP_2334,TMP_2335,block.chainid,TMP_2336,TMP_2337,TMP_2339
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_2340(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_747(bytes4) (->None) := 33540519(bytes4)
			TMP_2341(bool) = interfaceId == REF_747
			RETURN TMP_2341
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function GovernorVotes.constructor(IVotes) (*)
		Expression: token = IERC5805(address(tokenAddress))
		IRs:
			TMP_2342 = CONVERT tokenAddress to address
			TMP_2343 = CONVERT TMP_2342 to IERC5805
			token(IERC5805) := TMP_2343(IERC5805)
	Function GovernorVotes.clock() (*)
		Expression: timepoint = token.clock()
		IRs:
			TMP_2344(uint48) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:clock, arguments:[]  
			timepoint(uint48) := TMP_2344(uint48)
		Expression: timepoint
		IRs:
			RETURN timepoint
		Expression: SafeCast.toUint48(block.number)
		IRs:
			TMP_2345(uint48) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint48(uint256), arguments:['block.number'] 
			RETURN TMP_2345
	Function GovernorVotes.CLOCK_MODE() (*)
		Expression: clockmode = token.CLOCK_MODE()
		IRs:
			TMP_2346(string) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:CLOCK_MODE, arguments:[]  
			clockmode(string) := TMP_2346(string)
		Expression: clockmode
		IRs:
			RETURN clockmode
		Expression: mode=blocknumber&from=default
		IRs:
			RETURN mode=blocknumber&from=default
	Function GovernorVotes._getVotes(address,uint256,bytes) (*)
		Expression: token.getPastVotes(account,timepoint)
		IRs:
			TMP_2347(uint256) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:getPastVotes, arguments:['account', 'timepoint']  
			RETURN TMP_2347
	Function GovernorVotes.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_2348(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_2348(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_2349(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_2349(bytes32)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_2350(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2351(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2352(bool) = TMP_2350 == TMP_2351
			TMP_2353(None) = SOLIDITY_CALL require(bool,string)(TMP_2352,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_2354(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2355 = CONVERT this to address
			TMP_2356(bool) = TMP_2354 != TMP_2355
			CONDITION TMP_2356
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_2357(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_2358(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2357)
			msgDataHash(bytes32) := TMP_2358(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_2359(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_2360(bool) = TMP_2359 != msgDataHash
			CONDITION TMP_2360
Contract GovernorVotesQuorumFraction
	Function GovernorVotes.constructor(IVotes) (*)
		Expression: token = IERC5805(address(tokenAddress))
		IRs:
			TMP_2361 = CONVERT tokenAddress to address
			TMP_2362 = CONVERT TMP_2361 to IERC5805
			token(IERC5805) := TMP_2362(IERC5805)
	Function GovernorVotes.clock() (*)
		Expression: timepoint = token.clock()
		IRs:
			TMP_2363(uint48) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:clock, arguments:[]  
			timepoint(uint48) := TMP_2363(uint48)
		Expression: timepoint
		IRs:
			RETURN timepoint
		Expression: SafeCast.toUint48(block.number)
		IRs:
			TMP_2364(uint48) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint48(uint256), arguments:['block.number'] 
			RETURN TMP_2364
	Function GovernorVotes.CLOCK_MODE() (*)
		Expression: clockmode = token.CLOCK_MODE()
		IRs:
			TMP_2365(string) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:CLOCK_MODE, arguments:[]  
			clockmode(string) := TMP_2365(string)
		Expression: clockmode
		IRs:
			RETURN clockmode
		Expression: mode=blocknumber&from=default
		IRs:
			RETURN mode=blocknumber&from=default
	Function GovernorVotes._getVotes(address,uint256,bytes) (*)
		Expression: token.getPastVotes(account,timepoint)
		IRs:
			TMP_2366(uint256) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:getPastVotes, arguments:['account', 'timepoint']  
			RETURN TMP_2366
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_2367(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_2367)
		Expression: EIP712(name_,version())
		IRs:
			TMP_2369(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_2369)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_2371(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2372 = CONVERT this to address
			TMP_2373(bool) = TMP_2371 == TMP_2372
			TMP_2374(None) = SOLIDITY_CALL require(bool,string)(TMP_2373,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) (*)
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_757(function(None,None,None,None) returns(None)) -> this.cancel
			REF_758(None) -> REF_757.selector
			REF_759(function(None) returns(None)) -> this.proposalProposer
			REF_760(None) -> REF_759.selector
			TMP_2375(None) = REF_758 ^ REF_760
			governorCancelId(bytes4) := TMP_2375(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_761(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_762(None) -> REF_761.selector
			REF_763(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_764(None) -> REF_763.selector
			TMP_2376(None) = REF_762 ^ REF_764
			REF_765(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_766(None) -> REF_765.selector
			TMP_2377(None) = TMP_2376 ^ REF_766
			governorParamsId(bytes4) := TMP_2377(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_2378(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_767(bytes4) (->None) := 4078917331(bytes4)
			TMP_2379(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_768(bytes4) (->None) := 3660085789(bytes4)
			TMP_2380(bytes4) = REF_767 ^ REF_768
			TMP_2381(bytes4) = TMP_2380 ^ governorCancelId
			TMP_2382(bytes4) = TMP_2381 ^ governorParamsId
			governor43Id(bytes4) := TMP_2382(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_2383(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_769(bytes4) (->None) := 4078917331(bytes4)
			TMP_2384(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_770(bytes4) (->None) := 3660085789(bytes4)
			TMP_2385(bytes4) = REF_769 ^ REF_770
			TMP_2386(bytes4) = TMP_2385 ^ governorCancelId
			governor46Id(bytes4) := TMP_2386(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_2387(bool) = interfaceId == governor43Id
			TMP_2388(bool) = interfaceId == governor46Id
			TMP_2389(bool) = TMP_2387 || TMP_2388
			TMP_2390(bool) = interfaceId == governorCancelId
			TMP_2391(bool) = TMP_2389 || TMP_2390
			TMP_2392(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_771(bytes4) (->None) := 1339874119(bytes4)
			TMP_2393(bool) = interfaceId == REF_771
			TMP_2394(bool) = TMP_2391 || TMP_2393
			TMP_2395(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_2396(bool) = TMP_2394 || TMP_2395
			RETURN TMP_2396
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_2397(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_2398(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2397)
			TMP_2399 = CONVERT TMP_2398 to uint256
			RETURN TMP_2399
	Function Governor.state(uint256) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_773(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_773(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_774(bool) -> proposal.executed
			CONDITION REF_774
		Expression: ProposalState.Executed
		IRs:
			REF_775(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_775
		Expression: proposal.canceled
		IRs:
			REF_776(bool) -> proposal.canceled
			CONDITION REF_776
		Expression: ProposalState.Canceled
		IRs:
			REF_777(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_777
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_2400(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_2400(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_2401(bool) = snapshot == 0
			CONDITION TMP_2401
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_2402(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_2403(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_2403(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_2404(bool) = snapshot >= currentTimepoint
			CONDITION TMP_2404
		Expression: ProposalState.Pending
		IRs:
			REF_778(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_778
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_2405(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_2405(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_2406(bool) = deadline >= currentTimepoint
			CONDITION TMP_2406
		Expression: ProposalState.Active
		IRs:
			REF_779(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_779
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_2407(bool) = INTERNAL_CALL, Governor._quorumReached(uint256)(proposalId)
			TMP_2408(bool) = INTERNAL_CALL, Governor._voteSucceeded(uint256)(proposalId)
			TMP_2409(bool) = TMP_2407 && TMP_2408
			CONDITION TMP_2409
		Expression: ProposalState.Succeeded
		IRs:
			REF_780(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_780
		Expression: ProposalState.Defeated
		IRs:
			REF_781(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_781
	Function Governor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_782(Governor.ProposalCore) -> _proposals[proposalId]
			REF_783(uint64) -> REF_782.voteStart
			RETURN REF_783
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_784(Governor.ProposalCore) -> _proposals[proposalId]
			REF_785(uint64) -> REF_784.voteEnd
			RETURN REF_785
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_786(Governor.ProposalCore) -> _proposals[proposalId]
			REF_787(address) -> REF_786.proposer
			RETURN REF_787
	Function Governor._quorumReached(uint256) (*)
	Function Governor._voteSucceeded(uint256) (*)
	Function Governor._getVotes(address,uint256,bytes) 
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) (*)
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) (*)
		Expression: proposer = _msgSender()
		IRs:
			TMP_2410(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_2410(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_2411(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_2412(None) = SOLIDITY_CALL require(bool,string)(TMP_2411,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_2413(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_2413(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_2414(uint256) = currentTimepoint (c)- 1
			TMP_2415(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_2414)
			TMP_2416(uint256) = INTERNAL_CALL, Governor.proposalThreshold()()
			TMP_2417(bool) = TMP_2415 >= TMP_2416
			TMP_2418(None) = SOLIDITY_CALL require(bool,string)(TMP_2417,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_2419 = CONVERT description to bytes
			TMP_2420(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2419)
			TMP_2421(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_2420)
			proposalId(uint256) := TMP_2421(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_788 -> LENGTH targets
			REF_789 -> LENGTH values
			TMP_2422(bool) = REF_788 == REF_789
			TMP_2423(None) = SOLIDITY_CALL require(bool,string)(TMP_2422,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_790 -> LENGTH targets
			REF_791 -> LENGTH calldatas
			TMP_2424(bool) = REF_790 == REF_791
			TMP_2425(None) = SOLIDITY_CALL require(bool,string)(TMP_2424,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_792 -> LENGTH targets
			TMP_2426(bool) = REF_792 > 0
			TMP_2427(None) = SOLIDITY_CALL require(bool,string)(TMP_2426,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_793(Governor.ProposalCore) -> _proposals[proposalId]
			REF_794(uint64) -> REF_793.voteStart
			TMP_2428(bool) = REF_794 == 0
			TMP_2429(None) = SOLIDITY_CALL require(bool,string)(TMP_2428,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_2430(uint256) = INTERNAL_CALL, IGovernor.votingDelay()()
			TMP_2431(uint256) = currentTimepoint (c)+ TMP_2430
			snapshot(uint256) := TMP_2431(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_2432(uint256) = INTERNAL_CALL, IGovernor.votingPeriod()()
			TMP_2433(uint256) = snapshot (c)+ TMP_2432
			deadline(uint256) := TMP_2433(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_795(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_2434(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_2435(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_2436(Governor.ProposalCore) = new ProposalCore(TMP_2434,proposer,0,TMP_2435,0,False,False)
			REF_795(Governor.ProposalCore) (->_proposals) := TMP_2436(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_798 -> LENGTH targets
			TMP_2438(string[])  = new string[](REF_798)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_2438,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2440(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2440(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_2441(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_2441(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_799(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_2442(bool) = currentState == REF_799
			REF_800(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_2443(bool) = currentState == REF_800
			TMP_2444(bool) = TMP_2442 || TMP_2443
			TMP_2445(None) = SOLIDITY_CALL require(bool,string)(TMP_2444,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_801(Governor.ProposalCore) -> _proposals[proposalId]
			REF_802(bool) -> REF_801.executed
			REF_802(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2450(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2450(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_2451(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_803(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_2452(bool) = TMP_2451 == REF_803
			TMP_2453(None) = SOLIDITY_CALL require(bool,string)(TMP_2452,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_2454(address) = INTERNAL_CALL, Context._msgSender()()
			REF_804(Governor.ProposalCore) -> _proposals[proposalId]
			REF_805(address) -> REF_804.proposer
			TMP_2455(bool) = TMP_2454 == REF_805
			TMP_2456(None) = SOLIDITY_CALL require(bool,string)(TMP_2455,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2457(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_2457
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_806 -> LENGTH targets
			TMP_2458(bool) = i < REF_806
			CONDITION TMP_2458
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_807(address) -> targets[i]
			REF_809(bytes) -> calldatas[i]
			REF_810(uint256) -> values[i]
			TUPLE_31(bool,bytes) = LOW_LEVEL_CALL, dest:REF_807, function:call, arguments:['REF_809'] value:REF_810 
			success(bool)= UNPACK TUPLE_31 index: 0 
			returndata(bytes)= UNPACK TUPLE_31 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_2459(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_2460(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2461 = CONVERT this to address
			TMP_2462(bool) = TMP_2460 != TMP_2461
			CONDITION TMP_2462
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_812 -> LENGTH targets
			TMP_2463(bool) = i < REF_812
			CONDITION TMP_2463
		Expression: targets[i] == address(this)
		IRs:
			REF_813(address) -> targets[i]
			TMP_2464 = CONVERT this to address
			TMP_2465(bool) = REF_813 == TMP_2464
			CONDITION TMP_2465
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_815(bytes) -> calldatas[i]
			TMP_2466(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_815)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_2466'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_2468(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2469 = CONVERT this to address
			TMP_2470(bool) = TMP_2468 != TMP_2469
			CONDITION TMP_2470
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_2471(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_2472 = UnaryType.BANG TMP_2471 
			CONDITION TMP_2472
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_2474(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_2474(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_2475(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_2475(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_818(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_2476(bool) = currentState != REF_818
			REF_819(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_2477(bool) = currentState != REF_819
			TMP_2478(bool) = TMP_2476 && TMP_2477
			REF_820(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_2479(bool) = currentState != REF_820
			TMP_2480(bool) = TMP_2478 && TMP_2479
			TMP_2481(None) = SOLIDITY_CALL require(bool,string)(TMP_2480,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_821(Governor.ProposalCore) -> _proposals[proposalId]
			REF_822(bool) -> REF_821.canceled
			REF_822(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_2483(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2484(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,TMP_2483)
			RETURN TMP_2484
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_2485(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_2485
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2486(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2486(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2487(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2487
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2488(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2488(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_2489(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_2489
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_2490(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_2490(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2491(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2491
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_2492(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_2493(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2492)
			TMP_2494(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2493)
			TMP_2495(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2494', 'v', 'r', 's'] 
			voter(address) := TMP_2495(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_2496(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_2496
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_2497 = CONVERT reason to bytes
			TMP_2498(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2497)
			TMP_2499(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_2500(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_2498,TMP_2499)
			TMP_2501(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2500)
			TMP_2502(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_2501)
			TMP_2503(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_2502', 'v', 'r', 's'] 
			voter(address) := TMP_2503(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_2504(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_2504
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_2505(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_2506(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_2505)
			RETURN TMP_2506
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_827(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_827(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_2507(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			REF_828(IGovernor.ProposalState) -> ProposalState.Active
			TMP_2508(bool) = TMP_2507 == REF_828
			TMP_2509(None) = SOLIDITY_CALL require(bool,string)(TMP_2508,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_829(uint64) -> proposal.voteStart
			TMP_2510(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,REF_829,params)
			weight(uint256) := TMP_2510(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, Governor._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_830 -> LENGTH params
			TMP_2512(bool) = REF_830 == 0
			CONDITION TMP_2512
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_32(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_32 index: 0 
			returndata(bytes)= UNPACK TUPLE_32 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_2515(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() (*)
		Expression: address(this)
		IRs:
			TMP_2517 = CONVERT this to address
			RETURN TMP_2517
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_833(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_834(None) -> REF_833.selector
			RETURN REF_834
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_835(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_836(None) -> REF_835.selector
			RETURN REF_836
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_837(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_838(None) -> REF_837.selector
			RETURN REF_838
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_2518 = CONVERT description to bytes
			REF_839 -> LENGTH TMP_2518
			len(uint256) := REF_839(uint256)
		Expression: len < 52
		IRs:
			TMP_2519(bool) = len < 52
			CONDITION TMP_2519
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_2520(uint256) = len - 20
			TMP_2521(string) = description + TMP_2520
			TMP_2522(uint256) = SOLIDITY_CALL mload(uint256)(TMP_2521)
			marker(bytes12) := TMP_2522(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_2523 = CONVERT #proposer=0x to bytes12
			TMP_2524(bool) = marker != TMP_2523
			CONDITION TMP_2524
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_2525(uint256) = len (c)- 40
			i(uint256) := TMP_2525(uint256)
		Expression: i < len
		IRs:
			TMP_2526(bool) = i < len
			CONDITION TMP_2526
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_2527 = CONVERT description to bytes
			REF_840(None) -> TMP_2527[i]
			TUPLE_33(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_840)
			isHex(bool)= UNPACK TUPLE_33 index: 0 
			value(uint8)= UNPACK TUPLE_33 index: 1 
		Expression: ! isHex
		IRs:
			TMP_2528 = UnaryType.BANG isHex 
			CONDITION TMP_2528
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_2529(uint160) = recovered << 4
			TMP_2530(uint160) = TMP_2529 | value
			recovered(uint160) := TMP_2530(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_2531 = CONVERT proposer to uint160
			TMP_2532(bool) = recovered == TMP_2531
			RETURN TMP_2532
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_2533 = CONVERT char to uint8
			c(uint8) := TMP_2533(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_2534(bool) = 47 < c
			TMP_2535(bool) = c < 58
			TMP_2536(bool) = TMP_2534 && TMP_2535
			CONDITION TMP_2536
		Expression: (true,c - 48)
		IRs:
			TMP_2537(uint8) = c - 48
			RETURN True,TMP_2537
		Expression: 64 < c && c < 71
		IRs:
			TMP_2538(bool) = 64 < c
			TMP_2539(bool) = c < 71
			TMP_2540(bool) = TMP_2538 && TMP_2539
			CONDITION TMP_2540
		Expression: (true,c - 55)
		IRs:
			TMP_2541(uint8) = c - 55
			RETURN True,TMP_2541
		Expression: 96 < c && c < 103
		IRs:
			TMP_2542(bool) = 96 < c
			TMP_2543(bool) = c < 103
			TMP_2544(bool) = TMP_2542 && TMP_2543
			CONDITION TMP_2544
		Expression: (true,c - 87)
		IRs:
			TMP_2545(uint8) = c - 87
			RETURN True,TMP_2545
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() 
	Function IGovernor.CLOCK_MODE() 
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) 
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_2546(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_2546(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_2547(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_2547(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_2548 = CONVERT name to bytes
			TMP_2549(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2548)
			_hashedName(bytes32) := TMP_2549(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_2550 = CONVERT version to bytes
			TMP_2551(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2550)
			_hashedVersion(bytes32) := TMP_2551(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_2552(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_2552(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_2553 = CONVERT this to address
			_cachedThis(address) := TMP_2553(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_2554 = CONVERT this to address
			TMP_2555(bool) = TMP_2554 == _cachedThis
			TMP_2556(bool) = block.chainid == _cachedChainId
			TMP_2557(bool) = TMP_2555 && TMP_2556
			CONDITION TMP_2557
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_2558(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_2558
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_2559 = CONVERT this to address
			TMP_2560(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_2559)
			TMP_2561(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2560)
			RETURN TMP_2561
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_2562(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_2563(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_2562', 'structHash'] 
			RETURN TMP_2563
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_2564(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_2565(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_2566 = CONVERT this to address
			TMP_2567 = CONVERT 0 to bytes32
			TMP_2569(uint256[])  = new uint256[](0)
			RETURN ,TMP_2564,TMP_2565,block.chainid,TMP_2566,TMP_2567,TMP_2569
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_2570(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_847(bytes4) (->None) := 33540519(bytes4)
			TMP_2571(bool) = interfaceId == REF_847
			RETURN TMP_2571
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function GovernorVotesQuorumFraction.constructor(uint256) (*)
		Expression: _updateQuorumNumerator(quorumNumeratorValue)
		IRs:
			INTERNAL_CALL, GovernorVotesQuorumFraction._updateQuorumNumerator(uint256)(quorumNumeratorValue)
	Function GovernorVotesQuorumFraction.quorumNumerator() (*)
		Expression: _quorumNumeratorHistory._checkpoints.length == 0
		IRs:
			REF_848(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_849 -> LENGTH REF_848
			TMP_2573(bool) = REF_849 == 0
			CONDITION TMP_2573
		Expression: _quorumNumerator
		IRs:
			RETURN _quorumNumerator
		Expression: _quorumNumeratorHistory.latest()
		IRs:
			TMP_2574(uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.latest(Checkpoints.Trace224), arguments:['_quorumNumeratorHistory'] 
			RETURN TMP_2574
	Function GovernorVotesQuorumFraction.quorumNumerator(uint256) (*)
		Expression: length = _quorumNumeratorHistory._checkpoints.length
		IRs:
			REF_851(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_852 -> LENGTH REF_851
			length(uint256) := REF_852(uint256)
		Expression: length == 0
		IRs:
			TMP_2575(bool) = length == 0
			CONDITION TMP_2575
		Expression: _quorumNumerator
		IRs:
			RETURN _quorumNumerator
		Expression: latest = _quorumNumeratorHistory._checkpoints[length - 1]
		IRs:
			REF_853(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			TMP_2576(uint256) = length (c)- 1
			REF_854(Checkpoints.Checkpoint224) -> REF_853[TMP_2576]
			latest(Checkpoints.Checkpoint224) := REF_854(Checkpoints.Checkpoint224)
		Expression: latest._key <= timepoint
		IRs:
			REF_855(uint32) -> latest._key
			TMP_2577(bool) = REF_855 <= timepoint
			CONDITION TMP_2577
		Expression: latest._value
		IRs:
			REF_856(uint224) -> latest._value
			RETURN REF_856
		Expression: _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint32(timepoint))
		IRs:
			TMP_2578(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['timepoint'] 
			TMP_2579(uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.upperLookupRecent(Checkpoints.Trace224,uint32), arguments:['_quorumNumeratorHistory', 'TMP_2578'] 
			RETURN TMP_2579
	Function GovernorVotesQuorumFraction.quorumDenominator() (*)
		Expression: 100
		IRs:
			RETURN 100
	Function GovernorVotesQuorumFraction.quorum(uint256) (*)
		Expression: (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator()
		IRs:
			TMP_2580(uint256) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:getPastTotalSupply, arguments:['timepoint']  
			TMP_2581(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumNumerator(uint256)(timepoint)
			TMP_2582(uint256) = TMP_2580 (c)* TMP_2581
			TMP_2583(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumDenominator()()
			TMP_2584(uint256) = TMP_2582 (c)/ TMP_2583
			RETURN TMP_2584
	Function GovernorVotesQuorumFraction.updateQuorumNumerator(uint256) (*)
		Expression: _updateQuorumNumerator(newQuorumNumerator)
		IRs:
			INTERNAL_CALL, GovernorVotesQuorumFraction._updateQuorumNumerator(uint256)(newQuorumNumerator)
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function GovernorVotesQuorumFraction._updateQuorumNumerator(uint256) (*)
		Expression: require(bool,string)(newQuorumNumerator <= quorumDenominator(),GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator)
		IRs:
			TMP_2587(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumDenominator()()
			TMP_2588(bool) = newQuorumNumerator <= TMP_2587
			TMP_2589(None) = SOLIDITY_CALL require(bool,string)(TMP_2588,GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator)
		Expression: oldQuorumNumerator = quorumNumerator()
		IRs:
			TMP_2590(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumNumerator()()
			oldQuorumNumerator(uint256) := TMP_2590(uint256)
		Expression: oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0
		IRs:
			TMP_2591(bool) = oldQuorumNumerator != 0
			REF_860(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_861 -> LENGTH REF_860
			TMP_2592(bool) = REF_861 == 0
			TMP_2593(bool) = TMP_2591 && TMP_2592
			CONDITION TMP_2593
		Expression: _quorumNumeratorHistory._checkpoints.push(Checkpoints.Checkpoint224({_key:0,_value:SafeCast.toUint224(oldQuorumNumerator)}))
		IRs:
			REF_862(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			TMP_2594(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['oldQuorumNumerator'] 
			TMP_2595(Checkpoints.Checkpoint224) = new Checkpoint224(0,TMP_2594)
			REF_866 -> LENGTH REF_862
			TMP_2597(uint256) := REF_866(uint256)
			TMP_2598(uint256) = TMP_2597 (c)+ 1
			REF_866(uint256) (->_quorumNumeratorHistory) := TMP_2598(uint256)
			REF_867(Checkpoints.Checkpoint224) -> REF_862[TMP_2597]
			REF_867(Checkpoints.Checkpoint224) (->_quorumNumeratorHistory) := TMP_2595(Checkpoints.Checkpoint224)
		Expression: _quorumNumeratorHistory.push(SafeCast.toUint32(clock()),SafeCast.toUint224(newQuorumNumerator))
		IRs:
			TMP_2599(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			TMP_2600(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['TMP_2599'] 
			TMP_2601(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newQuorumNumerator'] 
			TUPLE_34(uint224,uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.push(Checkpoints.Trace224,uint32,uint224), arguments:['_quorumNumeratorHistory', 'TMP_2600', 'TMP_2601'] 
		Expression: QuorumNumeratorUpdated(oldQuorumNumerator,newQuorumNumerator)
		IRs:
			Emit QuorumNumeratorUpdated(oldQuorumNumerator,newQuorumNumerator)
	Function GovernorVotesQuorumFraction.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_2603(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_2603(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_2604(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_2604(bytes32)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_2605(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2606(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2607(bool) = TMP_2605 == TMP_2606
			TMP_2608(None) = SOLIDITY_CALL require(bool,string)(TMP_2607,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_2609(address) = INTERNAL_CALL, Governor._executor()()
			TMP_2610 = CONVERT this to address
			TMP_2611(bool) = TMP_2609 != TMP_2610
			CONDITION TMP_2611
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_2612(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_2613(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_2612)
			msgDataHash(bytes32) := TMP_2613(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_2614(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_2615(bool) = TMP_2614 != msgDataHash
			CONDITION TMP_2615
Contract IGovernorTimelock
	Function IGovernor.name() (*)
	Function IGovernor.version() (*)
	Function IGovernor.clock() (*)
	Function IGovernor.CLOCK_MODE() (*)
	Function IGovernor.COUNTING_MODE() (*)
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.state(uint256) (*)
	Function IGovernor.proposalSnapshot(uint256) (*)
	Function IGovernor.proposalDeadline(uint256) (*)
	Function IGovernor.proposalProposer(uint256) (*)
	Function IGovernor.votingDelay() (*)
	Function IGovernor.votingPeriod() (*)
	Function IGovernor.quorum(uint256) (*)
	Function IGovernor.getVotes(address,uint256) (*)
	Function IGovernor.getVotesWithParams(address,uint256,bytes) (*)
	Function IGovernor.hasVoted(uint256,address) (*)
	Function IGovernor.propose(address[],uint256[],bytes[],string) (*)
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) (*)
	Function IGovernor.castVote(uint256,uint8) (*)
	Function IGovernor.castVoteWithReason(uint256,uint8,string) (*)
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function IERC165.supportsInterface(bytes4) (*)
	Function IGovernorTimelock.timelock() (*)
	Function IGovernorTimelock.proposalEta(uint256) (*)
	Function IGovernorTimelock.queue(address[],uint256[],bytes[],bytes32) (*)
Contract IVotes
	Function IVotes.getVotes(address) (*)
	Function IVotes.getPastVotes(address,uint256) (*)
	Function IVotes.getPastTotalSupply(uint256) (*)
	Function IVotes.delegates(address) (*)
	Function IVotes.delegate(address) (*)
	Function IVotes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) (*)
Contract IERC1967
Contract IERC3156FlashBorrower
	Function IERC3156FlashBorrower.onFlashLoan(address,address,uint256,uint256,bytes) (*)
Contract IERC3156FlashLender
	Function IERC3156FlashLender.maxFlashLoan(address) (*)
	Function IERC3156FlashLender.flashFee(address,uint256) (*)
	Function IERC3156FlashLender.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (*)
Contract IERC4626
	Function IERC20Metadata.name() (*)
	Function IERC20Metadata.symbol() (*)
	Function IERC20Metadata.decimals() (*)
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) (*)
	Function IERC20.transfer(address,uint256) (*)
	Function IERC20.allowance(address,address) (*)
	Function IERC20.approve(address,uint256) (*)
	Function IERC20.transferFrom(address,address,uint256) (*)
	Function IERC4626.asset() (*)
	Function IERC4626.totalAssets() (*)
	Function IERC4626.convertToShares(uint256) (*)
	Function IERC4626.convertToAssets(uint256) (*)
	Function IERC4626.maxDeposit(address) (*)
	Function IERC4626.previewDeposit(uint256) (*)
	Function IERC4626.deposit(uint256,address) (*)
	Function IERC4626.maxMint(address) (*)
	Function IERC4626.previewMint(uint256) (*)
	Function IERC4626.mint(uint256,address) (*)
	Function IERC4626.maxWithdraw(address) (*)
	Function IERC4626.previewWithdraw(uint256) (*)
	Function IERC4626.withdraw(uint256,address,address) (*)
	Function IERC4626.maxRedeem(address) (*)
	Function IERC4626.previewRedeem(uint256) (*)
	Function IERC4626.redeem(uint256,address,address) (*)
Contract IERC5267
	Function IERC5267.eip712Domain() (*)
Contract IERC5805
	Function IVotes.getVotes(address) (*)
	Function IVotes.getPastVotes(address,uint256) (*)
	Function IVotes.getPastTotalSupply(uint256) (*)
	Function IVotes.delegates(address) (*)
	Function IVotes.delegate(address) (*)
	Function IVotes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) (*)
	Function IERC6372.clock() (*)
	Function IERC6372.CLOCK_MODE() (*)
Contract IERC6372
	Function IERC6372.clock() (*)
	Function IERC6372.CLOCK_MODE() (*)
Contract IERC1822Proxiable
	Function IERC1822Proxiable.proxiableUUID() (*)
Contract ERC1967Proxy
	Function ERC1967Upgrade._getImplementation() (*)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value
		IRs:
			TMP_2616(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_873(address) -> TMP_2616.value
			RETURN REF_873
	Function ERC1967Upgrade._setImplementation(address) (*)
		Expression: require(bool,string)(Address.isContract(newImplementation),ERC1967: new implementation is not a contract)
		IRs:
			TMP_2617(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newImplementation'] 
			TMP_2618(None) = SOLIDITY_CALL require(bool,string)(TMP_2617,ERC1967: new implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation
		IRs:
			TMP_2619(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_876(address) -> TMP_2619.value
			REF_876(address) (->TMP_2619) := newImplementation(address)
	Function ERC1967Upgrade._upgradeTo(address) (*)
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: Upgraded(newImplementation)
		IRs:
			Emit Upgraded(newImplementation)
	Function ERC1967Upgrade._upgradeToAndCall(address,bytes,bool) (*)
		Expression: _upgradeTo(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeTo(address)(newImplementation)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_877 -> LENGTH data
			TMP_2623(bool) = REF_877 > 0
			TMP_2624(bool) = TMP_2623 || forceCall
			CONDITION TMP_2624
		Expression: Address.functionDelegateCall(newImplementation,data)
		IRs:
			TMP_2625(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['newImplementation', 'data'] 
	Function ERC1967Upgrade._upgradeToAndCallUUPS(address,bytes,bool) (*)
		Expression: StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value
		IRs:
			TMP_2626(StorageSlot.BooleanSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getBooleanSlot(bytes32), arguments:['_ROLLBACK_SLOT'] 
			REF_880(bool) -> TMP_2626.value
			CONDITION REF_880
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: slot = IERC1822Proxiable(newImplementation).proxiableUUID()
		IRs:
			TMP_2628 = CONVERT newImplementation to IERC1822Proxiable
			TMP_2629(bytes32) = HIGH_LEVEL_CALL, dest:TMP_2628(IERC1822Proxiable), function:proxiableUUID, arguments:[]  
			slot(bytes32) := TMP_2629(bytes32)
		Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)
		IRs:
			TMP_2630(bool) = slot == _IMPLEMENTATION_SLOT
			TMP_2631(None) = SOLIDITY_CALL require(bool,string)(TMP_2630,ERC1967Upgrade: unsupported proxiableUUID)
		Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		IRs:
			TMP_2632(None) = SOLIDITY_CALL revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		Expression: _upgradeToAndCall(newImplementation,data,forceCall)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,forceCall)
	Function ERC1967Upgrade._getAdmin() (*)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value
		IRs:
			TMP_2634(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_883(address) -> TMP_2634.value
			RETURN REF_883
	Function ERC1967Upgrade._setAdmin(address) (*)
		Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)
		IRs:
			TMP_2635 = CONVERT 0 to address
			TMP_2636(bool) = newAdmin != TMP_2635
			TMP_2637(None) = SOLIDITY_CALL require(bool,string)(TMP_2636,ERC1967: new admin is the zero address)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin
		IRs:
			TMP_2638(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_885(address) -> TMP_2638.value
			REF_885(address) (->TMP_2638) := newAdmin(address)
	Function ERC1967Upgrade._changeAdmin(address) (*)
		Expression: AdminChanged(_getAdmin(),newAdmin)
		IRs:
			TMP_2639(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			Emit AdminChanged(TMP_2639,newAdmin)
		Expression: _setAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setAdmin(address)(newAdmin)
	Function ERC1967Upgrade._getBeacon() (*)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value
		IRs:
			TMP_2642(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_887(address) -> TMP_2642.value
			RETURN REF_887
	Function ERC1967Upgrade._setBeacon(address) (*)
		Expression: require(bool,string)(Address.isContract(newBeacon),ERC1967: new beacon is not a contract)
		IRs:
			TMP_2643(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newBeacon'] 
			TMP_2644(None) = SOLIDITY_CALL require(bool,string)(TMP_2643,ERC1967: new beacon is not a contract)
		Expression: require(bool,string)(Address.isContract(IBeacon(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)
		IRs:
			TMP_2645 = CONVERT newBeacon to IBeacon
			TMP_2646(address) = HIGH_LEVEL_CALL, dest:TMP_2645(IBeacon), function:implementation, arguments:[]  
			TMP_2647(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['TMP_2646'] 
			TMP_2648(None) = SOLIDITY_CALL require(bool,string)(TMP_2647,ERC1967: beacon implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon
		IRs:
			TMP_2649(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_892(address) -> TMP_2649.value
			REF_892(address) (->TMP_2649) := newBeacon(address)
	Function ERC1967Upgrade._upgradeBeaconToAndCall(address,bytes,bool) (*)
		Expression: _setBeacon(newBeacon)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setBeacon(address)(newBeacon)
		Expression: BeaconUpgraded(newBeacon)
		IRs:
			Emit BeaconUpgraded(newBeacon)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_893 -> LENGTH data
			TMP_2652(bool) = REF_893 > 0
			TMP_2653(bool) = TMP_2652 || forceCall
			CONDITION TMP_2653
		Expression: Address.functionDelegateCall(IBeacon(newBeacon).implementation(),data)
		IRs:
			TMP_2654 = CONVERT newBeacon to IBeacon
			TMP_2655(address) = HIGH_LEVEL_CALL, dest:TMP_2654(IBeacon), function:implementation, arguments:[]  
			TMP_2656(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['TMP_2655', 'data'] 
	Function Proxy._delegate(address) (*)
		Expression: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()())
		IRs:
			TMP_2657(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2658(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(0,0,TMP_2657)
		Expression: result__delegate_asm_0 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),implementation,0,calldatasize()(),0,0)
		IRs:
			TMP_2659(uint256) = SOLIDITY_CALL gas()()
			TMP_2660(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2661(uint256) = SOLIDITY_CALL delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2659,implementation,0,TMP_2660,0,0)
			result__delegate_asm_0(uint256) := TMP_2661(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())
		IRs:
			TMP_2662(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2663(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_2662)
		Expression: switch_expr_1607_220_63__delegate_asm_0 = result__delegate_asm_0
		IRs:
			switch_expr_1607_220_63__delegate_asm_0(uint256) := result__delegate_asm_0(uint256)
		Expression: switch_expr_1607_220_63__delegate_asm_0 == 0
		IRs:
			TMP_2664(bool) = switch_expr_1607_220_63__delegate_asm_0 == 0
			CONDITION TMP_2664
		Expression: revert(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2665(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2666(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_2665)
		Expression: return(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2667(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2668(None) = SOLIDITY_CALL return(uint256,uint256)(0,TMP_2667)
	Function Proxy._implementation() 
	Function Proxy._fallback() (*)
		Expression: _beforeFallback()
		IRs:
			INTERNAL_CALL, Proxy._beforeFallback()()
		Expression: _delegate(_implementation())
		IRs:
			TMP_2670(address) = INTERNAL_CALL, ERC1967Proxy._implementation()()
			INTERNAL_CALL, Proxy._delegate(address)(TMP_2670)
	Function Proxy.fallback() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function Proxy.receive() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function Proxy._beforeFallback() (*)
	Function ERC1967Proxy.constructor(address,bytes) (*)
		Expression: _upgradeToAndCall(_logic,_data,false)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(_logic,_data,False)
	Function ERC1967Proxy._implementation() (*)
		Expression: ERC1967Upgrade._getImplementation()
		IRs:
			TMP_2675(address) = INTERNAL_CALL, ERC1967Upgrade._getImplementation()()
			RETURN TMP_2675
	Function ERC1967Proxy.slitherConstructorConstantVariables() (*)
		Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
		IRs:
			_IMPLEMENTATION_SLOT(bytes32) := 24440054405305269366569402256811496959409073762505157381672968839269610695612(uint256)
		Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
		IRs:
			_ADMIN_SLOT(bytes32) := 81955473079516046949633743016697847541294818689821282749996681496272635257091(uint256)
		Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50
		IRs:
			_BEACON_SLOT(bytes32) := 74152234768234802001998023604048924213078445070507226371336425913862612794704(uint256)
Contract ERC1967Upgrade
	Function ERC1967Upgrade._getImplementation() (*)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value
		IRs:
			TMP_2676(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_898(address) -> TMP_2676.value
			RETURN REF_898
	Function ERC1967Upgrade._setImplementation(address) (*)
		Expression: require(bool,string)(Address.isContract(newImplementation),ERC1967: new implementation is not a contract)
		IRs:
			TMP_2677(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newImplementation'] 
			TMP_2678(None) = SOLIDITY_CALL require(bool,string)(TMP_2677,ERC1967: new implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation
		IRs:
			TMP_2679(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_901(address) -> TMP_2679.value
			REF_901(address) (->TMP_2679) := newImplementation(address)
	Function ERC1967Upgrade._upgradeTo(address) (*)
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: Upgraded(newImplementation)
		IRs:
			Emit Upgraded(newImplementation)
	Function ERC1967Upgrade._upgradeToAndCall(address,bytes,bool) (*)
		Expression: _upgradeTo(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeTo(address)(newImplementation)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_902 -> LENGTH data
			TMP_2683(bool) = REF_902 > 0
			TMP_2684(bool) = TMP_2683 || forceCall
			CONDITION TMP_2684
		Expression: Address.functionDelegateCall(newImplementation,data)
		IRs:
			TMP_2685(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['newImplementation', 'data'] 
	Function ERC1967Upgrade._upgradeToAndCallUUPS(address,bytes,bool) (*)
		Expression: StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value
		IRs:
			TMP_2686(StorageSlot.BooleanSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getBooleanSlot(bytes32), arguments:['_ROLLBACK_SLOT'] 
			REF_905(bool) -> TMP_2686.value
			CONDITION REF_905
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: slot = IERC1822Proxiable(newImplementation).proxiableUUID()
		IRs:
			TMP_2688 = CONVERT newImplementation to IERC1822Proxiable
			TMP_2689(bytes32) = HIGH_LEVEL_CALL, dest:TMP_2688(IERC1822Proxiable), function:proxiableUUID, arguments:[]  
			slot(bytes32) := TMP_2689(bytes32)
		Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)
		IRs:
			TMP_2690(bool) = slot == _IMPLEMENTATION_SLOT
			TMP_2691(None) = SOLIDITY_CALL require(bool,string)(TMP_2690,ERC1967Upgrade: unsupported proxiableUUID)
		Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		IRs:
			TMP_2692(None) = SOLIDITY_CALL revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		Expression: _upgradeToAndCall(newImplementation,data,forceCall)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,forceCall)
	Function ERC1967Upgrade._getAdmin() (*)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value
		IRs:
			TMP_2694(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_908(address) -> TMP_2694.value
			RETURN REF_908
	Function ERC1967Upgrade._setAdmin(address) (*)
		Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)
		IRs:
			TMP_2695 = CONVERT 0 to address
			TMP_2696(bool) = newAdmin != TMP_2695
			TMP_2697(None) = SOLIDITY_CALL require(bool,string)(TMP_2696,ERC1967: new admin is the zero address)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin
		IRs:
			TMP_2698(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_910(address) -> TMP_2698.value
			REF_910(address) (->TMP_2698) := newAdmin(address)
	Function ERC1967Upgrade._changeAdmin(address) (*)
		Expression: AdminChanged(_getAdmin(),newAdmin)
		IRs:
			TMP_2699(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			Emit AdminChanged(TMP_2699,newAdmin)
		Expression: _setAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setAdmin(address)(newAdmin)
	Function ERC1967Upgrade._getBeacon() (*)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value
		IRs:
			TMP_2702(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_912(address) -> TMP_2702.value
			RETURN REF_912
	Function ERC1967Upgrade._setBeacon(address) (*)
		Expression: require(bool,string)(Address.isContract(newBeacon),ERC1967: new beacon is not a contract)
		IRs:
			TMP_2703(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newBeacon'] 
			TMP_2704(None) = SOLIDITY_CALL require(bool,string)(TMP_2703,ERC1967: new beacon is not a contract)
		Expression: require(bool,string)(Address.isContract(IBeacon(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)
		IRs:
			TMP_2705 = CONVERT newBeacon to IBeacon
			TMP_2706(address) = HIGH_LEVEL_CALL, dest:TMP_2705(IBeacon), function:implementation, arguments:[]  
			TMP_2707(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['TMP_2706'] 
			TMP_2708(None) = SOLIDITY_CALL require(bool,string)(TMP_2707,ERC1967: beacon implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon
		IRs:
			TMP_2709(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_917(address) -> TMP_2709.value
			REF_917(address) (->TMP_2709) := newBeacon(address)
	Function ERC1967Upgrade._upgradeBeaconToAndCall(address,bytes,bool) (*)
		Expression: _setBeacon(newBeacon)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setBeacon(address)(newBeacon)
		Expression: BeaconUpgraded(newBeacon)
		IRs:
			Emit BeaconUpgraded(newBeacon)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_918 -> LENGTH data
			TMP_2712(bool) = REF_918 > 0
			TMP_2713(bool) = TMP_2712 || forceCall
			CONDITION TMP_2713
		Expression: Address.functionDelegateCall(IBeacon(newBeacon).implementation(),data)
		IRs:
			TMP_2714 = CONVERT newBeacon to IBeacon
			TMP_2715(address) = HIGH_LEVEL_CALL, dest:TMP_2714(IBeacon), function:implementation, arguments:[]  
			TMP_2716(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['TMP_2715', 'data'] 
	Function ERC1967Upgrade.slitherConstructorConstantVariables() (*)
		Expression: _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143
		IRs:
			_ROLLBACK_SLOT(bytes32) := 33048860383849004559742813297059419343339852917517107368639918720169455489347(uint256)
		Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
		IRs:
			_IMPLEMENTATION_SLOT(bytes32) := 24440054405305269366569402256811496959409073762505157381672968839269610695612(uint256)
		Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
		IRs:
			_ADMIN_SLOT(bytes32) := 81955473079516046949633743016697847541294818689821282749996681496272635257091(uint256)
		Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50
		IRs:
			_BEACON_SLOT(bytes32) := 74152234768234802001998023604048924213078445070507226371336425913862612794704(uint256)
Contract Proxy
	Function Proxy._delegate(address) (*)
		Expression: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()())
		IRs:
			TMP_2717(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2718(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(0,0,TMP_2717)
		Expression: result__delegate_asm_0 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),implementation,0,calldatasize()(),0,0)
		IRs:
			TMP_2719(uint256) = SOLIDITY_CALL gas()()
			TMP_2720(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2721(uint256) = SOLIDITY_CALL delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2719,implementation,0,TMP_2720,0,0)
			result__delegate_asm_0(uint256) := TMP_2721(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())
		IRs:
			TMP_2722(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2723(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_2722)
		Expression: switch_expr_1607_220_63__delegate_asm_0 = result__delegate_asm_0
		IRs:
			switch_expr_1607_220_63__delegate_asm_0(uint256) := result__delegate_asm_0(uint256)
		Expression: switch_expr_1607_220_63__delegate_asm_0 == 0
		IRs:
			TMP_2724(bool) = switch_expr_1607_220_63__delegate_asm_0 == 0
			CONDITION TMP_2724
		Expression: revert(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2725(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2726(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_2725)
		Expression: return(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2727(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2728(None) = SOLIDITY_CALL return(uint256,uint256)(0,TMP_2727)
	Function Proxy._implementation() (*)
	Function Proxy._fallback() (*)
		Expression: _beforeFallback()
		IRs:
			INTERNAL_CALL, Proxy._beforeFallback()()
		Expression: _delegate(_implementation())
		IRs:
			TMP_2730(address) = INTERNAL_CALL, Proxy._implementation()()
			INTERNAL_CALL, Proxy._delegate(address)(TMP_2730)
	Function Proxy.fallback() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function Proxy.receive() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function Proxy._beforeFallback() (*)
Contract IBeacon
	Function IBeacon.implementation() (*)
Contract ProxyAdmin
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_2734(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2734)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_2736(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_2737(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_2738(bool) = TMP_2736 == TMP_2737
			TMP_2739(None) = SOLIDITY_CALL require(bool,string)(TMP_2738,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_2740 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_2740)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_2743 = CONVERT 0 to address
			TMP_2744(bool) = newOwner != TMP_2743
			TMP_2745(None) = SOLIDITY_CALL require(bool,string)(TMP_2744,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ProxyAdmin.getProxyImplementation(ITransparentUpgradeableProxy) (*)
		Expression: (success,returndata) = address(proxy).staticcall(0x5c60da1b)
		IRs:
			TMP_2749 = CONVERT proxy to address
			TUPLE_35(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_2749, function:staticcall, arguments:['0x5c60da1b']  
			success(bool)= UNPACK TUPLE_35 index: 0 
			returndata(bytes)= UNPACK TUPLE_35 index: 1 
		Expression: require(bool)(success)
		IRs:
			TMP_2750(None) = SOLIDITY_CALL require(bool)(success)
		Expression: abi.decode(returndata,(address))
		IRs:
			TMP_2751(address) = SOLIDITY_CALL abi.decode()(returndata,address)
			RETURN TMP_2751
	Function ProxyAdmin.getProxyAdmin(ITransparentUpgradeableProxy) (*)
		Expression: (success,returndata) = address(proxy).staticcall(0xf851a440)
		IRs:
			TMP_2752 = CONVERT proxy to address
			TUPLE_36(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_2752, function:staticcall, arguments:['0xf851a440']  
			success(bool)= UNPACK TUPLE_36 index: 0 
			returndata(bytes)= UNPACK TUPLE_36 index: 1 
		Expression: require(bool)(success)
		IRs:
			TMP_2753(None) = SOLIDITY_CALL require(bool)(success)
		Expression: abi.decode(returndata,(address))
		IRs:
			TMP_2754(address) = SOLIDITY_CALL abi.decode()(returndata,address)
			RETURN TMP_2754
	Function ProxyAdmin.changeProxyAdmin(ITransparentUpgradeableProxy,address) (*)
		Expression: proxy.changeAdmin(newAdmin)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:changeAdmin, arguments:['newAdmin']  
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function ProxyAdmin.upgrade(ITransparentUpgradeableProxy,address) (*)
		Expression: proxy.upgradeTo(implementation)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:upgradeTo, arguments:['implementation']  
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function ProxyAdmin.upgradeAndCall(ITransparentUpgradeableProxy,address,bytes) (*)
		Expression: proxy.upgradeToAndCall{value: msg.value}(implementation,data)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:upgradeToAndCall, arguments:['implementation', 'data'] value:msg.value 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract ITransparentUpgradeableProxy
	Function ITransparentUpgradeableProxy.admin() (*)
	Function ITransparentUpgradeableProxy.implementation() (*)
	Function ITransparentUpgradeableProxy.changeAdmin(address) (*)
	Function ITransparentUpgradeableProxy.upgradeTo(address) (*)
	Function ITransparentUpgradeableProxy.upgradeToAndCall(address,bytes) (*)
Contract TransparentUpgradeableProxy
	Function ERC1967Proxy.constructor(address,bytes) (*)
		Expression: _upgradeToAndCall(_logic,_data,false)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(_logic,_data,False)
	Function ERC1967Proxy._implementation() (*)
		Expression: ERC1967Upgrade._getImplementation()
		IRs:
			TMP_2763(address) = INTERNAL_CALL, ERC1967Upgrade._getImplementation()()
			RETURN TMP_2763
	Function ERC1967Upgrade._getImplementation() (*)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value
		IRs:
			TMP_2764(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_930(address) -> TMP_2764.value
			RETURN REF_930
	Function ERC1967Upgrade._setImplementation(address) (*)
		Expression: require(bool,string)(Address.isContract(newImplementation),ERC1967: new implementation is not a contract)
		IRs:
			TMP_2765(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newImplementation'] 
			TMP_2766(None) = SOLIDITY_CALL require(bool,string)(TMP_2765,ERC1967: new implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation
		IRs:
			TMP_2767(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_933(address) -> TMP_2767.value
			REF_933(address) (->TMP_2767) := newImplementation(address)
	Function ERC1967Upgrade._upgradeTo(address) (*)
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: Upgraded(newImplementation)
		IRs:
			Emit Upgraded(newImplementation)
	Function ERC1967Upgrade._upgradeToAndCall(address,bytes,bool) (*)
		Expression: _upgradeTo(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeTo(address)(newImplementation)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_934 -> LENGTH data
			TMP_2771(bool) = REF_934 > 0
			TMP_2772(bool) = TMP_2771 || forceCall
			CONDITION TMP_2772
		Expression: Address.functionDelegateCall(newImplementation,data)
		IRs:
			TMP_2773(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['newImplementation', 'data'] 
	Function ERC1967Upgrade._upgradeToAndCallUUPS(address,bytes,bool) (*)
		Expression: StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value
		IRs:
			TMP_2774(StorageSlot.BooleanSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getBooleanSlot(bytes32), arguments:['_ROLLBACK_SLOT'] 
			REF_937(bool) -> TMP_2774.value
			CONDITION REF_937
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: slot = IERC1822Proxiable(newImplementation).proxiableUUID()
		IRs:
			TMP_2776 = CONVERT newImplementation to IERC1822Proxiable
			TMP_2777(bytes32) = HIGH_LEVEL_CALL, dest:TMP_2776(IERC1822Proxiable), function:proxiableUUID, arguments:[]  
			slot(bytes32) := TMP_2777(bytes32)
		Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)
		IRs:
			TMP_2778(bool) = slot == _IMPLEMENTATION_SLOT
			TMP_2779(None) = SOLIDITY_CALL require(bool,string)(TMP_2778,ERC1967Upgrade: unsupported proxiableUUID)
		Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		IRs:
			TMP_2780(None) = SOLIDITY_CALL revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		Expression: _upgradeToAndCall(newImplementation,data,forceCall)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,forceCall)
	Function ERC1967Upgrade._getAdmin() (*)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value
		IRs:
			TMP_2782(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_940(address) -> TMP_2782.value
			RETURN REF_940
	Function ERC1967Upgrade._setAdmin(address) (*)
		Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)
		IRs:
			TMP_2783 = CONVERT 0 to address
			TMP_2784(bool) = newAdmin != TMP_2783
			TMP_2785(None) = SOLIDITY_CALL require(bool,string)(TMP_2784,ERC1967: new admin is the zero address)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin
		IRs:
			TMP_2786(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_942(address) -> TMP_2786.value
			REF_942(address) (->TMP_2786) := newAdmin(address)
	Function ERC1967Upgrade._changeAdmin(address) (*)
		Expression: AdminChanged(_getAdmin(),newAdmin)
		IRs:
			TMP_2787(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			Emit AdminChanged(TMP_2787,newAdmin)
		Expression: _setAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setAdmin(address)(newAdmin)
	Function ERC1967Upgrade._getBeacon() (*)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value
		IRs:
			TMP_2790(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_944(address) -> TMP_2790.value
			RETURN REF_944
	Function ERC1967Upgrade._setBeacon(address) (*)
		Expression: require(bool,string)(Address.isContract(newBeacon),ERC1967: new beacon is not a contract)
		IRs:
			TMP_2791(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newBeacon'] 
			TMP_2792(None) = SOLIDITY_CALL require(bool,string)(TMP_2791,ERC1967: new beacon is not a contract)
		Expression: require(bool,string)(Address.isContract(IBeacon(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)
		IRs:
			TMP_2793 = CONVERT newBeacon to IBeacon
			TMP_2794(address) = HIGH_LEVEL_CALL, dest:TMP_2793(IBeacon), function:implementation, arguments:[]  
			TMP_2795(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['TMP_2794'] 
			TMP_2796(None) = SOLIDITY_CALL require(bool,string)(TMP_2795,ERC1967: beacon implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon
		IRs:
			TMP_2797(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_949(address) -> TMP_2797.value
			REF_949(address) (->TMP_2797) := newBeacon(address)
	Function ERC1967Upgrade._upgradeBeaconToAndCall(address,bytes,bool) (*)
		Expression: _setBeacon(newBeacon)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setBeacon(address)(newBeacon)
		Expression: BeaconUpgraded(newBeacon)
		IRs:
			Emit BeaconUpgraded(newBeacon)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_950 -> LENGTH data
			TMP_2800(bool) = REF_950 > 0
			TMP_2801(bool) = TMP_2800 || forceCall
			CONDITION TMP_2801
		Expression: Address.functionDelegateCall(IBeacon(newBeacon).implementation(),data)
		IRs:
			TMP_2802 = CONVERT newBeacon to IBeacon
			TMP_2803(address) = HIGH_LEVEL_CALL, dest:TMP_2802(IBeacon), function:implementation, arguments:[]  
			TMP_2804(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['TMP_2803', 'data'] 
	Function Proxy._delegate(address) (*)
		Expression: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()())
		IRs:
			TMP_2805(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2806(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(0,0,TMP_2805)
		Expression: result__delegate_asm_0 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),implementation,0,calldatasize()(),0,0)
		IRs:
			TMP_2807(uint256) = SOLIDITY_CALL gas()()
			TMP_2808(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_2809(uint256) = SOLIDITY_CALL delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_2807,implementation,0,TMP_2808,0,0)
			result__delegate_asm_0(uint256) := TMP_2809(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())
		IRs:
			TMP_2810(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2811(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_2810)
		Expression: switch_expr_1607_220_63__delegate_asm_0 = result__delegate_asm_0
		IRs:
			switch_expr_1607_220_63__delegate_asm_0(uint256) := result__delegate_asm_0(uint256)
		Expression: switch_expr_1607_220_63__delegate_asm_0 == 0
		IRs:
			TMP_2812(bool) = switch_expr_1607_220_63__delegate_asm_0 == 0
			CONDITION TMP_2812
		Expression: revert(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2813(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2814(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_2813)
		Expression: return(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_2815(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_2816(None) = SOLIDITY_CALL return(uint256,uint256)(0,TMP_2815)
	Function Proxy._implementation() 
	Function Proxy._fallback() 
		Expression: _beforeFallback()
		IRs:
			INTERNAL_CALL, Proxy._beforeFallback()()
		Expression: _delegate(_implementation())
		IRs:
			TMP_2818(address) = INTERNAL_CALL, ERC1967Proxy._implementation()()
			INTERNAL_CALL, Proxy._delegate(address)(TMP_2818)
	Function Proxy.fallback() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
	Function Proxy.receive() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
	Function Proxy._beforeFallback() (*)
	Function TransparentUpgradeableProxy.constructor(address,address,bytes) (*)
		Expression: _changeAdmin(admin_)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._changeAdmin(address)(admin_)
		Expression: ERC1967Proxy(_logic,_data)
		IRs:
			INTERNAL_CALL, ERC1967Proxy.constructor(address,bytes)(_logic,_data)
	Function TransparentUpgradeableProxy._fallback() (*)
		Expression: msg.sender == _getAdmin()
		IRs:
			TMP_2824(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			TMP_2825(bool) = msg.sender == TMP_2824
			CONDITION TMP_2825
		Expression: selector = msg.sig
		IRs:
			selector(bytes4) := msg.sig(bytes4)
		Expression: selector == ITransparentUpgradeableProxy.upgradeTo.selector
		IRs:
			REF_954(bytes4) (->None) := 911855590(uint256)
			TMP_2826(bool) = selector == REF_954
			CONDITION TMP_2826
		Expression: ret = _dispatchUpgradeTo()
		IRs:
			TMP_2827(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchUpgradeTo()()
			ret(bytes) := TMP_2827(bytes)
		Expression: selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector
		IRs:
			REF_956(bytes4) (->None) := 1327428230(uint256)
			TMP_2828(bool) = selector == REF_956
			CONDITION TMP_2828
		Expression: ret = _dispatchUpgradeToAndCall()
		IRs:
			TMP_2829(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchUpgradeToAndCall()()
			ret(bytes) := TMP_2829(bytes)
		Expression: selector == ITransparentUpgradeableProxy.changeAdmin.selector
		IRs:
			REF_958(bytes4) (->None) := 2401778032(uint256)
			TMP_2830(bool) = selector == REF_958
			CONDITION TMP_2830
		Expression: ret = _dispatchChangeAdmin()
		IRs:
			TMP_2831(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchChangeAdmin()()
			ret(bytes) := TMP_2831(bytes)
		Expression: selector == ITransparentUpgradeableProxy.admin.selector
		IRs:
			REF_960(bytes4) (->None) := 4166100032(uint256)
			TMP_2832(bool) = selector == REF_960
			CONDITION TMP_2832
		Expression: ret = _dispatchAdmin()
		IRs:
			TMP_2833(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchAdmin()()
			ret(bytes) := TMP_2833(bytes)
		Expression: selector == ITransparentUpgradeableProxy.implementation.selector
		IRs:
			REF_962(bytes4) (->None) := 1549851163(uint256)
			TMP_2834(bool) = selector == REF_962
			CONDITION TMP_2834
		Expression: ret = _dispatchImplementation()
		IRs:
			TMP_2835(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchImplementation()()
			ret(bytes) := TMP_2835(bytes)
		Expression: revert(string)(TransparentUpgradeableProxy: admin cannot fallback to proxy target)
		IRs:
			TMP_2836(None) = SOLIDITY_CALL revert(string)(TransparentUpgradeableProxy: admin cannot fallback to proxy target)
		Expression: return(uint256,uint256)(ret + 0x20,mload(uint256)(ret))
		IRs:
			TMP_2837(bytes) = ret + 32
			TMP_2838(uint256) = SOLIDITY_CALL mload(uint256)(ret)
			TMP_2839(None) = SOLIDITY_CALL return(uint256,uint256)(TMP_2837,TMP_2838)
		Expression: super._fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function TransparentUpgradeableProxy._dispatchAdmin() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: admin = _getAdmin()
		IRs:
			TMP_2842(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			admin(address) := TMP_2842(address)
		Expression: abi.encode(admin)
		IRs:
			TMP_2843(bytes) = SOLIDITY_CALL abi.encode()(admin)
			RETURN TMP_2843
	Function TransparentUpgradeableProxy._dispatchImplementation() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: implementation = _implementation()
		IRs:
			TMP_2845(address) = INTERNAL_CALL, ERC1967Proxy._implementation()()
			implementation(address) := TMP_2845(address)
		Expression: abi.encode(implementation)
		IRs:
			TMP_2846(bytes) = SOLIDITY_CALL abi.encode()(implementation)
			RETURN TMP_2846
	Function TransparentUpgradeableProxy._dispatchChangeAdmin() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: newAdmin = abi.decode(msg.data,(address))
		IRs:
			TMP_2848(address) = SOLIDITY_CALL abi.decode()(msg.data,address)
			newAdmin(address) := TMP_2848(address)
		Expression: _changeAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._changeAdmin(address)(newAdmin)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._dispatchUpgradeTo() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: newImplementation = abi.decode(msg.data,(address))
		IRs:
			TMP_2851(address) = SOLIDITY_CALL abi.decode()(msg.data,address)
			newImplementation(address) := TMP_2851(address)
		Expression: _upgradeToAndCall(newImplementation,bytes(),false)
		IRs:
			TMP_2852 = CONVERT  to bytes
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,TMP_2852,False)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._dispatchUpgradeToAndCall() (*)
		Expression: (newImplementation,data) = abi.decode(msg.data,(address,bytes))
		IRs:
			TUPLE_37(address,bytes) = SOLIDITY_CALL abi.decode()(msg.data(address,bytes))
			newImplementation(address)= UNPACK TUPLE_37 index: 0 
			data(bytes)= UNPACK TUPLE_37 index: 1 
		Expression: _upgradeToAndCall(newImplementation,data,true)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,True)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._admin() (*)
		Expression: _getAdmin()
		IRs:
			TMP_2855(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			RETURN TMP_2855
	Function TransparentUpgradeableProxy._requireZeroValue() (*)
		Expression: require(bool)(msg.value == 0)
		IRs:
			TMP_2856(bool) = msg.value == 0
			TMP_2857(None) = SOLIDITY_CALL require(bool)(TMP_2856)
	Function TransparentUpgradeableProxy.slitherConstructorConstantVariables() (*)
		Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
		IRs:
			_IMPLEMENTATION_SLOT(bytes32) := 24440054405305269366569402256811496959409073762505157381672968839269610695612(uint256)
		Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
		IRs:
			_ADMIN_SLOT(bytes32) := 81955473079516046949633743016697847541294818689821282749996681496272635257091(uint256)
		Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50
		IRs:
			_BEACON_SLOT(bytes32) := 74152234768234802001998023604048924213078445070507226371336425913862612794704(uint256)
	Modifier TransparentUpgradeableProxy.ifAdmin()
		Expression: msg.sender == _getAdmin()
		IRs:
			TMP_2858(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			TMP_2859(bool) = msg.sender == TMP_2858
			CONDITION TMP_2859
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
Contract ReentrancyGuard
	Function ReentrancyGuard.constructor() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_2861(bool) = _status != _ENTERED
			TMP_2862(None) = SOLIDITY_CALL require(bool,string)(TMP_2861,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_2863(bool) = _status == _ENTERED
			RETURN TMP_2863
	Function ReentrancyGuard.slitherConstructorConstantVariables() (*)
		Expression: _NOT_ENTERED = 1
		IRs:
			_NOT_ENTERED(uint256) := 1(uint256)
		Expression: _ENTERED = 2
		IRs:
			_ENTERED(uint256) := 2(uint256)
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract IERC1155Receiver
	Function IERC165.supportsInterface(bytes4) (*)
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) (*)
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
Contract ERC20
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_968(uint256) -> _balances[account]
			RETURN REF_968
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2866(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2866(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_969(mapping(address => uint256)) -> _allowances[owner]
			REF_970(uint256) -> REF_969[spender]
			RETURN REF_970
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2868(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2868(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_2870(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_2870(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2873(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2873(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2874(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_2875(uint256) = TMP_2874 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2875)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2877(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2877(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2878(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_2878(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2879(bool) = currentAllowance >= subtractedValue
			TMP_2880(None) = SOLIDITY_CALL require(bool,string)(TMP_2879,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2881(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2881)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2883 = CONVERT 0 to address
			TMP_2884(bool) = from != TMP_2883
			TMP_2885(None) = SOLIDITY_CALL require(bool,string)(TMP_2884,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2886 = CONVERT 0 to address
			TMP_2887(bool) = to != TMP_2886
			TMP_2888(None) = SOLIDITY_CALL require(bool,string)(TMP_2887,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_971(uint256) -> _balances[from]
			fromBalance(uint256) := REF_971(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2890(bool) = fromBalance >= amount
			TMP_2891(None) = SOLIDITY_CALL require(bool,string)(TMP_2890,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_972(uint256) -> _balances[from]
			TMP_2892(uint256) = fromBalance - amount
			REF_972(uint256) (->_balances) := TMP_2892(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_973(uint256) -> _balances[to]
			REF_973(-> _balances) = REF_973 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2895 = CONVERT 0 to address
			TMP_2896(bool) = account != TMP_2895
			TMP_2897(None) = SOLIDITY_CALL require(bool,string)(TMP_2896,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2898 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2898,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_974(uint256) -> _balances[account]
			REF_974(-> _balances) = REF_974 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2900 = CONVERT 0 to address
			Emit Transfer(TMP_2900,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2902 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2902,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2904 = CONVERT 0 to address
			TMP_2905(bool) = account != TMP_2904
			TMP_2906(None) = SOLIDITY_CALL require(bool,string)(TMP_2905,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2907 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_2907,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_975(uint256) -> _balances[account]
			accountBalance(uint256) := REF_975(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2909(bool) = accountBalance >= amount
			TMP_2910(None) = SOLIDITY_CALL require(bool,string)(TMP_2909,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_976(uint256) -> _balances[account]
			TMP_2911(uint256) = accountBalance - amount
			REF_976(uint256) (->_balances) := TMP_2911(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2912 = CONVERT 0 to address
			Emit Transfer(account,TMP_2912,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2914 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_2914,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2916 = CONVERT 0 to address
			TMP_2917(bool) = owner != TMP_2916
			TMP_2918(None) = SOLIDITY_CALL require(bool,string)(TMP_2917,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2919 = CONVERT 0 to address
			TMP_2920(bool) = spender != TMP_2919
			TMP_2921(None) = SOLIDITY_CALL require(bool,string)(TMP_2920,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_977(mapping(address => uint256)) -> _allowances[owner]
			REF_978(uint256) -> REF_977[spender]
			REF_978(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2923(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_2923(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2925(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2926(bool) = currentAllowance != TMP_2925
			CONDITION TMP_2926
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2927(bool) = currentAllowance >= amount
			TMP_2928(None) = SOLIDITY_CALL require(bool,string)(TMP_2927,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2929(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2929)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
Contract IERC20
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) (*)
	Function IERC20.transfer(address,uint256) (*)
	Function IERC20.allowance(address,address) (*)
	Function IERC20.approve(address,uint256) (*)
	Function IERC20.transferFrom(address,address,uint256) (*)
Contract ERC20Burnable
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_979(uint256) -> _balances[account]
			RETURN REF_979
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2931(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2931(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_980(mapping(address => uint256)) -> _allowances[owner]
			REF_981(uint256) -> REF_980[spender]
			RETURN REF_981
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2933(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2933(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_2935(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_2935(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2938(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2938(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_2939(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_2940(uint256) = TMP_2939 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2940)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_2942(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_2942(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2943(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_2943(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_2944(bool) = currentAllowance >= subtractedValue
			TMP_2945(None) = SOLIDITY_CALL require(bool,string)(TMP_2944,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_2946(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2946)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_2948 = CONVERT 0 to address
			TMP_2949(bool) = from != TMP_2948
			TMP_2950(None) = SOLIDITY_CALL require(bool,string)(TMP_2949,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_2951 = CONVERT 0 to address
			TMP_2952(bool) = to != TMP_2951
			TMP_2953(None) = SOLIDITY_CALL require(bool,string)(TMP_2952,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_982(uint256) -> _balances[from]
			fromBalance(uint256) := REF_982(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_2955(bool) = fromBalance >= amount
			TMP_2956(None) = SOLIDITY_CALL require(bool,string)(TMP_2955,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_983(uint256) -> _balances[from]
			TMP_2957(uint256) = fromBalance - amount
			REF_983(uint256) (->_balances) := TMP_2957(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_984(uint256) -> _balances[to]
			REF_984(-> _balances) = REF_984 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_2960 = CONVERT 0 to address
			TMP_2961(bool) = account != TMP_2960
			TMP_2962(None) = SOLIDITY_CALL require(bool,string)(TMP_2961,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2963 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_2963,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_985(uint256) -> _balances[account]
			REF_985(-> _balances) = REF_985 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_2965 = CONVERT 0 to address
			Emit Transfer(TMP_2965,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_2967 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_2967,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_2969 = CONVERT 0 to address
			TMP_2970(bool) = account != TMP_2969
			TMP_2971(None) = SOLIDITY_CALL require(bool,string)(TMP_2970,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2972 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_2972,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_986(uint256) -> _balances[account]
			accountBalance(uint256) := REF_986(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_2974(bool) = accountBalance >= amount
			TMP_2975(None) = SOLIDITY_CALL require(bool,string)(TMP_2974,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_987(uint256) -> _balances[account]
			TMP_2976(uint256) = accountBalance - amount
			REF_987(uint256) (->_balances) := TMP_2976(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_2977 = CONVERT 0 to address
			Emit Transfer(account,TMP_2977,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_2979 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_2979,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_2981 = CONVERT 0 to address
			TMP_2982(bool) = owner != TMP_2981
			TMP_2983(None) = SOLIDITY_CALL require(bool,string)(TMP_2982,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_2984 = CONVERT 0 to address
			TMP_2985(bool) = spender != TMP_2984
			TMP_2986(None) = SOLIDITY_CALL require(bool,string)(TMP_2985,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_988(mapping(address => uint256)) -> _allowances[owner]
			REF_989(uint256) -> REF_988[spender]
			REF_989(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_2988(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_2988(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_2990(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_2991(bool) = currentAllowance != TMP_2990
			CONDITION TMP_2991
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_2992(bool) = currentAllowance >= amount
			TMP_2993(None) = SOLIDITY_CALL require(bool,string)(TMP_2992,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_2994(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_2994)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20Burnable.burn(uint256) (*)
		Expression: _burn(_msgSender(),amount)
		IRs:
			TMP_2996(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20._burn(address,uint256)(TMP_2996,amount)
	Function ERC20Burnable.burnFrom(address,uint256) (*)
		Expression: _spendAllowance(account,_msgSender(),amount)
		IRs:
			TMP_2998(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(account,TMP_2998,amount)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account,amount)
Contract ERC20Permit
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_3001(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_3001(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_3002(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_3002(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_3003 = CONVERT name to bytes
			TMP_3004(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3003)
			_hashedName(bytes32) := TMP_3004(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_3005 = CONVERT version to bytes
			TMP_3006(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3005)
			_hashedVersion(bytes32) := TMP_3006(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_3007(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_3007(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_3008 = CONVERT this to address
			_cachedThis(address) := TMP_3008(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_3009 = CONVERT this to address
			TMP_3010(bool) = TMP_3009 == _cachedThis
			TMP_3011(bool) = block.chainid == _cachedChainId
			TMP_3012(bool) = TMP_3010 && TMP_3011
			CONDITION TMP_3012
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_3013(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_3013
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_3014 = CONVERT this to address
			TMP_3015(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_3014)
			TMP_3016(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3015)
			RETURN TMP_3016
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_3017(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_3018(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_3017', 'structHash'] 
			RETURN TMP_3018
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_3019(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_3020(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_3021 = CONVERT this to address
			TMP_3022 = CONVERT 0 to bytes32
			TMP_3024(uint256[])  = new uint256[](0)
			RETURN ,TMP_3019,TMP_3020,block.chainid,TMP_3021,TMP_3022,TMP_3024
	Function IERC5267.eip712Domain() 
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20Permit.nonces(address) 
	Function IERC20Permit.DOMAIN_SEPARATOR() 
	Function ERC20.constructor(string,string) 
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_996(uint256) -> _balances[account]
			RETURN REF_996
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3025(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3025(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_997(mapping(address => uint256)) -> _allowances[owner]
			REF_998(uint256) -> REF_997[spender]
			RETURN REF_998
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3027(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3027(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_3029(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_3029(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3032(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3032(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_3033(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_3034(uint256) = TMP_3033 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3034)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3036(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3036(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3037(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_3037(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_3038(bool) = currentAllowance >= subtractedValue
			TMP_3039(None) = SOLIDITY_CALL require(bool,string)(TMP_3038,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_3040(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3040)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_3042 = CONVERT 0 to address
			TMP_3043(bool) = from != TMP_3042
			TMP_3044(None) = SOLIDITY_CALL require(bool,string)(TMP_3043,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_3045 = CONVERT 0 to address
			TMP_3046(bool) = to != TMP_3045
			TMP_3047(None) = SOLIDITY_CALL require(bool,string)(TMP_3046,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_999(uint256) -> _balances[from]
			fromBalance(uint256) := REF_999(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_3049(bool) = fromBalance >= amount
			TMP_3050(None) = SOLIDITY_CALL require(bool,string)(TMP_3049,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1000(uint256) -> _balances[from]
			TMP_3051(uint256) = fromBalance - amount
			REF_1000(uint256) (->_balances) := TMP_3051(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1001(uint256) -> _balances[to]
			REF_1001(-> _balances) = REF_1001 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_3054 = CONVERT 0 to address
			TMP_3055(bool) = account != TMP_3054
			TMP_3056(None) = SOLIDITY_CALL require(bool,string)(TMP_3055,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3057 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_3057,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_1002(uint256) -> _balances[account]
			REF_1002(-> _balances) = REF_1002 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_3059 = CONVERT 0 to address
			Emit Transfer(TMP_3059,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3061 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_3061,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_3063 = CONVERT 0 to address
			TMP_3064(bool) = account != TMP_3063
			TMP_3065(None) = SOLIDITY_CALL require(bool,string)(TMP_3064,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3066 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_3066,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1003(uint256) -> _balances[account]
			accountBalance(uint256) := REF_1003(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_3068(bool) = accountBalance >= amount
			TMP_3069(None) = SOLIDITY_CALL require(bool,string)(TMP_3068,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1004(uint256) -> _balances[account]
			TMP_3070(uint256) = accountBalance - amount
			REF_1004(uint256) (->_balances) := TMP_3070(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_3071 = CONVERT 0 to address
			Emit Transfer(account,TMP_3071,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3073 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_3073,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_3075 = CONVERT 0 to address
			TMP_3076(bool) = owner != TMP_3075
			TMP_3077(None) = SOLIDITY_CALL require(bool,string)(TMP_3076,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_3078 = CONVERT 0 to address
			TMP_3079(bool) = spender != TMP_3078
			TMP_3080(None) = SOLIDITY_CALL require(bool,string)(TMP_3079,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1005(mapping(address => uint256)) -> _allowances[owner]
			REF_1006(uint256) -> REF_1005[spender]
			REF_1006(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3082(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_3082(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_3084(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_3085(bool) = currentAllowance != TMP_3084
			CONDITION TMP_3085
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_3086(bool) = currentAllowance >= amount
			TMP_3087(None) = SOLIDITY_CALL require(bool,string)(TMP_3086,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_3088(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3088)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20Permit.constructor(string) (*)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_3091(bool) = block.timestamp <= deadline
			TMP_3092(None) = SOLIDITY_CALL require(bool,string)(TMP_3091,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_3093(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner)
			TMP_3094(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_3093,deadline)
			TMP_3095(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3094)
			structHash(bytes32) := TMP_3095(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_3096(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_3096(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_3097(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_3097(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_3098(bool) = signer == owner
			TMP_3099(None) = SOLIDITY_CALL require(bool,string)(TMP_3098,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,value)
	Function ERC20Permit.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_1009(Counters.Counter) -> _nonces[owner]
			TMP_3101(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_1009'] 
			RETURN TMP_3101
	Function ERC20Permit.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_3102(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_3102
	Function ERC20Permit._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_1011(Counters.Counter) -> _nonces[owner]
			nonce(Counters.Counter) := REF_1011(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_3103(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['nonce'] 
			current(uint256) := TMP_3103(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:['nonce'] 
	Function ERC20Permit.slitherConstructorConstantVariables() (*)
		Expression: _PERMIT_TYPEHASH = keccak256(bytes)(Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline))
		IRs:
			TMP_3105(bytes32) = SOLIDITY_CALL keccak256(bytes)(Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline))
			_PERMIT_TYPEHASH(bytes32) := TMP_3105(bytes32)
Contract ERC20Votes
	Function IVotes.getVotes(address) 
	Function IVotes.getPastVotes(address,uint256) 
	Function IVotes.getPastTotalSupply(uint256) 
	Function IVotes.delegates(address) 
	Function IVotes.delegate(address) 
	Function IVotes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function ERC20Permit.constructor(string) (*)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_3107(bool) = block.timestamp <= deadline
			TMP_3108(None) = SOLIDITY_CALL require(bool,string)(TMP_3107,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_3109(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner)
			TMP_3110(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_3109,deadline)
			TMP_3111(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3110)
			structHash(bytes32) := TMP_3111(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_3112(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_3112(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_3113(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_3113(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_3114(bool) = signer == owner
			TMP_3115(None) = SOLIDITY_CALL require(bool,string)(TMP_3114,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,value)
	Function ERC20Permit.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_1016(Counters.Counter) -> _nonces[owner]
			TMP_3117(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_1016'] 
			RETURN TMP_3117
	Function ERC20Permit.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_3118(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_3118
	Function ERC20Permit._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_1018(Counters.Counter) -> _nonces[owner]
			nonce(Counters.Counter) := REF_1018(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_3119(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['nonce'] 
			current(uint256) := TMP_3119(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:['nonce'] 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_3121(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_3121(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_3122(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_3122(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_3123 = CONVERT name to bytes
			TMP_3124(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3123)
			_hashedName(bytes32) := TMP_3124(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_3125 = CONVERT version to bytes
			TMP_3126(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3125)
			_hashedVersion(bytes32) := TMP_3126(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_3127(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_3127(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_3128 = CONVERT this to address
			_cachedThis(address) := TMP_3128(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_3129 = CONVERT this to address
			TMP_3130(bool) = TMP_3129 == _cachedThis
			TMP_3131(bool) = block.chainid == _cachedChainId
			TMP_3132(bool) = TMP_3130 && TMP_3131
			CONDITION TMP_3132
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_3133(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_3133
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_3134 = CONVERT this to address
			TMP_3135(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_3134)
			TMP_3136(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3135)
			RETURN TMP_3136
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_3137(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_3138(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_3137', 'structHash'] 
			RETURN TMP_3138
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_3139(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_3140(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_3141 = CONVERT this to address
			TMP_3142 = CONVERT 0 to bytes32
			TMP_3144(uint256[])  = new uint256[](0)
			RETURN ,TMP_3139,TMP_3140,block.chainid,TMP_3141,TMP_3142,TMP_3144
	Function IERC5267.eip712Domain() 
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20Permit.nonces(address) 
	Function IERC20Permit.DOMAIN_SEPARATOR() 
	Function ERC20.constructor(string,string) 
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_1027(uint256) -> _balances[account]
			RETURN REF_1027
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3145(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3145(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_1028(mapping(address => uint256)) -> _allowances[owner]
			REF_1029(uint256) -> REF_1028[spender]
			RETURN REF_1029
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3147(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3147(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_3149(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_3149(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3152(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3152(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_3153(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_3154(uint256) = TMP_3153 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3154)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_3156(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_3156(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3157(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_3157(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_3158(bool) = currentAllowance >= subtractedValue
			TMP_3159(None) = SOLIDITY_CALL require(bool,string)(TMP_3158,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_3160(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3160)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_3162 = CONVERT 0 to address
			TMP_3163(bool) = from != TMP_3162
			TMP_3164(None) = SOLIDITY_CALL require(bool,string)(TMP_3163,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_3165 = CONVERT 0 to address
			TMP_3166(bool) = to != TMP_3165
			TMP_3167(None) = SOLIDITY_CALL require(bool,string)(TMP_3166,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1030(uint256) -> _balances[from]
			fromBalance(uint256) := REF_1030(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_3169(bool) = fromBalance >= amount
			TMP_3170(None) = SOLIDITY_CALL require(bool,string)(TMP_3169,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1031(uint256) -> _balances[from]
			TMP_3171(uint256) = fromBalance - amount
			REF_1031(uint256) (->_balances) := TMP_3171(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1032(uint256) -> _balances[to]
			REF_1032(-> _balances) = REF_1032 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Votes._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) 
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_3174 = CONVERT 0 to address
			TMP_3175(bool) = account != TMP_3174
			TMP_3176(None) = SOLIDITY_CALL require(bool,string)(TMP_3175,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3177 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_3177,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_1033(uint256) -> _balances[account]
			REF_1033(-> _balances) = REF_1033 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_3179 = CONVERT 0 to address
			Emit Transfer(TMP_3179,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_3181 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Votes._afterTokenTransfer(address,address,uint256)(TMP_3181,account,amount)
	Function ERC20._burn(address,uint256) 
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_3183 = CONVERT 0 to address
			TMP_3184(bool) = account != TMP_3183
			TMP_3185(None) = SOLIDITY_CALL require(bool,string)(TMP_3184,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3186 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_3186,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1034(uint256) -> _balances[account]
			accountBalance(uint256) := REF_1034(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_3188(bool) = accountBalance >= amount
			TMP_3189(None) = SOLIDITY_CALL require(bool,string)(TMP_3188,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1035(uint256) -> _balances[account]
			TMP_3190(uint256) = accountBalance - amount
			REF_1035(uint256) (->_balances) := TMP_3190(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_3191 = CONVERT 0 to address
			Emit Transfer(account,TMP_3191,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_3193 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Votes._afterTokenTransfer(address,address,uint256)(account,TMP_3193,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_3195 = CONVERT 0 to address
			TMP_3196(bool) = owner != TMP_3195
			TMP_3197(None) = SOLIDITY_CALL require(bool,string)(TMP_3196,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_3198 = CONVERT 0 to address
			TMP_3199(bool) = spender != TMP_3198
			TMP_3200(None) = SOLIDITY_CALL require(bool,string)(TMP_3199,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1036(mapping(address => uint256)) -> _allowances[owner]
			REF_1037(uint256) -> REF_1036[spender]
			REF_1037(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_3202(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_3202(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_3204(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_3205(bool) = currentAllowance != TMP_3204
			CONDITION TMP_3205
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_3206(bool) = currentAllowance >= amount
			TMP_3207(None) = SOLIDITY_CALL require(bool,string)(TMP_3206,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_3208(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_3208)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) 
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20Votes.clock() (*)
		Expression: SafeCast.toUint48(block.number)
		IRs:
			TMP_3210(uint48) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint48(uint256), arguments:['block.number'] 
			RETURN TMP_3210
	Function ERC20Votes.CLOCK_MODE() (*)
		Expression: require(bool,string)(clock() == block.number,ERC20Votes: broken clock mode)
		IRs:
			TMP_3211(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_3212(bool) = TMP_3211 == block.number
			TMP_3213(None) = SOLIDITY_CALL require(bool,string)(TMP_3212,ERC20Votes: broken clock mode)
		Expression: mode=blocknumber&from=default
		IRs:
			RETURN mode=blocknumber&from=default
	Function ERC20Votes.checkpoints(address,uint32) (*)
		Expression: _checkpoints[account][pos]
		IRs:
			REF_1039(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1040(ERC20Votes.Checkpoint) -> REF_1039[pos]
			RETURN REF_1040
	Function ERC20Votes.numCheckpoints(address) (*)
		Expression: SafeCast.toUint32(_checkpoints[account].length)
		IRs:
			REF_1042(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1043 -> LENGTH REF_1042
			TMP_3214(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['REF_1043'] 
			RETURN TMP_3214
	Function ERC20Votes.delegates(address) (*)
		Expression: _delegates[account]
		IRs:
			REF_1044(address) -> _delegates[account]
			RETURN REF_1044
	Function ERC20Votes.getVotes(address) (*)
		Expression: pos = _checkpoints[account].length
		IRs:
			REF_1045(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1046 -> LENGTH REF_1045
			pos(uint256) := REF_1046(uint256)
		Expression: pos == 0
		IRs:
			TMP_3215(bool) = pos == 0
			CONDITION TMP_3215
		Expression: 0
		IRs:
			RETURN 0
		Expression: _checkpoints[account][pos - 1].votes
		IRs:
			REF_1047(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			TMP_3216(uint256) = pos - 1
			REF_1048(ERC20Votes.Checkpoint) -> REF_1047[TMP_3216]
			REF_1049(uint224) -> REF_1048.votes
			RETURN REF_1049
	Function ERC20Votes.getPastVotes(address,uint256) (*)
		Expression: require(bool,string)(timepoint < clock(),ERC20Votes: future lookup)
		IRs:
			TMP_3217(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_3218(bool) = timepoint < TMP_3217
			TMP_3219(None) = SOLIDITY_CALL require(bool,string)(TMP_3218,ERC20Votes: future lookup)
		Expression: _checkpointsLookup(_checkpoints[account],timepoint)
		IRs:
			REF_1050(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			TMP_3220(uint256) = INTERNAL_CALL, ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256)(REF_1050,timepoint)
			RETURN TMP_3220
	Function ERC20Votes.getPastTotalSupply(uint256) (*)
		Expression: require(bool,string)(timepoint < clock(),ERC20Votes: future lookup)
		IRs:
			TMP_3221(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_3222(bool) = timepoint < TMP_3221
			TMP_3223(None) = SOLIDITY_CALL require(bool,string)(TMP_3222,ERC20Votes: future lookup)
		Expression: _checkpointsLookup(_totalSupplyCheckpoints,timepoint)
		IRs:
			TMP_3224(uint256) = INTERNAL_CALL, ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256)(_totalSupplyCheckpoints,timepoint)
			RETURN TMP_3224
	Function ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256) (*)
		Expression: length = ckpts.length
		IRs:
			REF_1051 -> LENGTH ckpts
			length(uint256) := REF_1051(uint256)
		Expression: low = 0
		IRs:
			low(uint256) := 0(uint256)
		Expression: high = length
		IRs:
			high(uint256) := length(uint256)
		Expression: length > 5
		IRs:
			TMP_3225(bool) = length > 5
			CONDITION TMP_3225
		Expression: mid = length - Math.sqrt(length)
		IRs:
			TMP_3226(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['length'] 
			TMP_3227(uint256) = length (c)- TMP_3226
			mid(uint256) := TMP_3227(uint256)
		Expression: _unsafeAccess(ckpts,mid).fromBlock > timepoint
		IRs:
			TMP_3228(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,mid)
			REF_1053(uint32) -> TMP_3228.fromBlock
			TMP_3229(bool) = REF_1053 > timepoint
			CONDITION TMP_3229
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3230(uint256) = mid (c)+ 1
			low(uint256) := TMP_3230(uint256)
		Expression: low < high
		IRs:
			TMP_3231(bool) = low < high
			CONDITION TMP_3231
		Expression: mid_scope_0 = Math.average(low,high)
		IRs:
			TMP_3232(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid_scope_0(uint256) := TMP_3232(uint256)
		Expression: _unsafeAccess(ckpts,mid_scope_0).fromBlock > timepoint
		IRs:
			TMP_3233(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,mid_scope_0)
			REF_1055(uint32) -> TMP_3233.fromBlock
			TMP_3234(bool) = REF_1055 > timepoint
			CONDITION TMP_3234
		Expression: high = mid_scope_0
		IRs:
			high(uint256) := mid_scope_0(uint256)
		Expression: low = mid_scope_0 + 1
		IRs:
			TMP_3235(uint256) = mid_scope_0 (c)+ 1
			low(uint256) := TMP_3235(uint256)
		Expression: high == 0
		IRs:
			TMP_3236(bool) = high == 0
			CONDITION TMP_3236
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(ckpts,high - 1).votes
		IRs:
			TMP_3237(uint256) = high - 1
			TMP_3238(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_3237)
			REF_1056(uint224) -> TMP_3238.votes
			RETURN REF_1056
	Function ERC20Votes.delegate(address) (*)
		Expression: _delegate(_msgSender(),delegatee)
		IRs:
			TMP_3239(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20Votes._delegate(address,address)(TMP_3239,delegatee)
	Function ERC20Votes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= expiry,ERC20Votes: signature expired)
		IRs:
			TMP_3241(bool) = block.timestamp <= expiry
			TMP_3242(None) = SOLIDITY_CALL require(bool,string)(TMP_3241,ERC20Votes: signature expired)
		Expression: signer = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(_DELEGATION_TYPEHASH,delegatee,nonce,expiry))),v,r,s)
		IRs:
			TMP_3243(bytes) = SOLIDITY_CALL abi.encode()(_DELEGATION_TYPEHASH,delegatee,nonce,expiry)
			TMP_3244(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3243)
			TMP_3245(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_3244)
			TMP_3246(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_3245', 'v', 'r', 's'] 
			signer(address) := TMP_3246(address)
		Expression: require(bool,string)(nonce == _useNonce(signer),ERC20Votes: invalid nonce)
		IRs:
			TMP_3247(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(signer)
			TMP_3248(bool) = nonce == TMP_3247
			TMP_3249(None) = SOLIDITY_CALL require(bool,string)(TMP_3248,ERC20Votes: invalid nonce)
		Expression: _delegate(signer,delegatee)
		IRs:
			INTERNAL_CALL, ERC20Votes._delegate(address,address)(signer,delegatee)
	Function ERC20Votes._maxSupply() (*)
		Expression: type()(uint224).max
		IRs:
			TMP_3252(uint224) := 26959946667150639794667015087019630673637144422540572481103610249215(uint224)
			RETURN TMP_3252
	Function ERC20Votes._mint(address,uint256) (*)
		Expression: super._mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account,amount)
		Expression: require(bool,string)(totalSupply() <= _maxSupply(),ERC20Votes: total supply risks overflowing votes)
		IRs:
			TMP_3254(uint256) = INTERNAL_CALL, ERC20.totalSupply()()
			TMP_3255(uint224) = INTERNAL_CALL, ERC20Votes._maxSupply()()
			TMP_3256(bool) = TMP_3254 <= TMP_3255
			TMP_3257(None) = SOLIDITY_CALL require(bool,string)(TMP_3256,ERC20Votes: total supply risks overflowing votes)
		Expression: _writeCheckpoint(_totalSupplyCheckpoints,_add,amount)
		IRs:
			TUPLE_38(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(_totalSupplyCheckpoints,_add,amount)
	Function ERC20Votes._burn(address,uint256) (*)
		Expression: super._burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account,amount)
		Expression: _writeCheckpoint(_totalSupplyCheckpoints,_subtract,amount)
		IRs:
			TUPLE_39(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(_totalSupplyCheckpoints,_subtract,amount)
	Function ERC20Votes._afterTokenTransfer(address,address,uint256) (*)
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: _moveVotingPower(delegates(from),delegates(to),amount)
		IRs:
			TMP_3260(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(from)
			TMP_3261(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(to)
			INTERNAL_CALL, ERC20Votes._moveVotingPower(address,address,uint256)(TMP_3260,TMP_3261,amount)
	Function ERC20Votes._delegate(address,address) (*)
		Expression: currentDelegate = delegates(delegator)
		IRs:
			TMP_3263(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(delegator)
			currentDelegate(address) := TMP_3263(address)
		Expression: delegatorBalance = balanceOf(delegator)
		IRs:
			TMP_3264(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(delegator)
			delegatorBalance(uint256) := TMP_3264(uint256)
		Expression: _delegates[delegator] = delegatee
		IRs:
			REF_1059(address) -> _delegates[delegator]
			REF_1059(address) (->_delegates) := delegatee(address)
		Expression: DelegateChanged(delegator,currentDelegate,delegatee)
		IRs:
			Emit DelegateChanged(delegator,currentDelegate,delegatee)
		Expression: _moveVotingPower(currentDelegate,delegatee,delegatorBalance)
		IRs:
			INTERNAL_CALL, ERC20Votes._moveVotingPower(address,address,uint256)(currentDelegate,delegatee,delegatorBalance)
	Function ERC20Votes._moveVotingPower(address,address,uint256) (*)
		Expression: src != dst && amount > 0
		IRs:
			TMP_3267(bool) = src != dst
			TMP_3268(bool) = amount > 0
			TMP_3269(bool) = TMP_3267 && TMP_3268
			CONDITION TMP_3269
		Expression: src != address(0)
		IRs:
			TMP_3270 = CONVERT 0 to address
			TMP_3271(bool) = src != TMP_3270
			CONDITION TMP_3271
		Expression: (oldWeight,newWeight) = _writeCheckpoint(_checkpoints[src],_subtract,amount)
		IRs:
			REF_1060(ERC20Votes.Checkpoint[]) -> _checkpoints[src]
			TUPLE_40(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(REF_1060,_subtract,amount)
			oldWeight(uint256)= UNPACK TUPLE_40 index: 0 
			newWeight(uint256)= UNPACK TUPLE_40 index: 1 
		Expression: DelegateVotesChanged(src,oldWeight,newWeight)
		IRs:
			Emit DelegateVotesChanged(src,oldWeight,newWeight)
		Expression: dst != address(0)
		IRs:
			TMP_3273 = CONVERT 0 to address
			TMP_3274(bool) = dst != TMP_3273
			CONDITION TMP_3274
		Expression: (oldWeight_scope_0,newWeight_scope_1) = _writeCheckpoint(_checkpoints[dst],_add,amount)
		IRs:
			REF_1061(ERC20Votes.Checkpoint[]) -> _checkpoints[dst]
			TUPLE_41(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(REF_1061,_add,amount)
			oldWeight_scope_0(uint256)= UNPACK TUPLE_41 index: 0 
			newWeight_scope_1(uint256)= UNPACK TUPLE_41 index: 1 
		Expression: DelegateVotesChanged(dst,oldWeight_scope_0,newWeight_scope_1)
		IRs:
			Emit DelegateVotesChanged(dst,oldWeight_scope_0,newWeight_scope_1)
	Function ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256) (*)
		Expression: pos = ckpts.length
		IRs:
			REF_1062 -> LENGTH ckpts
			pos(uint256) := REF_1062(uint256)
		Expression: oldWeight = oldCkpt.votes
		IRs:
			REF_1063(uint224) -> oldCkpt.votes
			oldWeight(uint256) := REF_1063(uint224)
		Expression: newWeight = op(oldWeight,delta)
		IRs:
			TMP_3276(uint256) = INTERNAL_DYNAMIC_CALL op(oldWeight,delta)  
			newWeight(uint256) := TMP_3276(uint256)
		Expression: pos > 0 && oldCkpt.fromBlock == clock()
		IRs:
			TMP_3277(bool) = pos > 0
			REF_1064(uint32) -> oldCkpt.fromBlock
			TMP_3278(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_3279(bool) = REF_1064 == TMP_3278
			TMP_3280(bool) = TMP_3277 && TMP_3279
			CONDITION TMP_3280
		Expression: _unsafeAccess(ckpts,pos - 1).votes = SafeCast.toUint224(newWeight)
		IRs:
			TMP_3281(uint256) = pos - 1
			TMP_3282(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_3281)
			REF_1065(uint224) -> TMP_3282.votes
			TMP_3283(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newWeight'] 
			REF_1065(uint224) (->TMP_3282) := TMP_3283(uint224)
		Expression: ckpts.push(Checkpoint({fromBlock:SafeCast.toUint32(clock()),votes:SafeCast.toUint224(newWeight)}))
		IRs:
			TMP_3284(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_3285(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['TMP_3284'] 
			TMP_3286(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newWeight'] 
			TMP_3287(ERC20Votes.Checkpoint) = new Checkpoint(TMP_3285,TMP_3286)
			REF_1070 -> LENGTH ckpts
			TMP_3289(uint256) := REF_1070(uint256)
			TMP_3290(uint256) = TMP_3289 + 1
			REF_1070(uint256) (->ckpts) := TMP_3290(uint256)
			REF_1071(ERC20Votes.Checkpoint) -> ckpts[TMP_3289]
			REF_1071(ERC20Votes.Checkpoint) (->ckpts) := TMP_3287(ERC20Votes.Checkpoint)
		Expression: pos == 0
		IRs:
			TMP_3291(bool) = pos == 0
			CONDITION TMP_3291
		Expression: oldCkpt = Checkpoint(0,0)
		IRs:
			TMP_3292(ERC20Votes.Checkpoint) = new Checkpoint(0,0)
			oldCkpt(ERC20Votes.Checkpoint) := TMP_3292(ERC20Votes.Checkpoint)
		Expression: oldCkpt = _unsafeAccess(ckpts,pos - 1)
		IRs:
			TMP_3293(uint256) = pos - 1
			TMP_3294(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_3293)
			oldCkpt(ERC20Votes.Checkpoint) := TMP_3294(ERC20Votes.Checkpoint)
	Function ERC20Votes._add(uint256,uint256) (*)
		Expression: a + b
		IRs:
			TMP_3295(uint256) = a (c)+ b
			RETURN TMP_3295
	Function ERC20Votes._subtract(uint256,uint256) (*)
		Expression: a - b
		IRs:
			TMP_3296(uint256) = a (c)- b
			RETURN TMP_3296
	Function ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256) (*)
		Expression: mstore(uint256,uint256)(0,ckpts)
		IRs:
			TMP_3297(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,ckpts)
		Expression: result = keccak256(uint256,uint256)(0,0x20) + pos
		IRs:
			TMP_3298(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,32)
			TMP_3299(uint256) = TMP_3298 + pos
			result(ERC20Votes.Checkpoint) := TMP_3299(uint256)
	Function ERC20Votes.slitherConstructorConstantVariables() (*)
		Expression: _DELEGATION_TYPEHASH = keccak256(bytes)(Delegation(address delegatee,uint256 nonce,uint256 expiry))
		IRs:
			TMP_3300(bytes32) = SOLIDITY_CALL keccak256(bytes)(Delegation(address delegatee,uint256 nonce,uint256 expiry))
			_DELEGATION_TYPEHASH(bytes32) := TMP_3300(bytes32)
Contract IERC20Metadata
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) (*)
	Function IERC20.transfer(address,uint256) (*)
	Function IERC20.allowance(address,address) (*)
	Function IERC20.approve(address,uint256) (*)
	Function IERC20.transferFrom(address,address,uint256) (*)
	Function IERC20Metadata.name() (*)
	Function IERC20Metadata.symbol() (*)
	Function IERC20Metadata.decimals() (*)
Contract IERC20Permit
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
	Function IERC20Permit.nonces(address) (*)
	Function IERC20Permit.DOMAIN_SEPARATOR() (*)
Contract SafeERC20
	Function SafeERC20.safeTransfer(IERC20,address,uint256) (*)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transfer.selector,to,value))
		IRs:
			REF_1074(bytes4) (->None) := 2835717307(uint256)
			TMP_3301(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1074,to,value)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3301)
	Function SafeERC20.safeTransferFrom(IERC20,address,address,uint256) (*)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.transferFrom.selector,from,to,value))
		IRs:
			REF_1077(bytes4) (->None) := 599290589(uint256)
			TMP_3303(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1077,from,to,value)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3303)
	Function SafeERC20.safeApprove(IERC20,address,uint256) (*)
		Expression: require(bool,string)((value == 0) || (token.allowance(address(this),spender) == 0),SafeERC20: approve from non-zero to non-zero allowance)
		IRs:
			TMP_3305(bool) = value == 0
			TMP_3306 = CONVERT this to address
			TMP_3307(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['TMP_3306', 'spender']  
			TMP_3308(bool) = TMP_3307 == 0
			TMP_3309(bool) = TMP_3305 || TMP_3308
			TMP_3310(None) = SOLIDITY_CALL require(bool,string)(TMP_3309,SafeERC20: approve from non-zero to non-zero allowance)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,value))
		IRs:
			REF_1081(bytes4) (->None) := 157198259(uint256)
			TMP_3311(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1081,spender,value)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3311)
	Function SafeERC20.safeIncreaseAllowance(IERC20,address,uint256) (*)
		Expression: oldAllowance = token.allowance(address(this),spender)
		IRs:
			TMP_3313 = CONVERT this to address
			TMP_3314(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['TMP_3313', 'spender']  
			oldAllowance(uint256) := TMP_3314(uint256)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance + value))
		IRs:
			REF_1085(bytes4) (->None) := 157198259(uint256)
			TMP_3315(uint256) = oldAllowance (c)+ value
			TMP_3316(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1085,spender,TMP_3315)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3316)
	Function SafeERC20.safeDecreaseAllowance(IERC20,address,uint256) (*)
		Expression: oldAllowance = token.allowance(address(this),spender)
		IRs:
			TMP_3318 = CONVERT this to address
			TMP_3319(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['TMP_3318', 'spender']  
			oldAllowance(uint256) := TMP_3319(uint256)
		Expression: require(bool,string)(oldAllowance >= value,SafeERC20: decreased allowance below zero)
		IRs:
			TMP_3320(bool) = oldAllowance >= value
			TMP_3321(None) = SOLIDITY_CALL require(bool,string)(TMP_3320,SafeERC20: decreased allowance below zero)
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,oldAllowance - value))
		IRs:
			REF_1089(bytes4) (->None) := 157198259(uint256)
			TMP_3322(uint256) = oldAllowance - value
			TMP_3323(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1089,spender,TMP_3322)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3323)
	Function SafeERC20.forceApprove(IERC20,address,uint256) (*)
		Expression: approvalCall = abi.encodeWithSelector(token.approve.selector,spender,value)
		IRs:
			REF_1092(bytes4) (->None) := 157198259(uint256)
			TMP_3325(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1092,spender,value)
			approvalCall(bytes) := TMP_3325(bytes)
		Expression: ! _callOptionalReturnBool(token,approvalCall)
		IRs:
			TMP_3326(bool) = INTERNAL_CALL, SafeERC20._callOptionalReturnBool(IERC20,bytes)(token,approvalCall)
			TMP_3327 = UnaryType.BANG TMP_3326 
			CONDITION TMP_3327
		Expression: _callOptionalReturn(token,abi.encodeWithSelector(token.approve.selector,spender,0))
		IRs:
			REF_1095(bytes4) (->None) := 157198259(uint256)
			TMP_3328(bytes) = SOLIDITY_CALL abi.encodeWithSelector()(REF_1095,spender,0)
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,TMP_3328)
		Expression: _callOptionalReturn(token,approvalCall)
		IRs:
			INTERNAL_CALL, SafeERC20._callOptionalReturn(IERC20,bytes)(token,approvalCall)
	Function SafeERC20.safePermit(IERC20Permit,address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: nonceBefore = token.nonces(owner)
		IRs:
			TMP_3331(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20Permit), function:nonces, arguments:['owner']  
			nonceBefore(uint256) := TMP_3331(uint256)
		Expression: token.permit(owner,spender,value,deadline,v,r,s)
		IRs:
			HIGH_LEVEL_CALL, dest:token(IERC20Permit), function:permit, arguments:['owner', 'spender', 'value', 'deadline', 'v', 'r', 's']  
		Expression: nonceAfter = token.nonces(owner)
		IRs:
			TMP_3333(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20Permit), function:nonces, arguments:['owner']  
			nonceAfter(uint256) := TMP_3333(uint256)
		Expression: require(bool,string)(nonceAfter == nonceBefore + 1,SafeERC20: permit did not succeed)
		IRs:
			TMP_3334(uint256) = nonceBefore (c)+ 1
			TMP_3335(bool) = nonceAfter == TMP_3334
			TMP_3336(None) = SOLIDITY_CALL require(bool,string)(TMP_3335,SafeERC20: permit did not succeed)
	Function SafeERC20._callOptionalReturn(IERC20,bytes) (*)
		Expression: returndata = address(token).functionCall(data,SafeERC20: low-level call failed)
		IRs:
			TMP_3337 = CONVERT token to address
			TMP_3338(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionCall(address,bytes,string), arguments:['TMP_3337', 'data', 'SafeERC20: low-level call failed'] 
			returndata(bytes) := TMP_3338(bytes)
		Expression: require(bool,string)(returndata.length == 0 || abi.decode(returndata,(bool)),SafeERC20: ERC20 operation did not succeed)
		IRs:
			REF_1100 -> LENGTH returndata
			TMP_3339(bool) = REF_1100 == 0
			TMP_3340(bool) = SOLIDITY_CALL abi.decode()(returndata,bool)
			TMP_3341(bool) = TMP_3339 || TMP_3340
			TMP_3342(None) = SOLIDITY_CALL require(bool,string)(TMP_3341,SafeERC20: ERC20 operation did not succeed)
	Function SafeERC20._callOptionalReturnBool(IERC20,bytes) (*)
		Expression: (success,returndata) = address(token).call(data)
		IRs:
			TMP_3343 = CONVERT token to address
			TUPLE_42(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_3343, function:call, arguments:['data']  
			success(bool)= UNPACK TUPLE_42 index: 0 
			returndata(bytes)= UNPACK TUPLE_42 index: 1 
		Expression: success && (returndata.length == 0 || abi.decode(returndata,(bool))) && Address.isContract(address(token))
		IRs:
			REF_1103 -> LENGTH returndata
			TMP_3344(bool) = REF_1103 == 0
			TMP_3345(bool) = SOLIDITY_CALL abi.decode()(returndata,bool)
			TMP_3346(bool) = TMP_3344 || TMP_3345
			TMP_3347(bool) = success && TMP_3346
			TMP_3348 = CONVERT token to address
			TMP_3349(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['TMP_3348'] 
			TMP_3350(bool) = TMP_3347 && TMP_3349
			RETURN TMP_3350
Contract IERC721Receiver
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) (*)
Contract Address
	Function Address.isContract(address) (*)
		Expression: account.code.length > 0
		IRs:
			TMP_3351(bytes) = SOLIDITY_CALL code(address)(account)
			REF_1106 -> LENGTH TMP_3351
			TMP_3352(bool) = REF_1106 > 0
			RETURN TMP_3352
	Function Address.sendValue(address,uint256) (*)
		Expression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)
		IRs:
			TMP_3353 = CONVERT this to address
			TMP_3354(uint256) = SOLIDITY_CALL balance(address)(TMP_3353)
			TMP_3355(bool) = TMP_3354 >= amount
			TMP_3356(None) = SOLIDITY_CALL require(bool,string)(TMP_3355,Address: insufficient balance)
		Expression: (success) = recipient.call{value: amount}()
		IRs:
			TUPLE_43(bool,bytes) = LOW_LEVEL_CALL, dest:recipient, function:call, arguments:[''] value:amount 
			success(bool)= UNPACK TUPLE_43 index: 0 
		Expression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)
		IRs:
			TMP_3357(None) = SOLIDITY_CALL require(bool,string)(success,Address: unable to send value, recipient may have reverted)
	Function Address.functionCall(address,bytes) (*)
		Expression: functionCallWithValue(target,data,0,Address: low-level call failed)
		IRs:
			TMP_3358(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,0,Address: low-level call failed)
			RETURN TMP_3358
	Function Address.functionCall(address,bytes,string) (*)
		Expression: functionCallWithValue(target,data,0,errorMessage)
		IRs:
			TMP_3359(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,0,errorMessage)
			RETURN TMP_3359
	Function Address.functionCallWithValue(address,bytes,uint256) (*)
		Expression: functionCallWithValue(target,data,value,Address: low-level call with value failed)
		IRs:
			TMP_3360(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,value,Address: low-level call with value failed)
			RETURN TMP_3360
	Function Address.functionCallWithValue(address,bytes,uint256,string) (*)
		Expression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)
		IRs:
			TMP_3361 = CONVERT this to address
			TMP_3362(uint256) = SOLIDITY_CALL balance(address)(TMP_3361)
			TMP_3363(bool) = TMP_3362 >= value
			TMP_3364(None) = SOLIDITY_CALL require(bool,string)(TMP_3363,Address: insufficient balance for call)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_44(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_44 index: 0 
			returndata(bytes)= UNPACK TUPLE_44 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3365(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_3365
	Function Address.functionStaticCall(address,bytes) (*)
		Expression: functionStaticCall(target,data,Address: low-level static call failed)
		IRs:
			TMP_3366(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target,data,Address: low-level static call failed)
			RETURN TMP_3366
	Function Address.functionStaticCall(address,bytes,string) (*)
		Expression: (success,returndata) = target.staticcall(data)
		IRs:
			TUPLE_45(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:staticcall, arguments:['data']  
			success(bool)= UNPACK TUPLE_45 index: 0 
			returndata(bytes)= UNPACK TUPLE_45 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3367(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_3367
	Function Address.functionDelegateCall(address,bytes) (*)
		Expression: functionDelegateCall(target,data,Address: low-level delegate call failed)
		IRs:
			TMP_3368(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target,data,Address: low-level delegate call failed)
			RETURN TMP_3368
	Function Address.functionDelegateCall(address,bytes,string) (*)
		Expression: (success,returndata) = target.delegatecall(data)
		IRs:
			TUPLE_46(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:delegatecall, arguments:['data']  
			success(bool)= UNPACK TUPLE_46 index: 0 
			returndata(bytes)= UNPACK TUPLE_46 index: 1 
		Expression: verifyCallResultFromTarget(target,success,returndata,errorMessage)
		IRs:
			TMP_3369(bytes) = INTERNAL_CALL, Address.verifyCallResultFromTarget(address,bool,bytes,string)(target,success,returndata,errorMessage)
			RETURN TMP_3369
	Function Address.verifyCallResultFromTarget(address,bool,bytes,string) (*)
		Expression: success
		IRs:
			CONDITION success
		Expression: returndata.length == 0
		IRs:
			REF_1111 -> LENGTH returndata
			TMP_3370(bool) = REF_1111 == 0
			CONDITION TMP_3370
		Expression: require(bool,string)(isContract(target),Address: call to non-contract)
		IRs:
			TMP_3371(bool) = INTERNAL_CALL, Address.isContract(address)(target)
			TMP_3372(None) = SOLIDITY_CALL require(bool,string)(TMP_3371,Address: call to non-contract)
		Expression: returndata
		IRs:
			RETURN returndata
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata,errorMessage)
	Function Address.verifyCallResult(bool,bytes,string) (*)
		Expression: success
		IRs:
			CONDITION success
		Expression: returndata
		IRs:
			RETURN returndata
		Expression: _revert(returndata,errorMessage)
		IRs:
			INTERNAL_CALL, Address._revert(bytes,string)(returndata,errorMessage)
	Function Address._revert(bytes,string) (*)
		Expression: returndata.length > 0
		IRs:
			REF_1112 -> LENGTH returndata
			TMP_3375(bool) = REF_1112 > 0
			CONDITION TMP_3375
		Expression: returndata_size__revert_asm_0 = mload(uint256)(returndata)
		IRs:
			TMP_3376(uint256) = SOLIDITY_CALL mload(uint256)(returndata)
			returndata_size__revert_asm_0(uint256) := TMP_3376(uint256)
		Expression: revert(uint256,uint256)(32 + returndata,returndata_size__revert_asm_0)
		IRs:
			TMP_3377(uint256) = 32 + returndata
			TMP_3378(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_3377,returndata_size__revert_asm_0)
		Expression: revert(string)(errorMessage)
		IRs:
			TMP_3379(None) = SOLIDITY_CALL revert(string)(errorMessage)
Contract Checkpoints
	Function Checkpoints.getAtBlock(Checkpoints.History,uint256) (*)
		Expression: require(bool,string)(blockNumber < block.number,Checkpoints: block not yet mined)
		IRs:
			TMP_3380(bool) = blockNumber < block.number
			TMP_3381(None) = SOLIDITY_CALL require(bool,string)(TMP_3380,Checkpoints: block not yet mined)
		Expression: key = SafeCast.toUint32(blockNumber)
		IRs:
			TMP_3382(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['blockNumber'] 
			key(uint32) := TMP_3382(uint32)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1114(Checkpoints.Checkpoint[]) -> self._checkpoints
			REF_1115 -> LENGTH REF_1114
			len(uint256) := REF_1115(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,0,len)
		IRs:
			REF_1116(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3383(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256)(REF_1116,key,0,len)
			pos(uint256) := TMP_3383(uint256)
		Expression: pos == 0
		IRs:
			TMP_3384(bool) = pos == 0
			CONDITION TMP_3384
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1117(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3385(uint256) = pos (c)- 1
			TMP_3386(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(REF_1117,TMP_3385)
			REF_1118(uint224) -> TMP_3386._value
			RETURN REF_1118
	Function Checkpoints.getAtProbablyRecentBlock(Checkpoints.History,uint256) (*)
		Expression: require(bool,string)(blockNumber < block.number,Checkpoints: block not yet mined)
		IRs:
			TMP_3387(bool) = blockNumber < block.number
			TMP_3388(None) = SOLIDITY_CALL require(bool,string)(TMP_3387,Checkpoints: block not yet mined)
		Expression: key = SafeCast.toUint32(blockNumber)
		IRs:
			TMP_3389(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['blockNumber'] 
			key(uint32) := TMP_3389(uint32)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1120(Checkpoints.Checkpoint[]) -> self._checkpoints
			REF_1121 -> LENGTH REF_1120
			len(uint256) := REF_1121(uint256)
		Expression: low = 0
		IRs:
			low(uint256) := 0(uint256)
		Expression: high = len
		IRs:
			high(uint256) := len(uint256)
		Expression: len > 5
		IRs:
			TMP_3390(bool) = len > 5
			CONDITION TMP_3390
		Expression: mid = len - Math.sqrt(len)
		IRs:
			TMP_3391(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['len'] 
			TMP_3392(uint256) = len (c)- TMP_3391
			mid(uint256) := TMP_3392(uint256)
		Expression: key < _unsafeAccess(self._checkpoints,mid)._blockNumber
		IRs:
			REF_1123(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3393(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(REF_1123,mid)
			REF_1124(uint32) -> TMP_3393._blockNumber
			TMP_3394(bool) = key < REF_1124
			CONDITION TMP_3394
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3395(uint256) = mid (c)+ 1
			low(uint256) := TMP_3395(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,low,high)
		IRs:
			REF_1125(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3396(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256)(REF_1125,key,low,high)
			pos(uint256) := TMP_3396(uint256)
		Expression: pos == 0
		IRs:
			TMP_3397(bool) = pos == 0
			CONDITION TMP_3397
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1126(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3398(uint256) = pos (c)- 1
			TMP_3399(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(REF_1126,TMP_3398)
			REF_1127(uint224) -> TMP_3399._value
			RETURN REF_1127
	Function Checkpoints.push(Checkpoints.History,uint256) (*)
		Expression: _insert(self._checkpoints,SafeCast.toUint32(block.number),SafeCast.toUint224(value))
		IRs:
			REF_1128(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3400(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['block.number'] 
			TMP_3401(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['value'] 
			TUPLE_47(uint224,uint224) = INTERNAL_CALL, Checkpoints._insert(Checkpoints.Checkpoint[],uint32,uint224)(REF_1128,TMP_3400,TMP_3401)
			RETURN TUPLE_47
	Function Checkpoints.push(Checkpoints.History,function(uint256,uint256) returns(uint256),uint256) (*)
		Expression: push(self,op(latest(self),delta))
		IRs:
			TMP_3402(uint224) = INTERNAL_CALL, Checkpoints.latest(Checkpoints.History)(self)
			TMP_3403(uint256) = INTERNAL_DYNAMIC_CALL op(TMP_3402,delta)  
			TUPLE_48(uint256,uint256) = INTERNAL_CALL, Checkpoints.push(Checkpoints.History,uint256)(self,TMP_3403)
			RETURN TUPLE_48
	Function Checkpoints.latest(Checkpoints.History) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1131(Checkpoints.Checkpoint[]) -> self._checkpoints
			REF_1132 -> LENGTH REF_1131
			pos(uint256) := REF_1132(uint256)
		Expression: pos == 0
		IRs:
			TMP_3404(bool) = pos == 0
			CONDITION TMP_3404
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1133(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3405(uint256) = pos (c)- 1
			TMP_3406(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(REF_1133,TMP_3405)
			REF_1134(uint224) -> TMP_3406._value
			RETURN REF_1134
	Function Checkpoints.latestCheckpoint(Checkpoints.History) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1135(Checkpoints.Checkpoint[]) -> self._checkpoints
			REF_1136 -> LENGTH REF_1135
			pos(uint256) := REF_1136(uint256)
		Expression: pos == 0
		IRs:
			TMP_3407(bool) = pos == 0
			CONDITION TMP_3407
		Expression: (false,0,0)
		IRs:
			RETURN False,0,0
		Expression: ckpt = _unsafeAccess(self._checkpoints,pos - 1)
		IRs:
			REF_1137(Checkpoints.Checkpoint[]) -> self._checkpoints
			TMP_3408(uint256) = pos (c)- 1
			TMP_3409(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(REF_1137,TMP_3408)
			ckpt(Checkpoints.Checkpoint) := TMP_3409(Checkpoints.Checkpoint)
		Expression: (true,ckpt._blockNumber,ckpt._value)
		IRs:
			REF_1138(uint32) -> ckpt._blockNumber
			REF_1139(uint224) -> ckpt._value
			RETURN True,REF_1138,REF_1139
	Function Checkpoints.length(Checkpoints.History) (*)
		Expression: self._checkpoints.length
		IRs:
			REF_1140(Checkpoints.Checkpoint[]) -> self._checkpoints
			REF_1141 -> LENGTH REF_1140
			RETURN REF_1141
	Function Checkpoints._insert(Checkpoints.Checkpoint[],uint32,uint224) (*)
		Expression: pos = self.length
		IRs:
			REF_1142 -> LENGTH self
			pos(uint256) := REF_1142(uint256)
		Expression: pos > 0
		IRs:
			TMP_3410(bool) = pos > 0
			CONDITION TMP_3410
		Expression: last = _unsafeAccess(self,pos - 1)
		IRs:
			TMP_3411(uint256) = pos (c)- 1
			TMP_3412(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(self,TMP_3411)
			last(Checkpoints.Checkpoint) := TMP_3412(Checkpoints.Checkpoint)
		Expression: require(bool,string)(last._blockNumber <= key,Checkpoint: decreasing keys)
		IRs:
			REF_1143(uint32) -> last._blockNumber
			TMP_3413(bool) = REF_1143 <= key
			TMP_3414(None) = SOLIDITY_CALL require(bool,string)(TMP_3413,Checkpoint: decreasing keys)
		Expression: last._blockNumber == key
		IRs:
			REF_1144(uint32) -> last._blockNumber
			TMP_3415(bool) = REF_1144 == key
			CONDITION TMP_3415
		Expression: _unsafeAccess(self,pos - 1)._value = value
		IRs:
			TMP_3416(uint256) = pos (c)- 1
			TMP_3417(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(self,TMP_3416)
			REF_1145(uint224) -> TMP_3417._value
			REF_1145(uint224) (->TMP_3417) := value(uint224)
		Expression: self.push(Checkpoint({_blockNumber:key,_value:value}))
		IRs:
			TMP_3418(Checkpoints.Checkpoint) = new Checkpoint(key,value)
			REF_1147 -> LENGTH self
			TMP_3420(uint256) := REF_1147(uint256)
			TMP_3421(uint256) = TMP_3420 (c)+ 1
			REF_1147(uint256) (->self) := TMP_3421(uint256)
			REF_1148(Checkpoints.Checkpoint) -> self[TMP_3420]
			REF_1148(Checkpoints.Checkpoint) (->self) := TMP_3418(Checkpoints.Checkpoint)
		Expression: (last._value,value)
		IRs:
			REF_1149(uint224) -> last._value
			RETURN REF_1149,value
		Expression: self.push(Checkpoint({_blockNumber:key,_value:value}))
		IRs:
			TMP_3422(Checkpoints.Checkpoint) = new Checkpoint(key,value)
			REF_1151 -> LENGTH self
			TMP_3424(uint256) := REF_1151(uint256)
			TMP_3425(uint256) = TMP_3424 (c)+ 1
			REF_1151(uint256) (->self) := TMP_3425(uint256)
			REF_1152(Checkpoints.Checkpoint) -> self[TMP_3424]
			REF_1152(Checkpoints.Checkpoint) (->self) := TMP_3422(Checkpoints.Checkpoint)
		Expression: (0,value)
		IRs:
			RETURN 0,value
	Function Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3426(bool) = low < high
			CONDITION TMP_3426
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3427(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3427(uint256)
		Expression: _unsafeAccess(self,mid)._blockNumber > key
		IRs:
			TMP_3428(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(self,mid)
			REF_1154(uint32) -> TMP_3428._blockNumber
			TMP_3429(bool) = REF_1154 > key
			CONDITION TMP_3429
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3430(uint256) = mid (c)+ 1
			low(uint256) := TMP_3430(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3431(bool) = low < high
			CONDITION TMP_3431
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3432(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3432(uint256)
		Expression: _unsafeAccess(self,mid)._blockNumber < key
		IRs:
			TMP_3433(Checkpoints.Checkpoint) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256)(self,mid)
			REF_1156(uint32) -> TMP_3433._blockNumber
			TMP_3434(bool) = REF_1156 < key
			CONDITION TMP_3434
		Expression: low = mid + 1
		IRs:
			TMP_3435(uint256) = mid (c)+ 1
			low(uint256) := TMP_3435(uint256)
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._unsafeAccess(Checkpoints.Checkpoint[],uint256) (*)
		Expression: mstore(uint256,uint256)(0,self)
		IRs:
			TMP_3436(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,self)
		Expression: result = keccak256(uint256,uint256)(0,0x20) + pos
		IRs:
			TMP_3437(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,32)
			TMP_3438(uint256) = TMP_3437 + pos
			result(Checkpoints.Checkpoint) := TMP_3438(uint256)
	Function Checkpoints.push(Checkpoints.Trace224,uint32,uint224) (*)
		Expression: _insert(self._checkpoints,key,value)
		IRs:
			REF_1157(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TUPLE_49(uint224,uint224) = INTERNAL_CALL, Checkpoints._insert(Checkpoints.Checkpoint224[],uint32,uint224)(REF_1157,key,value)
			RETURN TUPLE_49
	Function Checkpoints.lowerLookup(Checkpoints.Trace224,uint32) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1158(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1159 -> LENGTH REF_1158
			len(uint256) := REF_1159(uint256)
		Expression: pos = _lowerBinaryLookup(self._checkpoints,key,0,len)
		IRs:
			REF_1160(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3439(uint256) = INTERNAL_CALL, Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256)(REF_1160,key,0,len)
			pos(uint256) := TMP_3439(uint256)
		Expression: pos == len
		IRs:
			TMP_3440(bool) = pos == len
			CONDITION TMP_3440
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos)._value
		IRs:
			REF_1161(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3441(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1161,pos)
			REF_1162(uint224) -> TMP_3441._value
			RETURN REF_1162
	Function Checkpoints.upperLookup(Checkpoints.Trace224,uint32) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1163(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1164 -> LENGTH REF_1163
			len(uint256) := REF_1164(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,0,len)
		IRs:
			REF_1165(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3442(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256)(REF_1165,key,0,len)
			pos(uint256) := TMP_3442(uint256)
		Expression: pos == 0
		IRs:
			TMP_3443(bool) = pos == 0
			CONDITION TMP_3443
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1166(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3444(uint256) = pos (c)- 1
			TMP_3445(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1166,TMP_3444)
			REF_1167(uint224) -> TMP_3445._value
			RETURN REF_1167
	Function Checkpoints.upperLookupRecent(Checkpoints.Trace224,uint32) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1168(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1169 -> LENGTH REF_1168
			len(uint256) := REF_1169(uint256)
		Expression: low = 0
		IRs:
			low(uint256) := 0(uint256)
		Expression: high = len
		IRs:
			high(uint256) := len(uint256)
		Expression: len > 5
		IRs:
			TMP_3446(bool) = len > 5
			CONDITION TMP_3446
		Expression: mid = len - Math.sqrt(len)
		IRs:
			TMP_3447(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['len'] 
			TMP_3448(uint256) = len (c)- TMP_3447
			mid(uint256) := TMP_3448(uint256)
		Expression: key < _unsafeAccess(self._checkpoints,mid)._key
		IRs:
			REF_1171(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3449(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1171,mid)
			REF_1172(uint32) -> TMP_3449._key
			TMP_3450(bool) = key < REF_1172
			CONDITION TMP_3450
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3451(uint256) = mid (c)+ 1
			low(uint256) := TMP_3451(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,low,high)
		IRs:
			REF_1173(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3452(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256)(REF_1173,key,low,high)
			pos(uint256) := TMP_3452(uint256)
		Expression: pos == 0
		IRs:
			TMP_3453(bool) = pos == 0
			CONDITION TMP_3453
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1174(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3454(uint256) = pos (c)- 1
			TMP_3455(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1174,TMP_3454)
			REF_1175(uint224) -> TMP_3455._value
			RETURN REF_1175
	Function Checkpoints.latest(Checkpoints.Trace224) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1176(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1177 -> LENGTH REF_1176
			pos(uint256) := REF_1177(uint256)
		Expression: pos == 0
		IRs:
			TMP_3456(bool) = pos == 0
			CONDITION TMP_3456
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1178(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3457(uint256) = pos (c)- 1
			TMP_3458(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1178,TMP_3457)
			REF_1179(uint224) -> TMP_3458._value
			RETURN REF_1179
	Function Checkpoints.latestCheckpoint(Checkpoints.Trace224) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1180(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1181 -> LENGTH REF_1180
			pos(uint256) := REF_1181(uint256)
		Expression: pos == 0
		IRs:
			TMP_3459(bool) = pos == 0
			CONDITION TMP_3459
		Expression: (false,0,0)
		IRs:
			RETURN False,0,0
		Expression: ckpt = _unsafeAccess(self._checkpoints,pos - 1)
		IRs:
			REF_1182(Checkpoints.Checkpoint224[]) -> self._checkpoints
			TMP_3460(uint256) = pos (c)- 1
			TMP_3461(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(REF_1182,TMP_3460)
			ckpt(Checkpoints.Checkpoint224) := TMP_3461(Checkpoints.Checkpoint224)
		Expression: (true,ckpt._key,ckpt._value)
		IRs:
			REF_1183(uint32) -> ckpt._key
			REF_1184(uint224) -> ckpt._value
			RETURN True,REF_1183,REF_1184
	Function Checkpoints.length(Checkpoints.Trace224) (*)
		Expression: self._checkpoints.length
		IRs:
			REF_1185(Checkpoints.Checkpoint224[]) -> self._checkpoints
			REF_1186 -> LENGTH REF_1185
			RETURN REF_1186
	Function Checkpoints._insert(Checkpoints.Checkpoint224[],uint32,uint224) (*)
		Expression: pos = self.length
		IRs:
			REF_1187 -> LENGTH self
			pos(uint256) := REF_1187(uint256)
		Expression: pos > 0
		IRs:
			TMP_3462(bool) = pos > 0
			CONDITION TMP_3462
		Expression: last = _unsafeAccess(self,pos - 1)
		IRs:
			TMP_3463(uint256) = pos (c)- 1
			TMP_3464(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(self,TMP_3463)
			last(Checkpoints.Checkpoint224) := TMP_3464(Checkpoints.Checkpoint224)
		Expression: require(bool,string)(last._key <= key,Checkpoint: decreasing keys)
		IRs:
			REF_1188(uint32) -> last._key
			TMP_3465(bool) = REF_1188 <= key
			TMP_3466(None) = SOLIDITY_CALL require(bool,string)(TMP_3465,Checkpoint: decreasing keys)
		Expression: last._key == key
		IRs:
			REF_1189(uint32) -> last._key
			TMP_3467(bool) = REF_1189 == key
			CONDITION TMP_3467
		Expression: _unsafeAccess(self,pos - 1)._value = value
		IRs:
			TMP_3468(uint256) = pos (c)- 1
			TMP_3469(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(self,TMP_3468)
			REF_1190(uint224) -> TMP_3469._value
			REF_1190(uint224) (->TMP_3469) := value(uint224)
		Expression: self.push(Checkpoint224({_key:key,_value:value}))
		IRs:
			TMP_3470(Checkpoints.Checkpoint224) = new Checkpoint224(key,value)
			REF_1192 -> LENGTH self
			TMP_3472(uint256) := REF_1192(uint256)
			TMP_3473(uint256) = TMP_3472 (c)+ 1
			REF_1192(uint256) (->self) := TMP_3473(uint256)
			REF_1193(Checkpoints.Checkpoint224) -> self[TMP_3472]
			REF_1193(Checkpoints.Checkpoint224) (->self) := TMP_3470(Checkpoints.Checkpoint224)
		Expression: (last._value,value)
		IRs:
			REF_1194(uint224) -> last._value
			RETURN REF_1194,value
		Expression: self.push(Checkpoint224({_key:key,_value:value}))
		IRs:
			TMP_3474(Checkpoints.Checkpoint224) = new Checkpoint224(key,value)
			REF_1196 -> LENGTH self
			TMP_3476(uint256) := REF_1196(uint256)
			TMP_3477(uint256) = TMP_3476 (c)+ 1
			REF_1196(uint256) (->self) := TMP_3477(uint256)
			REF_1197(Checkpoints.Checkpoint224) -> self[TMP_3476]
			REF_1197(Checkpoints.Checkpoint224) (->self) := TMP_3474(Checkpoints.Checkpoint224)
		Expression: (0,value)
		IRs:
			RETURN 0,value
	Function Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3478(bool) = low < high
			CONDITION TMP_3478
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3479(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3479(uint256)
		Expression: _unsafeAccess(self,mid)._key > key
		IRs:
			TMP_3480(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(self,mid)
			REF_1199(uint32) -> TMP_3480._key
			TMP_3481(bool) = REF_1199 > key
			CONDITION TMP_3481
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3482(uint256) = mid (c)+ 1
			low(uint256) := TMP_3482(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3483(bool) = low < high
			CONDITION TMP_3483
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3484(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3484(uint256)
		Expression: _unsafeAccess(self,mid)._key < key
		IRs:
			TMP_3485(Checkpoints.Checkpoint224) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256)(self,mid)
			REF_1201(uint32) -> TMP_3485._key
			TMP_3486(bool) = REF_1201 < key
			CONDITION TMP_3486
		Expression: low = mid + 1
		IRs:
			TMP_3487(uint256) = mid (c)+ 1
			low(uint256) := TMP_3487(uint256)
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._unsafeAccess(Checkpoints.Checkpoint224[],uint256) (*)
		Expression: mstore(uint256,uint256)(0,self)
		IRs:
			TMP_3488(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,self)
		Expression: result = keccak256(uint256,uint256)(0,0x20) + pos
		IRs:
			TMP_3489(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,32)
			TMP_3490(uint256) = TMP_3489 + pos
			result(Checkpoints.Checkpoint224) := TMP_3490(uint256)
	Function Checkpoints.push(Checkpoints.Trace160,uint96,uint160) (*)
		Expression: _insert(self._checkpoints,key,value)
		IRs:
			REF_1202(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TUPLE_50(uint160,uint160) = INTERNAL_CALL, Checkpoints._insert(Checkpoints.Checkpoint160[],uint96,uint160)(REF_1202,key,value)
			RETURN TUPLE_50
	Function Checkpoints.lowerLookup(Checkpoints.Trace160,uint96) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1203(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1204 -> LENGTH REF_1203
			len(uint256) := REF_1204(uint256)
		Expression: pos = _lowerBinaryLookup(self._checkpoints,key,0,len)
		IRs:
			REF_1205(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3491(uint256) = INTERNAL_CALL, Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256)(REF_1205,key,0,len)
			pos(uint256) := TMP_3491(uint256)
		Expression: pos == len
		IRs:
			TMP_3492(bool) = pos == len
			CONDITION TMP_3492
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos)._value
		IRs:
			REF_1206(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3493(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1206,pos)
			REF_1207(uint160) -> TMP_3493._value
			RETURN REF_1207
	Function Checkpoints.upperLookup(Checkpoints.Trace160,uint96) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1208(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1209 -> LENGTH REF_1208
			len(uint256) := REF_1209(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,0,len)
		IRs:
			REF_1210(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3494(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256)(REF_1210,key,0,len)
			pos(uint256) := TMP_3494(uint256)
		Expression: pos == 0
		IRs:
			TMP_3495(bool) = pos == 0
			CONDITION TMP_3495
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1211(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3496(uint256) = pos (c)- 1
			TMP_3497(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1211,TMP_3496)
			REF_1212(uint160) -> TMP_3497._value
			RETURN REF_1212
	Function Checkpoints.upperLookupRecent(Checkpoints.Trace160,uint96) (*)
		Expression: len = self._checkpoints.length
		IRs:
			REF_1213(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1214 -> LENGTH REF_1213
			len(uint256) := REF_1214(uint256)
		Expression: low = 0
		IRs:
			low(uint256) := 0(uint256)
		Expression: high = len
		IRs:
			high(uint256) := len(uint256)
		Expression: len > 5
		IRs:
			TMP_3498(bool) = len > 5
			CONDITION TMP_3498
		Expression: mid = len - Math.sqrt(len)
		IRs:
			TMP_3499(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['len'] 
			TMP_3500(uint256) = len (c)- TMP_3499
			mid(uint256) := TMP_3500(uint256)
		Expression: key < _unsafeAccess(self._checkpoints,mid)._key
		IRs:
			REF_1216(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3501(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1216,mid)
			REF_1217(uint96) -> TMP_3501._key
			TMP_3502(bool) = key < REF_1217
			CONDITION TMP_3502
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3503(uint256) = mid (c)+ 1
			low(uint256) := TMP_3503(uint256)
		Expression: pos = _upperBinaryLookup(self._checkpoints,key,low,high)
		IRs:
			REF_1218(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3504(uint256) = INTERNAL_CALL, Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256)(REF_1218,key,low,high)
			pos(uint256) := TMP_3504(uint256)
		Expression: pos == 0
		IRs:
			TMP_3505(bool) = pos == 0
			CONDITION TMP_3505
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1219(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3506(uint256) = pos (c)- 1
			TMP_3507(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1219,TMP_3506)
			REF_1220(uint160) -> TMP_3507._value
			RETURN REF_1220
	Function Checkpoints.latest(Checkpoints.Trace160) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1221(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1222 -> LENGTH REF_1221
			pos(uint256) := REF_1222(uint256)
		Expression: pos == 0
		IRs:
			TMP_3508(bool) = pos == 0
			CONDITION TMP_3508
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(self._checkpoints,pos - 1)._value
		IRs:
			REF_1223(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3509(uint256) = pos (c)- 1
			TMP_3510(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1223,TMP_3509)
			REF_1224(uint160) -> TMP_3510._value
			RETURN REF_1224
	Function Checkpoints.latestCheckpoint(Checkpoints.Trace160) (*)
		Expression: pos = self._checkpoints.length
		IRs:
			REF_1225(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1226 -> LENGTH REF_1225
			pos(uint256) := REF_1226(uint256)
		Expression: pos == 0
		IRs:
			TMP_3511(bool) = pos == 0
			CONDITION TMP_3511
		Expression: (false,0,0)
		IRs:
			RETURN False,0,0
		Expression: ckpt = _unsafeAccess(self._checkpoints,pos - 1)
		IRs:
			REF_1227(Checkpoints.Checkpoint160[]) -> self._checkpoints
			TMP_3512(uint256) = pos (c)- 1
			TMP_3513(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(REF_1227,TMP_3512)
			ckpt(Checkpoints.Checkpoint160) := TMP_3513(Checkpoints.Checkpoint160)
		Expression: (true,ckpt._key,ckpt._value)
		IRs:
			REF_1228(uint96) -> ckpt._key
			REF_1229(uint160) -> ckpt._value
			RETURN True,REF_1228,REF_1229
	Function Checkpoints.length(Checkpoints.Trace160) (*)
		Expression: self._checkpoints.length
		IRs:
			REF_1230(Checkpoints.Checkpoint160[]) -> self._checkpoints
			REF_1231 -> LENGTH REF_1230
			RETURN REF_1231
	Function Checkpoints._insert(Checkpoints.Checkpoint160[],uint96,uint160) (*)
		Expression: pos = self.length
		IRs:
			REF_1232 -> LENGTH self
			pos(uint256) := REF_1232(uint256)
		Expression: pos > 0
		IRs:
			TMP_3514(bool) = pos > 0
			CONDITION TMP_3514
		Expression: last = _unsafeAccess(self,pos - 1)
		IRs:
			TMP_3515(uint256) = pos (c)- 1
			TMP_3516(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(self,TMP_3515)
			last(Checkpoints.Checkpoint160) := TMP_3516(Checkpoints.Checkpoint160)
		Expression: require(bool,string)(last._key <= key,Checkpoint: decreasing keys)
		IRs:
			REF_1233(uint96) -> last._key
			TMP_3517(bool) = REF_1233 <= key
			TMP_3518(None) = SOLIDITY_CALL require(bool,string)(TMP_3517,Checkpoint: decreasing keys)
		Expression: last._key == key
		IRs:
			REF_1234(uint96) -> last._key
			TMP_3519(bool) = REF_1234 == key
			CONDITION TMP_3519
		Expression: _unsafeAccess(self,pos - 1)._value = value
		IRs:
			TMP_3520(uint256) = pos (c)- 1
			TMP_3521(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(self,TMP_3520)
			REF_1235(uint160) -> TMP_3521._value
			REF_1235(uint160) (->TMP_3521) := value(uint160)
		Expression: self.push(Checkpoint160({_key:key,_value:value}))
		IRs:
			TMP_3522(Checkpoints.Checkpoint160) = new Checkpoint160(key,value)
			REF_1237 -> LENGTH self
			TMP_3524(uint256) := REF_1237(uint256)
			TMP_3525(uint256) = TMP_3524 (c)+ 1
			REF_1237(uint256) (->self) := TMP_3525(uint256)
			REF_1238(Checkpoints.Checkpoint160) -> self[TMP_3524]
			REF_1238(Checkpoints.Checkpoint160) (->self) := TMP_3522(Checkpoints.Checkpoint160)
		Expression: (last._value,value)
		IRs:
			REF_1239(uint160) -> last._value
			RETURN REF_1239,value
		Expression: self.push(Checkpoint160({_key:key,_value:value}))
		IRs:
			TMP_3526(Checkpoints.Checkpoint160) = new Checkpoint160(key,value)
			REF_1241 -> LENGTH self
			TMP_3528(uint256) := REF_1241(uint256)
			TMP_3529(uint256) = TMP_3528 (c)+ 1
			REF_1241(uint256) (->self) := TMP_3529(uint256)
			REF_1242(Checkpoints.Checkpoint160) -> self[TMP_3528]
			REF_1242(Checkpoints.Checkpoint160) (->self) := TMP_3526(Checkpoints.Checkpoint160)
		Expression: (0,value)
		IRs:
			RETURN 0,value
	Function Checkpoints._upperBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3530(bool) = low < high
			CONDITION TMP_3530
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3531(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3531(uint256)
		Expression: _unsafeAccess(self,mid)._key > key
		IRs:
			TMP_3532(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(self,mid)
			REF_1244(uint96) -> TMP_3532._key
			TMP_3533(bool) = REF_1244 > key
			CONDITION TMP_3533
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_3534(uint256) = mid (c)+ 1
			low(uint256) := TMP_3534(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._lowerBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256) (*)
		Expression: low < high
		IRs:
			TMP_3535(bool) = low < high
			CONDITION TMP_3535
		Expression: mid = Math.average(low,high)
		IRs:
			TMP_3536(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid(uint256) := TMP_3536(uint256)
		Expression: _unsafeAccess(self,mid)._key < key
		IRs:
			TMP_3537(Checkpoints.Checkpoint160) = INTERNAL_CALL, Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256)(self,mid)
			REF_1246(uint96) -> TMP_3537._key
			TMP_3538(bool) = REF_1246 < key
			CONDITION TMP_3538
		Expression: low = mid + 1
		IRs:
			TMP_3539(uint256) = mid (c)+ 1
			low(uint256) := TMP_3539(uint256)
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: high
		IRs:
			RETURN high
	Function Checkpoints._unsafeAccess(Checkpoints.Checkpoint160[],uint256) (*)
		Expression: mstore(uint256,uint256)(0,self)
		IRs:
			TMP_3540(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,self)
		Expression: result = keccak256(uint256,uint256)(0,0x20) + pos
		IRs:
			TMP_3541(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,32)
			TMP_3542(uint256) = TMP_3541 + pos
			result(Checkpoints.Checkpoint160) := TMP_3542(uint256)
Contract Context
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
Contract Counters
	Function Counters.current(Counters.Counter) (*)
		Expression: counter._value
		IRs:
			REF_1247(uint256) -> counter._value
			RETURN REF_1247
	Function Counters.increment(Counters.Counter) (*)
		Expression: counter._value += 1
		IRs:
			REF_1248(uint256) -> counter._value
			REF_1248(-> counter) = REF_1248 + 1
	Function Counters.decrement(Counters.Counter) (*)
		Expression: value = counter._value
		IRs:
			REF_1249(uint256) -> counter._value
			value(uint256) := REF_1249(uint256)
		Expression: require(bool,string)(value > 0,Counter: decrement overflow)
		IRs:
			TMP_3543(bool) = value > 0
			TMP_3544(None) = SOLIDITY_CALL require(bool,string)(TMP_3543,Counter: decrement overflow)
		Expression: counter._value = value - 1
		IRs:
			REF_1250(uint256) -> counter._value
			TMP_3545(uint256) = value - 1
			REF_1250(uint256) (->counter) := TMP_3545(uint256)
	Function Counters.reset(Counters.Counter) (*)
		Expression: counter._value = 0
		IRs:
			REF_1251(uint256) -> counter._value
			REF_1251(uint256) (->counter) := 0(uint256)
Contract ShortStrings
	Function ShortStrings.toShortString(string) (*)
		Expression: bstr = bytes(str)
		IRs:
			TMP_3546 = CONVERT str to bytes
			bstr(bytes) := TMP_3546(bytes)
		Expression: bstr.length > 31
		IRs:
			REF_1252 -> LENGTH bstr
			TMP_3547(bool) = REF_1252 > 31
			CONDITION TMP_3547
		Expression: revert StringTooLong(string)(str)
		IRs:
			TMP_3548(None) = SOLIDITY_CALL revert StringTooLong(string)(str)
		Expression: ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length))
		IRs:
			TMP_3549 = CONVERT bstr to bytes32
			TMP_3550 = CONVERT TMP_3549 to uint256
			REF_1253 -> LENGTH bstr
			TMP_3551(uint256) = TMP_3550 | REF_1253
			TMP_3552 = CONVERT TMP_3551 to bytes32
			TMP_3553 = CONVERT TMP_3552 to ShortString
			RETURN TMP_3553
	Function ShortStrings.toString(ShortString) (*)
		Expression: len = byteLength(sstr)
		IRs:
			TMP_3554(uint256) = INTERNAL_CALL, ShortStrings.byteLength(ShortString)(sstr)
			len(uint256) := TMP_3554(uint256)
		Expression: str = new string(32)
		IRs:
			TMP_3556 = new string(32)
			str(string) := TMP_3556(string)
		Expression: mstore(uint256,uint256)(str,len)
		IRs:
			TMP_3557(None) = SOLIDITY_CALL mstore(uint256,uint256)(str,len)
		Expression: mstore(uint256,uint256)(str + 0x20,sstr)
		IRs:
			TMP_3558(string) = str + 32
			TMP_3559(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3558,sstr)
		Expression: str
		IRs:
			RETURN str
	Function ShortStrings.byteLength(ShortString) (*)
		Expression: result = uint256(ShortString.unwrap(sstr)) & 0xFF
		IRs:
			TMP_3560 = CONVERT sstr to bytes32
			TMP_3561 = CONVERT TMP_3560 to uint256
			TMP_3562(uint256) = TMP_3561 & 255
			result(uint256) := TMP_3562(uint256)
		Expression: result > 31
		IRs:
			TMP_3563(bool) = result > 31
			CONDITION TMP_3563
		Expression: revert InvalidShortString()()
		IRs:
			TMP_3564(None) = SOLIDITY_CALL revert InvalidShortString()()
		Expression: result
		IRs:
			RETURN result
	Function ShortStrings.toShortStringWithFallback(string,string) (*)
		Expression: bytes(value).length < 32
		IRs:
			TMP_3565 = CONVERT value to bytes
			REF_1254 -> LENGTH TMP_3565
			TMP_3566(bool) = REF_1254 < 32
			CONDITION TMP_3566
		Expression: toShortString(value)
		IRs:
			TMP_3567(ShortString) = INTERNAL_CALL, ShortStrings.toShortString(string)(value)
			RETURN TMP_3567
		Expression: StorageSlot.getStringSlot(store).value = value
		IRs:
			TMP_3568(StorageSlot.StringSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getStringSlot(string), arguments:['store'] 
			REF_1256(string) -> TMP_3568.value
			REF_1256(string) (->TMP_3568) := value(string)
		Expression: ShortString.wrap(_FALLBACK_SENTINEL)
		IRs:
			TMP_3569 = CONVERT _FALLBACK_SENTINEL to ShortString
			RETURN TMP_3569
	Function ShortStrings.toStringWithFallback(ShortString,string) (*)
		Expression: ShortString.unwrap(value) != _FALLBACK_SENTINEL
		IRs:
			TMP_3570 = CONVERT value to bytes32
			TMP_3571(bool) = TMP_3570 != _FALLBACK_SENTINEL
			CONDITION TMP_3571
		Expression: toString(value)
		IRs:
			TMP_3572(string) = INTERNAL_CALL, ShortStrings.toString(ShortString)(value)
			RETURN TMP_3572
		Expression: store
		IRs:
			RETURN store
	Function ShortStrings.byteLengthWithFallback(ShortString,string) (*)
		Expression: ShortString.unwrap(value) != _FALLBACK_SENTINEL
		IRs:
			TMP_3573 = CONVERT value to bytes32
			TMP_3574(bool) = TMP_3573 != _FALLBACK_SENTINEL
			CONDITION TMP_3574
		Expression: byteLength(value)
		IRs:
			TMP_3575(uint256) = INTERNAL_CALL, ShortStrings.byteLength(ShortString)(value)
			RETURN TMP_3575
		Expression: bytes(store).length
		IRs:
			TMP_3576 = CONVERT store to bytes
			REF_1257 -> LENGTH TMP_3576
			RETURN REF_1257
	Function ShortStrings.slitherConstructorConstantVariables() (*)
		Expression: _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF
		IRs:
			_FALLBACK_SENTINEL(bytes32) := 255(uint256)
Contract StorageSlot
	Function StorageSlot.getAddressSlot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.AddressSlot) := slot(bytes32)
	Function StorageSlot.getBooleanSlot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.BooleanSlot) := slot(bytes32)
	Function StorageSlot.getBytes32Slot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.Bytes32Slot) := slot(bytes32)
	Function StorageSlot.getUint256Slot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.Uint256Slot) := slot(bytes32)
	Function StorageSlot.getStringSlot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.StringSlot) := slot(bytes32)
	Function StorageSlot.getStringSlot(string) (*)
		Expression: r = store
		IRs:
			r(StorageSlot.StringSlot) := store(string)
	Function StorageSlot.getBytesSlot(bytes32) (*)
		Expression: r = slot
		IRs:
			r(StorageSlot.BytesSlot) := slot(bytes32)
	Function StorageSlot.getBytesSlot(bytes) (*)
		Expression: r = store
		IRs:
			r(StorageSlot.BytesSlot) := store(bytes)
Contract Strings
	Function Strings.toString(uint256) (*)
		Expression: length = Math.log10(value) + 1
		IRs:
			TMP_3577(uint256) = LIBRARY_CALL, dest:Math, function:Math.log10(uint256), arguments:['value'] 
			TMP_3578(uint256) = TMP_3577 + 1
			length(uint256) := TMP_3578(uint256)
		Expression: buffer = new string(length)
		IRs:
			TMP_3580 = new string(length)
			buffer(string) := TMP_3580(string)
		Expression: ptr = buffer + 32 + length
		IRs:
			TMP_3581(uint256) = 32 + length
			TMP_3582(string) = buffer + TMP_3581
			ptr(uint256) := TMP_3582(string)
		Expression: true
		IRs:
			CONDITION True
		Expression: ptr --
		IRs:
			TMP_3583(uint256) := ptr(uint256)
			ptr(uint256) = ptr - 1
		Expression: mstore8(uint256,uint256)(ptr,byte(uint256,uint256)(value % 10,_SYMBOLS))
		IRs:
			TMP_3584(uint256) = value % 10
			TMP_3585(uint256) = SOLIDITY_CALL byte(uint256,uint256)(TMP_3584,_SYMBOLS)
			TMP_3586(None) = SOLIDITY_CALL mstore8(uint256,uint256)(ptr,TMP_3585)
		Expression: value /= 10
		IRs:
			value(uint256) = value / 10
		Expression: value == 0
		IRs:
			TMP_3587(bool) = value == 0
			CONDITION TMP_3587
		Expression: buffer
		IRs:
			RETURN buffer
	Function Strings.toString(int256) (*)
		Expression: value < 0
		IRs:
			TMP_3588(bool) = value < 0
			CONDITION TMP_3588
		Expression: string(abi.encodePacked(-,toString(SignedMath.abs(value))))
		IRs:
			TMP_3589(uint256) = LIBRARY_CALL, dest:SignedMath, function:SignedMath.abs(int256), arguments:['value'] 
			TMP_3590(string) = INTERNAL_CALL, Strings.toString(uint256)(TMP_3589)
			TMP_3591(bytes) = SOLIDITY_CALL abi.encodePacked()(-,TMP_3590)
			TMP_3592 = CONVERT TMP_3591 to string
			RETURN TMP_3592
		Expression: string(abi.encodePacked(,toString(SignedMath.abs(value))))
		IRs:
			TMP_3593(uint256) = LIBRARY_CALL, dest:SignedMath, function:SignedMath.abs(int256), arguments:['value'] 
			TMP_3594(string) = INTERNAL_CALL, Strings.toString(uint256)(TMP_3593)
			TMP_3595(bytes) = SOLIDITY_CALL abi.encodePacked()(,TMP_3594)
			TMP_3596 = CONVERT TMP_3595 to string
			RETURN TMP_3596
	Function Strings.toHexString(uint256) (*)
		Expression: toHexString(value,Math.log256(value) + 1)
		IRs:
			TMP_3597(uint256) = LIBRARY_CALL, dest:Math, function:Math.log256(uint256), arguments:['value'] 
			TMP_3598(uint256) = TMP_3597 + 1
			TMP_3599(string) = INTERNAL_CALL, Strings.toHexString(uint256,uint256)(value,TMP_3598)
			RETURN TMP_3599
	Function Strings.toHexString(uint256,uint256) (*)
		Expression: buffer = new bytes(2 * length + 2)
		IRs:
			TMP_3601(uint256) = 2 (c)* length
			TMP_3602(uint256) = TMP_3601 (c)+ 2
			TMP_3603 = new bytes(TMP_3602)
			buffer(bytes) := TMP_3603(bytes)
		Expression: buffer[0] = 0
		IRs:
			REF_1264(string) -> buffer[0]
			REF_1264(string) (->buffer) := 0(string)
		Expression: buffer[1] = x
		IRs:
			REF_1265(string) -> buffer[1]
			REF_1265(string) (->buffer) := x(string)
		Expression: i = 2 * length + 1
		IRs:
			TMP_3604(uint256) = 2 (c)* length
			TMP_3605(uint256) = TMP_3604 (c)+ 1
			i(uint256) := TMP_3605(uint256)
		Expression: i > 1
		IRs:
			TMP_3606(bool) = i > 1
			CONDITION TMP_3606
		Expression: buffer[i] = _SYMBOLS[value & 0xf]
		IRs:
			REF_1266(None) -> buffer[i]
			TMP_3607(uint256) = value & 15
			REF_1267(None) -> _SYMBOLS[TMP_3607]
			REF_1266(None) (->buffer) := REF_1267(None)
		Expression: value >>= 4
		IRs:
			value(uint256) = value >> 4
		Expression: -- i
		IRs:
			i(uint256) = i (c)- 1
		Expression: require(bool,string)(value == 0,Strings: hex length insufficient)
		IRs:
			TMP_3608(bool) = value == 0
			TMP_3609(None) = SOLIDITY_CALL require(bool,string)(TMP_3608,Strings: hex length insufficient)
		Expression: string(buffer)
		IRs:
			TMP_3610 = CONVERT buffer to string
			RETURN TMP_3610
	Function Strings.toHexString(address) (*)
		Expression: toHexString(uint256(uint160(addr)),_ADDRESS_LENGTH)
		IRs:
			TMP_3611 = CONVERT addr to uint160
			TMP_3612 = CONVERT TMP_3611 to uint256
			TMP_3613(string) = INTERNAL_CALL, Strings.toHexString(uint256,uint256)(TMP_3612,_ADDRESS_LENGTH)
			RETURN TMP_3613
	Function Strings.equal(string,string) (*)
		Expression: keccak256(bytes)(bytes(a)) == keccak256(bytes)(bytes(b))
		IRs:
			TMP_3614 = CONVERT a to bytes
			TMP_3615(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3614)
			TMP_3616 = CONVERT b to bytes
			TMP_3617(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3616)
			TMP_3618(bool) = TMP_3615 == TMP_3617
			RETURN TMP_3618
	Function Strings.slitherConstructorConstantVariables() (*)
		Expression: _SYMBOLS = 0123456789abcdef
		IRs:
			_SYMBOLS(bytes16) := 0123456789abcdef(string)
		Expression: _ADDRESS_LENGTH = 20
		IRs:
			_ADDRESS_LENGTH(uint8) := 20(uint256)
Contract ECDSA
	Function ECDSA._throwError(ECDSA.RecoverError) (*)
		Expression: error == RecoverError.NoError
		IRs:
			REF_1268(ECDSA.RecoverError) -> RecoverError.NoError
			TMP_3619(bool) = error == REF_1268
			CONDITION TMP_3619
		Expression: error == RecoverError.InvalidSignature
		IRs:
			REF_1269(ECDSA.RecoverError) -> RecoverError.InvalidSignature
			TMP_3620(bool) = error == REF_1269
			CONDITION TMP_3620
		Expression: revert(string)(ECDSA: invalid signature)
		IRs:
			TMP_3621(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature)
		Expression: error == RecoverError.InvalidSignatureLength
		IRs:
			REF_1270(ECDSA.RecoverError) -> RecoverError.InvalidSignatureLength
			TMP_3622(bool) = error == REF_1270
			CONDITION TMP_3622
		Expression: revert(string)(ECDSA: invalid signature length)
		IRs:
			TMP_3623(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature length)
		Expression: error == RecoverError.InvalidSignatureS
		IRs:
			REF_1271(ECDSA.RecoverError) -> RecoverError.InvalidSignatureS
			TMP_3624(bool) = error == REF_1271
			CONDITION TMP_3624
		Expression: revert(string)(ECDSA: invalid signature 's' value)
		IRs:
			TMP_3625(None) = SOLIDITY_CALL revert(string)(ECDSA: invalid signature 's' value)
	Function ECDSA.tryRecover(bytes32,bytes) (*)
		Expression: signature.length == 65
		IRs:
			REF_1272 -> LENGTH signature
			TMP_3626(bool) = REF_1272 == 65
			CONDITION TMP_3626
		Expression: r = mload(uint256)(signature + 0x20)
		IRs:
			TMP_3627(bytes) = signature + 32
			TMP_3628(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3627)
			r(bytes32) := TMP_3628(uint256)
		Expression: s = mload(uint256)(signature + 0x40)
		IRs:
			TMP_3629(bytes) = signature + 64
			TMP_3630(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3629)
			s(bytes32) := TMP_3630(uint256)
		Expression: v = byte(uint256,uint256)(0,mload(uint256)(signature + 0x60))
		IRs:
			TMP_3631(bytes) = signature + 96
			TMP_3632(uint256) = SOLIDITY_CALL mload(uint256)(TMP_3631)
			TMP_3633(uint256) = SOLIDITY_CALL byte(uint256,uint256)(0,TMP_3632)
			v(uint8) := TMP_3633(uint256)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_51(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			RETURN TUPLE_51
		Expression: (address(0),RecoverError.InvalidSignatureLength)
		IRs:
			TMP_3634 = CONVERT 0 to address
			REF_1273(ECDSA.RecoverError) -> RecoverError.InvalidSignatureLength
			RETURN TMP_3634,REF_1273
	Function ECDSA.recover(bytes32,bytes) (*)
		Expression: (recovered,error) = tryRecover(hash,signature)
		IRs:
			TUPLE_52(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,bytes)(hash,signature)
			recovered(address)= UNPACK TUPLE_52 index: 0 
			error(ECDSA.RecoverError)= UNPACK TUPLE_52 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSA.tryRecover(bytes32,bytes32,bytes32) (*)
		Expression: s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
		IRs:
			TMP_3636 = CONVERT 57896044618658097711785492504343953926634992332820282019728792003956564819967 to bytes32
			TMP_3637(bytes32) = vs & TMP_3636
			s(bytes32) := TMP_3637(bytes32)
		Expression: v = uint8((uint256(vs) >> 255) + 27)
		IRs:
			TMP_3638 = CONVERT vs to uint256
			TMP_3639(uint256) = TMP_3638 >> 255
			TMP_3640(uint256) = TMP_3639 (c)+ 27
			TMP_3641 = CONVERT TMP_3640 to uint8
			v(uint8) := TMP_3641(uint8)
		Expression: tryRecover(hash,v,r,s)
		IRs:
			TUPLE_53(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			RETURN TUPLE_53
	Function ECDSA.recover(bytes32,bytes32,bytes32) (*)
		Expression: (recovered,error) = tryRecover(hash,r,vs)
		IRs:
			TUPLE_54(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,bytes32,bytes32)(hash,r,vs)
			recovered(address)= UNPACK TUPLE_54 index: 0 
			error(ECDSA.RecoverError)= UNPACK TUPLE_54 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32) (*)
		Expression: uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
		IRs:
			TMP_3643 = CONVERT s to uint256
			TMP_3644(bool) = TMP_3643 > 57896044618658097711785492504343953926418782139537452191302581570759080747168
			CONDITION TMP_3644
		Expression: (address(0),RecoverError.InvalidSignatureS)
		IRs:
			TMP_3645 = CONVERT 0 to address
			REF_1274(ECDSA.RecoverError) -> RecoverError.InvalidSignatureS
			RETURN TMP_3645,REF_1274
		Expression: signer = ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
		IRs:
			TMP_3646(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			signer(address) := TMP_3646(address)
		Expression: signer == address(0)
		IRs:
			TMP_3647 = CONVERT 0 to address
			TMP_3648(bool) = signer == TMP_3647
			CONDITION TMP_3648
		Expression: (address(0),RecoverError.InvalidSignature)
		IRs:
			TMP_3649 = CONVERT 0 to address
			REF_1275(ECDSA.RecoverError) -> RecoverError.InvalidSignature
			RETURN TMP_3649,REF_1275
		Expression: (signer,RecoverError.NoError)
		IRs:
			REF_1276(ECDSA.RecoverError) -> RecoverError.NoError
			RETURN signer,REF_1276
	Function ECDSA.recover(bytes32,uint8,bytes32,bytes32) (*)
		Expression: (recovered,error) = tryRecover(hash,v,r,s)
		IRs:
			TUPLE_55(address,ECDSA.RecoverError) = INTERNAL_CALL, ECDSA.tryRecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
			recovered(address)= UNPACK TUPLE_55 index: 0 
			error(ECDSA.RecoverError)= UNPACK TUPLE_55 index: 1 
		Expression: _throwError(error)
		IRs:
			INTERNAL_CALL, ECDSA._throwError(ECDSA.RecoverError)(error)
		Expression: recovered
		IRs:
			RETURN recovered
	Function ECDSA.toEthSignedMessageHash(bytes32) (*)
		Expression: mstore(uint256,uint256)(0x00,Ethereum Signed Message:
32)
		IRs:
			TMP_3651(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,Ethereum Signed Message:
32)
		Expression: mstore(uint256,uint256)(0x1c,hash)
		IRs:
			TMP_3652(None) = SOLIDITY_CALL mstore(uint256,uint256)(28,hash)
		Expression: message = keccak256(uint256,uint256)(0x00,0x3c)
		IRs:
			TMP_3653(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,60)
			message(bytes32) := TMP_3653(uint256)
	Function ECDSA.toEthSignedMessageHash(bytes) (*)
		Expression: keccak256(bytes)(abi.encodePacked(Ethereum Signed Message:
,Strings.toString(s.length),s))
		IRs:
			REF_1279 -> LENGTH s
			TMP_3654(string) = LIBRARY_CALL, dest:Strings, function:Strings.toString(uint256), arguments:['REF_1279'] 
			TMP_3655(bytes) = SOLIDITY_CALL abi.encodePacked()(Ethereum Signed Message:
,TMP_3654,s)
			TMP_3656(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3655)
			RETURN TMP_3656
	Function ECDSA.toTypedDataHash(bytes32,bytes32) (*)
		Expression: ptr_toTypedDataHash_asm_0 = mload(uint256)(0x40)
		IRs:
			TMP_3657(uint256) = SOLIDITY_CALL mload(uint256)(64)
			ptr_toTypedDataHash_asm_0(uint256) := TMP_3657(uint256)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,)
		IRs:
			TMP_3658(None) = SOLIDITY_CALL mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0,)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x02,domainSeparator)
		IRs:
			TMP_3659(uint256) = ptr_toTypedDataHash_asm_0 + 2
			TMP_3660(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3659,domainSeparator)
		Expression: mstore(uint256,uint256)(ptr_toTypedDataHash_asm_0 + 0x22,structHash)
		IRs:
			TMP_3661(uint256) = ptr_toTypedDataHash_asm_0 + 34
			TMP_3662(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_3661,structHash)
		Expression: data = keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,0x42)
		IRs:
			TMP_3663(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(ptr_toTypedDataHash_asm_0,66)
			data(bytes32) := TMP_3663(uint256)
	Function ECDSA.toDataWithIntendedValidatorHash(address,bytes) (*)
		Expression: keccak256(bytes)(abi.encodePacked( ,validator,data))
		IRs:
			TMP_3664(bytes) = SOLIDITY_CALL abi.encodePacked()( ,validator,data)
			TMP_3665(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3664)
			RETURN TMP_3665
Contract EIP712
	Function IERC5267.eip712Domain() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_3666(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_3666(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_3667(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_3667(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_3668 = CONVERT name to bytes
			TMP_3669(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3668)
			_hashedName(bytes32) := TMP_3669(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_3670 = CONVERT version to bytes
			TMP_3671(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3670)
			_hashedVersion(bytes32) := TMP_3671(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_3672(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_3672(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_3673 = CONVERT this to address
			_cachedThis(address) := TMP_3673(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_3674 = CONVERT this to address
			TMP_3675(bool) = TMP_3674 == _cachedThis
			TMP_3676(bool) = block.chainid == _cachedChainId
			TMP_3677(bool) = TMP_3675 && TMP_3676
			CONDITION TMP_3677
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_3678(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_3678
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_3679 = CONVERT this to address
			TMP_3680(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_3679)
			TMP_3681(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_3680)
			RETURN TMP_3681
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_3682(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_3683(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_3682', 'structHash'] 
			RETURN TMP_3683
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_3684(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_3685(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_3686 = CONVERT this to address
			TMP_3687 = CONVERT 0 to bytes32
			TMP_3689(uint256[])  = new uint256[](0)
			RETURN ,TMP_3684,TMP_3685,block.chainid,TMP_3686,TMP_3687,TMP_3689
	Function EIP712.slitherConstructorConstantVariables() (*)
		Expression: _TYPE_HASH = keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
		IRs:
			TMP_3690(bytes32) = SOLIDITY_CALL keccak256(bytes)(EIP712Domain(string name,string version,uint256 chainId,address verifyingContract))
			_TYPE_HASH(bytes32) := TMP_3690(bytes32)
Contract ERC165
	Function IERC165.supportsInterface(bytes4) 
	Function ERC165.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_3691(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_1287(bytes4) (->None) := 33540519(bytes4)
			TMP_3692(bool) = interfaceId == REF_1287
			RETURN TMP_3692
Contract IERC165
	Function IERC165.supportsInterface(bytes4) (*)
Contract Math
	Function Math.max(uint256,uint256) (*)
		Expression: a > b
		IRs:
			TMP_3693(bool) = a > b
			CONDITION TMP_3693
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function Math.min(uint256,uint256) (*)
		Expression: a < b
		IRs:
			TMP_3694(bool) = a < b
			CONDITION TMP_3694
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function Math.average(uint256,uint256) (*)
		Expression: (a & b) + (a ^ b) / 2
		IRs:
			TMP_3695(uint256) = a & b
			TMP_3696(uint256) = a ^ b
			TMP_3697(uint256) = TMP_3696 (c)/ 2
			TMP_3698(uint256) = TMP_3695 (c)+ TMP_3697
			RETURN TMP_3698
	Function Math.ceilDiv(uint256,uint256) (*)
		Expression: a == 0
		IRs:
			TMP_3699(bool) = a == 0
			CONDITION TMP_3699
		Expression: 0
		IRs:
			RETURN 0
		Expression: (a - 1) / b + 1
		IRs:
			TMP_3700(uint256) = a (c)- 1
			TMP_3701(uint256) = TMP_3700 (c)/ b
			TMP_3702(uint256) = TMP_3701 (c)+ 1
			RETURN TMP_3702
	Function Math.mulDiv(uint256,uint256,uint256) (*)
		Expression: mm_mulDiv_asm_0 = mulmod(uint256,uint256,uint256)(x,y,~ 0)
		IRs:
			TMP_3703 = UnaryType.TILD 0 
			TMP_3704(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,TMP_3703)
			mm_mulDiv_asm_0(uint256) := TMP_3704(uint256)
		Expression: prod0 = x * y
		IRs:
			TMP_3705(uint256) = x * y
			prod0(uint256) := TMP_3705(uint256)
		Expression: prod1 = mm_mulDiv_asm_0 - prod0 - mm_mulDiv_asm_0 < prod0
		IRs:
			TMP_3706(uint256) = mm_mulDiv_asm_0 - prod0
			TMP_3707(bool) = mm_mulDiv_asm_0 < prod0
			TMP_3708(uint256) = TMP_3706 - TMP_3707
			prod1(uint256) := TMP_3708(uint256)
		Expression: prod1 == 0
		IRs:
			TMP_3709(bool) = prod1 == 0
			CONDITION TMP_3709
		Expression: prod0 / denominator
		IRs:
			TMP_3710(uint256) = prod0 / denominator
			RETURN TMP_3710
		Expression: require(bool,string)(denominator > prod1,Math: mulDiv overflow)
		IRs:
			TMP_3711(bool) = denominator > prod1
			TMP_3712(None) = SOLIDITY_CALL require(bool,string)(TMP_3711,Math: mulDiv overflow)
		Expression: remainder = mulmod(uint256,uint256,uint256)(x,y,denominator)
		IRs:
			TMP_3713(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,denominator)
			remainder(uint256) := TMP_3713(uint256)
		Expression: prod1 = prod1 - remainder > prod0
		IRs:
			TMP_3714(bool) = remainder > prod0
			TMP_3715(uint256) = prod1 - TMP_3714
			prod1(uint256) := TMP_3715(uint256)
		Expression: prod0 = prod0 - remainder
		IRs:
			TMP_3716(uint256) = prod0 - remainder
			prod0(uint256) := TMP_3716(uint256)
		Expression: twos = denominator & (~ denominator + 1)
		IRs:
			TMP_3717 = UnaryType.TILD denominator 
			TMP_3718(uint256) = TMP_3717 + 1
			TMP_3719(uint256) = denominator & TMP_3718
			twos(uint256) := TMP_3719(uint256)
		Expression: denominator = denominator / twos
		IRs:
			TMP_3720(uint256) = denominator / twos
			denominator(uint256) := TMP_3720(uint256)
		Expression: prod0 = prod0 / twos
		IRs:
			TMP_3721(uint256) = prod0 / twos
			prod0(uint256) := TMP_3721(uint256)
		Expression: twos = 0 - twos / twos + 1
		IRs:
			TMP_3722(uint256) = 0 - twos
			TMP_3723(uint256) = TMP_3722 / twos
			TMP_3724(uint256) = TMP_3723 + 1
			twos(uint256) := TMP_3724(uint256)
		Expression: prod0 |= prod1 * twos
		IRs:
			TMP_3725(uint256) = prod1 * twos
			prod0(uint256) = prod0 | TMP_3725
		Expression: inverse = (3 * denominator) ^ 2
		IRs:
			TMP_3726(uint256) = 3 * denominator
			TMP_3727(uint256) = TMP_3726 ^ 2
			inverse(uint256) := TMP_3727(uint256)
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3728(uint256) = denominator * inverse
			TMP_3729(uint256) = 2 - TMP_3728
			inverse(uint256) = inverse * TMP_3729
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3730(uint256) = denominator * inverse
			TMP_3731(uint256) = 2 - TMP_3730
			inverse(uint256) = inverse * TMP_3731
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3732(uint256) = denominator * inverse
			TMP_3733(uint256) = 2 - TMP_3732
			inverse(uint256) = inverse * TMP_3733
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3734(uint256) = denominator * inverse
			TMP_3735(uint256) = 2 - TMP_3734
			inverse(uint256) = inverse * TMP_3735
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3736(uint256) = denominator * inverse
			TMP_3737(uint256) = 2 - TMP_3736
			inverse(uint256) = inverse * TMP_3737
		Expression: inverse *= 2 - denominator * inverse
		IRs:
			TMP_3738(uint256) = denominator * inverse
			TMP_3739(uint256) = 2 - TMP_3738
			inverse(uint256) = inverse * TMP_3739
		Expression: result = prod0 * inverse
		IRs:
			TMP_3740(uint256) = prod0 * inverse
			result(uint256) := TMP_3740(uint256)
		Expression: result
		IRs:
			RETURN result
	Function Math.mulDiv(uint256,uint256,uint256,Math.Rounding) (*)
		Expression: result = mulDiv(x,y,denominator)
		IRs:
			TMP_3741(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x,y,denominator)
			result(uint256) := TMP_3741(uint256)
		Expression: rounding == Rounding.Up && mulmod(uint256,uint256,uint256)(x,y,denominator) > 0
		IRs:
			REF_1288(Math.Rounding) -> Rounding.Up
			TMP_3742(bool) = rounding == REF_1288
			TMP_3743(uint256) = SOLIDITY_CALL mulmod(uint256,uint256,uint256)(x,y,denominator)
			TMP_3744(bool) = TMP_3743 > 0
			TMP_3745(bool) = TMP_3742 && TMP_3744
			CONDITION TMP_3745
		Expression: result += 1
		IRs:
			result(uint256) = result (c)+ 1
		Expression: result
		IRs:
			RETURN result
	Function Math.sqrt(uint256) (*)
		Expression: a == 0
		IRs:
			TMP_3746(bool) = a == 0
			CONDITION TMP_3746
		Expression: 0
		IRs:
			RETURN 0
		Expression: result = 1 << (log2(a) >> 1)
		IRs:
			TMP_3747(uint256) = INTERNAL_CALL, Math.log2(uint256)(a)
			TMP_3748(uint256) = TMP_3747 >> 1
			TMP_3749(uint256) = 1 << TMP_3748
			result(uint256) := TMP_3749(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3750(uint256) = a / result
			TMP_3751(uint256) = result + TMP_3750
			TMP_3752(uint256) = TMP_3751 >> 1
			result(uint256) := TMP_3752(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3753(uint256) = a / result
			TMP_3754(uint256) = result + TMP_3753
			TMP_3755(uint256) = TMP_3754 >> 1
			result(uint256) := TMP_3755(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3756(uint256) = a / result
			TMP_3757(uint256) = result + TMP_3756
			TMP_3758(uint256) = TMP_3757 >> 1
			result(uint256) := TMP_3758(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3759(uint256) = a / result
			TMP_3760(uint256) = result + TMP_3759
			TMP_3761(uint256) = TMP_3760 >> 1
			result(uint256) := TMP_3761(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3762(uint256) = a / result
			TMP_3763(uint256) = result + TMP_3762
			TMP_3764(uint256) = TMP_3763 >> 1
			result(uint256) := TMP_3764(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3765(uint256) = a / result
			TMP_3766(uint256) = result + TMP_3765
			TMP_3767(uint256) = TMP_3766 >> 1
			result(uint256) := TMP_3767(uint256)
		Expression: result = (result + a / result) >> 1
		IRs:
			TMP_3768(uint256) = a / result
			TMP_3769(uint256) = result + TMP_3768
			TMP_3770(uint256) = TMP_3769 >> 1
			result(uint256) := TMP_3770(uint256)
		Expression: min(result,a / result)
		IRs:
			TMP_3771(uint256) = a / result
			TMP_3772(uint256) = INTERNAL_CALL, Math.min(uint256,uint256)(result,TMP_3771)
			RETURN TMP_3772
	Function Math.sqrt(uint256,Math.Rounding) (*)
		Expression: result = sqrt(a)
		IRs:
			TMP_3773(uint256) = INTERNAL_CALL, Math.sqrt(uint256)(a)
			result(uint256) := TMP_3773(uint256)
		Expression: rounding == Rounding.Up && result * result < a
		IRs:
			REF_1289(Math.Rounding) -> Rounding.Up
			TMP_3774(bool) = rounding == REF_1289
			TMP_3775(uint256) = result * result
			TMP_3776(bool) = TMP_3775 < a
			TMP_3777(bool) = TMP_3774 && TMP_3776
			CONDITION TMP_3777
		Expression: result + 1
		IRs:
			TMP_3778(uint256) = result + 1
			RETURN TMP_3778
		Expression: result + 0
		IRs:
			TMP_3779(uint256) = result + 0
			RETURN TMP_3779
	Function Math.log2(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_3780(uint256) = value >> 128
			TMP_3781(bool) = TMP_3780 > 0
			CONDITION TMP_3781
		Expression: value >>= 128
		IRs:
			value(uint256) = value >> 128
		Expression: result += 128
		IRs:
			result(uint256) = result + 128
		Expression: value >> 64 > 0
		IRs:
			TMP_3782(uint256) = value >> 64
			TMP_3783(bool) = TMP_3782 > 0
			CONDITION TMP_3783
		Expression: value >>= 64
		IRs:
			value(uint256) = value >> 64
		Expression: result += 64
		IRs:
			result(uint256) = result + 64
		Expression: value >> 32 > 0
		IRs:
			TMP_3784(uint256) = value >> 32
			TMP_3785(bool) = TMP_3784 > 0
			CONDITION TMP_3785
		Expression: value >>= 32
		IRs:
			value(uint256) = value >> 32
		Expression: result += 32
		IRs:
			result(uint256) = result + 32
		Expression: value >> 16 > 0
		IRs:
			TMP_3786(uint256) = value >> 16
			TMP_3787(bool) = TMP_3786 > 0
			CONDITION TMP_3787
		Expression: value >>= 16
		IRs:
			value(uint256) = value >> 16
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >> 8 > 0
		IRs:
			TMP_3788(uint256) = value >> 8
			TMP_3789(bool) = TMP_3788 > 0
			CONDITION TMP_3789
		Expression: value >>= 8
		IRs:
			value(uint256) = value >> 8
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >> 4 > 0
		IRs:
			TMP_3790(uint256) = value >> 4
			TMP_3791(bool) = TMP_3790 > 0
			CONDITION TMP_3791
		Expression: value >>= 4
		IRs:
			value(uint256) = value >> 4
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >> 2 > 0
		IRs:
			TMP_3792(uint256) = value >> 2
			TMP_3793(bool) = TMP_3792 > 0
			CONDITION TMP_3793
		Expression: value >>= 2
		IRs:
			value(uint256) = value >> 2
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >> 1 > 0
		IRs:
			TMP_3794(uint256) = value >> 1
			TMP_3795(bool) = TMP_3794 > 0
			CONDITION TMP_3795
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function Math.log2(uint256,Math.Rounding) (*)
		Expression: result = log2(value)
		IRs:
			TMP_3796(uint256) = INTERNAL_CALL, Math.log2(uint256)(value)
			result(uint256) := TMP_3796(uint256)
		Expression: rounding == Rounding.Up && 1 << result < value
		IRs:
			REF_1290(Math.Rounding) -> Rounding.Up
			TMP_3797(bool) = rounding == REF_1290
			TMP_3798(uint256) = 1 << result
			TMP_3799(bool) = TMP_3798 < value
			TMP_3800(bool) = TMP_3797 && TMP_3799
			CONDITION TMP_3800
		Expression: result + 1
		IRs:
			TMP_3801(uint256) = result + 1
			RETURN TMP_3801
		Expression: result + 0
		IRs:
			TMP_3802(uint256) = result + 0
			RETURN TMP_3802
	Function Math.log10(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >= 10 ** 64
		IRs:
			TMP_3803(uint256) = 10 ** 64
			TMP_3804(bool) = value >= TMP_3803
			CONDITION TMP_3804
		Expression: value /= 10 ** 64
		IRs:
			TMP_3805(uint256) = 10 ** 64
			value(uint256) = value / TMP_3805
		Expression: result += 64
		IRs:
			result(uint256) = result + 64
		Expression: value >= 10 ** 32
		IRs:
			TMP_3806(uint256) = 10 ** 32
			TMP_3807(bool) = value >= TMP_3806
			CONDITION TMP_3807
		Expression: value /= 10 ** 32
		IRs:
			TMP_3808(uint256) = 10 ** 32
			value(uint256) = value / TMP_3808
		Expression: result += 32
		IRs:
			result(uint256) = result + 32
		Expression: value >= 10 ** 16
		IRs:
			TMP_3809(uint256) = 10 ** 16
			TMP_3810(bool) = value >= TMP_3809
			CONDITION TMP_3810
		Expression: value /= 10 ** 16
		IRs:
			TMP_3811(uint256) = 10 ** 16
			value(uint256) = value / TMP_3811
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >= 10 ** 8
		IRs:
			TMP_3812(uint256) = 10 ** 8
			TMP_3813(bool) = value >= TMP_3812
			CONDITION TMP_3813
		Expression: value /= 10 ** 8
		IRs:
			TMP_3814(uint256) = 10 ** 8
			value(uint256) = value / TMP_3814
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >= 10 ** 4
		IRs:
			TMP_3815(uint256) = 10 ** 4
			TMP_3816(bool) = value >= TMP_3815
			CONDITION TMP_3816
		Expression: value /= 10 ** 4
		IRs:
			TMP_3817(uint256) = 10 ** 4
			value(uint256) = value / TMP_3817
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >= 10 ** 2
		IRs:
			TMP_3818(uint256) = 10 ** 2
			TMP_3819(bool) = value >= TMP_3818
			CONDITION TMP_3819
		Expression: value /= 10 ** 2
		IRs:
			TMP_3820(uint256) = 10 ** 2
			value(uint256) = value / TMP_3820
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >= 10 ** 1
		IRs:
			TMP_3821(uint256) = 10 ** 1
			TMP_3822(bool) = value >= TMP_3821
			CONDITION TMP_3822
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function Math.log10(uint256,Math.Rounding) (*)
		Expression: result = log10(value)
		IRs:
			TMP_3823(uint256) = INTERNAL_CALL, Math.log10(uint256)(value)
			result(uint256) := TMP_3823(uint256)
		Expression: rounding == Rounding.Up && 10 ** result < value
		IRs:
			REF_1291(Math.Rounding) -> Rounding.Up
			TMP_3824(bool) = rounding == REF_1291
			TMP_3825(uint256) = 10 ** result
			TMP_3826(bool) = TMP_3825 < value
			TMP_3827(bool) = TMP_3824 && TMP_3826
			CONDITION TMP_3827
		Expression: result + 1
		IRs:
			TMP_3828(uint256) = result + 1
			RETURN TMP_3828
		Expression: result + 0
		IRs:
			TMP_3829(uint256) = result + 0
			RETURN TMP_3829
	Function Math.log256(uint256) (*)
		Expression: result = 0
		IRs:
			result(uint256) := 0(uint256)
		Expression: value >> 128 > 0
		IRs:
			TMP_3830(uint256) = value >> 128
			TMP_3831(bool) = TMP_3830 > 0
			CONDITION TMP_3831
		Expression: value >>= 128
		IRs:
			value(uint256) = value >> 128
		Expression: result += 16
		IRs:
			result(uint256) = result + 16
		Expression: value >> 64 > 0
		IRs:
			TMP_3832(uint256) = value >> 64
			TMP_3833(bool) = TMP_3832 > 0
			CONDITION TMP_3833
		Expression: value >>= 64
		IRs:
			value(uint256) = value >> 64
		Expression: result += 8
		IRs:
			result(uint256) = result + 8
		Expression: value >> 32 > 0
		IRs:
			TMP_3834(uint256) = value >> 32
			TMP_3835(bool) = TMP_3834 > 0
			CONDITION TMP_3835
		Expression: value >>= 32
		IRs:
			value(uint256) = value >> 32
		Expression: result += 4
		IRs:
			result(uint256) = result + 4
		Expression: value >> 16 > 0
		IRs:
			TMP_3836(uint256) = value >> 16
			TMP_3837(bool) = TMP_3836 > 0
			CONDITION TMP_3837
		Expression: value >>= 16
		IRs:
			value(uint256) = value >> 16
		Expression: result += 2
		IRs:
			result(uint256) = result + 2
		Expression: value >> 8 > 0
		IRs:
			TMP_3838(uint256) = value >> 8
			TMP_3839(bool) = TMP_3838 > 0
			CONDITION TMP_3839
		Expression: result += 1
		IRs:
			result(uint256) = result + 1
		Expression: result
		IRs:
			RETURN result
	Function Math.log256(uint256,Math.Rounding) (*)
		Expression: result = log256(value)
		IRs:
			TMP_3840(uint256) = INTERNAL_CALL, Math.log256(uint256)(value)
			result(uint256) := TMP_3840(uint256)
		Expression: rounding == Rounding.Up && 1 << (result << 3) < value
		IRs:
			REF_1292(Math.Rounding) -> Rounding.Up
			TMP_3841(bool) = rounding == REF_1292
			TMP_3842(uint256) = result << 3
			TMP_3843(uint256) = 1 << TMP_3842
			TMP_3844(bool) = TMP_3843 < value
			TMP_3845(bool) = TMP_3841 && TMP_3844
			CONDITION TMP_3845
		Expression: result + 1
		IRs:
			TMP_3846(uint256) = result + 1
			RETURN TMP_3846
		Expression: result + 0
		IRs:
			TMP_3847(uint256) = result + 0
			RETURN TMP_3847
Contract SafeCast
	Function SafeCast.toUint248(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint248).max,SafeCast: value doesn't fit in 248 bits)
		IRs:
			TMP_3849(uint248) := 452312848583266388373324160190187140051835877600158453279131187530910662655(uint248)
			TMP_3850(bool) = value <= TMP_3849
			TMP_3851(None) = SOLIDITY_CALL require(bool,string)(TMP_3850,SafeCast: value doesn't fit in 248 bits)
		Expression: uint248(value)
		IRs:
			TMP_3852 = CONVERT value to uint248
			RETURN TMP_3852
	Function SafeCast.toUint240(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint240).max,SafeCast: value doesn't fit in 240 bits)
		IRs:
			TMP_3854(uint240) := 1766847064778384329583297500742918515827483896875618958121606201292619775(uint240)
			TMP_3855(bool) = value <= TMP_3854
			TMP_3856(None) = SOLIDITY_CALL require(bool,string)(TMP_3855,SafeCast: value doesn't fit in 240 bits)
		Expression: uint240(value)
		IRs:
			TMP_3857 = CONVERT value to uint240
			RETURN TMP_3857
	Function SafeCast.toUint232(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint232).max,SafeCast: value doesn't fit in 232 bits)
		IRs:
			TMP_3859(uint232) := 6901746346790563787434755862277025452451108972170386555162524223799295(uint232)
			TMP_3860(bool) = value <= TMP_3859
			TMP_3861(None) = SOLIDITY_CALL require(bool,string)(TMP_3860,SafeCast: value doesn't fit in 232 bits)
		Expression: uint232(value)
		IRs:
			TMP_3862 = CONVERT value to uint232
			RETURN TMP_3862
	Function SafeCast.toUint224(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint224).max,SafeCast: value doesn't fit in 224 bits)
		IRs:
			TMP_3864(uint224) := 26959946667150639794667015087019630673637144422540572481103610249215(uint224)
			TMP_3865(bool) = value <= TMP_3864
			TMP_3866(None) = SOLIDITY_CALL require(bool,string)(TMP_3865,SafeCast: value doesn't fit in 224 bits)
		Expression: uint224(value)
		IRs:
			TMP_3867 = CONVERT value to uint224
			RETURN TMP_3867
	Function SafeCast.toUint216(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint216).max,SafeCast: value doesn't fit in 216 bits)
		IRs:
			TMP_3869(uint216) := 105312291668557186697918027683670432318895095400549111254310977535(uint216)
			TMP_3870(bool) = value <= TMP_3869
			TMP_3871(None) = SOLIDITY_CALL require(bool,string)(TMP_3870,SafeCast: value doesn't fit in 216 bits)
		Expression: uint216(value)
		IRs:
			TMP_3872 = CONVERT value to uint216
			RETURN TMP_3872
	Function SafeCast.toUint208(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint208).max,SafeCast: value doesn't fit in 208 bits)
		IRs:
			TMP_3874(uint208) := 411376139330301510538742295639337626245683966408394965837152255(uint208)
			TMP_3875(bool) = value <= TMP_3874
			TMP_3876(None) = SOLIDITY_CALL require(bool,string)(TMP_3875,SafeCast: value doesn't fit in 208 bits)
		Expression: uint208(value)
		IRs:
			TMP_3877 = CONVERT value to uint208
			RETURN TMP_3877
	Function SafeCast.toUint200(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint200).max,SafeCast: value doesn't fit in 200 bits)
		IRs:
			TMP_3879(uint200) := 1606938044258990275541962092341162602522202993782792835301375(uint200)
			TMP_3880(bool) = value <= TMP_3879
			TMP_3881(None) = SOLIDITY_CALL require(bool,string)(TMP_3880,SafeCast: value doesn't fit in 200 bits)
		Expression: uint200(value)
		IRs:
			TMP_3882 = CONVERT value to uint200
			RETURN TMP_3882
	Function SafeCast.toUint192(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint192).max,SafeCast: value doesn't fit in 192 bits)
		IRs:
			TMP_3884(uint192) := 6277101735386680763835789423207666416102355444464034512895(uint192)
			TMP_3885(bool) = value <= TMP_3884
			TMP_3886(None) = SOLIDITY_CALL require(bool,string)(TMP_3885,SafeCast: value doesn't fit in 192 bits)
		Expression: uint192(value)
		IRs:
			TMP_3887 = CONVERT value to uint192
			RETURN TMP_3887
	Function SafeCast.toUint184(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint184).max,SafeCast: value doesn't fit in 184 bits)
		IRs:
			TMP_3889(uint184) := 24519928653854221733733552434404946937899825954937634815(uint184)
			TMP_3890(bool) = value <= TMP_3889
			TMP_3891(None) = SOLIDITY_CALL require(bool,string)(TMP_3890,SafeCast: value doesn't fit in 184 bits)
		Expression: uint184(value)
		IRs:
			TMP_3892 = CONVERT value to uint184
			RETURN TMP_3892
	Function SafeCast.toUint176(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint176).max,SafeCast: value doesn't fit in 176 bits)
		IRs:
			TMP_3894(uint176) := 95780971304118053647396689196894323976171195136475135(uint176)
			TMP_3895(bool) = value <= TMP_3894
			TMP_3896(None) = SOLIDITY_CALL require(bool,string)(TMP_3895,SafeCast: value doesn't fit in 176 bits)
		Expression: uint176(value)
		IRs:
			TMP_3897 = CONVERT value to uint176
			RETURN TMP_3897
	Function SafeCast.toUint168(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint168).max,SafeCast: value doesn't fit in 168 bits)
		IRs:
			TMP_3899(uint168) := 374144419156711147060143317175368453031918731001855(uint168)
			TMP_3900(bool) = value <= TMP_3899
			TMP_3901(None) = SOLIDITY_CALL require(bool,string)(TMP_3900,SafeCast: value doesn't fit in 168 bits)
		Expression: uint168(value)
		IRs:
			TMP_3902 = CONVERT value to uint168
			RETURN TMP_3902
	Function SafeCast.toUint160(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint160).max,SafeCast: value doesn't fit in 160 bits)
		IRs:
			TMP_3904(uint160) := 1461501637330902918203684832716283019655932542975(uint160)
			TMP_3905(bool) = value <= TMP_3904
			TMP_3906(None) = SOLIDITY_CALL require(bool,string)(TMP_3905,SafeCast: value doesn't fit in 160 bits)
		Expression: uint160(value)
		IRs:
			TMP_3907 = CONVERT value to uint160
			RETURN TMP_3907
	Function SafeCast.toUint152(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint152).max,SafeCast: value doesn't fit in 152 bits)
		IRs:
			TMP_3909(uint152) := 5708990770823839524233143877797980545530986495(uint152)
			TMP_3910(bool) = value <= TMP_3909
			TMP_3911(None) = SOLIDITY_CALL require(bool,string)(TMP_3910,SafeCast: value doesn't fit in 152 bits)
		Expression: uint152(value)
		IRs:
			TMP_3912 = CONVERT value to uint152
			RETURN TMP_3912
	Function SafeCast.toUint144(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint144).max,SafeCast: value doesn't fit in 144 bits)
		IRs:
			TMP_3914(uint144) := 22300745198530623141535718272648361505980415(uint144)
			TMP_3915(bool) = value <= TMP_3914
			TMP_3916(None) = SOLIDITY_CALL require(bool,string)(TMP_3915,SafeCast: value doesn't fit in 144 bits)
		Expression: uint144(value)
		IRs:
			TMP_3917 = CONVERT value to uint144
			RETURN TMP_3917
	Function SafeCast.toUint136(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint136).max,SafeCast: value doesn't fit in 136 bits)
		IRs:
			TMP_3919(uint136) := 87112285931760246646623899502532662132735(uint136)
			TMP_3920(bool) = value <= TMP_3919
			TMP_3921(None) = SOLIDITY_CALL require(bool,string)(TMP_3920,SafeCast: value doesn't fit in 136 bits)
		Expression: uint136(value)
		IRs:
			TMP_3922 = CONVERT value to uint136
			RETURN TMP_3922
	Function SafeCast.toUint128(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint128).max,SafeCast: value doesn't fit in 128 bits)
		IRs:
			TMP_3924(uint128) := 340282366920938463463374607431768211455(uint128)
			TMP_3925(bool) = value <= TMP_3924
			TMP_3926(None) = SOLIDITY_CALL require(bool,string)(TMP_3925,SafeCast: value doesn't fit in 128 bits)
		Expression: uint128(value)
		IRs:
			TMP_3927 = CONVERT value to uint128
			RETURN TMP_3927
	Function SafeCast.toUint120(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint120).max,SafeCast: value doesn't fit in 120 bits)
		IRs:
			TMP_3929(uint120) := 1329227995784915872903807060280344575(uint120)
			TMP_3930(bool) = value <= TMP_3929
			TMP_3931(None) = SOLIDITY_CALL require(bool,string)(TMP_3930,SafeCast: value doesn't fit in 120 bits)
		Expression: uint120(value)
		IRs:
			TMP_3932 = CONVERT value to uint120
			RETURN TMP_3932
	Function SafeCast.toUint112(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint112).max,SafeCast: value doesn't fit in 112 bits)
		IRs:
			TMP_3934(uint112) := 5192296858534827628530496329220095(uint112)
			TMP_3935(bool) = value <= TMP_3934
			TMP_3936(None) = SOLIDITY_CALL require(bool,string)(TMP_3935,SafeCast: value doesn't fit in 112 bits)
		Expression: uint112(value)
		IRs:
			TMP_3937 = CONVERT value to uint112
			RETURN TMP_3937
	Function SafeCast.toUint104(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint104).max,SafeCast: value doesn't fit in 104 bits)
		IRs:
			TMP_3939(uint104) := 20282409603651670423947251286015(uint104)
			TMP_3940(bool) = value <= TMP_3939
			TMP_3941(None) = SOLIDITY_CALL require(bool,string)(TMP_3940,SafeCast: value doesn't fit in 104 bits)
		Expression: uint104(value)
		IRs:
			TMP_3942 = CONVERT value to uint104
			RETURN TMP_3942
	Function SafeCast.toUint96(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint96).max,SafeCast: value doesn't fit in 96 bits)
		IRs:
			TMP_3944(uint96) := 79228162514264337593543950335(uint96)
			TMP_3945(bool) = value <= TMP_3944
			TMP_3946(None) = SOLIDITY_CALL require(bool,string)(TMP_3945,SafeCast: value doesn't fit in 96 bits)
		Expression: uint96(value)
		IRs:
			TMP_3947 = CONVERT value to uint96
			RETURN TMP_3947
	Function SafeCast.toUint88(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint88).max,SafeCast: value doesn't fit in 88 bits)
		IRs:
			TMP_3949(uint88) := 309485009821345068724781055(uint88)
			TMP_3950(bool) = value <= TMP_3949
			TMP_3951(None) = SOLIDITY_CALL require(bool,string)(TMP_3950,SafeCast: value doesn't fit in 88 bits)
		Expression: uint88(value)
		IRs:
			TMP_3952 = CONVERT value to uint88
			RETURN TMP_3952
	Function SafeCast.toUint80(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint80).max,SafeCast: value doesn't fit in 80 bits)
		IRs:
			TMP_3954(uint80) := 1208925819614629174706175(uint80)
			TMP_3955(bool) = value <= TMP_3954
			TMP_3956(None) = SOLIDITY_CALL require(bool,string)(TMP_3955,SafeCast: value doesn't fit in 80 bits)
		Expression: uint80(value)
		IRs:
			TMP_3957 = CONVERT value to uint80
			RETURN TMP_3957
	Function SafeCast.toUint72(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint72).max,SafeCast: value doesn't fit in 72 bits)
		IRs:
			TMP_3959(uint72) := 4722366482869645213695(uint72)
			TMP_3960(bool) = value <= TMP_3959
			TMP_3961(None) = SOLIDITY_CALL require(bool,string)(TMP_3960,SafeCast: value doesn't fit in 72 bits)
		Expression: uint72(value)
		IRs:
			TMP_3962 = CONVERT value to uint72
			RETURN TMP_3962
	Function SafeCast.toUint64(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint64).max,SafeCast: value doesn't fit in 64 bits)
		IRs:
			TMP_3964(uint64) := 18446744073709551615(uint64)
			TMP_3965(bool) = value <= TMP_3964
			TMP_3966(None) = SOLIDITY_CALL require(bool,string)(TMP_3965,SafeCast: value doesn't fit in 64 bits)
		Expression: uint64(value)
		IRs:
			TMP_3967 = CONVERT value to uint64
			RETURN TMP_3967
	Function SafeCast.toUint56(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint56).max,SafeCast: value doesn't fit in 56 bits)
		IRs:
			TMP_3969(uint56) := 72057594037927935(uint56)
			TMP_3970(bool) = value <= TMP_3969
			TMP_3971(None) = SOLIDITY_CALL require(bool,string)(TMP_3970,SafeCast: value doesn't fit in 56 bits)
		Expression: uint56(value)
		IRs:
			TMP_3972 = CONVERT value to uint56
			RETURN TMP_3972
	Function SafeCast.toUint48(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint48).max,SafeCast: value doesn't fit in 48 bits)
		IRs:
			TMP_3974(uint48) := 281474976710655(uint48)
			TMP_3975(bool) = value <= TMP_3974
			TMP_3976(None) = SOLIDITY_CALL require(bool,string)(TMP_3975,SafeCast: value doesn't fit in 48 bits)
		Expression: uint48(value)
		IRs:
			TMP_3977 = CONVERT value to uint48
			RETURN TMP_3977
	Function SafeCast.toUint40(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint40).max,SafeCast: value doesn't fit in 40 bits)
		IRs:
			TMP_3979(uint40) := 1099511627775(uint40)
			TMP_3980(bool) = value <= TMP_3979
			TMP_3981(None) = SOLIDITY_CALL require(bool,string)(TMP_3980,SafeCast: value doesn't fit in 40 bits)
		Expression: uint40(value)
		IRs:
			TMP_3982 = CONVERT value to uint40
			RETURN TMP_3982
	Function SafeCast.toUint32(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint32).max,SafeCast: value doesn't fit in 32 bits)
		IRs:
			TMP_3984(uint32) := 4294967295(uint32)
			TMP_3985(bool) = value <= TMP_3984
			TMP_3986(None) = SOLIDITY_CALL require(bool,string)(TMP_3985,SafeCast: value doesn't fit in 32 bits)
		Expression: uint32(value)
		IRs:
			TMP_3987 = CONVERT value to uint32
			RETURN TMP_3987
	Function SafeCast.toUint24(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint24).max,SafeCast: value doesn't fit in 24 bits)
		IRs:
			TMP_3989(uint24) := 16777215(uint24)
			TMP_3990(bool) = value <= TMP_3989
			TMP_3991(None) = SOLIDITY_CALL require(bool,string)(TMP_3990,SafeCast: value doesn't fit in 24 bits)
		Expression: uint24(value)
		IRs:
			TMP_3992 = CONVERT value to uint24
			RETURN TMP_3992
	Function SafeCast.toUint16(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint16).max,SafeCast: value doesn't fit in 16 bits)
		IRs:
			TMP_3994(uint16) := 65535(uint16)
			TMP_3995(bool) = value <= TMP_3994
			TMP_3996(None) = SOLIDITY_CALL require(bool,string)(TMP_3995,SafeCast: value doesn't fit in 16 bits)
		Expression: uint16(value)
		IRs:
			TMP_3997 = CONVERT value to uint16
			RETURN TMP_3997
	Function SafeCast.toUint8(uint256) (*)
		Expression: require(bool,string)(value <= type()(uint8).max,SafeCast: value doesn't fit in 8 bits)
		IRs:
			TMP_3999(uint8) := 255(uint8)
			TMP_4000(bool) = value <= TMP_3999
			TMP_4001(None) = SOLIDITY_CALL require(bool,string)(TMP_4000,SafeCast: value doesn't fit in 8 bits)
		Expression: uint8(value)
		IRs:
			TMP_4002 = CONVERT value to uint8
			RETURN TMP_4002
	Function SafeCast.toUint256(int256) (*)
		Expression: require(bool,string)(value >= 0,SafeCast: value must be positive)
		IRs:
			TMP_4003(bool) = value >= 0
			TMP_4004(None) = SOLIDITY_CALL require(bool,string)(TMP_4003,SafeCast: value must be positive)
		Expression: uint256(value)
		IRs:
			TMP_4005 = CONVERT value to uint256
			RETURN TMP_4005
	Function SafeCast.toInt248(int256) (*)
		Expression: downcasted = int248(value)
		IRs:
			TMP_4006 = CONVERT value to int248
			downcasted(int248) := TMP_4006(int248)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 248 bits)
		IRs:
			TMP_4007(bool) = downcasted == value
			TMP_4008(None) = SOLIDITY_CALL require(bool,string)(TMP_4007,SafeCast: value doesn't fit in 248 bits)
	Function SafeCast.toInt240(int256) (*)
		Expression: downcasted = int240(value)
		IRs:
			TMP_4009 = CONVERT value to int240
			downcasted(int240) := TMP_4009(int240)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 240 bits)
		IRs:
			TMP_4010(bool) = downcasted == value
			TMP_4011(None) = SOLIDITY_CALL require(bool,string)(TMP_4010,SafeCast: value doesn't fit in 240 bits)
	Function SafeCast.toInt232(int256) (*)
		Expression: downcasted = int232(value)
		IRs:
			TMP_4012 = CONVERT value to int232
			downcasted(int232) := TMP_4012(int232)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 232 bits)
		IRs:
			TMP_4013(bool) = downcasted == value
			TMP_4014(None) = SOLIDITY_CALL require(bool,string)(TMP_4013,SafeCast: value doesn't fit in 232 bits)
	Function SafeCast.toInt224(int256) (*)
		Expression: downcasted = int224(value)
		IRs:
			TMP_4015 = CONVERT value to int224
			downcasted(int224) := TMP_4015(int224)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 224 bits)
		IRs:
			TMP_4016(bool) = downcasted == value
			TMP_4017(None) = SOLIDITY_CALL require(bool,string)(TMP_4016,SafeCast: value doesn't fit in 224 bits)
	Function SafeCast.toInt216(int256) (*)
		Expression: downcasted = int216(value)
		IRs:
			TMP_4018 = CONVERT value to int216
			downcasted(int216) := TMP_4018(int216)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 216 bits)
		IRs:
			TMP_4019(bool) = downcasted == value
			TMP_4020(None) = SOLIDITY_CALL require(bool,string)(TMP_4019,SafeCast: value doesn't fit in 216 bits)
	Function SafeCast.toInt208(int256) (*)
		Expression: downcasted = int208(value)
		IRs:
			TMP_4021 = CONVERT value to int208
			downcasted(int208) := TMP_4021(int208)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 208 bits)
		IRs:
			TMP_4022(bool) = downcasted == value
			TMP_4023(None) = SOLIDITY_CALL require(bool,string)(TMP_4022,SafeCast: value doesn't fit in 208 bits)
	Function SafeCast.toInt200(int256) (*)
		Expression: downcasted = int200(value)
		IRs:
			TMP_4024 = CONVERT value to int200
			downcasted(int200) := TMP_4024(int200)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 200 bits)
		IRs:
			TMP_4025(bool) = downcasted == value
			TMP_4026(None) = SOLIDITY_CALL require(bool,string)(TMP_4025,SafeCast: value doesn't fit in 200 bits)
	Function SafeCast.toInt192(int256) (*)
		Expression: downcasted = int192(value)
		IRs:
			TMP_4027 = CONVERT value to int192
			downcasted(int192) := TMP_4027(int192)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 192 bits)
		IRs:
			TMP_4028(bool) = downcasted == value
			TMP_4029(None) = SOLIDITY_CALL require(bool,string)(TMP_4028,SafeCast: value doesn't fit in 192 bits)
	Function SafeCast.toInt184(int256) (*)
		Expression: downcasted = int184(value)
		IRs:
			TMP_4030 = CONVERT value to int184
			downcasted(int184) := TMP_4030(int184)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 184 bits)
		IRs:
			TMP_4031(bool) = downcasted == value
			TMP_4032(None) = SOLIDITY_CALL require(bool,string)(TMP_4031,SafeCast: value doesn't fit in 184 bits)
	Function SafeCast.toInt176(int256) (*)
		Expression: downcasted = int176(value)
		IRs:
			TMP_4033 = CONVERT value to int176
			downcasted(int176) := TMP_4033(int176)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 176 bits)
		IRs:
			TMP_4034(bool) = downcasted == value
			TMP_4035(None) = SOLIDITY_CALL require(bool,string)(TMP_4034,SafeCast: value doesn't fit in 176 bits)
	Function SafeCast.toInt168(int256) (*)
		Expression: downcasted = int168(value)
		IRs:
			TMP_4036 = CONVERT value to int168
			downcasted(int168) := TMP_4036(int168)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 168 bits)
		IRs:
			TMP_4037(bool) = downcasted == value
			TMP_4038(None) = SOLIDITY_CALL require(bool,string)(TMP_4037,SafeCast: value doesn't fit in 168 bits)
	Function SafeCast.toInt160(int256) (*)
		Expression: downcasted = int160(value)
		IRs:
			TMP_4039 = CONVERT value to int160
			downcasted(int160) := TMP_4039(int160)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 160 bits)
		IRs:
			TMP_4040(bool) = downcasted == value
			TMP_4041(None) = SOLIDITY_CALL require(bool,string)(TMP_4040,SafeCast: value doesn't fit in 160 bits)
	Function SafeCast.toInt152(int256) (*)
		Expression: downcasted = int152(value)
		IRs:
			TMP_4042 = CONVERT value to int152
			downcasted(int152) := TMP_4042(int152)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 152 bits)
		IRs:
			TMP_4043(bool) = downcasted == value
			TMP_4044(None) = SOLIDITY_CALL require(bool,string)(TMP_4043,SafeCast: value doesn't fit in 152 bits)
	Function SafeCast.toInt144(int256) (*)
		Expression: downcasted = int144(value)
		IRs:
			TMP_4045 = CONVERT value to int144
			downcasted(int144) := TMP_4045(int144)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 144 bits)
		IRs:
			TMP_4046(bool) = downcasted == value
			TMP_4047(None) = SOLIDITY_CALL require(bool,string)(TMP_4046,SafeCast: value doesn't fit in 144 bits)
	Function SafeCast.toInt136(int256) (*)
		Expression: downcasted = int136(value)
		IRs:
			TMP_4048 = CONVERT value to int136
			downcasted(int136) := TMP_4048(int136)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 136 bits)
		IRs:
			TMP_4049(bool) = downcasted == value
			TMP_4050(None) = SOLIDITY_CALL require(bool,string)(TMP_4049,SafeCast: value doesn't fit in 136 bits)
	Function SafeCast.toInt128(int256) (*)
		Expression: downcasted = int128(value)
		IRs:
			TMP_4051 = CONVERT value to int128
			downcasted(int128) := TMP_4051(int128)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 128 bits)
		IRs:
			TMP_4052(bool) = downcasted == value
			TMP_4053(None) = SOLIDITY_CALL require(bool,string)(TMP_4052,SafeCast: value doesn't fit in 128 bits)
	Function SafeCast.toInt120(int256) (*)
		Expression: downcasted = int120(value)
		IRs:
			TMP_4054 = CONVERT value to int120
			downcasted(int120) := TMP_4054(int120)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 120 bits)
		IRs:
			TMP_4055(bool) = downcasted == value
			TMP_4056(None) = SOLIDITY_CALL require(bool,string)(TMP_4055,SafeCast: value doesn't fit in 120 bits)
	Function SafeCast.toInt112(int256) (*)
		Expression: downcasted = int112(value)
		IRs:
			TMP_4057 = CONVERT value to int112
			downcasted(int112) := TMP_4057(int112)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 112 bits)
		IRs:
			TMP_4058(bool) = downcasted == value
			TMP_4059(None) = SOLIDITY_CALL require(bool,string)(TMP_4058,SafeCast: value doesn't fit in 112 bits)
	Function SafeCast.toInt104(int256) (*)
		Expression: downcasted = int104(value)
		IRs:
			TMP_4060 = CONVERT value to int104
			downcasted(int104) := TMP_4060(int104)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 104 bits)
		IRs:
			TMP_4061(bool) = downcasted == value
			TMP_4062(None) = SOLIDITY_CALL require(bool,string)(TMP_4061,SafeCast: value doesn't fit in 104 bits)
	Function SafeCast.toInt96(int256) (*)
		Expression: downcasted = int96(value)
		IRs:
			TMP_4063 = CONVERT value to int96
			downcasted(int96) := TMP_4063(int96)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 96 bits)
		IRs:
			TMP_4064(bool) = downcasted == value
			TMP_4065(None) = SOLIDITY_CALL require(bool,string)(TMP_4064,SafeCast: value doesn't fit in 96 bits)
	Function SafeCast.toInt88(int256) (*)
		Expression: downcasted = int88(value)
		IRs:
			TMP_4066 = CONVERT value to int88
			downcasted(int88) := TMP_4066(int88)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 88 bits)
		IRs:
			TMP_4067(bool) = downcasted == value
			TMP_4068(None) = SOLIDITY_CALL require(bool,string)(TMP_4067,SafeCast: value doesn't fit in 88 bits)
	Function SafeCast.toInt80(int256) (*)
		Expression: downcasted = int80(value)
		IRs:
			TMP_4069 = CONVERT value to int80
			downcasted(int80) := TMP_4069(int80)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 80 bits)
		IRs:
			TMP_4070(bool) = downcasted == value
			TMP_4071(None) = SOLIDITY_CALL require(bool,string)(TMP_4070,SafeCast: value doesn't fit in 80 bits)
	Function SafeCast.toInt72(int256) (*)
		Expression: downcasted = int72(value)
		IRs:
			TMP_4072 = CONVERT value to int72
			downcasted(int72) := TMP_4072(int72)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 72 bits)
		IRs:
			TMP_4073(bool) = downcasted == value
			TMP_4074(None) = SOLIDITY_CALL require(bool,string)(TMP_4073,SafeCast: value doesn't fit in 72 bits)
	Function SafeCast.toInt64(int256) (*)
		Expression: downcasted = int64(value)
		IRs:
			TMP_4075 = CONVERT value to int64
			downcasted(int64) := TMP_4075(int64)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 64 bits)
		IRs:
			TMP_4076(bool) = downcasted == value
			TMP_4077(None) = SOLIDITY_CALL require(bool,string)(TMP_4076,SafeCast: value doesn't fit in 64 bits)
	Function SafeCast.toInt56(int256) (*)
		Expression: downcasted = int56(value)
		IRs:
			TMP_4078 = CONVERT value to int56
			downcasted(int56) := TMP_4078(int56)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 56 bits)
		IRs:
			TMP_4079(bool) = downcasted == value
			TMP_4080(None) = SOLIDITY_CALL require(bool,string)(TMP_4079,SafeCast: value doesn't fit in 56 bits)
	Function SafeCast.toInt48(int256) (*)
		Expression: downcasted = int48(value)
		IRs:
			TMP_4081 = CONVERT value to int48
			downcasted(int48) := TMP_4081(int48)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 48 bits)
		IRs:
			TMP_4082(bool) = downcasted == value
			TMP_4083(None) = SOLIDITY_CALL require(bool,string)(TMP_4082,SafeCast: value doesn't fit in 48 bits)
	Function SafeCast.toInt40(int256) (*)
		Expression: downcasted = int40(value)
		IRs:
			TMP_4084 = CONVERT value to int40
			downcasted(int40) := TMP_4084(int40)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 40 bits)
		IRs:
			TMP_4085(bool) = downcasted == value
			TMP_4086(None) = SOLIDITY_CALL require(bool,string)(TMP_4085,SafeCast: value doesn't fit in 40 bits)
	Function SafeCast.toInt32(int256) (*)
		Expression: downcasted = int32(value)
		IRs:
			TMP_4087 = CONVERT value to int32
			downcasted(int32) := TMP_4087(int32)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 32 bits)
		IRs:
			TMP_4088(bool) = downcasted == value
			TMP_4089(None) = SOLIDITY_CALL require(bool,string)(TMP_4088,SafeCast: value doesn't fit in 32 bits)
	Function SafeCast.toInt24(int256) (*)
		Expression: downcasted = int24(value)
		IRs:
			TMP_4090 = CONVERT value to int24
			downcasted(int24) := TMP_4090(int24)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 24 bits)
		IRs:
			TMP_4091(bool) = downcasted == value
			TMP_4092(None) = SOLIDITY_CALL require(bool,string)(TMP_4091,SafeCast: value doesn't fit in 24 bits)
	Function SafeCast.toInt16(int256) (*)
		Expression: downcasted = int16(value)
		IRs:
			TMP_4093 = CONVERT value to int16
			downcasted(int16) := TMP_4093(int16)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 16 bits)
		IRs:
			TMP_4094(bool) = downcasted == value
			TMP_4095(None) = SOLIDITY_CALL require(bool,string)(TMP_4094,SafeCast: value doesn't fit in 16 bits)
	Function SafeCast.toInt8(int256) (*)
		Expression: downcasted = int8(value)
		IRs:
			TMP_4096 = CONVERT value to int8
			downcasted(int8) := TMP_4096(int8)
		Expression: require(bool,string)(downcasted == value,SafeCast: value doesn't fit in 8 bits)
		IRs:
			TMP_4097(bool) = downcasted == value
			TMP_4098(None) = SOLIDITY_CALL require(bool,string)(TMP_4097,SafeCast: value doesn't fit in 8 bits)
	Function SafeCast.toInt256(uint256) (*)
		Expression: require(bool,string)(value <= uint256(type()(int256).max),SafeCast: value doesn't fit in an int256)
		IRs:
			TMP_4100(int256) := 57896044618658097711785492504343953926634992332820282019728792003956564819967(int256)
			TMP_4101 = CONVERT TMP_4100 to uint256
			TMP_4102(bool) = value <= TMP_4101
			TMP_4103(None) = SOLIDITY_CALL require(bool,string)(TMP_4102,SafeCast: value doesn't fit in an int256)
		Expression: int256(value)
		IRs:
			TMP_4104 = CONVERT value to int256
			RETURN TMP_4104
Contract SignedMath
	Function SignedMath.max(int256,int256) (*)
		Expression: a > b
		IRs:
			TMP_4105(bool) = a > b
			CONDITION TMP_4105
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function SignedMath.min(int256,int256) (*)
		Expression: a < b
		IRs:
			TMP_4106(bool) = a < b
			CONDITION TMP_4106
		Expression: a
		IRs:
			RETURN a
		Expression: b
		IRs:
			RETURN b
	Function SignedMath.average(int256,int256) (*)
		Expression: x = (a & b) + ((a ^ b) >> 1)
		IRs:
			TMP_4107(int256) = a & b
			TMP_4108(int256) = a ^ b
			TMP_4109(int256) = TMP_4108 >> 1
			TMP_4110(int256) = TMP_4107 (c)+ TMP_4109
			x(int256) := TMP_4110(int256)
		Expression: x + (int256(uint256(x) >> 255) & (a ^ b))
		IRs:
			TMP_4111 = CONVERT x to uint256
			TMP_4112(uint256) = TMP_4111 >> 255
			TMP_4113 = CONVERT TMP_4112 to int256
			TMP_4114(int256) = a ^ b
			TMP_4115(int256) = TMP_4113 & TMP_4114
			TMP_4116(int256) = x (c)+ TMP_4115
			RETURN TMP_4116
	Function SignedMath.abs(int256) (*)
		Expression: n >= 0
		IRs:
			TMP_4117(bool) = n >= 0
			CONDITION TMP_4117
		Expression: uint256(n)
		IRs:
			TMP_4118 = CONVERT n to uint256
			RETURN TMP_4118
		Expression: uint256(- n)
		IRs:
			TMP_4119(int256) = 0 - n
			TMP_4120 = CONVERT TMP_4119 to uint256
			RETURN TMP_4120
Contract DoubleEndedQueue
	Function DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32) (*)
		Expression: backIndex = deque._end
		IRs:
			REF_1293(int128) -> deque._end
			backIndex(int128) := REF_1293(int128)
		Expression: deque._data[backIndex] = value
		IRs:
			REF_1294(mapping(int128 => bytes32)) -> deque._data
			REF_1295(bytes32) -> REF_1294[backIndex]
			REF_1295(bytes32) (->deque) := value(bytes32)
		Expression: deque._end = backIndex + 1
		IRs:
			REF_1296(int128) -> deque._end
			TMP_4121(int128) = backIndex + 1
			REF_1296(int128) (->deque) := TMP_4121(int128)
	Function DoubleEndedQueue.popBack(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: empty(deque)
		IRs:
			TMP_4122(bool) = INTERNAL_CALL, DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque)(deque)
			CONDITION TMP_4122
		Expression: revert Empty()()
		IRs:
			TMP_4123(None) = SOLIDITY_CALL revert Empty()()
		Expression: backIndex = deque._end - 1
		IRs:
			REF_1297(int128) -> deque._end
			TMP_4124(int128) = REF_1297 - 1
			backIndex(int128) := TMP_4124(int128)
		Expression: value = deque._data[backIndex]
		IRs:
			REF_1298(mapping(int128 => bytes32)) -> deque._data
			REF_1299(bytes32) -> REF_1298[backIndex]
			value(bytes32) := REF_1299(bytes32)
		Expression: delete deque._data[backIndex]
		IRs:
			REF_1300(mapping(int128 => bytes32)) -> deque._data
			REF_1301(bytes32) -> REF_1300[backIndex]
			REF_1300 = delete REF_1301 
		Expression: deque._end = backIndex
		IRs:
			REF_1302(int128) -> deque._end
			REF_1302(int128) (->deque) := backIndex(int128)
	Function DoubleEndedQueue.pushFront(DoubleEndedQueue.Bytes32Deque,bytes32) (*)
		Expression: frontIndex = deque._begin - 1
		IRs:
			REF_1303(int128) -> deque._begin
			TMP_4125(int128) = REF_1303 - 1
			frontIndex(int128) := TMP_4125(int128)
		Expression: deque._data[frontIndex] = value
		IRs:
			REF_1304(mapping(int128 => bytes32)) -> deque._data
			REF_1305(bytes32) -> REF_1304[frontIndex]
			REF_1305(bytes32) (->deque) := value(bytes32)
		Expression: deque._begin = frontIndex
		IRs:
			REF_1306(int128) -> deque._begin
			REF_1306(int128) (->deque) := frontIndex(int128)
	Function DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: empty(deque)
		IRs:
			TMP_4126(bool) = INTERNAL_CALL, DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque)(deque)
			CONDITION TMP_4126
		Expression: revert Empty()()
		IRs:
			TMP_4127(None) = SOLIDITY_CALL revert Empty()()
		Expression: frontIndex = deque._begin
		IRs:
			REF_1307(int128) -> deque._begin
			frontIndex(int128) := REF_1307(int128)
		Expression: value = deque._data[frontIndex]
		IRs:
			REF_1308(mapping(int128 => bytes32)) -> deque._data
			REF_1309(bytes32) -> REF_1308[frontIndex]
			value(bytes32) := REF_1309(bytes32)
		Expression: delete deque._data[frontIndex]
		IRs:
			REF_1310(mapping(int128 => bytes32)) -> deque._data
			REF_1311(bytes32) -> REF_1310[frontIndex]
			REF_1310 = delete REF_1311 
		Expression: deque._begin = frontIndex + 1
		IRs:
			REF_1312(int128) -> deque._begin
			TMP_4128(int128) = frontIndex + 1
			REF_1312(int128) (->deque) := TMP_4128(int128)
	Function DoubleEndedQueue.front(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: empty(deque)
		IRs:
			TMP_4129(bool) = INTERNAL_CALL, DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque)(deque)
			CONDITION TMP_4129
		Expression: revert Empty()()
		IRs:
			TMP_4130(None) = SOLIDITY_CALL revert Empty()()
		Expression: frontIndex = deque._begin
		IRs:
			REF_1313(int128) -> deque._begin
			frontIndex(int128) := REF_1313(int128)
		Expression: deque._data[frontIndex]
		IRs:
			REF_1314(mapping(int128 => bytes32)) -> deque._data
			REF_1315(bytes32) -> REF_1314[frontIndex]
			RETURN REF_1315
	Function DoubleEndedQueue.back(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: empty(deque)
		IRs:
			TMP_4131(bool) = INTERNAL_CALL, DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque)(deque)
			CONDITION TMP_4131
		Expression: revert Empty()()
		IRs:
			TMP_4132(None) = SOLIDITY_CALL revert Empty()()
		Expression: backIndex = deque._end - 1
		IRs:
			REF_1316(int128) -> deque._end
			TMP_4133(int128) = REF_1316 - 1
			backIndex(int128) := TMP_4133(int128)
		Expression: deque._data[backIndex]
		IRs:
			REF_1317(mapping(int128 => bytes32)) -> deque._data
			REF_1318(bytes32) -> REF_1317[backIndex]
			RETURN REF_1318
	Function DoubleEndedQueue.at(DoubleEndedQueue.Bytes32Deque,uint256) (*)
		Expression: idx = SafeCast.toInt128(int256(deque._begin) + SafeCast.toInt256(index))
		IRs:
			REF_1320(int128) -> deque._begin
			TMP_4134 = CONVERT REF_1320 to int256
			TMP_4135(int256) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toInt256(uint256), arguments:['index'] 
			TMP_4136(int256) = TMP_4134 (c)+ TMP_4135
			TMP_4137(int128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toInt128(int256), arguments:['TMP_4136'] 
			idx(int128) := TMP_4137(int128)
		Expression: idx >= deque._end
		IRs:
			REF_1322(int128) -> deque._end
			TMP_4138(bool) = idx >= REF_1322
			CONDITION TMP_4138
		Expression: revert OutOfBounds()()
		IRs:
			TMP_4139(None) = SOLIDITY_CALL revert OutOfBounds()()
		Expression: deque._data[idx]
		IRs:
			REF_1323(mapping(int128 => bytes32)) -> deque._data
			REF_1324(bytes32) -> REF_1323[idx]
			RETURN REF_1324
	Function DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: deque._begin = 0
		IRs:
			REF_1325(int128) -> deque._begin
			REF_1325(int128) (->deque) := 0(int128)
		Expression: deque._end = 0
		IRs:
			REF_1326(int128) -> deque._end
			REF_1326(int128) (->deque) := 0(int128)
	Function DoubleEndedQueue.length(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: uint256(int256(deque._end) - int256(deque._begin))
		IRs:
			REF_1327(int128) -> deque._end
			TMP_4140 = CONVERT REF_1327 to int256
			REF_1328(int128) -> deque._begin
			TMP_4141 = CONVERT REF_1328 to int256
			TMP_4142(int256) = TMP_4140 - TMP_4141
			TMP_4143 = CONVERT TMP_4142 to uint256
			RETURN TMP_4143
	Function DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque) (*)
		Expression: deque._end <= deque._begin
		IRs:
			REF_1329(int128) -> deque._end
			REF_1330(int128) -> deque._begin
			TMP_4144(bool) = REF_1329 <= REF_1330
			RETURN TMP_4144
Contract EnumerableSet
	Function EnumerableSet._add(EnumerableSet.Set,bytes32) (*)
		Expression: ! _contains(set,value)
		IRs:
			TMP_4145(bool) = INTERNAL_CALL, EnumerableSet._contains(EnumerableSet.Set,bytes32)(set,value)
			TMP_4146 = UnaryType.BANG TMP_4145 
			CONDITION TMP_4146
		Expression: set._values.push(value)
		IRs:
			REF_1331(bytes32[]) -> set._values
			REF_1333 -> LENGTH REF_1331
			TMP_4148(uint256) := REF_1333(uint256)
			TMP_4149(uint256) = TMP_4148 (c)+ 1
			REF_1333(uint256) (->set) := TMP_4149(uint256)
			REF_1334(bytes32) -> REF_1331[TMP_4148]
			REF_1334(bytes32) (->set) := value(bytes32)
		Expression: set._indexes[value] = set._values.length
		IRs:
			REF_1335(mapping(bytes32 => uint256)) -> set._indexes
			REF_1336(uint256) -> REF_1335[value]
			REF_1337(bytes32[]) -> set._values
			REF_1338 -> LENGTH REF_1337
			REF_1336(uint256) (->set) := REF_1338(uint256)
		Expression: true
		IRs:
			RETURN True
		Expression: false
		IRs:
			RETURN False
	Function EnumerableSet._remove(EnumerableSet.Set,bytes32) (*)
		Expression: valueIndex = set._indexes[value]
		IRs:
			REF_1339(mapping(bytes32 => uint256)) -> set._indexes
			REF_1340(uint256) -> REF_1339[value]
			valueIndex(uint256) := REF_1340(uint256)
		Expression: valueIndex != 0
		IRs:
			TMP_4150(bool) = valueIndex != 0
			CONDITION TMP_4150
		Expression: toDeleteIndex = valueIndex - 1
		IRs:
			TMP_4151(uint256) = valueIndex (c)- 1
			toDeleteIndex(uint256) := TMP_4151(uint256)
		Expression: lastIndex = set._values.length - 1
		IRs:
			REF_1341(bytes32[]) -> set._values
			REF_1342 -> LENGTH REF_1341
			TMP_4152(uint256) = REF_1342 (c)- 1
			lastIndex(uint256) := TMP_4152(uint256)
		Expression: lastIndex != toDeleteIndex
		IRs:
			TMP_4153(bool) = lastIndex != toDeleteIndex
			CONDITION TMP_4153
		Expression: lastValue = set._values[lastIndex]
		IRs:
			REF_1343(bytes32[]) -> set._values
			REF_1344(bytes32) -> REF_1343[lastIndex]
			lastValue(bytes32) := REF_1344(bytes32)
		Expression: set._values[toDeleteIndex] = lastValue
		IRs:
			REF_1345(bytes32[]) -> set._values
			REF_1346(bytes32) -> REF_1345[toDeleteIndex]
			REF_1346(bytes32) (->set) := lastValue(bytes32)
		Expression: set._indexes[lastValue] = valueIndex
		IRs:
			REF_1347(mapping(bytes32 => uint256)) -> set._indexes
			REF_1348(uint256) -> REF_1347[lastValue]
			REF_1348(uint256) (->set) := valueIndex(uint256)
		Expression: set._values.pop()
		IRs:
			REF_1349(bytes32[]) -> set._values
			REF_1351 -> LENGTH REF_1349
			TMP_4155(uint256) = REF_1351 (c)- 1
			REF_1352(bytes32) -> REF_1349[TMP_4155]
			REF_1349 = delete REF_1352 
			REF_1353 -> LENGTH REF_1349
			REF_1353(uint256) (->set) := TMP_4155(uint256)
		Expression: delete set._indexes[value]
		IRs:
			REF_1354(mapping(bytes32 => uint256)) -> set._indexes
			REF_1355(uint256) -> REF_1354[value]
			REF_1354 = delete REF_1355 
		Expression: true
		IRs:
			RETURN True
		Expression: false
		IRs:
			RETURN False
	Function EnumerableSet._contains(EnumerableSet.Set,bytes32) (*)
		Expression: set._indexes[value] != 0
		IRs:
			REF_1356(mapping(bytes32 => uint256)) -> set._indexes
			REF_1357(uint256) -> REF_1356[value]
			TMP_4156(bool) = REF_1357 != 0
			RETURN TMP_4156
	Function EnumerableSet._length(EnumerableSet.Set) (*)
		Expression: set._values.length
		IRs:
			REF_1358(bytes32[]) -> set._values
			REF_1359 -> LENGTH REF_1358
			RETURN REF_1359
	Function EnumerableSet._at(EnumerableSet.Set,uint256) (*)
		Expression: set._values[index]
		IRs:
			REF_1360(bytes32[]) -> set._values
			REF_1361(bytes32) -> REF_1360[index]
			RETURN REF_1361
	Function EnumerableSet._values(EnumerableSet.Set) (*)
		Expression: set._values
		IRs:
			REF_1362(bytes32[]) -> set._values
			RETURN REF_1362
	Function EnumerableSet.add(EnumerableSet.Bytes32Set,bytes32) (*)
		Expression: _add(set._inner,value)
		IRs:
			REF_1363(EnumerableSet.Set) -> set._inner
			TMP_4157(bool) = INTERNAL_CALL, EnumerableSet._add(EnumerableSet.Set,bytes32)(REF_1363,value)
			RETURN TMP_4157
	Function EnumerableSet.remove(EnumerableSet.Bytes32Set,bytes32) (*)
		Expression: _remove(set._inner,value)
		IRs:
			REF_1364(EnumerableSet.Set) -> set._inner
			TMP_4158(bool) = INTERNAL_CALL, EnumerableSet._remove(EnumerableSet.Set,bytes32)(REF_1364,value)
			RETURN TMP_4158
	Function EnumerableSet.contains(EnumerableSet.Bytes32Set,bytes32) (*)
		Expression: _contains(set._inner,value)
		IRs:
			REF_1365(EnumerableSet.Set) -> set._inner
			TMP_4159(bool) = INTERNAL_CALL, EnumerableSet._contains(EnumerableSet.Set,bytes32)(REF_1365,value)
			RETURN TMP_4159
	Function EnumerableSet.length(EnumerableSet.Bytes32Set) (*)
		Expression: _length(set._inner)
		IRs:
			REF_1366(EnumerableSet.Set) -> set._inner
			TMP_4160(uint256) = INTERNAL_CALL, EnumerableSet._length(EnumerableSet.Set)(REF_1366)
			RETURN TMP_4160
	Function EnumerableSet.at(EnumerableSet.Bytes32Set,uint256) (*)
		Expression: _at(set._inner,index)
		IRs:
			REF_1367(EnumerableSet.Set) -> set._inner
			TMP_4161(bytes32) = INTERNAL_CALL, EnumerableSet._at(EnumerableSet.Set,uint256)(REF_1367,index)
			RETURN TMP_4161
	Function EnumerableSet.values(EnumerableSet.Bytes32Set) (*)
		Expression: store = _values(set._inner)
		IRs:
			REF_1368(EnumerableSet.Set) -> set._inner
			TMP_4162(bytes32[]) = INTERNAL_CALL, EnumerableSet._values(EnumerableSet.Set)(REF_1368)
			store(bytes32[]) = ['TMP_4162(bytes32[])']
		Expression: result = store
		IRs:
			result(bytes32[]) = ['store(bytes32[])']
		Expression: result
		IRs:
			RETURN result
	Function EnumerableSet.add(EnumerableSet.AddressSet,address) (*)
		Expression: _add(set._inner,bytes32(uint256(uint160(value))))
		IRs:
			REF_1369(EnumerableSet.Set) -> set._inner
			TMP_4163 = CONVERT value to uint160
			TMP_4164 = CONVERT TMP_4163 to uint256
			TMP_4165 = CONVERT TMP_4164 to bytes32
			TMP_4166(bool) = INTERNAL_CALL, EnumerableSet._add(EnumerableSet.Set,bytes32)(REF_1369,TMP_4165)
			RETURN TMP_4166
	Function EnumerableSet.remove(EnumerableSet.AddressSet,address) (*)
		Expression: _remove(set._inner,bytes32(uint256(uint160(value))))
		IRs:
			REF_1370(EnumerableSet.Set) -> set._inner
			TMP_4167 = CONVERT value to uint160
			TMP_4168 = CONVERT TMP_4167 to uint256
			TMP_4169 = CONVERT TMP_4168 to bytes32
			TMP_4170(bool) = INTERNAL_CALL, EnumerableSet._remove(EnumerableSet.Set,bytes32)(REF_1370,TMP_4169)
			RETURN TMP_4170
	Function EnumerableSet.contains(EnumerableSet.AddressSet,address) (*)
		Expression: _contains(set._inner,bytes32(uint256(uint160(value))))
		IRs:
			REF_1371(EnumerableSet.Set) -> set._inner
			TMP_4171 = CONVERT value to uint160
			TMP_4172 = CONVERT TMP_4171 to uint256
			TMP_4173 = CONVERT TMP_4172 to bytes32
			TMP_4174(bool) = INTERNAL_CALL, EnumerableSet._contains(EnumerableSet.Set,bytes32)(REF_1371,TMP_4173)
			RETURN TMP_4174
	Function EnumerableSet.length(EnumerableSet.AddressSet) (*)
		Expression: _length(set._inner)
		IRs:
			REF_1372(EnumerableSet.Set) -> set._inner
			TMP_4175(uint256) = INTERNAL_CALL, EnumerableSet._length(EnumerableSet.Set)(REF_1372)
			RETURN TMP_4175
	Function EnumerableSet.at(EnumerableSet.AddressSet,uint256) (*)
		Expression: address(uint160(uint256(_at(set._inner,index))))
		IRs:
			REF_1373(EnumerableSet.Set) -> set._inner
			TMP_4176(bytes32) = INTERNAL_CALL, EnumerableSet._at(EnumerableSet.Set,uint256)(REF_1373,index)
			TMP_4177 = CONVERT TMP_4176 to uint256
			TMP_4178 = CONVERT TMP_4177 to uint160
			TMP_4179 = CONVERT TMP_4178 to address
			RETURN TMP_4179
	Function EnumerableSet.values(EnumerableSet.AddressSet) (*)
		Expression: store = _values(set._inner)
		IRs:
			REF_1374(EnumerableSet.Set) -> set._inner
			TMP_4180(bytes32[]) = INTERNAL_CALL, EnumerableSet._values(EnumerableSet.Set)(REF_1374)
			store(bytes32[]) = ['TMP_4180(bytes32[])']
		Expression: result = store
		IRs:
			result(address[]) = ['store(bytes32[])']
		Expression: result
		IRs:
			RETURN result
	Function EnumerableSet.add(EnumerableSet.UintSet,uint256) (*)
		Expression: _add(set._inner,bytes32(value))
		IRs:
			REF_1375(EnumerableSet.Set) -> set._inner
			TMP_4181 = CONVERT value to bytes32
			TMP_4182(bool) = INTERNAL_CALL, EnumerableSet._add(EnumerableSet.Set,bytes32)(REF_1375,TMP_4181)
			RETURN TMP_4182
	Function EnumerableSet.remove(EnumerableSet.UintSet,uint256) (*)
		Expression: _remove(set._inner,bytes32(value))
		IRs:
			REF_1376(EnumerableSet.Set) -> set._inner
			TMP_4183 = CONVERT value to bytes32
			TMP_4184(bool) = INTERNAL_CALL, EnumerableSet._remove(EnumerableSet.Set,bytes32)(REF_1376,TMP_4183)
			RETURN TMP_4184
	Function EnumerableSet.contains(EnumerableSet.UintSet,uint256) (*)
		Expression: _contains(set._inner,bytes32(value))
		IRs:
			REF_1377(EnumerableSet.Set) -> set._inner
			TMP_4185 = CONVERT value to bytes32
			TMP_4186(bool) = INTERNAL_CALL, EnumerableSet._contains(EnumerableSet.Set,bytes32)(REF_1377,TMP_4185)
			RETURN TMP_4186
	Function EnumerableSet.length(EnumerableSet.UintSet) (*)
		Expression: _length(set._inner)
		IRs:
			REF_1378(EnumerableSet.Set) -> set._inner
			TMP_4187(uint256) = INTERNAL_CALL, EnumerableSet._length(EnumerableSet.Set)(REF_1378)
			RETURN TMP_4187
	Function EnumerableSet.at(EnumerableSet.UintSet,uint256) (*)
		Expression: uint256(_at(set._inner,index))
		IRs:
			REF_1379(EnumerableSet.Set) -> set._inner
			TMP_4188(bytes32) = INTERNAL_CALL, EnumerableSet._at(EnumerableSet.Set,uint256)(REF_1379,index)
			TMP_4189 = CONVERT TMP_4188 to uint256
			RETURN TMP_4189
	Function EnumerableSet.values(EnumerableSet.UintSet) (*)
		Expression: store = _values(set._inner)
		IRs:
			REF_1380(EnumerableSet.Set) -> set._inner
			TMP_4190(bytes32[]) = INTERNAL_CALL, EnumerableSet._values(EnumerableSet.Set)(REF_1380)
			store(bytes32[]) = ['TMP_4190(bytes32[])']
		Expression: result = store
		IRs:
			result(uint256[]) = ['store(bytes32[])']
		Expression: result
		IRs:
			RETURN result
Contract EmptySlot
Contract GovernableOwnable
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4193(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_4193)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4196(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_4197(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_4198(bool) = TMP_4196 == TMP_4197
			TMP_4199(None) = SOLIDITY_CALL require(bool,string)(TMP_4198,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4200 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_4200)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4203 = CONVERT 0 to address
			TMP_4204(bool) = newOwner != TMP_4203
			TMP_4205(None) = SOLIDITY_CALL require(bool,string)(TMP_4204,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_4211 = UnaryType.BANG _initializing 
			TMP_4212(None) = SOLIDITY_CALL require(bool,string)(TMP_4211,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_4214(uint8) := 255(uint8)
			TMP_4215(bool) = _initialized != TMP_4214
			CONDITION TMP_4215
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_4217(uint8) := 255(uint8)
			_initialized(uint8) := TMP_4217(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_4219(uint8) := 255(uint8)
			Emit Initialized(TMP_4219)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_4224 = CONVERT 0 to address
			TMP_4225(bool) = _newGovernor == TMP_4224
			CONDITION TMP_4225
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_4226(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_4231 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_4231(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_4232(bool) = _initialized < 1
			TMP_4233(bool) = isTopLevelCall && TMP_4232
			TMP_4234 = CONVERT this to address
			TMP_4235(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_4234'] 
			TMP_4236 = UnaryType.BANG TMP_4235 
			TMP_4237(bool) = _initialized == 1
			TMP_4238(bool) = TMP_4236 && TMP_4237
			TMP_4239(bool) = TMP_4233 || TMP_4238
			TMP_4240(None) = SOLIDITY_CALL require(bool,string)(TMP_4239,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_4242 = UnaryType.BANG _initializing 
			TMP_4243(bool) = _initialized < version
			TMP_4244(bool) = TMP_4242 && TMP_4243
			TMP_4245(None) = SOLIDITY_CALL require(bool,string)(TMP_4244,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_4247(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_4248(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_4249(bool) = msg.sender != TMP_4248
			CONDITION TMP_4249
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_4250(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
Contract MultiCommand
	Function MultiCommand.dispatch(uint256,bytes,uint256[]) (*)
	Function MultiCommand.execute(Command[]) (*)
		Expression: numCommands = commands.length
		IRs:
			REF_1382 -> LENGTH commands
			numCommands(uint256) := REF_1382(uint256)
		Expression: callStack = new uint256[](Commands.CALL_STACK_SIZE)
		IRs:
			REF_1383(uint256) -> Commands.CALL_STACK_SIZE
			TMP_4252(uint256[])  = new uint256[](REF_1383)
			callStack(uint256[]) = ['TMP_4252(uint256[])']
		Expression: commandIndex = 0
		IRs:
			commandIndex(uint256) := 0(uint256)
		Expression: commandIndex < numCommands
		IRs:
			TMP_4253(bool) = commandIndex < numCommands
			CONDITION TMP_4253
		Expression: (success,output) = dispatch(commands[commandIndex].action,commands[commandIndex].data,callStack)
		IRs:
			REF_1384(Command) -> commands[commandIndex]
			REF_1385(uint256) -> REF_1384.action
			REF_1386(Command) -> commands[commandIndex]
			REF_1387(bytes) -> REF_1386.data
			TUPLE_56(bool,bytes) = INTERNAL_CALL, MultiCommand.dispatch(uint256,bytes,uint256[])(REF_1385,REF_1387,callStack)
			success(bool)= UNPACK TUPLE_56 index: 0 
			output(bytes)= UNPACK TUPLE_56 index: 1 
		Expression: ! success
		IRs:
			TMP_4254 = UnaryType.BANG success 
			CONDITION TMP_4254
		Expression: revert ExecutionFailed(uint256,bytes)({commandIndex:commandIndex,message:output})
		IRs:
			TMP_4255(None) = SOLIDITY_CALL revert ExecutionFailed(uint256,bytes)(commandIndex,output)
		Expression: commandIndex ++
		IRs:
			TMP_4256(uint256) := commandIndex(uint256)
			commandIndex(uint256) = commandIndex + 1
Contract MultiStrategy
	Function Ownable2StepUpgradeable.__Ownable2Step_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.pendingOwner() (*)
		Expression: _pendingOwner
		IRs:
			RETURN _pendingOwner
	Function Ownable2StepUpgradeable.transferOwnership(address) (*)
		Expression: _pendingOwner = newOwner
		IRs:
			_pendingOwner(address) := newOwner(address)
		Expression: OwnershipTransferStarted(owner(),newOwner)
		IRs:
			TMP_4260(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			Emit OwnershipTransferStarted(TMP_4260,newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable._transferOwnership(address) (*)
		Expression: delete _pendingOwner
		IRs:
			_pendingOwner = delete _pendingOwner 
		Expression: super._transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
	Function Ownable2StepUpgradeable.acceptOwnership() (*)
		Expression: sender = _msgSender()
		IRs:
			TMP_4264(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			sender(address) := TMP_4264(address)
		Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)
		IRs:
			TMP_4265(address) = INTERNAL_CALL, Ownable2StepUpgradeable.pendingOwner()()
			TMP_4266(bool) = TMP_4265 == sender
			TMP_4267(None) = SOLIDITY_CALL require(bool,string)(TMP_4266,Ownable2Step: caller is not the new owner)
		Expression: _transferOwnership(sender)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(sender)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4271(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_4271)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4274(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_4275(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_4276(bool) = TMP_4274 == TMP_4275
			TMP_4277(None) = SOLIDITY_CALL require(bool,string)(TMP_4276,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4278 = CONVERT 0 to address
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_4278)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) 
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4281 = CONVERT 0 to address
			TMP_4282(bool) = newOwner != TMP_4281
			TMP_4283(None) = SOLIDITY_CALL require(bool,string)(TMP_4282,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) 
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_4289 = UnaryType.BANG _initializing 
			TMP_4290(None) = SOLIDITY_CALL require(bool,string)(TMP_4289,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_4292(uint8) := 255(uint8)
			TMP_4293(bool) = _initialized != TMP_4292
			CONDITION TMP_4293
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_4295(uint8) := 255(uint8)
			_initialized(uint8) := TMP_4295(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_4297(uint8) := 255(uint8)
			Emit Initialized(TMP_4297)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function MultiStrategy._initMultiStrategy(IStrategy[],uint16[]) (*)
		Expression: istrategies.length == 0
		IRs:
			REF_1388 -> LENGTH istrategies
			TMP_4299(bool) = REF_1388 == 0
			CONDITION TMP_4299
		Expression: revert InvalidStrategies()()
		IRs:
			TMP_4300(None) = SOLIDITY_CALL revert InvalidStrategies()()
		Expression: iweights.length == 0
		IRs:
			REF_1389 -> LENGTH iweights
			TMP_4301(bool) = REF_1389 == 0
			CONDITION TMP_4301
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4302(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: istrategies.length != iweights.length
		IRs:
			REF_1390 -> LENGTH istrategies
			REF_1391 -> LENGTH iweights
			TMP_4303(bool) = REF_1390 != REF_1391
			CONDITION TMP_4303
		Expression: revert InvalidWeightsLength()()
		IRs:
			TMP_4304(None) = SOLIDITY_CALL revert InvalidWeightsLength()()
		Expression: _strategies = istrategies
		IRs:
			_strategies(IStrategy[]) = ['istrategies(IStrategy[])']
		Expression: _weights = iweights
		IRs:
			_weights(uint16[]) = ['iweights(uint16[])']
		Expression: _totalWeight = 0
		IRs:
			_totalWeight(uint16) := 0(uint256)
		Expression: _maxDifference = 100
		IRs:
			_maxDifference(uint256) := 100(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < istrategies.length
		IRs:
			REF_1392 -> LENGTH istrategies
			TMP_4305(bool) = i < REF_1392
			CONDITION TMP_4305
		Expression: _totalWeight += iweights[i]
		IRs:
			REF_1393(uint16) -> iweights[i]
			_totalWeight(uint16) = _totalWeight (c)+ REF_1393
		Expression: i ++
		IRs:
			TMP_4306(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
		Expression: _totalWeight == 0
		IRs:
			TMP_4307(bool) = _totalWeight == 0
			CONDITION TMP_4307
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4308(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: _totalWeight > 10000
		IRs:
			TMP_4309(bool) = _totalWeight > 10000
			CONDITION TMP_4309
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4310(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function MultiStrategy.setWeights(uint16[]) (*)
		Expression: iweights.length != _strategies.length
		IRs:
			REF_1394 -> LENGTH iweights
			REF_1395 -> LENGTH _strategies
			TMP_4312(bool) = REF_1394 != REF_1395
			CONDITION TMP_4312
		Expression: revert InvalidWeightsLength()()
		IRs:
			TMP_4313(None) = SOLIDITY_CALL revert InvalidWeightsLength()()
		Expression: _weights = iweights
		IRs:
			_weights(uint16[]) = ['iweights(uint16[])']
		Expression: _totalWeight = 0
		IRs:
			_totalWeight(uint16) := 0(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < iweights.length
		IRs:
			REF_1396 -> LENGTH iweights
			TMP_4314(bool) = i < REF_1396
			CONDITION TMP_4314
		Expression: _totalWeight += iweights[i]
		IRs:
			REF_1397(uint16) -> iweights[i]
			_totalWeight(uint16) = _totalWeight (c)+ REF_1397
		Expression: i ++
		IRs:
			TMP_4315(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: _totalWeight == 0 || _totalWeight > MAX_TOTAL_WEIGHT
		IRs:
			TMP_4316(bool) = _totalWeight == 0
			TMP_4317(bool) = _totalWeight > MAX_TOTAL_WEIGHT
			TMP_4318(bool) = TMP_4316 || TMP_4317
			CONDITION TMP_4318
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4319(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: WeightsUpdated(iweights)
		IRs:
			Emit WeightsUpdated(iweights)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.maxDifference() (*)
		Expression: _maxDifference
		IRs:
			RETURN _maxDifference
	Function MultiStrategy.setMaxDifference(uint256) (*)
		Expression: imaxDifference > MAX_TOTAL_WEIGHT
		IRs:
			TMP_4322(bool) = imaxDifference > MAX_TOTAL_WEIGHT
			CONDITION TMP_4322
		Expression: revert InvalidMaxDifference(uint256)(imaxDifference)
		IRs:
			TMP_4323(None) = SOLIDITY_CALL revert InvalidMaxDifference(uint256)(imaxDifference)
		Expression: _maxDifference = imaxDifference
		IRs:
			_maxDifference(uint256) := imaxDifference(uint256)
		Expression: MaxDifferenceUpdated(imaxDifference)
		IRs:
			Emit MaxDifferenceUpdated(imaxDifference)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.addStrategy(IStrategy) (*)
		Expression: address(strategy) == address(0)
		IRs:
			TMP_4326 = CONVERT strategy to address
			TMP_4327 = CONVERT 0 to address
			TMP_4328(bool) = TMP_4326 == TMP_4327
			CONDITION TMP_4328
		Expression: revert InvalidStrategy()()
		IRs:
			TMP_4329(None) = SOLIDITY_CALL revert InvalidStrategy()()
		Expression: _strategies.push(strategy)
		IRs:
			REF_1399 -> LENGTH _strategies
			TMP_4331(uint256) := REF_1399(uint256)
			TMP_4332(uint256) = TMP_4331 (c)+ 1
			REF_1399(uint256) (->_strategies) := TMP_4332(uint256)
			REF_1400(IStrategy) -> _strategies[TMP_4331]
			REF_1400(IStrategy) (->_strategies) := strategy(IStrategy)
		Expression: _weights.push(0)
		IRs:
			REF_1402 -> LENGTH _weights
			TMP_4334(uint256) := REF_1402(uint256)
			TMP_4335(uint256) = TMP_4334 (c)+ 1
			REF_1402(uint256) (->_weights) := TMP_4335(uint256)
			REF_1403(uint16) -> _weights[TMP_4334]
			REF_1403(uint16) (->_weights) := 0(uint256)
		Expression: AddStrategy(address(strategy))
		IRs:
			TMP_4336 = CONVERT strategy to address
			Emit AddStrategy(TMP_4336)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.strategies() (*)
		Expression: _strategies
		IRs:
			RETURN _strategies
	Function MultiStrategy.weights() (*)
		Expression: _weights
		IRs:
			RETURN _weights
	Function MultiStrategy.totalWeight() (*)
		Expression: _totalWeight
		IRs:
			RETURN _totalWeight
	Function MultiStrategy._allocateAssets(uint256) (*)
		Expression: totalDeployed = 0
		IRs:
			totalDeployed(uint256) := 0(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1404 -> LENGTH _strategies
			TMP_4339(bool) = i < REF_1404
			CONDITION TMP_4339
		Expression: fractAmount = (amount * _weights[i]) / _totalWeight
		IRs:
			REF_1405(uint16) -> _weights[i]
			TMP_4340(uint256) = amount (c)* REF_1405
			TMP_4341(uint256) = TMP_4340 (c)/ _totalWeight
			fractAmount(uint256) := TMP_4341(uint256)
		Expression: fractAmount > 0
		IRs:
			TMP_4342(bool) = fractAmount > 0
			CONDITION TMP_4342
		Expression: totalDeployed += IStrategy(_strategies[i]).deploy(fractAmount)
		IRs:
			REF_1406(IStrategy) -> _strategies[i]
			TMP_4343 = CONVERT REF_1406 to IStrategy
			TMP_4344(uint256) = HIGH_LEVEL_CALL, dest:TMP_4343(IStrategy), function:deploy, arguments:['fractAmount']  
			totalDeployed(uint256) = totalDeployed (c)+ TMP_4344
		Expression: i ++
		IRs:
			TMP_4345(uint256) := i(uint256)
			i(uint256) = i + 1
	Function MultiStrategy._deallocateAssets(uint256) (*)
		Expression: currentAssets = new uint256[](_strategies.length)
		IRs:
			REF_1408 -> LENGTH _strategies
			TMP_4347(uint256[])  = new uint256[](REF_1408)
			currentAssets(uint256[]) = ['TMP_4347(uint256[])']
		Expression: totalAssets = 0
		IRs:
			totalAssets(uint256) := 0(uint256)
		Expression: strategiesLength = _strategies.length
		IRs:
			REF_1409 -> LENGTH _strategies
			strategiesLength(uint256) := REF_1409(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < strategiesLength
		IRs:
			TMP_4348(bool) = i < strategiesLength
			CONDITION TMP_4348
		Expression: currentAssets[i] = IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1410(uint256) -> currentAssets[i]
			REF_1411(IStrategy) -> _strategies[i]
			TMP_4349 = CONVERT REF_1411 to IStrategy
			TMP_4350(uint256) = HIGH_LEVEL_CALL, dest:TMP_4349(IStrategy), function:totalAssets, arguments:[]  
			REF_1410(uint256) (->currentAssets) := TMP_4350(uint256)
		Expression: totalAssets += currentAssets[i]
		IRs:
			REF_1413(uint256) -> currentAssets[i]
			totalAssets(uint256) = totalAssets (c)+ REF_1413
		Expression: i ++
		IRs:
			TMP_4351(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
		Expression: totalUndeployed = 0
		IRs:
			totalUndeployed(uint256) := 0(uint256)
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < strategiesLength
		IRs:
			TMP_4352(bool) = i_scope_0 < strategiesLength
			CONDITION TMP_4352
		Expression: fractAmount = (amount * currentAssets[i_scope_0]) / totalAssets
		IRs:
			REF_1414(uint256) -> currentAssets[i_scope_0]
			TMP_4353(uint256) = amount (c)* REF_1414
			TMP_4354(uint256) = TMP_4353 (c)/ totalAssets
			fractAmount(uint256) := TMP_4354(uint256)
		Expression: totalUndeployed += IStrategy(_strategies[i_scope_0]).undeploy(fractAmount)
		IRs:
			REF_1415(IStrategy) -> _strategies[i_scope_0]
			TMP_4355 = CONVERT REF_1415 to IStrategy
			TMP_4356(uint256) = HIGH_LEVEL_CALL, dest:TMP_4355(IStrategy), function:undeploy, arguments:['fractAmount']  
			totalUndeployed(uint256) = totalUndeployed (c)+ TMP_4356
		Expression: i_scope_0 ++
		IRs:
			TMP_4357(uint256) := i_scope_0(uint256)
			i_scope_0(uint256) = i_scope_0 (c)+ 1
	Function MultiStrategy._totalAssets() (*)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1417 -> LENGTH _strategies
			TMP_4358(bool) = i < REF_1417
			CONDITION TMP_4358
		Expression: assets += IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1418(IStrategy) -> _strategies[i]
			TMP_4359 = CONVERT REF_1418 to IStrategy
			TMP_4360(uint256) = HIGH_LEVEL_CALL, dest:TMP_4359(IStrategy), function:totalAssets, arguments:[]  
			assets(uint256) = assets (c)+ TMP_4360
		Expression: i ++
		IRs:
			TMP_4361(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: assets
		IRs:
			RETURN assets
	Function MultiStrategy._harvestStrategies() (*)
		Expression: balanceChange = 0
		IRs:
			balanceChange(int256) := 0(int256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1420 -> LENGTH _strategies
			TMP_4362(bool) = i < REF_1420
			CONDITION TMP_4362
		Expression: balanceChange += IStrategy(_strategies[i]).harvest()
		IRs:
			REF_1421(IStrategy) -> _strategies[i]
			TMP_4363 = CONVERT REF_1421 to IStrategy
			TMP_4364(int256) = HIGH_LEVEL_CALL, dest:TMP_4363(IStrategy), function:harvest, arguments:[]  
			balanceChange(int256) = balanceChange (c)+ TMP_4364
		Expression: i ++
		IRs:
			TMP_4365(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
	Function MultiStrategy._rebalanceStrategies() (*)
		Expression: totalCapital = _totalAssets()
		IRs:
			TMP_4366(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			totalCapital(uint256) := TMP_4366(uint256)
		Expression: maxDifferenceAllowed = _maxDifference
		IRs:
			maxDifferenceAllowed(uint256) := _maxDifference(uint256)
		Expression: totalStrategies = _strategies.length
		IRs:
			REF_1423 -> LENGTH _strategies
			totalStrategies(uint256) := REF_1423(uint256)
		Expression: deltas = new int256[](totalStrategies)
		IRs:
			TMP_4368(int256[])  = new int256[](totalStrategies)
			deltas(int256[]) = ['TMP_4368(int256[])']
		Expression: indexes = new uint256[](totalStrategies)
		IRs:
			TMP_4370(uint256[])  = new uint256[](totalStrategies)
			indexes(uint256[]) = ['TMP_4370(uint256[])']
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < totalStrategies
		IRs:
			TMP_4371(bool) = i < totalStrategies
			CONDITION TMP_4371
		Expression: targetAllocation = (totalCapital * _weights[i]) / _totalWeight
		IRs:
			REF_1424(uint16) -> _weights[i]
			TMP_4372(uint256) = totalCapital (c)* REF_1424
			TMP_4373(uint256) = TMP_4372 (c)/ _totalWeight
			targetAllocation(uint256) := TMP_4373(uint256)
		Expression: currentAllocation = IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1425(IStrategy) -> _strategies[i]
			TMP_4374 = CONVERT REF_1425 to IStrategy
			TMP_4375(uint256) = HIGH_LEVEL_CALL, dest:TMP_4374(IStrategy), function:totalAssets, arguments:[]  
			currentAllocation(uint256) := TMP_4375(uint256)
		Expression: deltas[i] = int256(targetAllocation) - int256(currentAllocation)
		IRs:
			REF_1427(int256) -> deltas[i]
			TMP_4376 = CONVERT targetAllocation to int256
			TMP_4377 = CONVERT currentAllocation to int256
			TMP_4378(int256) = TMP_4376 (c)- TMP_4377
			REF_1427(int256) (->deltas) := TMP_4378(int256)
		Expression: indexes[i] = i
		IRs:
			REF_1428(uint256) -> indexes[i]
			REF_1428(uint256) (->indexes) := i(uint256)
		Expression: j = i + 1
		IRs:
			TMP_4379(uint256) = i (c)+ 1
			j(uint256) := TMP_4379(uint256)
		Expression: j < totalStrategies
		IRs:
			TMP_4380(bool) = j < totalStrategies
			CONDITION TMP_4380
		Expression: deltas[i] > deltas[j]
		IRs:
			REF_1429(int256) -> deltas[i]
			REF_1430(int256) -> deltas[j]
			TMP_4381(bool) = REF_1429 > REF_1430
			CONDITION TMP_4381
		Expression: (deltas[i],deltas[j]) = (deltas[j],deltas[i])
		IRs:
			REF_1431(int256) -> deltas[i]
			REF_1432(int256) -> deltas[j]
			REF_1433(int256) -> deltas[j]
			REF_1434(int256) -> deltas[i]
			REF_1431(int256) (->deltas) := REF_1433(int256)
			REF_1432(int256) (->deltas) := REF_1434(int256)
		Expression: (indexes[i],indexes[j]) = (indexes[j],indexes[i])
		IRs:
			REF_1435(uint256) -> indexes[i]
			REF_1436(uint256) -> indexes[j]
			REF_1437(uint256) -> indexes[j]
			REF_1438(uint256) -> indexes[i]
			REF_1435(uint256) (->indexes) := REF_1437(uint256)
			REF_1436(uint256) (->indexes) := REF_1438(uint256)
		Expression: j ++
		IRs:
			TMP_4382(uint256) := j(uint256)
			j(uint256) = j (c)+ 1
		Expression: i ++
		IRs:
			TMP_4383(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < totalStrategies
		IRs:
			TMP_4384(bool) = i_scope_0 < totalStrategies
			CONDITION TMP_4384
		Expression: deltas[i_scope_0] > int256(maxDifferenceAllowed) && deltas[i_scope_0] < - int256(maxDifferenceAllowed)
		IRs:
			REF_1439(int256) -> deltas[i_scope_0]
			TMP_4385 = CONVERT maxDifferenceAllowed to int256
			TMP_4386(bool) = REF_1439 > TMP_4385
			REF_1440(int256) -> deltas[i_scope_0]
			TMP_4387 = CONVERT maxDifferenceAllowed to int256
			TMP_4388(int256) = 0 (c)- TMP_4387
			TMP_4389(bool) = REF_1440 < TMP_4388
			TMP_4390(bool) = TMP_4386 && TMP_4389
			CONDITION TMP_4390
		Expression: deltas[i_scope_0] > 0
		IRs:
			REF_1441(int256) -> deltas[i_scope_0]
			TMP_4391(bool) = REF_1441 > 0
			CONDITION TMP_4391
		Expression: balanceOf = IERC20(_strategies[indexes[i_scope_0]].asset()).balanceOf(address(this))
		IRs:
			REF_1442(uint256) -> indexes[i_scope_0]
			REF_1443(IStrategy) -> _strategies[REF_1442]
			TMP_4392(address) = HIGH_LEVEL_CALL, dest:REF_1443(IStrategy), function:asset, arguments:[]  
			TMP_4393 = CONVERT TMP_4392 to IERC20
			TMP_4394 = CONVERT this to address
			TMP_4395(uint256) = HIGH_LEVEL_CALL, dest:TMP_4393(IERC20), function:balanceOf, arguments:['TMP_4394']  
			balanceOf(uint256) := TMP_4395(uint256)
		Expression: IStrategy(_strategies[indexes[i_scope_0]]).deploy(amount)
		IRs:
			REF_1446(uint256) -> indexes[i_scope_0]
			REF_1447(IStrategy) -> _strategies[REF_1446]
			TMP_4396 = CONVERT REF_1447 to IStrategy
			TMP_4397(uint256) = HIGH_LEVEL_CALL, dest:TMP_4396(IStrategy), function:deploy, arguments:['amount']  
		Expression: deltas[i_scope_0] < 0
		IRs:
			REF_1449(int256) -> deltas[i_scope_0]
			TMP_4398(bool) = REF_1449 < 0
			CONDITION TMP_4398
		Expression: IStrategy(_strategies[indexes[i_scope_0]]).undeploy(uint256(- deltas[i_scope_0]))
		IRs:
			REF_1450(uint256) -> indexes[i_scope_0]
			REF_1451(IStrategy) -> _strategies[REF_1450]
			TMP_4399 = CONVERT REF_1451 to IStrategy
			REF_1453(int256) -> deltas[i_scope_0]
			TMP_4400(uint256) = 0 (c)- REF_1453
			TMP_4401 = CONVERT TMP_4400 to uint256
			TMP_4402(uint256) = HIGH_LEVEL_CALL, dest:TMP_4399(IStrategy), function:undeploy, arguments:['TMP_4401']  
		Expression: i_scope_0 ++
		IRs:
			TMP_4403(uint256) := i_scope_0(uint256)
			i_scope_0(uint256) = i_scope_0 (c)+ 1
		Expression: uint256(deltas[i_scope_0]) > balanceOf
		IRs:
			REF_1454(int256) -> deltas[i_scope_0]
			TMP_4404 = CONVERT REF_1454 to uint256
			TMP_4405(bool) = TMP_4404 > balanceOf
			CONDITION TMP_4405
		Expression: amount = balanceOf
		IRs:
			amount(uint256) := balanceOf(uint256)
		Expression: amount = uint256(deltas[i_scope_0])
		IRs:
			REF_1455(int256) -> deltas[i_scope_0]
			TMP_4406 = CONVERT REF_1455 to uint256
			amount(uint256) := TMP_4406(uint256)
	Function MultiStrategy.removeStrategy(uint256) (*)
		Expression: index >= _strategies.length
		IRs:
			REF_1456 -> LENGTH _strategies
			TMP_4407(bool) = index >= REF_1456
			CONDITION TMP_4407
		Expression: revert InvalidStrategyIndex(uint256)(index)
		IRs:
			TMP_4408(None) = SOLIDITY_CALL revert InvalidStrategyIndex(uint256)(index)
		Expression: strategyAssets = _strategies[index].totalAssets()
		IRs:
			REF_1457(IStrategy) -> _strategies[index]
			TMP_4409(uint256) = HIGH_LEVEL_CALL, dest:REF_1457(IStrategy), function:totalAssets, arguments:[]  
			strategyAssets(uint256) := TMP_4409(uint256)
		Expression: _totalWeight -= _weights[index]
		IRs:
			REF_1459(uint16) -> _weights[index]
			_totalWeight(uint16) = _totalWeight (c)- REF_1459
		Expression: _weights[index] = 0
		IRs:
			REF_1460(uint16) -> _weights[index]
			REF_1460(uint16) (->_weights) := 0(uint256)
		Expression: strategyAssets > 0
		IRs:
			TMP_4410(bool) = strategyAssets > 0
			CONDITION TMP_4410
		Expression: IStrategy(_strategies[index]).undeploy(strategyAssets)
		IRs:
			REF_1461(IStrategy) -> _strategies[index]
			TMP_4411 = CONVERT REF_1461 to IStrategy
			TMP_4412(uint256) = HIGH_LEVEL_CALL, dest:TMP_4411(IStrategy), function:undeploy, arguments:['strategyAssets']  
		Expression: _allocateAssets(strategyAssets)
		IRs:
			TMP_4413(uint256) = INTERNAL_CALL, MultiStrategy._allocateAssets(uint256)(strategyAssets)
		Expression: _rebalanceStrategies()
		IRs:
			INTERNAL_CALL, MultiStrategy._rebalanceStrategies()()
		Expression: lastIndex = _strategies.length - 1
		IRs:
			REF_1463 -> LENGTH _strategies
			TMP_4415(uint256) = REF_1463 (c)- 1
			lastIndex(uint256) := TMP_4415(uint256)
		Expression: index < lastIndex
		IRs:
			TMP_4416(bool) = index < lastIndex
			CONDITION TMP_4416
		Expression: _strategies[index] = _strategies[lastIndex]
		IRs:
			REF_1464(IStrategy) -> _strategies[index]
			REF_1465(IStrategy) -> _strategies[lastIndex]
			REF_1464(IStrategy) (->_strategies) := REF_1465(IStrategy)
		Expression: _weights[index] = _weights[lastIndex]
		IRs:
			REF_1466(uint16) -> _weights[index]
			REF_1467(uint16) -> _weights[lastIndex]
			REF_1466(uint16) (->_weights) := REF_1467(uint16)
		Expression: RemoveStrategy(address(_strategies[lastIndex]))
		IRs:
			REF_1468(IStrategy) -> _strategies[lastIndex]
			TMP_4417 = CONVERT REF_1468 to address
			Emit RemoveStrategy(TMP_4417)
		Expression: _strategies.pop()
		IRs:
			REF_1470 -> LENGTH _strategies
			TMP_4420(uint256) = REF_1470 (c)- 1
			REF_1471(IStrategy) -> _strategies[TMP_4420]
			_strategies = delete REF_1471 
			REF_1472 -> LENGTH _strategies
			REF_1472(uint256) (->_strategies) := TMP_4420(uint256)
		Expression: _weights.pop()
		IRs:
			REF_1474 -> LENGTH _weights
			TMP_4422(uint256) = REF_1474 (c)- 1
			REF_1475(uint16) -> _weights[TMP_4422]
			_weights = delete REF_1475 
			REF_1476 -> LENGTH _weights
			REF_1476(uint256) (->_weights) := TMP_4422(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.slitherConstructorConstantVariables() (*)
		Expression: MAX_TOTAL_WEIGHT = 10000
		IRs:
			MAX_TOTAL_WEIGHT(uint16) := 10000(uint256)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_4425 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_4425(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_4426(bool) = _initialized < 1
			TMP_4427(bool) = isTopLevelCall && TMP_4426
			TMP_4428 = CONVERT this to address
			TMP_4429(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_4428'] 
			TMP_4430 = UnaryType.BANG TMP_4429 
			TMP_4431(bool) = _initialized == 1
			TMP_4432(bool) = TMP_4430 && TMP_4431
			TMP_4433(bool) = TMP_4427 || TMP_4432
			TMP_4434(None) = SOLIDITY_CALL require(bool,string)(TMP_4433,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_4436 = UnaryType.BANG _initializing 
			TMP_4437(bool) = _initialized < version
			TMP_4438(bool) = TMP_4436 && TMP_4437
			TMP_4439(None) = SOLIDITY_CALL require(bool,string)(TMP_4438,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_4441(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract MultiStrategyVault
	Function IVault.depositNative(address) 
	Function IVault.withdrawNative(uint256) 
	Function IVault.redeemNative(uint256) 
	Function IVault.tokenPerAsset() 
	Function IVault.rebalance() 
	Function IERC4626Upgradeable.asset() 
	Function IERC4626Upgradeable.totalAssets() 
	Function IERC4626Upgradeable.convertToShares(uint256) 
	Function IERC4626Upgradeable.convertToAssets(uint256) 
	Function IERC4626Upgradeable.maxDeposit(address) 
	Function IERC4626Upgradeable.previewDeposit(uint256) 
	Function IERC4626Upgradeable.deposit(uint256,address) 
	Function IERC4626Upgradeable.maxMint(address) 
	Function IERC4626Upgradeable.previewMint(uint256) 
	Function IERC4626Upgradeable.mint(uint256,address) 
	Function IERC4626Upgradeable.maxWithdraw(address) 
	Function IERC4626Upgradeable.previewWithdraw(uint256) 
	Function IERC4626Upgradeable.withdraw(uint256,address,address) 
	Function IERC4626Upgradeable.maxRedeem(address) 
	Function IERC4626Upgradeable.previewRedeem(uint256) 
	Function IERC4626Upgradeable.redeem(uint256,address,address) 
	Function IERC20MetadataUpgradeable.name() 
	Function IERC20MetadataUpgradeable.symbol() 
	Function IERC20MetadataUpgradeable.decimals() 
	Function IERC20Upgradeable.totalSupply() 
	Function IERC20Upgradeable.balanceOf(address) 
	Function IERC20Upgradeable.transfer(address,uint256) 
	Function IERC20Upgradeable.allowance(address,address) 
	Function IERC20Upgradeable.approve(address,uint256) 
	Function IERC20Upgradeable.transferFrom(address,address,uint256) 
	Function MultiStrategy._initMultiStrategy(IStrategy[],uint16[]) (*)
		Expression: istrategies.length == 0
		IRs:
			REF_1478 -> LENGTH istrategies
			TMP_4442(bool) = REF_1478 == 0
			CONDITION TMP_4442
		Expression: revert InvalidStrategies()()
		IRs:
			TMP_4443(None) = SOLIDITY_CALL revert InvalidStrategies()()
		Expression: iweights.length == 0
		IRs:
			REF_1479 -> LENGTH iweights
			TMP_4444(bool) = REF_1479 == 0
			CONDITION TMP_4444
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4445(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: istrategies.length != iweights.length
		IRs:
			REF_1480 -> LENGTH istrategies
			REF_1481 -> LENGTH iweights
			TMP_4446(bool) = REF_1480 != REF_1481
			CONDITION TMP_4446
		Expression: revert InvalidWeightsLength()()
		IRs:
			TMP_4447(None) = SOLIDITY_CALL revert InvalidWeightsLength()()
		Expression: _strategies = istrategies
		IRs:
			_strategies(IStrategy[]) = ['istrategies(IStrategy[])']
		Expression: _weights = iweights
		IRs:
			_weights(uint16[]) = ['iweights(uint16[])']
		Expression: _totalWeight = 0
		IRs:
			_totalWeight(uint16) := 0(uint256)
		Expression: _maxDifference = 100
		IRs:
			_maxDifference(uint256) := 100(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < istrategies.length
		IRs:
			REF_1482 -> LENGTH istrategies
			TMP_4448(bool) = i < REF_1482
			CONDITION TMP_4448
		Expression: _totalWeight += iweights[i]
		IRs:
			REF_1483(uint16) -> iweights[i]
			_totalWeight(uint16) = _totalWeight (c)+ REF_1483
		Expression: i ++
		IRs:
			TMP_4449(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
		Expression: _totalWeight == 0
		IRs:
			TMP_4450(bool) = _totalWeight == 0
			CONDITION TMP_4450
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4451(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: _totalWeight > 10000
		IRs:
			TMP_4452(bool) = _totalWeight > 10000
			CONDITION TMP_4452
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4453(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function MultiStrategy.setWeights(uint16[]) (*)
		Expression: iweights.length != _strategies.length
		IRs:
			REF_1484 -> LENGTH iweights
			REF_1485 -> LENGTH _strategies
			TMP_4455(bool) = REF_1484 != REF_1485
			CONDITION TMP_4455
		Expression: revert InvalidWeightsLength()()
		IRs:
			TMP_4456(None) = SOLIDITY_CALL revert InvalidWeightsLength()()
		Expression: _weights = iweights
		IRs:
			_weights(uint16[]) = ['iweights(uint16[])']
		Expression: _totalWeight = 0
		IRs:
			_totalWeight(uint16) := 0(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < iweights.length
		IRs:
			REF_1486 -> LENGTH iweights
			TMP_4457(bool) = i < REF_1486
			CONDITION TMP_4457
		Expression: _totalWeight += iweights[i]
		IRs:
			REF_1487(uint16) -> iweights[i]
			_totalWeight(uint16) = _totalWeight (c)+ REF_1487
		Expression: i ++
		IRs:
			TMP_4458(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: _totalWeight == 0 || _totalWeight > MAX_TOTAL_WEIGHT
		IRs:
			TMP_4459(bool) = _totalWeight == 0
			TMP_4460(bool) = _totalWeight > MAX_TOTAL_WEIGHT
			TMP_4461(bool) = TMP_4459 || TMP_4460
			CONDITION TMP_4461
		Expression: revert InvalidWeights()()
		IRs:
			TMP_4462(None) = SOLIDITY_CALL revert InvalidWeights()()
		Expression: WeightsUpdated(iweights)
		IRs:
			Emit WeightsUpdated(iweights)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.maxDifference() (*)
		Expression: _maxDifference
		IRs:
			RETURN _maxDifference
	Function MultiStrategy.setMaxDifference(uint256) (*)
		Expression: imaxDifference > MAX_TOTAL_WEIGHT
		IRs:
			TMP_4465(bool) = imaxDifference > MAX_TOTAL_WEIGHT
			CONDITION TMP_4465
		Expression: revert InvalidMaxDifference(uint256)(imaxDifference)
		IRs:
			TMP_4466(None) = SOLIDITY_CALL revert InvalidMaxDifference(uint256)(imaxDifference)
		Expression: _maxDifference = imaxDifference
		IRs:
			_maxDifference(uint256) := imaxDifference(uint256)
		Expression: MaxDifferenceUpdated(imaxDifference)
		IRs:
			Emit MaxDifferenceUpdated(imaxDifference)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.addStrategy(IStrategy) (*)
		Expression: address(strategy) == address(0)
		IRs:
			TMP_4469 = CONVERT strategy to address
			TMP_4470 = CONVERT 0 to address
			TMP_4471(bool) = TMP_4469 == TMP_4470
			CONDITION TMP_4471
		Expression: revert InvalidStrategy()()
		IRs:
			TMP_4472(None) = SOLIDITY_CALL revert InvalidStrategy()()
		Expression: _strategies.push(strategy)
		IRs:
			REF_1489 -> LENGTH _strategies
			TMP_4474(uint256) := REF_1489(uint256)
			TMP_4475(uint256) = TMP_4474 (c)+ 1
			REF_1489(uint256) (->_strategies) := TMP_4475(uint256)
			REF_1490(IStrategy) -> _strategies[TMP_4474]
			REF_1490(IStrategy) (->_strategies) := strategy(IStrategy)
		Expression: _weights.push(0)
		IRs:
			REF_1492 -> LENGTH _weights
			TMP_4477(uint256) := REF_1492(uint256)
			TMP_4478(uint256) = TMP_4477 (c)+ 1
			REF_1492(uint256) (->_weights) := TMP_4478(uint256)
			REF_1493(uint16) -> _weights[TMP_4477]
			REF_1493(uint16) (->_weights) := 0(uint256)
		Expression: AddStrategy(address(strategy))
		IRs:
			TMP_4479 = CONVERT strategy to address
			Emit AddStrategy(TMP_4479)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function MultiStrategy.strategies() (*)
		Expression: _strategies
		IRs:
			RETURN _strategies
	Function MultiStrategy.weights() (*)
		Expression: _weights
		IRs:
			RETURN _weights
	Function MultiStrategy.totalWeight() (*)
		Expression: _totalWeight
		IRs:
			RETURN _totalWeight
	Function MultiStrategy._allocateAssets(uint256) (*)
		Expression: totalDeployed = 0
		IRs:
			totalDeployed(uint256) := 0(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1494 -> LENGTH _strategies
			TMP_4482(bool) = i < REF_1494
			CONDITION TMP_4482
		Expression: fractAmount = (amount * _weights[i]) / _totalWeight
		IRs:
			REF_1495(uint16) -> _weights[i]
			TMP_4483(uint256) = amount (c)* REF_1495
			TMP_4484(uint256) = TMP_4483 (c)/ _totalWeight
			fractAmount(uint256) := TMP_4484(uint256)
		Expression: fractAmount > 0
		IRs:
			TMP_4485(bool) = fractAmount > 0
			CONDITION TMP_4485
		Expression: totalDeployed += IStrategy(_strategies[i]).deploy(fractAmount)
		IRs:
			REF_1496(IStrategy) -> _strategies[i]
			TMP_4486 = CONVERT REF_1496 to IStrategy
			TMP_4487(uint256) = HIGH_LEVEL_CALL, dest:TMP_4486(IStrategy), function:deploy, arguments:['fractAmount']  
			totalDeployed(uint256) = totalDeployed (c)+ TMP_4487
		Expression: i ++
		IRs:
			TMP_4488(uint256) := i(uint256)
			i(uint256) = i + 1
	Function MultiStrategy._deallocateAssets(uint256) (*)
		Expression: currentAssets = new uint256[](_strategies.length)
		IRs:
			REF_1498 -> LENGTH _strategies
			TMP_4490(uint256[])  = new uint256[](REF_1498)
			currentAssets(uint256[]) = ['TMP_4490(uint256[])']
		Expression: totalAssets = 0
		IRs:
			totalAssets(uint256) := 0(uint256)
		Expression: strategiesLength = _strategies.length
		IRs:
			REF_1499 -> LENGTH _strategies
			strategiesLength(uint256) := REF_1499(uint256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < strategiesLength
		IRs:
			TMP_4491(bool) = i < strategiesLength
			CONDITION TMP_4491
		Expression: currentAssets[i] = IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1500(uint256) -> currentAssets[i]
			REF_1501(IStrategy) -> _strategies[i]
			TMP_4492 = CONVERT REF_1501 to IStrategy
			TMP_4493(uint256) = HIGH_LEVEL_CALL, dest:TMP_4492(IStrategy), function:totalAssets, arguments:[]  
			REF_1500(uint256) (->currentAssets) := TMP_4493(uint256)
		Expression: totalAssets += currentAssets[i]
		IRs:
			REF_1503(uint256) -> currentAssets[i]
			totalAssets(uint256) = totalAssets (c)+ REF_1503
		Expression: i ++
		IRs:
			TMP_4494(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
		Expression: totalUndeployed = 0
		IRs:
			totalUndeployed(uint256) := 0(uint256)
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < strategiesLength
		IRs:
			TMP_4495(bool) = i_scope_0 < strategiesLength
			CONDITION TMP_4495
		Expression: fractAmount = (amount * currentAssets[i_scope_0]) / totalAssets
		IRs:
			REF_1504(uint256) -> currentAssets[i_scope_0]
			TMP_4496(uint256) = amount (c)* REF_1504
			TMP_4497(uint256) = TMP_4496 (c)/ totalAssets
			fractAmount(uint256) := TMP_4497(uint256)
		Expression: totalUndeployed += IStrategy(_strategies[i_scope_0]).undeploy(fractAmount)
		IRs:
			REF_1505(IStrategy) -> _strategies[i_scope_0]
			TMP_4498 = CONVERT REF_1505 to IStrategy
			TMP_4499(uint256) = HIGH_LEVEL_CALL, dest:TMP_4498(IStrategy), function:undeploy, arguments:['fractAmount']  
			totalUndeployed(uint256) = totalUndeployed (c)+ TMP_4499
		Expression: i_scope_0 ++
		IRs:
			TMP_4500(uint256) := i_scope_0(uint256)
			i_scope_0(uint256) = i_scope_0 (c)+ 1
	Function MultiStrategy._totalAssets() (*)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1507 -> LENGTH _strategies
			TMP_4501(bool) = i < REF_1507
			CONDITION TMP_4501
		Expression: assets += IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1508(IStrategy) -> _strategies[i]
			TMP_4502 = CONVERT REF_1508 to IStrategy
			TMP_4503(uint256) = HIGH_LEVEL_CALL, dest:TMP_4502(IStrategy), function:totalAssets, arguments:[]  
			assets(uint256) = assets (c)+ TMP_4503
		Expression: i ++
		IRs:
			TMP_4504(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: assets
		IRs:
			RETURN assets
	Function MultiStrategy._harvestStrategies() (*)
		Expression: balanceChange = 0
		IRs:
			balanceChange(int256) := 0(int256)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < _strategies.length
		IRs:
			REF_1510 -> LENGTH _strategies
			TMP_4505(bool) = i < REF_1510
			CONDITION TMP_4505
		Expression: balanceChange += IStrategy(_strategies[i]).harvest()
		IRs:
			REF_1511(IStrategy) -> _strategies[i]
			TMP_4506 = CONVERT REF_1511 to IStrategy
			TMP_4507(int256) = HIGH_LEVEL_CALL, dest:TMP_4506(IStrategy), function:harvest, arguments:[]  
			balanceChange(int256) = balanceChange (c)+ TMP_4507
		Expression: i ++
		IRs:
			TMP_4508(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
	Function MultiStrategy._rebalanceStrategies() (*)
		Expression: totalCapital = _totalAssets()
		IRs:
			TMP_4509(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			totalCapital(uint256) := TMP_4509(uint256)
		Expression: maxDifferenceAllowed = _maxDifference
		IRs:
			maxDifferenceAllowed(uint256) := _maxDifference(uint256)
		Expression: totalStrategies = _strategies.length
		IRs:
			REF_1513 -> LENGTH _strategies
			totalStrategies(uint256) := REF_1513(uint256)
		Expression: deltas = new int256[](totalStrategies)
		IRs:
			TMP_4511(int256[])  = new int256[](totalStrategies)
			deltas(int256[]) = ['TMP_4511(int256[])']
		Expression: indexes = new uint256[](totalStrategies)
		IRs:
			TMP_4513(uint256[])  = new uint256[](totalStrategies)
			indexes(uint256[]) = ['TMP_4513(uint256[])']
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < totalStrategies
		IRs:
			TMP_4514(bool) = i < totalStrategies
			CONDITION TMP_4514
		Expression: targetAllocation = (totalCapital * _weights[i]) / _totalWeight
		IRs:
			REF_1514(uint16) -> _weights[i]
			TMP_4515(uint256) = totalCapital (c)* REF_1514
			TMP_4516(uint256) = TMP_4515 (c)/ _totalWeight
			targetAllocation(uint256) := TMP_4516(uint256)
		Expression: currentAllocation = IStrategy(_strategies[i]).totalAssets()
		IRs:
			REF_1515(IStrategy) -> _strategies[i]
			TMP_4517 = CONVERT REF_1515 to IStrategy
			TMP_4518(uint256) = HIGH_LEVEL_CALL, dest:TMP_4517(IStrategy), function:totalAssets, arguments:[]  
			currentAllocation(uint256) := TMP_4518(uint256)
		Expression: deltas[i] = int256(targetAllocation) - int256(currentAllocation)
		IRs:
			REF_1517(int256) -> deltas[i]
			TMP_4519 = CONVERT targetAllocation to int256
			TMP_4520 = CONVERT currentAllocation to int256
			TMP_4521(int256) = TMP_4519 (c)- TMP_4520
			REF_1517(int256) (->deltas) := TMP_4521(int256)
		Expression: indexes[i] = i
		IRs:
			REF_1518(uint256) -> indexes[i]
			REF_1518(uint256) (->indexes) := i(uint256)
		Expression: j = i + 1
		IRs:
			TMP_4522(uint256) = i (c)+ 1
			j(uint256) := TMP_4522(uint256)
		Expression: j < totalStrategies
		IRs:
			TMP_4523(bool) = j < totalStrategies
			CONDITION TMP_4523
		Expression: deltas[i] > deltas[j]
		IRs:
			REF_1519(int256) -> deltas[i]
			REF_1520(int256) -> deltas[j]
			TMP_4524(bool) = REF_1519 > REF_1520
			CONDITION TMP_4524
		Expression: (deltas[i],deltas[j]) = (deltas[j],deltas[i])
		IRs:
			REF_1521(int256) -> deltas[i]
			REF_1522(int256) -> deltas[j]
			REF_1523(int256) -> deltas[j]
			REF_1524(int256) -> deltas[i]
			REF_1521(int256) (->deltas) := REF_1523(int256)
			REF_1522(int256) (->deltas) := REF_1524(int256)
		Expression: (indexes[i],indexes[j]) = (indexes[j],indexes[i])
		IRs:
			REF_1525(uint256) -> indexes[i]
			REF_1526(uint256) -> indexes[j]
			REF_1527(uint256) -> indexes[j]
			REF_1528(uint256) -> indexes[i]
			REF_1525(uint256) (->indexes) := REF_1527(uint256)
			REF_1526(uint256) (->indexes) := REF_1528(uint256)
		Expression: j ++
		IRs:
			TMP_4525(uint256) := j(uint256)
			j(uint256) = j (c)+ 1
		Expression: i ++
		IRs:
			TMP_4526(uint256) := i(uint256)
			i(uint256) = i + 1
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < totalStrategies
		IRs:
			TMP_4527(bool) = i_scope_0 < totalStrategies
			CONDITION TMP_4527
		Expression: deltas[i_scope_0] > int256(maxDifferenceAllowed) && deltas[i_scope_0] < - int256(maxDifferenceAllowed)
		IRs:
			REF_1529(int256) -> deltas[i_scope_0]
			TMP_4528 = CONVERT maxDifferenceAllowed to int256
			TMP_4529(bool) = REF_1529 > TMP_4528
			REF_1530(int256) -> deltas[i_scope_0]
			TMP_4530 = CONVERT maxDifferenceAllowed to int256
			TMP_4531(int256) = 0 (c)- TMP_4530
			TMP_4532(bool) = REF_1530 < TMP_4531
			TMP_4533(bool) = TMP_4529 && TMP_4532
			CONDITION TMP_4533
		Expression: deltas[i_scope_0] > 0
		IRs:
			REF_1531(int256) -> deltas[i_scope_0]
			TMP_4534(bool) = REF_1531 > 0
			CONDITION TMP_4534
		Expression: balanceOf = IERC20(_strategies[indexes[i_scope_0]].asset()).balanceOf(address(this))
		IRs:
			REF_1532(uint256) -> indexes[i_scope_0]
			REF_1533(IStrategy) -> _strategies[REF_1532]
			TMP_4535(address) = HIGH_LEVEL_CALL, dest:REF_1533(IStrategy), function:asset, arguments:[]  
			TMP_4536 = CONVERT TMP_4535 to IERC20
			TMP_4537 = CONVERT this to address
			TMP_4538(uint256) = HIGH_LEVEL_CALL, dest:TMP_4536(IERC20), function:balanceOf, arguments:['TMP_4537']  
			balanceOf(uint256) := TMP_4538(uint256)
		Expression: IStrategy(_strategies[indexes[i_scope_0]]).deploy(amount)
		IRs:
			REF_1536(uint256) -> indexes[i_scope_0]
			REF_1537(IStrategy) -> _strategies[REF_1536]
			TMP_4539 = CONVERT REF_1537 to IStrategy
			TMP_4540(uint256) = HIGH_LEVEL_CALL, dest:TMP_4539(IStrategy), function:deploy, arguments:['amount']  
		Expression: deltas[i_scope_0] < 0
		IRs:
			REF_1539(int256) -> deltas[i_scope_0]
			TMP_4541(bool) = REF_1539 < 0
			CONDITION TMP_4541
		Expression: IStrategy(_strategies[indexes[i_scope_0]]).undeploy(uint256(- deltas[i_scope_0]))
		IRs:
			REF_1540(uint256) -> indexes[i_scope_0]
			REF_1541(IStrategy) -> _strategies[REF_1540]
			TMP_4542 = CONVERT REF_1541 to IStrategy
			REF_1543(int256) -> deltas[i_scope_0]
			TMP_4543(uint256) = 0 (c)- REF_1543
			TMP_4544 = CONVERT TMP_4543 to uint256
			TMP_4545(uint256) = HIGH_LEVEL_CALL, dest:TMP_4542(IStrategy), function:undeploy, arguments:['TMP_4544']  
		Expression: i_scope_0 ++
		IRs:
			TMP_4546(uint256) := i_scope_0(uint256)
			i_scope_0(uint256) = i_scope_0 (c)+ 1
		Expression: uint256(deltas[i_scope_0]) > balanceOf
		IRs:
			REF_1544(int256) -> deltas[i_scope_0]
			TMP_4547 = CONVERT REF_1544 to uint256
			TMP_4548(bool) = TMP_4547 > balanceOf
			CONDITION TMP_4548
		Expression: amount = balanceOf
		IRs:
			amount(uint256) := balanceOf(uint256)
		Expression: amount = uint256(deltas[i_scope_0])
		IRs:
			REF_1545(int256) -> deltas[i_scope_0]
			TMP_4549 = CONVERT REF_1545 to uint256
			amount(uint256) := TMP_4549(uint256)
	Function MultiStrategy.removeStrategy(uint256) (*)
		Expression: index >= _strategies.length
		IRs:
			REF_1546 -> LENGTH _strategies
			TMP_4550(bool) = index >= REF_1546
			CONDITION TMP_4550
		Expression: revert InvalidStrategyIndex(uint256)(index)
		IRs:
			TMP_4551(None) = SOLIDITY_CALL revert InvalidStrategyIndex(uint256)(index)
		Expression: strategyAssets = _strategies[index].totalAssets()
		IRs:
			REF_1547(IStrategy) -> _strategies[index]
			TMP_4552(uint256) = HIGH_LEVEL_CALL, dest:REF_1547(IStrategy), function:totalAssets, arguments:[]  
			strategyAssets(uint256) := TMP_4552(uint256)
		Expression: _totalWeight -= _weights[index]
		IRs:
			REF_1549(uint16) -> _weights[index]
			_totalWeight(uint16) = _totalWeight (c)- REF_1549
		Expression: _weights[index] = 0
		IRs:
			REF_1550(uint16) -> _weights[index]
			REF_1550(uint16) (->_weights) := 0(uint256)
		Expression: strategyAssets > 0
		IRs:
			TMP_4553(bool) = strategyAssets > 0
			CONDITION TMP_4553
		Expression: IStrategy(_strategies[index]).undeploy(strategyAssets)
		IRs:
			REF_1551(IStrategy) -> _strategies[index]
			TMP_4554 = CONVERT REF_1551 to IStrategy
			TMP_4555(uint256) = HIGH_LEVEL_CALL, dest:TMP_4554(IStrategy), function:undeploy, arguments:['strategyAssets']  
		Expression: _allocateAssets(strategyAssets)
		IRs:
			TMP_4556(uint256) = INTERNAL_CALL, MultiStrategy._allocateAssets(uint256)(strategyAssets)
		Expression: _rebalanceStrategies()
		IRs:
			INTERNAL_CALL, MultiStrategy._rebalanceStrategies()()
		Expression: lastIndex = _strategies.length - 1
		IRs:
			REF_1553 -> LENGTH _strategies
			TMP_4558(uint256) = REF_1553 (c)- 1
			lastIndex(uint256) := TMP_4558(uint256)
		Expression: index < lastIndex
		IRs:
			TMP_4559(bool) = index < lastIndex
			CONDITION TMP_4559
		Expression: _strategies[index] = _strategies[lastIndex]
		IRs:
			REF_1554(IStrategy) -> _strategies[index]
			REF_1555(IStrategy) -> _strategies[lastIndex]
			REF_1554(IStrategy) (->_strategies) := REF_1555(IStrategy)
		Expression: _weights[index] = _weights[lastIndex]
		IRs:
			REF_1556(uint16) -> _weights[index]
			REF_1557(uint16) -> _weights[lastIndex]
			REF_1556(uint16) (->_weights) := REF_1557(uint16)
		Expression: RemoveStrategy(address(_strategies[lastIndex]))
		IRs:
			REF_1558(IStrategy) -> _strategies[lastIndex]
			TMP_4560 = CONVERT REF_1558 to address
			Emit RemoveStrategy(TMP_4560)
		Expression: _strategies.pop()
		IRs:
			REF_1560 -> LENGTH _strategies
			TMP_4563(uint256) = REF_1560 (c)- 1
			REF_1561(IStrategy) -> _strategies[TMP_4563]
			_strategies = delete REF_1561 
			REF_1562 -> LENGTH _strategies
			REF_1562(uint256) (->_strategies) := TMP_4563(uint256)
		Expression: _weights.pop()
		IRs:
			REF_1564 -> LENGTH _weights
			TMP_4565(uint256) = REF_1564 (c)- 1
			REF_1565(uint16) -> _weights[TMP_4565]
			_weights = delete REF_1565 
			REF_1566 -> LENGTH _weights
			REF_1566(uint256) (->_weights) := TMP_4565(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.pendingOwner() (*)
		Expression: _pendingOwner
		IRs:
			RETURN _pendingOwner
	Function Ownable2StepUpgradeable.transferOwnership(address) (*)
		Expression: _pendingOwner = newOwner
		IRs:
			_pendingOwner(address) := newOwner(address)
		Expression: OwnershipTransferStarted(owner(),newOwner)
		IRs:
			TMP_4570(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			Emit OwnershipTransferStarted(TMP_4570,newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable._transferOwnership(address) (*)
		Expression: delete _pendingOwner
		IRs:
			_pendingOwner = delete _pendingOwner 
		Expression: super._transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
	Function Ownable2StepUpgradeable.acceptOwnership() (*)
		Expression: sender = _msgSender()
		IRs:
			TMP_4574(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			sender(address) := TMP_4574(address)
		Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)
		IRs:
			TMP_4575(address) = INTERNAL_CALL, Ownable2StepUpgradeable.pendingOwner()()
			TMP_4576(bool) = TMP_4575 == sender
			TMP_4577(None) = SOLIDITY_CALL require(bool,string)(TMP_4576,Ownable2Step: caller is not the new owner)
		Expression: _transferOwnership(sender)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(sender)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_4581(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_4581)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_4584(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_4585(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_4586(bool) = TMP_4584 == TMP_4585
			TMP_4587(None) = SOLIDITY_CALL require(bool,string)(TMP_4586,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_4588 = CONVERT 0 to address
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_4588)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) 
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_4591 = CONVERT 0 to address
			TMP_4592(bool) = newOwner != TMP_4591
			TMP_4593(None) = SOLIDITY_CALL require(bool,string)(TMP_4592,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) 
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_4599 = UnaryType.BANG _initializing 
			TMP_4600(None) = SOLIDITY_CALL require(bool,string)(TMP_4599,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_4602(uint8) := 255(uint8)
			TMP_4603(bool) = _initialized != TMP_4602
			CONDITION TMP_4603
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_4605(uint8) := 255(uint8)
			_initialized(uint8) := TMP_4605(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_4607(uint8) := 255(uint8)
			Emit Initialized(TMP_4607)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function AccessControlUpgradeable.__AccessControl_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.__AccessControl_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_4611(type(IAccessControlUpgradeable)) = SOLIDITY_CALL type()(IAccessControlUpgradeable)
			REF_1567(bytes4) (->None) := 2036718347(bytes4)
			TMP_4612(bool) = interfaceId == REF_1567
			TMP_4613(bool) = INTERNAL_CALL, ERC165Upgradeable.supportsInterface(bytes4)(interfaceId)
			TMP_4614(bool) = TMP_4612 || TMP_4613
			RETURN TMP_4614
	Function AccessControlUpgradeable.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_1568(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1569(mapping(address => bool)) -> REF_1568.members
			REF_1570(bool) -> REF_1569[account]
			RETURN REF_1570
	Function AccessControlUpgradeable._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_4615(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32,address)(role,TMP_4615)
	Function AccessControlUpgradeable._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_4617(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_4618 = UnaryType.BANG TMP_4617 
			CONDITION TMP_4618
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))
		IRs:
			TMP_4619(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(address), arguments:['account'] 
			TMP_4620 = CONVERT role to uint256
			TMP_4621(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(uint256,uint256), arguments:['TMP_4620', '32'] 
			TMP_4622(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_4619, is missing role ,TMP_4621)
			TMP_4623 = CONVERT TMP_4622 to string
			TMP_4624(None) = SOLIDITY_CALL revert(string)(TMP_4623)
	Function AccessControlUpgradeable.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_1574(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1575(bytes32) -> REF_1574.adminRole
			RETURN REF_1575
	Function AccessControlUpgradeable.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_4626(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_4626)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_4628(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_4628)
	Function AccessControlUpgradeable.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_4631(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_4631)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_4633(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_4633)
	Function AccessControlUpgradeable.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_4635(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_4636(bool) = account == TMP_4635
			TMP_4637(None) = SOLIDITY_CALL require(bool,string)(TMP_4636,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_4640(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_4640(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_1576(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1577(bytes32) -> REF_1576.adminRole
			REF_1577(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControlUpgradeable._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_4642(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_4643 = UnaryType.BANG TMP_4642 
			CONDITION TMP_4643
		Expression: _roles[role].members[account] = true
		IRs:
			REF_1578(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1579(mapping(address => bool)) -> REF_1578.members
			REF_1580(bool) -> REF_1579[account]
			REF_1580(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_4644(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleGranted(role,account,TMP_4644)
	Function AccessControlUpgradeable._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_4646(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			CONDITION TMP_4646
		Expression: _roles[role].members[account] = false
		IRs:
			REF_1581(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1582(mapping(address => bool)) -> REF_1581.members
			REF_1583(bool) -> REF_1582[account]
			REF_1583(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_4647(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleRevoked(role,account,TMP_4647)
	Function ERC165Upgradeable.__ERC165_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.__ERC165_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165Upgradeable).interfaceId
		IRs:
			TMP_4651(type(IERC165Upgradeable)) = SOLIDITY_CALL type()(IERC165Upgradeable)
			REF_1584(bytes4) (->None) := 33540519(bytes4)
			TMP_4652(bool) = interfaceId == REF_1584
			RETURN TMP_4652
	Function IERC165Upgradeable.supportsInterface(bytes4) 
	Function IAccessControlUpgradeable.hasRole(bytes32,address) 
	Function IAccessControlUpgradeable.getRoleAdmin(bytes32) 
	Function IAccessControlUpgradeable.grantRole(bytes32,address) 
	Function IAccessControlUpgradeable.revokeRole(bytes32,address) 
	Function IAccessControlUpgradeable.renounceRole(bytes32,address) 
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_4653 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_4653(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_4654 = CONVERT _wETH to address
			TMP_4655 = CONVERT 0 to address
			TMP_4656(bool) = TMP_4654 == TMP_4655
			CONDITION TMP_4656
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_4657(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() 
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_4659 = CONVERT _wETH to address
			RETURN TMP_4659
	Function UseWETH.unwrapETH(uint256) (*)
		Expression: wETHAmount == 0
		IRs:
			TMP_4660(bool) = wETHAmount == 0
			CONDITION TMP_4660
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_4661(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_4662 = CONVERT this to address
			TMP_4663(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_4662']  
			wETHBalance(uint256) := TMP_4663(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_4664(bool) = wETHBalance < wETHAmount
			CONDITION TMP_4664
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_4665(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_4666(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_4666(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) (*)
		Expression: address(this).balance < amount
		IRs:
			TMP_4668 = CONVERT this to address
			TMP_4669(uint256) = SOLIDITY_CALL balance(address)(TMP_4668)
			TMP_4670(bool) = TMP_4669 < amount
			CONDITION TMP_4670
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_4671(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_4672(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_4672(IWETH), function:deposit, arguments:[] value:amount 
	Function VaultSettings.constructor() 
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function VaultSettings._initializeVaultSettings() (*)
		Expression: _withdrawalFee = 10 * 1e6
		IRs:
			TMP_4675(uint256) = 10 (c)* 1000000
			_withdrawalFee(uint256) := TMP_4675(uint256)
		Expression: _performanceFee = 10 * 1e6
		IRs:
			TMP_4676(uint256) = 10 (c)* 1000000
			_performanceFee(uint256) := TMP_4676(uint256)
		Expression: _feeReceiver = address(0)
		IRs:
			TMP_4677 = CONVERT 0 to address
			_feeReceiver(address) := TMP_4677(address)
		Expression: _maxDeposit = 0
		IRs:
			_maxDeposit(uint256) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function VaultSettings.enableAccount(address,bool) (*)
		Expression: enabled
		IRs:
			CONDITION enabled
		Expression: _enabledAccounts.contains(account)
		IRs:
			TMP_4679(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			CONDITION TMP_4679
		Expression: revert WhiteListAlreadyEnabled()()
		IRs:
			TMP_4680(None) = SOLIDITY_CALL revert WhiteListAlreadyEnabled()()
		Expression: ! _enabledAccounts.add(account)
		IRs:
			TMP_4681(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.add(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_4682 = UnaryType.BANG TMP_4681 
			CONDITION TMP_4682
		Expression: revert WhiteListFailedToAdd()()
		IRs:
			TMP_4683(None) = SOLIDITY_CALL revert WhiteListFailedToAdd()()
		Expression: ! _enabledAccounts.contains(account)
		IRs:
			TMP_4684(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_4685 = UnaryType.BANG TMP_4684 
			CONDITION TMP_4685
		Expression: revert WhiteListNotEnabled()()
		IRs:
			TMP_4686(None) = SOLIDITY_CALL revert WhiteListNotEnabled()()
		Expression: ! _enabledAccounts.remove(account)
		IRs:
			TMP_4687(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.remove(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_4688 = UnaryType.BANG TMP_4687 
			CONDITION TMP_4688
		Expression: revert WhiteListFailedToRemove()()
		IRs:
			TMP_4689(None) = SOLIDITY_CALL revert WhiteListFailedToRemove()()
		Expression: AccountWhiteList(account,enabled)
		IRs:
			Emit AccountWhiteList(account,enabled)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.isAccountEnabled(address) (*)
		Expression: _enabledAccounts.length() == 0 || _enabledAccounts.contains(account)
		IRs:
			TMP_4692(uint256) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.length(EnumerableSet.AddressSet), arguments:['_enabledAccounts'] 
			TMP_4693(bool) = TMP_4692 == 0
			TMP_4694(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_4695(bool) = TMP_4693 || TMP_4694
			RETURN TMP_4695
	Function VaultSettings.setWithdrawalFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_4696(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_4696
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_4697(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _withdrawalFee = fee
		IRs:
			_withdrawalFee(uint256) := fee(uint256)
		Expression: WithdrawalFeeChanged(_withdrawalFee)
		IRs:
			Emit WithdrawalFeeChanged(_withdrawalFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getWithdrawalFee() (*)
		Expression: _withdrawalFee
		IRs:
			RETURN _withdrawalFee
	Function VaultSettings.setPerformanceFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_4700(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_4700
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_4701(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _performanceFee = fee
		IRs:
			_performanceFee(uint256) := fee(uint256)
		Expression: PerformanceFeeChanged(_performanceFee)
		IRs:
			Emit PerformanceFeeChanged(_performanceFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getPerformanceFee() (*)
		Expression: _performanceFee
		IRs:
			RETURN _performanceFee
	Function VaultSettings.setFeeReceiver(address) (*)
		Expression: receiver == address(0)
		IRs:
			TMP_4704 = CONVERT 0 to address
			TMP_4705(bool) = receiver == TMP_4704
			CONDITION TMP_4705
		Expression: revert InvalidAddress()()
		IRs:
			TMP_4706(None) = SOLIDITY_CALL revert InvalidAddress()()
		Expression: _feeReceiver = receiver
		IRs:
			_feeReceiver(address) := receiver(address)
		Expression: FeeReceiverChanged(_feeReceiver)
		IRs:
			Emit FeeReceiverChanged(_feeReceiver)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getFeeReceiver() (*)
		Expression: _feeReceiver
		IRs:
			RETURN _feeReceiver
	Function VaultSettings.getMaxDeposit() (*)
		Expression: _maxDeposit
		IRs:
			RETURN _maxDeposit
	Function VaultSettings.setMaxDeposit(uint256) (*)
		Expression: _maxDeposit = value
		IRs:
			_maxDeposit(uint256) := value(uint256)
		Expression: MaxDepositChanged(value)
		IRs:
			Emit MaxDepositChanged(value)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function IVaultSettings.setWithdrawalFee(uint256) 
	Function IVaultSettings.getWithdrawalFee() 
	Function IVaultSettings.setPerformanceFee(uint256) 
	Function IVaultSettings.getPerformanceFee() 
	Function IVaultSettings.setFeeReceiver(address) 
	Function IVaultSettings.getFeeReceiver() 
	Function IVaultSettings.enableAccount(address,bool) 
	Function IVaultSettings.isAccountEnabled(address) 
	Function IVaultSettings.getMaxDeposit() 
	Function IVaultSettings.setMaxDeposit(uint256) 
	Function ERC20Upgradeable.__ERC20_init(string,string) (*)
		Expression: __ERC20_init_unchained(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init_unchained(string,string)(name_,symbol_)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20Upgradeable.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20Upgradeable.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20Upgradeable.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20Upgradeable.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_1594(uint256) -> _balances[account]
			RETURN REF_1594
	Function ERC20Upgradeable.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_4714(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_4714(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_1595(mapping(address => uint256)) -> _allowances[owner]
			REF_1596(uint256) -> REF_1595[spender]
			RETURN REF_1596
	Function ERC20Upgradeable.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_4716(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_4716(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_4718(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			spender(address) := TMP_4718(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_4721(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_4721(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_4722(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			TMP_4723(uint256) = TMP_4722 (c)+ addedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_4723)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_4725(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_4725(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_4726(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_4726(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_4727(bool) = currentAllowance >= subtractedValue
			TMP_4728(None) = SOLIDITY_CALL require(bool,string)(TMP_4727,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_4729(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_4729)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_4731 = CONVERT 0 to address
			TMP_4732(bool) = from != TMP_4731
			TMP_4733(None) = SOLIDITY_CALL require(bool,string)(TMP_4732,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_4734 = CONVERT 0 to address
			TMP_4735(bool) = to != TMP_4734
			TMP_4736(None) = SOLIDITY_CALL require(bool,string)(TMP_4735,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1597(uint256) -> _balances[from]
			fromBalance(uint256) := REF_1597(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_4738(bool) = fromBalance >= amount
			TMP_4739(None) = SOLIDITY_CALL require(bool,string)(TMP_4738,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1598(uint256) -> _balances[from]
			TMP_4740(uint256) = fromBalance - amount
			REF_1598(uint256) (->_balances) := TMP_4740(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1599(uint256) -> _balances[to]
			REF_1599(-> _balances) = REF_1599 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20Upgradeable._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_4743 = CONVERT 0 to address
			TMP_4744(bool) = account != TMP_4743
			TMP_4745(None) = SOLIDITY_CALL require(bool,string)(TMP_4744,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_4746 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(TMP_4746,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_1600(uint256) -> _balances[account]
			REF_1600(-> _balances) = REF_1600 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_4748 = CONVERT 0 to address
			Emit Transfer(TMP_4748,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_4750 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(TMP_4750,account,amount)
	Function ERC20Upgradeable._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_4752 = CONVERT 0 to address
			TMP_4753(bool) = account != TMP_4752
			TMP_4754(None) = SOLIDITY_CALL require(bool,string)(TMP_4753,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_4755 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(account,TMP_4755,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1601(uint256) -> _balances[account]
			accountBalance(uint256) := REF_1601(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_4757(bool) = accountBalance >= amount
			TMP_4758(None) = SOLIDITY_CALL require(bool,string)(TMP_4757,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1602(uint256) -> _balances[account]
			TMP_4759(uint256) = accountBalance - amount
			REF_1602(uint256) (->_balances) := TMP_4759(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_4760 = CONVERT 0 to address
			Emit Transfer(account,TMP_4760,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_4762 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(account,TMP_4762,amount)
	Function ERC20Upgradeable._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_4764 = CONVERT 0 to address
			TMP_4765(bool) = owner != TMP_4764
			TMP_4766(None) = SOLIDITY_CALL require(bool,string)(TMP_4765,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_4767 = CONVERT 0 to address
			TMP_4768(bool) = spender != TMP_4767
			TMP_4769(None) = SOLIDITY_CALL require(bool,string)(TMP_4768,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1603(mapping(address => uint256)) -> _allowances[owner]
			REF_1604(uint256) -> REF_1603[spender]
			REF_1604(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20Upgradeable._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_4771(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_4771(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_4773(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_4774(bool) = currentAllowance != TMP_4773
			CONDITION TMP_4774
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_4775(bool) = currentAllowance >= amount
			TMP_4776(None) = SOLIDITY_CALL require(bool,string)(TMP_4775,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_4777(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_4777)
	Function ERC20Upgradeable._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20Upgradeable._afterTokenTransfer(address,address,uint256) (*)
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_4782(bool) = _status != _ENTERED
			TMP_4783(None) = SOLIDITY_CALL require(bool,string)(TMP_4782,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_4784(bool) = _status == _ENTERED
			RETURN TMP_4784
	Function PausableUpgradeable.__Pausable_init() (*)
		Expression: __Pausable_init_unchained()
		IRs:
			INTERNAL_CALL, PausableUpgradeable.__Pausable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.__Pausable_init_unchained() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.paused() (*)
		Expression: _paused
		IRs:
			RETURN _paused
	Function PausableUpgradeable._requireNotPaused() (*)
		Expression: require(bool,string)(! paused(),Pausable: paused)
		IRs:
			TMP_4788(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_4789 = UnaryType.BANG TMP_4788 
			TMP_4790(None) = SOLIDITY_CALL require(bool,string)(TMP_4789,Pausable: paused)
	Function PausableUpgradeable._requirePaused() (*)
		Expression: require(bool,string)(paused(),Pausable: not paused)
		IRs:
			TMP_4791(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_4792(None) = SOLIDITY_CALL require(bool,string)(TMP_4791,Pausable: not paused)
	Function PausableUpgradeable._pause() (*)
		Expression: _paused = true
		IRs:
			_paused(bool) := True(bool)
		Expression: Paused(_msgSender())
		IRs:
			TMP_4793(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Paused(TMP_4793)
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function PausableUpgradeable._unpause() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: Unpaused(_msgSender())
		IRs:
			TMP_4796(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Unpaused(TMP_4796)
		Expression: whenPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenPaused()()
	Function MultiStrategyVault.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function MultiStrategyVault.receive() (*)
		Expression: msg.sender != wETHA()
		IRs:
			TMP_4800(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_4801(bool) = msg.sender != TMP_4800
			CONDITION TMP_4801
		Expression: revert ETHTransferNotAllowed(address)(msg.sender)
		IRs:
			TMP_4802(None) = SOLIDITY_CALL revert ETHTransferNotAllowed(address)(msg.sender)
	Function MultiStrategyVault.initialize(address,string,string,address,IStrategy[],uint16[],address) (*)
		Expression: __ERC20_init(tokenName,tokenSymbol)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init(string,string)(tokenName,tokenSymbol)
		Expression: _initUseWETH(weth)
		IRs:
			INTERNAL_CALL, UseWETH._initUseWETH(address)(weth)
		Expression: __AccessControl_init()
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable.__AccessControl_init()()
		Expression: initialOwner == address(0)
		IRs:
			TMP_4806 = CONVERT 0 to address
			TMP_4807(bool) = initialOwner == TMP_4806
			CONDITION TMP_4807
		Expression: revert InvalidOwner()()
		IRs:
			TMP_4808(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _grantRole(DEFAULT_ADMIN_ROLE,initialOwner)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(DEFAULT_ADMIN_ROLE,initialOwner)
		Expression: _grantRole(PAUSER_ROLE,initialOwner)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(PAUSER_ROLE,initialOwner)
		Expression: _initializeVaultSettings()
		IRs:
			INTERNAL_CALL, VaultSettings._initializeVaultSettings()()
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _initMultiStrategy(istrategies,iweights)
		IRs:
			INTERNAL_CALL, MultiStrategy._initMultiStrategy(IStrategy[],uint16[])(istrategies,iweights)
		Expression: _asset = iAsset
		IRs:
			_asset(address) := iAsset(address)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < istrategies.length
		IRs:
			REF_1605 -> LENGTH istrategies
			TMP_4814(bool) = i < REF_1605
			CONDITION TMP_4814
		Expression: istrategies[i].asset() != iAsset
		IRs:
			REF_1606(IStrategy) -> istrategies[i]
			TMP_4815(address) = HIGH_LEVEL_CALL, dest:REF_1606(IStrategy), function:asset, arguments:[]  
			TMP_4816(bool) = TMP_4815 != iAsset
			CONDITION TMP_4816
		Expression: revert InvalidAsset()()
		IRs:
			TMP_4817(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: IERC20Upgradeable(iAsset).safeApprove(address(istrategies[i]),type()(uint256).max)
		IRs:
			TMP_4818 = CONVERT iAsset to IERC20Upgradeable
			REF_1609(IStrategy) -> istrategies[i]
			TMP_4819 = CONVERT REF_1609 to address
			TMP_4821(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeApprove(IERC20Upgradeable,address,uint256), arguments:['TMP_4818', 'TMP_4819', 'TMP_4821'] 
		Expression: i ++
		IRs:
			TMP_4823(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function MultiStrategyVault.rebalance() (*)
		Expression: currentPosition = _totalAssets()
		IRs:
			TMP_4825(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			currentPosition(uint256) := TMP_4825(uint256)
		Expression: currentPosition == 0
		IRs:
			TMP_4826(bool) = currentPosition == 0
			CONDITION TMP_4826
		Expression: 0
		IRs:
			RETURN 0
		Expression: balanceChange = _harvestStrategies()
		IRs:
			TMP_4827(int256) = INTERNAL_CALL, MultiStrategy._harvestStrategies()()
			balanceChange(int256) := TMP_4827(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_4828(bool) = balanceChange > 0
			CONDITION TMP_4828
		Expression: feeReceiver = getFeeReceiver()
		IRs:
			TMP_4829(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			feeReceiver(address) := TMP_4829(address)
		Expression: performanceFee = getPerformanceFee()
		IRs:
			TMP_4830(uint256) = INTERNAL_CALL, VaultSettings.getPerformanceFee()()
			performanceFee(uint256) := TMP_4830(uint256)
		Expression: feeReceiver != address(this) && feeReceiver != address(0) && performanceFee > 0
		IRs:
			TMP_4831 = CONVERT this to address
			TMP_4832(bool) = feeReceiver != TMP_4831
			TMP_4833 = CONVERT 0 to address
			TMP_4834(bool) = feeReceiver != TMP_4833
			TMP_4835(bool) = TMP_4832 && TMP_4834
			TMP_4836(bool) = performanceFee > 0
			TMP_4837(bool) = TMP_4835 && TMP_4836
			CONDITION TMP_4837
		Expression: feeInEth = uint256(balanceChange) * performanceFee
		IRs:
			TMP_4838 = CONVERT balanceChange to uint256
			TMP_4839(uint256) = TMP_4838 (c)* performanceFee
			feeInEth(uint256) := TMP_4839(uint256)
		Expression: sharesToMint = feeInEth.mulDivUp(totalSupply(),currentPosition * PERCENTAGE_PRECISION)
		IRs:
			TMP_4840(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_4841(uint256) = currentPosition (c)* PERCENTAGE_PRECISION
			TMP_4842(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['feeInEth', 'TMP_4840', 'TMP_4841'] 
			sharesToMint(uint256) := TMP_4842(uint256)
		Expression: _mint(feeReceiver,sharesToMint)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._mint(address,uint256)(feeReceiver,sharesToMint)
		Expression: _rebalanceStrategies()
		IRs:
			INTERNAL_CALL, MultiStrategy._rebalanceStrategies()()
		Expression: balanceChange
		IRs:
			RETURN balanceChange
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function MultiStrategyVault.maxMint(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_4848(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_4848
	Function MultiStrategyVault.previewMint(uint256) (*)
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_4849(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_4849(uint256)
	Function MultiStrategyVault.mint(uint256,address) (*)
		Expression: shares == 0
		IRs:
			TMP_4850(bool) = shares == 0
			CONDITION TMP_4850
		Expression: revert InvalidAmount()()
		IRs:
			TMP_4851(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_4852(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_4852(uint256)
		Expression: IERC20Upgradeable(_asset).safeTransferFrom(msg.sender,address(this),assets)
		IRs:
			TMP_4853 = CONVERT _asset to IERC20Upgradeable
			TMP_4854 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_4853', 'msg.sender', 'TMP_4854', 'assets'] 
		Expression: _depositInternal(assets,receiver)
		IRs:
			TMP_4856(uint256) = INTERNAL_CALL, MultiStrategyVault._depositInternal(uint256,address)(assets,receiver)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.maxDeposit(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_4861(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_4861
	Function MultiStrategyVault.previewDeposit(uint256) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_4862(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_4862(uint256)
	Function MultiStrategyVault.depositNative(address) (*)
		Expression: msg.value == 0
		IRs:
			TMP_4863(bool) = msg.value == 0
			CONDITION TMP_4863
		Expression: revert InvalidAmount()()
		IRs:
			TMP_4864(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: _asset != wETHA()
		IRs:
			TMP_4865(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_4866(bool) = _asset != TMP_4865
			CONDITION TMP_4866
		Expression: revert InvalidAsset()()
		IRs:
			TMP_4867(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: wETHA().functionCallWithValue(abi.encodeWithSignature(deposit()),msg.value)
		IRs:
			TMP_4868(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_4869(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(deposit())
			TMP_4870(bytes) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.functionCallWithValue(address,bytes,uint256), arguments:['TMP_4868', 'TMP_4869', 'msg.value'] 
		Expression: _depositInternal(msg.value,receiver)
		IRs:
			TMP_4871(uint256) = INTERNAL_CALL, MultiStrategyVault._depositInternal(uint256,address)(msg.value,receiver)
			RETURN TMP_4871
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.deposit(uint256,address) (*)
		Expression: assets == 0
		IRs:
			TMP_4875(bool) = assets == 0
			CONDITION TMP_4875
		Expression: revert InvalidAmount()()
		IRs:
			TMP_4876(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: IERC20Upgradeable(_asset).safeTransferFrom(msg.sender,address(this),assets)
		IRs:
			TMP_4877 = CONVERT _asset to IERC20Upgradeable
			TMP_4878 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_4877', 'msg.sender', 'TMP_4878', 'assets'] 
		Expression: _depositInternal(assets,receiver)
		IRs:
			TMP_4880(uint256) = INTERNAL_CALL, MultiStrategyVault._depositInternal(uint256,address)(assets,receiver)
			RETURN TMP_4880
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.totalAssets() (*)
		Expression: amount = _totalAssets()
		IRs:
			TMP_4884(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			amount(uint256) := TMP_4884(uint256)
	Function MultiStrategyVault._depositInternal(uint256,address) (*)
		Expression: receiver == address(0)
		IRs:
			TMP_4885 = CONVERT 0 to address
			TMP_4886(bool) = receiver == TMP_4885
			CONDITION TMP_4886
		Expression: revert InvalidReceiver()()
		IRs:
			TMP_4887(None) = SOLIDITY_CALL revert InvalidReceiver()()
		Expression: total = Rebase(_totalAssets(),totalSupply())
		IRs:
			TMP_4888(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			TMP_4889(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_4890(Rebase) = new Rebase(TMP_4888,TMP_4889)
			total(Rebase) := TMP_4890(Rebase)
		Expression: ! ((total.elastic == 0 && total.base == 0) || (total.base > 0 && total.elastic > 0))
		IRs:
			REF_1618(uint256) -> total.elastic
			TMP_4891(bool) = REF_1618 == 0
			REF_1619(uint256) -> total.base
			TMP_4892(bool) = REF_1619 == 0
			TMP_4893(bool) = TMP_4891 && TMP_4892
			REF_1620(uint256) -> total.base
			TMP_4894(bool) = REF_1620 > 0
			REF_1621(uint256) -> total.elastic
			TMP_4895(bool) = REF_1621 > 0
			TMP_4896(bool) = TMP_4894 && TMP_4895
			TMP_4897(bool) = TMP_4893 || TMP_4896
			TMP_4898 = UnaryType.BANG TMP_4897 
			CONDITION TMP_4898
		Expression: revert InvalidAssetsState()()
		IRs:
			TMP_4899(None) = SOLIDITY_CALL revert InvalidAssetsState()()
		Expression: maxDepositLocal = getMaxDeposit()
		IRs:
			TMP_4900(uint256) = INTERNAL_CALL, VaultSettings.getMaxDeposit()()
			maxDepositLocal(uint256) := TMP_4900(uint256)
		Expression: maxDepositLocal > 0
		IRs:
			TMP_4901(bool) = maxDepositLocal > 0
			CONDITION TMP_4901
		Expression: depositInAssets = (balanceOf(msg.sender) * _ONE) / tokenPerAsset()
		IRs:
			TMP_4902(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(msg.sender)
			TMP_4903(uint256) = TMP_4902 (c)* _ONE
			TMP_4904(uint256) = INTERNAL_CALL, MultiStrategyVault.tokenPerAsset()()
			TMP_4905(uint256) = TMP_4903 (c)/ TMP_4904
			depositInAssets(uint256) := TMP_4905(uint256)
		Expression: newBalance = assets + depositInAssets
		IRs:
			TMP_4906(uint256) = assets (c)+ depositInAssets
			newBalance(uint256) := TMP_4906(uint256)
		Expression: newBalance > maxDepositLocal
		IRs:
			TMP_4907(bool) = newBalance > maxDepositLocal
			CONDITION TMP_4907
		Expression: revert MaxDepositReached()()
		IRs:
			TMP_4908(None) = SOLIDITY_CALL revert MaxDepositReached()()
		Expression: deployedAmount = _allocateAssets(assets)
		IRs:
			TMP_4909(uint256) = INTERNAL_CALL, MultiStrategy._allocateAssets(uint256)(assets)
			deployedAmount(uint256) := TMP_4909(uint256)
		Expression: shares = total.toBase(deployedAmount,false)
		IRs:
			TMP_4910(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'deployedAmount', 'False'] 
			shares(uint256) := TMP_4910(uint256)
		Expression: total.base == 0 && shares < _MINIMUM_SHARE_BALANCE
		IRs:
			REF_1623(uint256) -> total.base
			TMP_4911(bool) = REF_1623 == 0
			TMP_4912(bool) = shares < _MINIMUM_SHARE_BALANCE
			TMP_4913(bool) = TMP_4911 && TMP_4912
			CONDITION TMP_4913
		Expression: revert InvalidShareBalance()()
		IRs:
			TMP_4914(None) = SOLIDITY_CALL revert InvalidShareBalance()()
		Expression: _mint(receiver,shares)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._mint(address,uint256)(receiver,shares)
		Expression: Deposit(msg.sender,receiver,assets,shares)
		IRs:
			Emit Deposit(msg.sender,receiver,assets,shares)
	Function MultiStrategyVault.maxWithdraw(address) (*)
		Expression: maxAssets = this.convertToAssets(balanceOf(shareHolder))
		IRs:
			TMP_4917(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(shareHolder)
			TMP_4918(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['TMP_4917']  
			maxAssets(uint256) := TMP_4918(uint256)
	Function MultiStrategyVault.previewWithdraw(uint256) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_4919(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_4919(uint256)
	Function MultiStrategyVault.withdrawNative(uint256) (*)
		Expression: _asset != wETHA()
		IRs:
			TMP_4920(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_4921(bool) = _asset != TMP_4920
			CONDITION TMP_4921
		Expression: revert InvalidAsset()()
		IRs:
			TMP_4922(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_4923(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_4923(uint256)
		Expression: _redeemInternal(shares,msg.sender,msg.sender,true)
		IRs:
			TMP_4924(uint256) = INTERNAL_CALL, MultiStrategyVault._redeemInternal(uint256,address,address,bool)(shares,msg.sender,msg.sender,True)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.redeemNative(uint256) (*)
		Expression: _asset != wETHA()
		IRs:
			TMP_4928(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_4929(bool) = _asset != TMP_4928
			CONDITION TMP_4929
		Expression: revert InvalidAsset()()
		IRs:
			TMP_4930(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: assets = _redeemInternal(shares,msg.sender,msg.sender,true)
		IRs:
			TMP_4931(uint256) = INTERNAL_CALL, MultiStrategyVault._redeemInternal(uint256,address,address,bool)(shares,msg.sender,msg.sender,True)
			assets(uint256) := TMP_4931(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.withdraw(uint256,address,address) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_4935(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_4935(uint256)
		Expression: _redeemInternal(shares,receiver,holder,false)
		IRs:
			TMP_4936(uint256) = INTERNAL_CALL, MultiStrategyVault._redeemInternal(uint256,address,address,bool)(shares,receiver,holder,False)
			RETURN TMP_4936
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
	Function MultiStrategyVault.maxRedeem(address) (*)
		Expression: maxShares = balanceOf(shareHolder)
		IRs:
			TMP_4940(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(shareHolder)
			maxShares(uint256) := TMP_4940(uint256)
	Function MultiStrategyVault.previewRedeem(uint256) (*)
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_4941(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_4941(uint256)
	Function MultiStrategyVault.redeem(uint256,address,address) (*)
		Expression: _redeemInternal(shares,receiver,holder,false)
		IRs:
			TMP_4942(uint256) = INTERNAL_CALL, MultiStrategyVault._redeemInternal(uint256,address,address,bool)(shares,receiver,holder,False)
			RETURN TMP_4942
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, MultiStrategyVault.onlyWhiteListed()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function MultiStrategyVault._redeemInternal(uint256,address,address,bool) (*)
		Expression: shares == 0
		IRs:
			TMP_4946(bool) = shares == 0
			CONDITION TMP_4946
		Expression: revert InvalidWithdrawAmount()()
		IRs:
			TMP_4947(None) = SOLIDITY_CALL revert InvalidWithdrawAmount()()
		Expression: receiver == address(0)
		IRs:
			TMP_4948 = CONVERT 0 to address
			TMP_4949(bool) = receiver == TMP_4948
			CONDITION TMP_4949
		Expression: revert InvalidReceiver()()
		IRs:
			TMP_4950(None) = SOLIDITY_CALL revert InvalidReceiver()()
		Expression: balanceOf(holder) < shares
		IRs:
			TMP_4951(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(holder)
			TMP_4952(bool) = TMP_4951 < shares
			CONDITION TMP_4952
		Expression: revert NotEnoughBalanceToWithdraw()()
		IRs:
			TMP_4953(None) = SOLIDITY_CALL revert NotEnoughBalanceToWithdraw()()
		Expression: msg.sender != holder
		IRs:
			TMP_4954(bool) = msg.sender != holder
			CONDITION TMP_4954
		Expression: allowance(holder,msg.sender) < shares
		IRs:
			TMP_4955(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(holder,msg.sender)
			TMP_4956(bool) = TMP_4955 < shares
			CONDITION TMP_4956
		Expression: revert NoAllowance()()
		IRs:
			TMP_4957(None) = SOLIDITY_CALL revert NoAllowance()()
		Expression: transferFrom(holder,msg.sender,shares)
		IRs:
			TMP_4958(bool) = INTERNAL_CALL, ERC20Upgradeable.transferFrom(address,address,uint256)(holder,msg.sender,shares)
		Expression: withdrawAmount = (shares * _totalAssets()) / totalSupply()
		IRs:
			TMP_4959(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			TMP_4960(uint256) = shares (c)* TMP_4959
			TMP_4961(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_4962(uint256) = TMP_4960 (c)/ TMP_4961
			withdrawAmount(uint256) := TMP_4962(uint256)
		Expression: withdrawAmount == 0
		IRs:
			TMP_4963(bool) = withdrawAmount == 0
			CONDITION TMP_4963
		Expression: revert NoAssetsToWithdraw()()
		IRs:
			TMP_4964(None) = SOLIDITY_CALL revert NoAssetsToWithdraw()()
		Expression: amount = _deallocateAssets(withdrawAmount)
		IRs:
			TMP_4965(uint256) = INTERNAL_CALL, MultiStrategy._deallocateAssets(uint256)(withdrawAmount)
			amount(uint256) := TMP_4965(uint256)
		Expression: fee = 0
		IRs:
			fee(uint256) := 0(uint256)
		Expression: remainingShares = totalSupply() - shares
		IRs:
			TMP_4966(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_4967(uint256) = TMP_4966 (c)- shares
			remainingShares(uint256) := TMP_4967(uint256)
		Expression: remainingShares < _MINIMUM_SHARE_BALANCE && remainingShares != 0
		IRs:
			TMP_4968(bool) = remainingShares < _MINIMUM_SHARE_BALANCE
			TMP_4969(bool) = remainingShares != 0
			TMP_4970(bool) = TMP_4968 && TMP_4969
			CONDITION TMP_4970
		Expression: revert InvalidShareBalance()()
		IRs:
			TMP_4971(None) = SOLIDITY_CALL revert InvalidShareBalance()()
		Expression: _burn(msg.sender,shares)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._burn(address,uint256)(msg.sender,shares)
		Expression: getWithdrawalFee() != 0 && getFeeReceiver() != address(0)
		IRs:
			TMP_4973(uint256) = INTERNAL_CALL, VaultSettings.getWithdrawalFee()()
			TMP_4974(bool) = TMP_4973 != 0
			TMP_4975(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_4976 = CONVERT 0 to address
			TMP_4977(bool) = TMP_4975 != TMP_4976
			TMP_4978(bool) = TMP_4974 && TMP_4977
			CONDITION TMP_4978
		Expression: fee = amount.mulDivUp(getWithdrawalFee(),PERCENTAGE_PRECISION)
		IRs:
			TMP_4979(uint256) = INTERNAL_CALL, VaultSettings.getWithdrawalFee()()
			TMP_4980(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['amount', 'TMP_4979', 'PERCENTAGE_PRECISION'] 
			fee(uint256) := TMP_4980(uint256)
		Expression: shouldRedeemETH
		IRs:
			CONDITION shouldRedeemETH
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(amount)
		Expression: address(receiver).sendValue(amount - fee)
		IRs:
			TMP_4982 = CONVERT receiver to address
			TMP_4983(uint256) = amount (c)- fee
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_4982', 'TMP_4983'] 
		Expression: address(getFeeReceiver()).sendValue(fee)
		IRs:
			TMP_4985(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_4986 = CONVERT TMP_4985 to address
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_4986', 'fee'] 
		Expression: IERC20Upgradeable(_asset).transfer(receiver,amount - fee)
		IRs:
			TMP_4988 = CONVERT _asset to IERC20Upgradeable
			TMP_4989(uint256) = amount (c)- fee
			TMP_4990(bool) = HIGH_LEVEL_CALL, dest:TMP_4988(IERC20Upgradeable), function:transfer, arguments:['receiver', 'TMP_4989']  
		Expression: IERC20Upgradeable(_asset).transfer(getFeeReceiver(),fee)
		IRs:
			TMP_4991 = CONVERT _asset to IERC20Upgradeable
			TMP_4992(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_4993(bool) = HIGH_LEVEL_CALL, dest:TMP_4991(IERC20Upgradeable), function:transfer, arguments:['TMP_4992', 'fee']  
		Expression: shouldRedeemETH
		IRs:
			CONDITION shouldRedeemETH
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(amount)
		Expression: address(receiver).sendValue(amount)
		IRs:
			TMP_4995 = CONVERT receiver to address
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_4995', 'amount'] 
		Expression: IERC20Upgradeable(_asset).transfer(receiver,amount)
		IRs:
			TMP_4997 = CONVERT _asset to IERC20Upgradeable
			TMP_4998(bool) = HIGH_LEVEL_CALL, dest:TMP_4997(IERC20Upgradeable), function:transfer, arguments:['receiver', 'amount']  
		Expression: Withdraw(msg.sender,receiver,holder,amount - fee,shares)
		IRs:
			TMP_4999(uint256) = amount (c)- fee
			Emit Withdraw(msg.sender,receiver,holder,TMP_4999,shares)
		Expression: retAmount = amount - fee
		IRs:
			TMP_5001(uint256) = amount (c)- fee
			retAmount(uint256) := TMP_5001(uint256)
	Function MultiStrategyVault.convertToShares(uint256) (*)
		Expression: total = Rebase(_totalAssets(),totalSupply())
		IRs:
			TMP_5002(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			TMP_5003(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5004(Rebase) = new Rebase(TMP_5002,TMP_5003)
			total(Rebase) := TMP_5004(Rebase)
		Expression: shares = total.toBase(assets,false)
		IRs:
			TMP_5005(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'assets', 'False'] 
			shares(uint256) := TMP_5005(uint256)
	Function MultiStrategyVault.convertToAssets(uint256) (*)
		Expression: total = Rebase(_totalAssets(),totalSupply())
		IRs:
			TMP_5006(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			TMP_5007(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5008(Rebase) = new Rebase(TMP_5006,TMP_5007)
			total(Rebase) := TMP_5008(Rebase)
		Expression: assets = total.toElastic(shares,false)
		IRs:
			TMP_5009(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toElastic(Rebase,uint256,bool), arguments:['total', 'shares', 'False'] 
			assets(uint256) := TMP_5009(uint256)
	Function MultiStrategyVault.tokenPerAsset() (*)
		Expression: totalAssetsValue = _totalAssets()
		IRs:
			TMP_5010(uint256) = INTERNAL_CALL, MultiStrategy._totalAssets()()
			totalAssetsValue(uint256) := TMP_5010(uint256)
		Expression: totalSupply() == 0 || totalAssetsValue == 0
		IRs:
			TMP_5011(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5012(bool) = TMP_5011 == 0
			TMP_5013(bool) = totalAssetsValue == 0
			TMP_5014(bool) = TMP_5012 || TMP_5013
			CONDITION TMP_5014
		Expression: _ONE
		IRs:
			RETURN _ONE
		Expression: (totalSupply() * _ONE) / totalAssetsValue
		IRs:
			TMP_5015(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5016(uint256) = TMP_5015 (c)* _ONE
			TMP_5017(uint256) = TMP_5016 (c)/ totalAssetsValue
			RETURN TMP_5017
	Function MultiStrategyVault.asset() (*)
		Expression: _asset
		IRs:
			RETURN _asset
	Function MultiStrategyVault.pause() (*)
		Expression: _pause()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._pause()()
		Expression: onlyRole(PAUSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(PAUSER_ROLE)
	Function MultiStrategyVault.unpause() (*)
		Expression: _unpause()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._unpause()()
		Expression: onlyRole(PAUSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(PAUSER_ROLE)
	Function MultiStrategyVault.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
		Expression: MAX_TOTAL_WEIGHT = 10000
		IRs:
			MAX_TOTAL_WEIGHT(uint16) := 10000(uint256)
		Expression: PAUSER_ROLE = keccak256(bytes)(PAUSER_ROLE)
		IRs:
			TMP_5022(bytes32) = SOLIDITY_CALL keccak256(bytes)(PAUSER_ROLE)
			PAUSER_ROLE(bytes32) := TMP_5022(bytes32)
		Expression: _MINIMUM_SHARE_BALANCE = 1000
		IRs:
			_MINIMUM_SHARE_BALANCE(uint256) := 1000(uint256)
		Expression: _ONE = 1e18
		IRs:
			_ONE(uint256) := 1000000000000000000(uint256)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_5024 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_5024(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_5025(bool) = _initialized < 1
			TMP_5026(bool) = isTopLevelCall && TMP_5025
			TMP_5027 = CONVERT this to address
			TMP_5028(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_5027'] 
			TMP_5029 = UnaryType.BANG TMP_5028 
			TMP_5030(bool) = _initialized == 1
			TMP_5031(bool) = TMP_5029 && TMP_5030
			TMP_5032(bool) = TMP_5026 || TMP_5031
			TMP_5033(None) = SOLIDITY_CALL require(bool,string)(TMP_5032,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_5035 = UnaryType.BANG _initializing 
			TMP_5036(bool) = _initialized < version
			TMP_5037(bool) = TMP_5035 && TMP_5036
			TMP_5038(None) = SOLIDITY_CALL require(bool,string)(TMP_5037,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_5040(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier AccessControlUpgradeable.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32)(role)
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
	Modifier PausableUpgradeable.whenNotPaused()
		Expression: _requireNotPaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requireNotPaused()()
	Modifier PausableUpgradeable.whenPaused()
		Expression: _requirePaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requirePaused()()
	Modifier MultiStrategyVault.onlyWhiteListed()
		Expression: ! isAccountEnabled(msg.sender)
		IRs:
			TMP_5046(bool) = INTERNAL_CALL, VaultSettings.isAccountEnabled(address)(msg.sender)
			TMP_5047 = UnaryType.BANG TMP_5046 
			CONDITION TMP_5047
		Expression: revert NoPermissions()()
		IRs:
			TMP_5048(None) = SOLIDITY_CALL revert NoPermissions()()
Contract Vault
	Function IVault.depositNative(address) 
	Function IVault.withdrawNative(uint256) 
	Function IVault.redeemNative(uint256) 
	Function IVault.tokenPerAsset() 
	Function IVault.rebalance() 
	Function IERC4626Upgradeable.asset() 
	Function IERC4626Upgradeable.totalAssets() 
	Function IERC4626Upgradeable.convertToShares(uint256) 
	Function IERC4626Upgradeable.convertToAssets(uint256) 
	Function IERC4626Upgradeable.maxDeposit(address) 
	Function IERC4626Upgradeable.previewDeposit(uint256) 
	Function IERC4626Upgradeable.deposit(uint256,address) 
	Function IERC4626Upgradeable.maxMint(address) 
	Function IERC4626Upgradeable.previewMint(uint256) 
	Function IERC4626Upgradeable.mint(uint256,address) 
	Function IERC4626Upgradeable.maxWithdraw(address) 
	Function IERC4626Upgradeable.previewWithdraw(uint256) 
	Function IERC4626Upgradeable.withdraw(uint256,address,address) 
	Function IERC4626Upgradeable.maxRedeem(address) 
	Function IERC4626Upgradeable.previewRedeem(uint256) 
	Function IERC4626Upgradeable.redeem(uint256,address,address) 
	Function IERC20MetadataUpgradeable.name() 
	Function IERC20MetadataUpgradeable.symbol() 
	Function IERC20MetadataUpgradeable.decimals() 
	Function IERC20Upgradeable.totalSupply() 
	Function IERC20Upgradeable.balanceOf(address) 
	Function IERC20Upgradeable.transfer(address,uint256) 
	Function IERC20Upgradeable.allowance(address,address) 
	Function IERC20Upgradeable.approve(address,uint256) 
	Function IERC20Upgradeable.transferFrom(address,address,uint256) 
	Function AccessControlUpgradeable.__AccessControl_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.__AccessControl_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function AccessControlUpgradeable.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_5051(type(IAccessControlUpgradeable)) = SOLIDITY_CALL type()(IAccessControlUpgradeable)
			REF_1639(bytes4) (->None) := 2036718347(bytes4)
			TMP_5052(bool) = interfaceId == REF_1639
			TMP_5053(bool) = INTERNAL_CALL, ERC165Upgradeable.supportsInterface(bytes4)(interfaceId)
			TMP_5054(bool) = TMP_5052 || TMP_5053
			RETURN TMP_5054
	Function AccessControlUpgradeable.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_1640(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1641(mapping(address => bool)) -> REF_1640.members
			REF_1642(bool) -> REF_1641[account]
			RETURN REF_1642
	Function AccessControlUpgradeable._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_5055(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32,address)(role,TMP_5055)
	Function AccessControlUpgradeable._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_5057(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_5058 = UnaryType.BANG TMP_5057 
			CONDITION TMP_5058
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,StringsUpgradeable.toHexString(account), is missing role ,StringsUpgradeable.toHexString(uint256(role),32))))
		IRs:
			TMP_5059(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(address), arguments:['account'] 
			TMP_5060 = CONVERT role to uint256
			TMP_5061(string) = LIBRARY_CALL, dest:StringsUpgradeable, function:StringsUpgradeable.toHexString(uint256,uint256), arguments:['TMP_5060', '32'] 
			TMP_5062(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_5059, is missing role ,TMP_5061)
			TMP_5063 = CONVERT TMP_5062 to string
			TMP_5064(None) = SOLIDITY_CALL revert(string)(TMP_5063)
	Function AccessControlUpgradeable.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_1646(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1647(bytes32) -> REF_1646.adminRole
			RETURN REF_1647
	Function AccessControlUpgradeable.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_5066(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_5066)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_5068(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_5068)
	Function AccessControlUpgradeable.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_5071(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_5071)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_5073(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(TMP_5073)
	Function AccessControlUpgradeable.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_5075(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_5076(bool) = account == TMP_5075
			TMP_5077(None) = SOLIDITY_CALL require(bool,string)(TMP_5076,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._revokeRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(role,account)
	Function AccessControlUpgradeable._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_5080(bytes32) = INTERNAL_CALL, AccessControlUpgradeable.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_5080(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_1648(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1649(bytes32) -> REF_1648.adminRole
			REF_1649(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControlUpgradeable._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_5082(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			TMP_5083 = UnaryType.BANG TMP_5082 
			CONDITION TMP_5083
		Expression: _roles[role].members[account] = true
		IRs:
			REF_1650(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1651(mapping(address => bool)) -> REF_1650.members
			REF_1652(bool) -> REF_1651[account]
			REF_1652(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_5084(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleGranted(role,account,TMP_5084)
	Function AccessControlUpgradeable._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_5086(bool) = INTERNAL_CALL, AccessControlUpgradeable.hasRole(bytes32,address)(role,account)
			CONDITION TMP_5086
		Expression: _roles[role].members[account] = false
		IRs:
			REF_1653(AccessControlUpgradeable.RoleData) -> _roles[role]
			REF_1654(mapping(address => bool)) -> REF_1653.members
			REF_1655(bool) -> REF_1654[account]
			REF_1655(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_5087(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit RoleRevoked(role,account,TMP_5087)
	Function ERC165Upgradeable.__ERC165_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.__ERC165_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC165Upgradeable.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165Upgradeable).interfaceId
		IRs:
			TMP_5091(type(IERC165Upgradeable)) = SOLIDITY_CALL type()(IERC165Upgradeable)
			REF_1656(bytes4) (->None) := 33540519(bytes4)
			TMP_5092(bool) = interfaceId == REF_1656
			RETURN TMP_5092
	Function IERC165Upgradeable.supportsInterface(bytes4) 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_5093 = UnaryType.BANG _initializing 
			TMP_5094(None) = SOLIDITY_CALL require(bool,string)(TMP_5093,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_5096(uint8) := 255(uint8)
			TMP_5097(bool) = _initialized != TMP_5096
			CONDITION TMP_5097
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_5099(uint8) := 255(uint8)
			_initialized(uint8) := TMP_5099(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_5101(uint8) := 255(uint8)
			Emit Initialized(TMP_5101)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function IAccessControlUpgradeable.hasRole(bytes32,address) 
	Function IAccessControlUpgradeable.getRoleAdmin(bytes32) 
	Function IAccessControlUpgradeable.grantRole(bytes32,address) 
	Function IAccessControlUpgradeable.revokeRole(bytes32,address) 
	Function IAccessControlUpgradeable.renounceRole(bytes32,address) 
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_5105 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_5105(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_5106 = CONVERT _wETH to address
			TMP_5107 = CONVERT 0 to address
			TMP_5108(bool) = TMP_5106 == TMP_5107
			CONDITION TMP_5108
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_5109(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() 
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_5111 = CONVERT _wETH to address
			RETURN TMP_5111
	Function UseWETH.unwrapETH(uint256) (*)
		Expression: wETHAmount == 0
		IRs:
			TMP_5112(bool) = wETHAmount == 0
			CONDITION TMP_5112
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_5113(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_5114 = CONVERT this to address
			TMP_5115(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_5114']  
			wETHBalance(uint256) := TMP_5115(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_5116(bool) = wETHBalance < wETHAmount
			CONDITION TMP_5116
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_5117(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_5118(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_5118(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) (*)
		Expression: address(this).balance < amount
		IRs:
			TMP_5120 = CONVERT this to address
			TMP_5121(uint256) = SOLIDITY_CALL balance(address)(TMP_5120)
			TMP_5122(bool) = TMP_5121 < amount
			CONDITION TMP_5122
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_5123(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_5124(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_5124(IWETH), function:deposit, arguments:[] value:amount 
	Function VaultSettings.constructor() 
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function VaultSettings._initializeVaultSettings() (*)
		Expression: _withdrawalFee = 10 * 1e6
		IRs:
			TMP_5127(uint256) = 10 (c)* 1000000
			_withdrawalFee(uint256) := TMP_5127(uint256)
		Expression: _performanceFee = 10 * 1e6
		IRs:
			TMP_5128(uint256) = 10 (c)* 1000000
			_performanceFee(uint256) := TMP_5128(uint256)
		Expression: _feeReceiver = address(0)
		IRs:
			TMP_5129 = CONVERT 0 to address
			_feeReceiver(address) := TMP_5129(address)
		Expression: _maxDeposit = 0
		IRs:
			_maxDeposit(uint256) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function VaultSettings.enableAccount(address,bool) (*)
		Expression: enabled
		IRs:
			CONDITION enabled
		Expression: _enabledAccounts.contains(account)
		IRs:
			TMP_5131(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			CONDITION TMP_5131
		Expression: revert WhiteListAlreadyEnabled()()
		IRs:
			TMP_5132(None) = SOLIDITY_CALL revert WhiteListAlreadyEnabled()()
		Expression: ! _enabledAccounts.add(account)
		IRs:
			TMP_5133(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.add(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_5134 = UnaryType.BANG TMP_5133 
			CONDITION TMP_5134
		Expression: revert WhiteListFailedToAdd()()
		IRs:
			TMP_5135(None) = SOLIDITY_CALL revert WhiteListFailedToAdd()()
		Expression: ! _enabledAccounts.contains(account)
		IRs:
			TMP_5136(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_5137 = UnaryType.BANG TMP_5136 
			CONDITION TMP_5137
		Expression: revert WhiteListNotEnabled()()
		IRs:
			TMP_5138(None) = SOLIDITY_CALL revert WhiteListNotEnabled()()
		Expression: ! _enabledAccounts.remove(account)
		IRs:
			TMP_5139(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.remove(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_5140 = UnaryType.BANG TMP_5139 
			CONDITION TMP_5140
		Expression: revert WhiteListFailedToRemove()()
		IRs:
			TMP_5141(None) = SOLIDITY_CALL revert WhiteListFailedToRemove()()
		Expression: AccountWhiteList(account,enabled)
		IRs:
			Emit AccountWhiteList(account,enabled)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.isAccountEnabled(address) (*)
		Expression: _enabledAccounts.length() == 0 || _enabledAccounts.contains(account)
		IRs:
			TMP_5144(uint256) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.length(EnumerableSet.AddressSet), arguments:['_enabledAccounts'] 
			TMP_5145(bool) = TMP_5144 == 0
			TMP_5146(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_5147(bool) = TMP_5145 || TMP_5146
			RETURN TMP_5147
	Function VaultSettings.setWithdrawalFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_5148(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_5148
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_5149(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _withdrawalFee = fee
		IRs:
			_withdrawalFee(uint256) := fee(uint256)
		Expression: WithdrawalFeeChanged(_withdrawalFee)
		IRs:
			Emit WithdrawalFeeChanged(_withdrawalFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getWithdrawalFee() (*)
		Expression: _withdrawalFee
		IRs:
			RETURN _withdrawalFee
	Function VaultSettings.setPerformanceFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_5152(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_5152
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_5153(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _performanceFee = fee
		IRs:
			_performanceFee(uint256) := fee(uint256)
		Expression: PerformanceFeeChanged(_performanceFee)
		IRs:
			Emit PerformanceFeeChanged(_performanceFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getPerformanceFee() (*)
		Expression: _performanceFee
		IRs:
			RETURN _performanceFee
	Function VaultSettings.setFeeReceiver(address) (*)
		Expression: receiver == address(0)
		IRs:
			TMP_5156 = CONVERT 0 to address
			TMP_5157(bool) = receiver == TMP_5156
			CONDITION TMP_5157
		Expression: revert InvalidAddress()()
		IRs:
			TMP_5158(None) = SOLIDITY_CALL revert InvalidAddress()()
		Expression: _feeReceiver = receiver
		IRs:
			_feeReceiver(address) := receiver(address)
		Expression: FeeReceiverChanged(_feeReceiver)
		IRs:
			Emit FeeReceiverChanged(_feeReceiver)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getFeeReceiver() (*)
		Expression: _feeReceiver
		IRs:
			RETURN _feeReceiver
	Function VaultSettings.getMaxDeposit() (*)
		Expression: _maxDeposit
		IRs:
			RETURN _maxDeposit
	Function VaultSettings.setMaxDeposit(uint256) (*)
		Expression: _maxDeposit = value
		IRs:
			_maxDeposit(uint256) := value(uint256)
		Expression: MaxDepositChanged(value)
		IRs:
			Emit MaxDepositChanged(value)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function IVaultSettings.setWithdrawalFee(uint256) 
	Function IVaultSettings.getWithdrawalFee() 
	Function IVaultSettings.setPerformanceFee(uint256) 
	Function IVaultSettings.getPerformanceFee() 
	Function IVaultSettings.setFeeReceiver(address) 
	Function IVaultSettings.getFeeReceiver() 
	Function IVaultSettings.enableAccount(address,bool) 
	Function IVaultSettings.isAccountEnabled(address) 
	Function IVaultSettings.getMaxDeposit() 
	Function IVaultSettings.setMaxDeposit(uint256) 
	Function Ownable2StepUpgradeable.__Ownable2Step_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.pendingOwner() (*)
		Expression: _pendingOwner
		IRs:
			RETURN _pendingOwner
	Function Ownable2StepUpgradeable.transferOwnership(address) (*)
		Expression: _pendingOwner = newOwner
		IRs:
			_pendingOwner(address) := newOwner(address)
		Expression: OwnershipTransferStarted(owner(),newOwner)
		IRs:
			TMP_5166(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			Emit OwnershipTransferStarted(TMP_5166,newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable._transferOwnership(address) (*)
		Expression: delete _pendingOwner
		IRs:
			_pendingOwner = delete _pendingOwner 
		Expression: super._transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
	Function Ownable2StepUpgradeable.acceptOwnership() (*)
		Expression: sender = _msgSender()
		IRs:
			TMP_5170(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			sender(address) := TMP_5170(address)
		Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)
		IRs:
			TMP_5171(address) = INTERNAL_CALL, Ownable2StepUpgradeable.pendingOwner()()
			TMP_5172(bool) = TMP_5171 == sender
			TMP_5173(None) = SOLIDITY_CALL require(bool,string)(TMP_5172,Ownable2Step: caller is not the new owner)
		Expression: _transferOwnership(sender)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(sender)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_5177(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_5177)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_5180(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_5181(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_5182(bool) = TMP_5180 == TMP_5181
			TMP_5183(None) = SOLIDITY_CALL require(bool,string)(TMP_5182,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_5184 = CONVERT 0 to address
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_5184)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) 
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_5187 = CONVERT 0 to address
			TMP_5188(bool) = newOwner != TMP_5187
			TMP_5189(None) = SOLIDITY_CALL require(bool,string)(TMP_5188,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) 
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ERC20PermitUpgradeable.__ERC20Permit_init(string) (*)
		Expression: __EIP712_init_unchained(name,1)
		IRs:
			INTERNAL_CALL, EIP712Upgradeable.__EIP712_init_unchained(string,string)(name,1)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20PermitUpgradeable.__ERC20Permit_init_unchained(string) (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20PermitUpgradeable.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_5196(bool) = block.timestamp <= deadline
			TMP_5197(None) = SOLIDITY_CALL require(bool,string)(TMP_5196,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_5198(uint256) = INTERNAL_CALL, ERC20PermitUpgradeable._useNonce(address)(owner)
			TMP_5199(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_5198,deadline)
			TMP_5200(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5199)
			structHash(bytes32) := TMP_5200(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_5201(bytes32) = INTERNAL_CALL, EIP712Upgradeable._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_5201(bytes32)
		Expression: signer = ECDSAUpgradeable.recover(hash,v,r,s)
		IRs:
			TMP_5202(address) = LIBRARY_CALL, dest:ECDSAUpgradeable, function:ECDSAUpgradeable.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_5202(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_5203(bool) = signer == owner
			TMP_5204(None) = SOLIDITY_CALL require(bool,string)(TMP_5203,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,value)
	Function ERC20PermitUpgradeable.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_1668(CountersUpgradeable.Counter) -> _nonces[owner]
			TMP_5206(uint256) = LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.current(CountersUpgradeable.Counter), arguments:['REF_1668'] 
			RETURN TMP_5206
	Function ERC20PermitUpgradeable.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_5207(bytes32) = INTERNAL_CALL, EIP712Upgradeable._domainSeparatorV4()()
			RETURN TMP_5207
	Function ERC20PermitUpgradeable._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_1670(CountersUpgradeable.Counter) -> _nonces[owner]
			nonce(CountersUpgradeable.Counter) := REF_1670(CountersUpgradeable.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_5208(uint256) = LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.current(CountersUpgradeable.Counter), arguments:['nonce'] 
			current(uint256) := TMP_5208(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:CountersUpgradeable, function:CountersUpgradeable.increment(CountersUpgradeable.Counter), arguments:['nonce'] 
	Function EIP712Upgradeable.__EIP712_init(string,string) (*)
		Expression: __EIP712_init_unchained(name,version)
		IRs:
			INTERNAL_CALL, EIP712Upgradeable.__EIP712_init_unchained(string,string)(name,version)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable.__EIP712_init_unchained(string,string) (*)
		Expression: _name = name
		IRs:
			_name(string) := name(string)
		Expression: _version = version
		IRs:
			_version(string) := version(string)
		Expression: _hashedName = 0
		IRs:
			_hashedName(bytes32) := 0(uint256)
		Expression: _hashedVersion = 0
		IRs:
			_hashedVersion(bytes32) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function EIP712Upgradeable._domainSeparatorV4() (*)
		Expression: _buildDomainSeparator()
		IRs:
			TMP_5213(bytes32) = INTERNAL_CALL, EIP712Upgradeable._buildDomainSeparator()()
			RETURN TMP_5213
	Function EIP712Upgradeable._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_EIP712NameHash(),_EIP712VersionHash(),block.chainid,address(this)))
		IRs:
			TMP_5214(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712NameHash()()
			TMP_5215(bytes32) = INTERNAL_CALL, EIP712Upgradeable._EIP712VersionHash()()
			TMP_5216 = CONVERT this to address
			TMP_5217(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,TMP_5214,TMP_5215,block.chainid,TMP_5216)
			TMP_5218(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5217)
			RETURN TMP_5218
	Function EIP712Upgradeable._hashTypedDataV4(bytes32) (*)
		Expression: ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_5219(bytes32) = INTERNAL_CALL, EIP712Upgradeable._domainSeparatorV4()()
			TMP_5220(bytes32) = LIBRARY_CALL, dest:ECDSAUpgradeable, function:ECDSAUpgradeable.toTypedDataHash(bytes32,bytes32), arguments:['TMP_5219', 'structHash'] 
			RETURN TMP_5220
	Function EIP712Upgradeable.eip712Domain() (*)
		Expression: require(bool,string)(_hashedName == 0 && _hashedVersion == 0,EIP712: Uninitialized)
		IRs:
			TMP_5221(bool) = _hashedName == 0
			TMP_5222(bool) = _hashedVersion == 0
			TMP_5223(bool) = TMP_5221 && TMP_5222
			TMP_5224(None) = SOLIDITY_CALL require(bool,string)(TMP_5223,EIP712: Uninitialized)
		Expression: (,_EIP712Name(),_EIP712Version(),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_5225(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			TMP_5226(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			TMP_5227 = CONVERT this to address
			TMP_5228 = CONVERT 0 to bytes32
			TMP_5230(uint256[])  = new uint256[](0)
			RETURN ,TMP_5225,TMP_5226,block.chainid,TMP_5227,TMP_5228,TMP_5230
	Function EIP712Upgradeable._EIP712Name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function EIP712Upgradeable._EIP712Version() (*)
		Expression: _version
		IRs:
			RETURN _version
	Function EIP712Upgradeable._EIP712NameHash() (*)
		Expression: name = _EIP712Name()
		IRs:
			TMP_5231(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Name()()
			name(string) := TMP_5231(string)
		Expression: bytes(name).length > 0
		IRs:
			TMP_5232 = CONVERT name to bytes
			REF_1675 -> LENGTH TMP_5232
			TMP_5233(bool) = REF_1675 > 0
			CONDITION TMP_5233
		Expression: keccak256(bytes)(bytes(name))
		IRs:
			TMP_5234 = CONVERT name to bytes
			TMP_5235(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5234)
			RETURN TMP_5235
		Expression: hashedName = _hashedName
		IRs:
			hashedName(bytes32) := _hashedName(bytes32)
		Expression: hashedName != 0
		IRs:
			TMP_5236(bool) = hashedName != 0
			CONDITION TMP_5236
		Expression: hashedName
		IRs:
			RETURN hashedName
		Expression: keccak256(bytes)()
		IRs:
			TMP_5237(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_5237
	Function EIP712Upgradeable._EIP712VersionHash() (*)
		Expression: version = _EIP712Version()
		IRs:
			TMP_5238(string) = INTERNAL_CALL, EIP712Upgradeable._EIP712Version()()
			version(string) := TMP_5238(string)
		Expression: bytes(version).length > 0
		IRs:
			TMP_5239 = CONVERT version to bytes
			REF_1676 -> LENGTH TMP_5239
			TMP_5240(bool) = REF_1676 > 0
			CONDITION TMP_5240
		Expression: keccak256(bytes)(bytes(version))
		IRs:
			TMP_5241 = CONVERT version to bytes
			TMP_5242(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5241)
			RETURN TMP_5242
		Expression: hashedVersion = _hashedVersion
		IRs:
			hashedVersion(bytes32) := _hashedVersion(bytes32)
		Expression: hashedVersion != 0
		IRs:
			TMP_5243(bool) = hashedVersion != 0
			CONDITION TMP_5243
		Expression: hashedVersion
		IRs:
			RETURN hashedVersion
		Expression: keccak256(bytes)()
		IRs:
			TMP_5244(bytes32) = SOLIDITY_CALL keccak256(bytes)()
			RETURN TMP_5244
	Function IERC5267Upgradeable.eip712Domain() 
	Function IERC20PermitUpgradeable.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20PermitUpgradeable.nonces(address) 
	Function IERC20PermitUpgradeable.DOMAIN_SEPARATOR() 
	Function ERC20Upgradeable.__ERC20_init(string,string) (*)
		Expression: __ERC20_init_unchained(name_,symbol_)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init_unchained(string,string)(name_,symbol_)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.__ERC20_init_unchained(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ERC20Upgradeable.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20Upgradeable.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20Upgradeable.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20Upgradeable.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20Upgradeable.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_1677(uint256) -> _balances[account]
			RETURN REF_1677
	Function ERC20Upgradeable.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_5248(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_5248(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_1678(mapping(address => uint256)) -> _allowances[owner]
			REF_1679(uint256) -> REF_1678[spender]
			RETURN REF_1679
	Function ERC20Upgradeable.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_5250(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_5250(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_5252(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			spender(address) := TMP_5252(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_5255(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_5255(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_5256(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			TMP_5257(uint256) = TMP_5256 (c)+ addedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_5257)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_5259(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			owner(address) := TMP_5259(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_5260(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_5260(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_5261(bool) = currentAllowance >= subtractedValue
			TMP_5262(None) = SOLIDITY_CALL require(bool,string)(TMP_5261,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_5263(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_5263)
		Expression: true
		IRs:
			RETURN True
	Function ERC20Upgradeable._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_5265 = CONVERT 0 to address
			TMP_5266(bool) = from != TMP_5265
			TMP_5267(None) = SOLIDITY_CALL require(bool,string)(TMP_5266,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_5268 = CONVERT 0 to address
			TMP_5269(bool) = to != TMP_5268
			TMP_5270(None) = SOLIDITY_CALL require(bool,string)(TMP_5269,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1680(uint256) -> _balances[from]
			fromBalance(uint256) := REF_1680(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_5272(bool) = fromBalance >= amount
			TMP_5273(None) = SOLIDITY_CALL require(bool,string)(TMP_5272,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1681(uint256) -> _balances[from]
			TMP_5274(uint256) = fromBalance - amount
			REF_1681(uint256) (->_balances) := TMP_5274(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1682(uint256) -> _balances[to]
			REF_1682(-> _balances) = REF_1682 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20Upgradeable._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_5277 = CONVERT 0 to address
			TMP_5278(bool) = account != TMP_5277
			TMP_5279(None) = SOLIDITY_CALL require(bool,string)(TMP_5278,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_5280 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(TMP_5280,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_1683(uint256) -> _balances[account]
			REF_1683(-> _balances) = REF_1683 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_5282 = CONVERT 0 to address
			Emit Transfer(TMP_5282,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_5284 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(TMP_5284,account,amount)
	Function ERC20Upgradeable._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_5286 = CONVERT 0 to address
			TMP_5287(bool) = account != TMP_5286
			TMP_5288(None) = SOLIDITY_CALL require(bool,string)(TMP_5287,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_5289 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._beforeTokenTransfer(address,address,uint256)(account,TMP_5289,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1684(uint256) -> _balances[account]
			accountBalance(uint256) := REF_1684(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_5291(bool) = accountBalance >= amount
			TMP_5292(None) = SOLIDITY_CALL require(bool,string)(TMP_5291,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1685(uint256) -> _balances[account]
			TMP_5293(uint256) = accountBalance - amount
			REF_1685(uint256) (->_balances) := TMP_5293(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_5294 = CONVERT 0 to address
			Emit Transfer(account,TMP_5294,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_5296 = CONVERT 0 to address
			INTERNAL_CALL, ERC20Upgradeable._afterTokenTransfer(address,address,uint256)(account,TMP_5296,amount)
	Function ERC20Upgradeable._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_5298 = CONVERT 0 to address
			TMP_5299(bool) = owner != TMP_5298
			TMP_5300(None) = SOLIDITY_CALL require(bool,string)(TMP_5299,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_5301 = CONVERT 0 to address
			TMP_5302(bool) = spender != TMP_5301
			TMP_5303(None) = SOLIDITY_CALL require(bool,string)(TMP_5302,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1686(mapping(address => uint256)) -> _allowances[owner]
			REF_1687(uint256) -> REF_1686[spender]
			REF_1687(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20Upgradeable._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_5305(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_5305(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_5307(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_5308(bool) = currentAllowance != TMP_5307
			CONDITION TMP_5308
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_5309(bool) = currentAllowance >= amount
			TMP_5310(None) = SOLIDITY_CALL require(bool,string)(TMP_5309,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_5311(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20Upgradeable._approve(address,address,uint256)(owner,spender,TMP_5311)
	Function ERC20Upgradeable._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20Upgradeable._afterTokenTransfer(address,address,uint256) (*)
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_5316(bool) = _status != _ENTERED
			TMP_5317(None) = SOLIDITY_CALL require(bool,string)(TMP_5316,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_5318(bool) = _status == _ENTERED
			RETURN TMP_5318
	Function PausableUpgradeable.__Pausable_init() (*)
		Expression: __Pausable_init_unchained()
		IRs:
			INTERNAL_CALL, PausableUpgradeable.__Pausable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.__Pausable_init_unchained() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function PausableUpgradeable.paused() (*)
		Expression: _paused
		IRs:
			RETURN _paused
	Function PausableUpgradeable._requireNotPaused() (*)
		Expression: require(bool,string)(! paused(),Pausable: paused)
		IRs:
			TMP_5322(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_5323 = UnaryType.BANG TMP_5322 
			TMP_5324(None) = SOLIDITY_CALL require(bool,string)(TMP_5323,Pausable: paused)
	Function PausableUpgradeable._requirePaused() (*)
		Expression: require(bool,string)(paused(),Pausable: not paused)
		IRs:
			TMP_5325(bool) = INTERNAL_CALL, PausableUpgradeable.paused()()
			TMP_5326(None) = SOLIDITY_CALL require(bool,string)(TMP_5325,Pausable: not paused)
	Function PausableUpgradeable._pause() (*)
		Expression: _paused = true
		IRs:
			_paused(bool) := True(bool)
		Expression: Paused(_msgSender())
		IRs:
			TMP_5327(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Paused(TMP_5327)
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function PausableUpgradeable._unpause() (*)
		Expression: _paused = false
		IRs:
			_paused(bool) := False(bool)
		Expression: Unpaused(_msgSender())
		IRs:
			TMP_5330(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			Emit Unpaused(TMP_5330)
		Expression: whenPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenPaused()()
	Function Vault.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function Vault.receive() (*)
		Expression: msg.sender != wETHA()
		IRs:
			TMP_5334(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5335(bool) = msg.sender != TMP_5334
			CONDITION TMP_5335
		Expression: revert ETHTransferNotAllowed(address)(msg.sender)
		IRs:
			TMP_5336(None) = SOLIDITY_CALL revert ETHTransferNotAllowed(address)(msg.sender)
	Function Vault.initialize(address,string,string,address,IStrategy,address) (*)
		Expression: __ERC20Permit_init(tokenName)
		IRs:
			INTERNAL_CALL, ERC20PermitUpgradeable.__ERC20Permit_init(string)(tokenName)
		Expression: __ERC20_init(tokenName,tokenSymbol)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable.__ERC20_init(string,string)(tokenName,tokenSymbol)
		Expression: _initUseWETH(weth)
		IRs:
			INTERNAL_CALL, UseWETH._initUseWETH(address)(weth)
		Expression: __AccessControl_init()
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable.__AccessControl_init()()
		Expression: initialOwner == address(0)
		IRs:
			TMP_5341 = CONVERT 0 to address
			TMP_5342(bool) = initialOwner == TMP_5341
			CONDITION TMP_5342
		Expression: revert InvalidOwner()()
		IRs:
			TMP_5343(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: iAsset == address(0)
		IRs:
			TMP_5344 = CONVERT 0 to address
			TMP_5345(bool) = iAsset == TMP_5344
			CONDITION TMP_5345
		Expression: revert InvalidAsset()()
		IRs:
			TMP_5346(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: iAsset != strategy.asset()
		IRs:
			TMP_5347(address) = HIGH_LEVEL_CALL, dest:strategy(IStrategy), function:asset, arguments:[]  
			TMP_5348(bool) = iAsset != TMP_5347
			CONDITION TMP_5348
		Expression: revert InvalidAsset()()
		IRs:
			TMP_5349(None) = SOLIDITY_CALL revert InvalidAsset()()
		Expression: _grantRole(DEFAULT_ADMIN_ROLE,initialOwner)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(DEFAULT_ADMIN_ROLE,initialOwner)
		Expression: _grantRole(PAUSER_ROLE,initialOwner)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._grantRole(bytes32,address)(PAUSER_ROLE,initialOwner)
		Expression: _initializeVaultSettings()
		IRs:
			INTERNAL_CALL, VaultSettings._initializeVaultSettings()()
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _strategy = strategy
		IRs:
			_strategy(IStrategy) := strategy(IStrategy)
		Expression: _asset = iAsset
		IRs:
			_asset(address) := iAsset(address)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function Vault.rebalance() (*)
		Expression: currentPosition = totalAssets()
		IRs:
			TMP_5355(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			currentPosition(uint256) := TMP_5355(uint256)
		Expression: currentPosition == 0
		IRs:
			TMP_5356(bool) = currentPosition == 0
			CONDITION TMP_5356
		Expression: 0
		IRs:
			RETURN 0
		Expression: balanceChange = _strategy.harvest()
		IRs:
			TMP_5357(int256) = HIGH_LEVEL_CALL, dest:_strategy(IStrategy), function:harvest, arguments:[]  
			balanceChange(int256) := TMP_5357(int256)
		Expression: balanceChange <= 0
		IRs:
			TMP_5358(bool) = balanceChange <= 0
			CONDITION TMP_5358
		Expression: balanceChange
		IRs:
			RETURN balanceChange
		Expression: feeReceiver = getFeeReceiver()
		IRs:
			TMP_5359(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			feeReceiver(address) := TMP_5359(address)
		Expression: performanceFee = getPerformanceFee()
		IRs:
			TMP_5360(uint256) = INTERNAL_CALL, VaultSettings.getPerformanceFee()()
			performanceFee(uint256) := TMP_5360(uint256)
		Expression: feeReceiver != address(this) && feeReceiver != address(0) && performanceFee > 0
		IRs:
			TMP_5361 = CONVERT this to address
			TMP_5362(bool) = feeReceiver != TMP_5361
			TMP_5363 = CONVERT 0 to address
			TMP_5364(bool) = feeReceiver != TMP_5363
			TMP_5365(bool) = TMP_5362 && TMP_5364
			TMP_5366(bool) = performanceFee > 0
			TMP_5367(bool) = TMP_5365 && TMP_5366
			CONDITION TMP_5367
		Expression: feeInEth = uint256(balanceChange) * performanceFee
		IRs:
			TMP_5368 = CONVERT balanceChange to uint256
			TMP_5369(uint256) = TMP_5368 (c)* performanceFee
			feeInEth(uint256) := TMP_5369(uint256)
		Expression: sharesToMint = feeInEth.mulDivUp(totalSupply(),currentPosition * PERCENTAGE_PRECISION)
		IRs:
			TMP_5370(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5371(uint256) = currentPosition (c)* PERCENTAGE_PRECISION
			TMP_5372(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['feeInEth', 'TMP_5370', 'TMP_5371'] 
			sharesToMint(uint256) := TMP_5372(uint256)
		Expression: _mint(feeReceiver,sharesToMint)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._mint(address,uint256)(feeReceiver,sharesToMint)
		Expression: balanceChange
		IRs:
			RETURN balanceChange
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function Vault.maxMint(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_5377(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_5377
	Function Vault.previewMint(uint256) (*)
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_5378(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_5378(uint256)
	Function Vault.mint(uint256,address) (*)
		Expression: shares == 0
		IRs:
			TMP_5379(bool) = shares == 0
			CONDITION TMP_5379
		Expression: revert InvalidDepositAmount()()
		IRs:
			TMP_5380(None) = SOLIDITY_CALL revert InvalidDepositAmount()()
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_5381(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_5381(uint256)
		Expression: IERC20Upgradeable(_asset).safeTransferFrom(msg.sender,address(this),assets)
		IRs:
			TMP_5382 = CONVERT _asset to IERC20Upgradeable
			TMP_5383 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_5382', 'msg.sender', 'TMP_5383', 'assets'] 
		Expression: _depositInternal(assets,receiver)
		IRs:
			TMP_5385(uint256) = INTERNAL_CALL, Vault._depositInternal(uint256,address)(assets,receiver)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault.maxDeposit(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_5390(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_5390
	Function Vault.previewDeposit(uint256) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_5391(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_5391(uint256)
	Function Vault.depositNative(address) (*)
		Expression: msg.value == 0
		IRs:
			TMP_5392(bool) = msg.value == 0
			CONDITION TMP_5392
		Expression: revert InvalidDepositAmount()()
		IRs:
			TMP_5393(None) = SOLIDITY_CALL revert InvalidDepositAmount()()
		Expression: _asset != wETHA()
		IRs:
			TMP_5394(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5395(bool) = _asset != TMP_5394
			CONDITION TMP_5395
		Expression: revert InvalidDepositAsset()()
		IRs:
			TMP_5396(None) = SOLIDITY_CALL revert InvalidDepositAsset()()
		Expression: wETHA().functionCallWithValue(abi.encodeWithSignature(deposit()),msg.value)
		IRs:
			TMP_5397(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5398(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(deposit())
			TMP_5399(bytes) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.functionCallWithValue(address,bytes,uint256), arguments:['TMP_5397', 'TMP_5398', 'msg.value'] 
		Expression: _depositInternal(msg.value,receiver)
		IRs:
			TMP_5400(uint256) = INTERNAL_CALL, Vault._depositInternal(uint256,address)(msg.value,receiver)
			RETURN TMP_5400
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault.deposit(uint256,address) (*)
		Expression: assets == 0
		IRs:
			TMP_5404(bool) = assets == 0
			CONDITION TMP_5404
		Expression: revert InvalidDepositAmount()()
		IRs:
			TMP_5405(None) = SOLIDITY_CALL revert InvalidDepositAmount()()
		Expression: IERC20Upgradeable(_asset).safeTransferFrom(msg.sender,address(this),assets)
		IRs:
			TMP_5406 = CONVERT _asset to IERC20Upgradeable
			TMP_5407 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_5406', 'msg.sender', 'TMP_5407', 'assets'] 
		Expression: _depositInternal(assets,receiver)
		IRs:
			TMP_5409(uint256) = INTERNAL_CALL, Vault._depositInternal(uint256,address)(assets,receiver)
			RETURN TMP_5409
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault._depositInternal(uint256,address) (*)
		Expression: receiver == address(0)
		IRs:
			TMP_5413 = CONVERT 0 to address
			TMP_5414(bool) = receiver == TMP_5413
			CONDITION TMP_5414
		Expression: revert InvalidReceiver()()
		IRs:
			TMP_5415(None) = SOLIDITY_CALL revert InvalidReceiver()()
		Expression: total = Rebase(totalAssets(),totalSupply())
		IRs:
			TMP_5416(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			TMP_5417(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5418(Rebase) = new Rebase(TMP_5416,TMP_5417)
			total(Rebase) := TMP_5418(Rebase)
		Expression: ! ((total.elastic == 0 && total.base == 0) || (total.base > 0 && total.elastic > 0))
		IRs:
			REF_1698(uint256) -> total.elastic
			TMP_5419(bool) = REF_1698 == 0
			REF_1699(uint256) -> total.base
			TMP_5420(bool) = REF_1699 == 0
			TMP_5421(bool) = TMP_5419 && TMP_5420
			REF_1700(uint256) -> total.base
			TMP_5422(bool) = REF_1700 > 0
			REF_1701(uint256) -> total.elastic
			TMP_5423(bool) = REF_1701 > 0
			TMP_5424(bool) = TMP_5422 && TMP_5423
			TMP_5425(bool) = TMP_5421 || TMP_5424
			TMP_5426 = UnaryType.BANG TMP_5425 
			CONDITION TMP_5426
		Expression: revert InvalidAssetsState()()
		IRs:
			TMP_5427(None) = SOLIDITY_CALL revert InvalidAssetsState()()
		Expression: maxDepositLocal = getMaxDeposit()
		IRs:
			TMP_5428(uint256) = INTERNAL_CALL, VaultSettings.getMaxDeposit()()
			maxDepositLocal(uint256) := TMP_5428(uint256)
		Expression: maxDepositLocal > 0
		IRs:
			TMP_5429(bool) = maxDepositLocal > 0
			CONDITION TMP_5429
		Expression: depositInAssets = (balanceOf(msg.sender) * _ONE) / tokenPerAsset()
		IRs:
			TMP_5430(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(msg.sender)
			TMP_5431(uint256) = TMP_5430 (c)* _ONE
			TMP_5432(uint256) = INTERNAL_CALL, Vault.tokenPerAsset()()
			TMP_5433(uint256) = TMP_5431 (c)/ TMP_5432
			depositInAssets(uint256) := TMP_5433(uint256)
		Expression: newBalance = assets + depositInAssets
		IRs:
			TMP_5434(uint256) = assets (c)+ depositInAssets
			newBalance(uint256) := TMP_5434(uint256)
		Expression: newBalance > maxDepositLocal
		IRs:
			TMP_5435(bool) = newBalance > maxDepositLocal
			CONDITION TMP_5435
		Expression: revert MaxDepositReached()()
		IRs:
			TMP_5436(None) = SOLIDITY_CALL revert MaxDepositReached()()
		Expression: IERC20Upgradeable(_asset).safeApprove(address(_strategy),assets)
		IRs:
			TMP_5437 = CONVERT _asset to IERC20Upgradeable
			TMP_5438 = CONVERT _strategy to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeApprove(IERC20Upgradeable,address,uint256), arguments:['TMP_5437', 'TMP_5438', 'assets'] 
		Expression: deployedAmount = _strategy.deploy(assets)
		IRs:
			TMP_5440(uint256) = HIGH_LEVEL_CALL, dest:_strategy(IStrategy), function:deploy, arguments:['assets']  
			deployedAmount(uint256) := TMP_5440(uint256)
		Expression: shares = total.toBase(deployedAmount,false)
		IRs:
			TMP_5441(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'deployedAmount', 'False'] 
			shares(uint256) := TMP_5441(uint256)
		Expression: total.base == 0 && shares < _MINIMUM_SHARE_BALANCE
		IRs:
			REF_1705(uint256) -> total.base
			TMP_5442(bool) = REF_1705 == 0
			TMP_5443(bool) = shares < _MINIMUM_SHARE_BALANCE
			TMP_5444(bool) = TMP_5442 && TMP_5443
			CONDITION TMP_5444
		Expression: revert InvalidShareBalance()()
		IRs:
			TMP_5445(None) = SOLIDITY_CALL revert InvalidShareBalance()()
		Expression: _mint(receiver,shares)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._mint(address,uint256)(receiver,shares)
		Expression: Deposit(msg.sender,receiver,assets,shares)
		IRs:
			Emit Deposit(msg.sender,receiver,assets,shares)
	Function Vault.maxWithdraw(address) (*)
		Expression: maxAssets = this.convertToAssets(balanceOf(shareHolder))
		IRs:
			TMP_5448(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(shareHolder)
			TMP_5449(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['TMP_5448']  
			maxAssets(uint256) := TMP_5449(uint256)
	Function Vault.previewWithdraw(uint256) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_5450(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_5450(uint256)
	Function Vault.withdrawNative(uint256) (*)
		Expression: _asset != wETHA()
		IRs:
			TMP_5451(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5452(bool) = _asset != TMP_5451
			CONDITION TMP_5452
		Expression: revert InvalidDepositAsset()()
		IRs:
			TMP_5453(None) = SOLIDITY_CALL revert InvalidDepositAsset()()
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_5454(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_5454(uint256)
		Expression: _redeemInternal(shares,msg.sender,msg.sender,true)
		IRs:
			TMP_5455(uint256) = INTERNAL_CALL, Vault._redeemInternal(uint256,address,address,bool)(shares,msg.sender,msg.sender,True)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault.redeemNative(uint256) (*)
		Expression: _asset != wETHA()
		IRs:
			TMP_5459(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5460(bool) = _asset != TMP_5459
			CONDITION TMP_5460
		Expression: revert InvalidDepositAsset()()
		IRs:
			TMP_5461(None) = SOLIDITY_CALL revert InvalidDepositAsset()()
		Expression: assets = _redeemInternal(shares,msg.sender,msg.sender,true)
		IRs:
			TMP_5462(uint256) = INTERNAL_CALL, Vault._redeemInternal(uint256,address,address,bool)(shares,msg.sender,msg.sender,True)
			assets(uint256) := TMP_5462(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault.withdraw(uint256,address,address) (*)
		Expression: shares = this.convertToShares(assets)
		IRs:
			TMP_5466(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToShares, arguments:['assets']  
			shares(uint256) := TMP_5466(uint256)
		Expression: _redeemInternal(shares,receiver,holder,false)
		IRs:
			TMP_5467(uint256) = INTERNAL_CALL, Vault._redeemInternal(uint256,address,address,bool)(shares,receiver,holder,False)
			RETURN TMP_5467
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
	Function Vault.maxRedeem(address) (*)
		Expression: maxShares = balanceOf(shareHolder)
		IRs:
			TMP_5471(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(shareHolder)
			maxShares(uint256) := TMP_5471(uint256)
	Function Vault.previewRedeem(uint256) (*)
		Expression: assets = this.convertToAssets(shares)
		IRs:
			TMP_5472(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:convertToAssets, arguments:['shares']  
			assets(uint256) := TMP_5472(uint256)
	Function Vault.redeem(uint256,address,address) (*)
		Expression: _redeemInternal(shares,receiver,holder,false)
		IRs:
			TMP_5473(uint256) = INTERNAL_CALL, Vault._redeemInternal(uint256,address,address,bool)(shares,receiver,holder,False)
			RETURN TMP_5473
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
		Expression: onlyWhiteListed()
		IRs:
			MODIFIER_CALL, Vault.onlyWhiteListed()()
		Expression: whenNotPaused()
		IRs:
			MODIFIER_CALL, PausableUpgradeable.whenNotPaused()()
	Function Vault._redeemInternal(uint256,address,address,bool) (*)
		Expression: shares == 0
		IRs:
			TMP_5477(bool) = shares == 0
			CONDITION TMP_5477
		Expression: revert InvalidWithdrawAmount()()
		IRs:
			TMP_5478(None) = SOLIDITY_CALL revert InvalidWithdrawAmount()()
		Expression: receiver == address(0)
		IRs:
			TMP_5479 = CONVERT 0 to address
			TMP_5480(bool) = receiver == TMP_5479
			CONDITION TMP_5480
		Expression: revert InvalidReceiver()()
		IRs:
			TMP_5481(None) = SOLIDITY_CALL revert InvalidReceiver()()
		Expression: balanceOf(holder) < shares
		IRs:
			TMP_5482(uint256) = INTERNAL_CALL, ERC20Upgradeable.balanceOf(address)(holder)
			TMP_5483(bool) = TMP_5482 < shares
			CONDITION TMP_5483
		Expression: revert NotEnoughBalanceToWithdraw()()
		IRs:
			TMP_5484(None) = SOLIDITY_CALL revert NotEnoughBalanceToWithdraw()()
		Expression: msg.sender != holder
		IRs:
			TMP_5485(bool) = msg.sender != holder
			CONDITION TMP_5485
		Expression: allowance(holder,msg.sender) < shares
		IRs:
			TMP_5486(uint256) = INTERNAL_CALL, ERC20Upgradeable.allowance(address,address)(holder,msg.sender)
			TMP_5487(bool) = TMP_5486 < shares
			CONDITION TMP_5487
		Expression: revert NoAllowance()()
		IRs:
			TMP_5488(None) = SOLIDITY_CALL revert NoAllowance()()
		Expression: transferFrom(holder,msg.sender,shares)
		IRs:
			TMP_5489(bool) = INTERNAL_CALL, ERC20Upgradeable.transferFrom(address,address,uint256)(holder,msg.sender,shares)
		Expression: withdrawAmount = (shares * totalAssets()) / totalSupply()
		IRs:
			TMP_5490(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			TMP_5491(uint256) = shares (c)* TMP_5490
			TMP_5492(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5493(uint256) = TMP_5491 (c)/ TMP_5492
			withdrawAmount(uint256) := TMP_5493(uint256)
		Expression: withdrawAmount == 0
		IRs:
			TMP_5494(bool) = withdrawAmount == 0
			CONDITION TMP_5494
		Expression: revert NoAssetsToWithdraw()()
		IRs:
			TMP_5495(None) = SOLIDITY_CALL revert NoAssetsToWithdraw()()
		Expression: amount = _strategy.undeploy(withdrawAmount)
		IRs:
			TMP_5496(uint256) = HIGH_LEVEL_CALL, dest:_strategy(IStrategy), function:undeploy, arguments:['withdrawAmount']  
			amount(uint256) := TMP_5496(uint256)
		Expression: fee = 0
		IRs:
			fee(uint256) := 0(uint256)
		Expression: remainingShares = totalSupply() - shares
		IRs:
			TMP_5497(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5498(uint256) = TMP_5497 (c)- shares
			remainingShares(uint256) := TMP_5498(uint256)
		Expression: remainingShares < _MINIMUM_SHARE_BALANCE && remainingShares != 0
		IRs:
			TMP_5499(bool) = remainingShares < _MINIMUM_SHARE_BALANCE
			TMP_5500(bool) = remainingShares != 0
			TMP_5501(bool) = TMP_5499 && TMP_5500
			CONDITION TMP_5501
		Expression: revert InvalidShareBalance()()
		IRs:
			TMP_5502(None) = SOLIDITY_CALL revert InvalidShareBalance()()
		Expression: _burn(msg.sender,shares)
		IRs:
			INTERNAL_CALL, ERC20Upgradeable._burn(address,uint256)(msg.sender,shares)
		Expression: getWithdrawalFee() != 0 && getFeeReceiver() != address(0)
		IRs:
			TMP_5504(uint256) = INTERNAL_CALL, VaultSettings.getWithdrawalFee()()
			TMP_5505(bool) = TMP_5504 != 0
			TMP_5506(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_5507 = CONVERT 0 to address
			TMP_5508(bool) = TMP_5506 != TMP_5507
			TMP_5509(bool) = TMP_5505 && TMP_5508
			CONDITION TMP_5509
		Expression: fee = amount.mulDivUp(getWithdrawalFee(),PERCENTAGE_PRECISION)
		IRs:
			TMP_5510(uint256) = INTERNAL_CALL, VaultSettings.getWithdrawalFee()()
			TMP_5511(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['amount', 'TMP_5510', 'PERCENTAGE_PRECISION'] 
			fee(uint256) := TMP_5511(uint256)
		Expression: shouldRedeemETH && _asset == wETHA()
		IRs:
			TMP_5512(address) = INTERNAL_CALL, UseWETH.wETHA()()
			TMP_5513(bool) = _asset == TMP_5512
			TMP_5514(bool) = shouldRedeemETH && TMP_5513
			CONDITION TMP_5514
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(amount)
		Expression: address(receiver).sendValue(amount - fee)
		IRs:
			TMP_5516 = CONVERT receiver to address
			TMP_5517(uint256) = amount (c)- fee
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_5516', 'TMP_5517'] 
		Expression: address(getFeeReceiver()).sendValue(fee)
		IRs:
			TMP_5519(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_5520 = CONVERT TMP_5519 to address
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_5520', 'fee'] 
		Expression: IERC20Upgradeable(_asset).transfer(receiver,amount - fee)
		IRs:
			TMP_5522 = CONVERT _asset to IERC20Upgradeable
			TMP_5523(uint256) = amount (c)- fee
			TMP_5524(bool) = HIGH_LEVEL_CALL, dest:TMP_5522(IERC20Upgradeable), function:transfer, arguments:['receiver', 'TMP_5523']  
		Expression: IERC20Upgradeable(_asset).transfer(getFeeReceiver(),fee)
		IRs:
			TMP_5525 = CONVERT _asset to IERC20Upgradeable
			TMP_5526(address) = INTERNAL_CALL, VaultSettings.getFeeReceiver()()
			TMP_5527(bool) = HIGH_LEVEL_CALL, dest:TMP_5525(IERC20Upgradeable), function:transfer, arguments:['TMP_5526', 'fee']  
		Expression: shouldRedeemETH
		IRs:
			CONDITION shouldRedeemETH
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(amount)
		Expression: address(receiver).sendValue(amount)
		IRs:
			TMP_5529 = CONVERT receiver to address
			LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.sendValue(address,uint256), arguments:['TMP_5529', 'amount'] 
		Expression: IERC20Upgradeable(_asset).transfer(receiver,amount)
		IRs:
			TMP_5531 = CONVERT _asset to IERC20Upgradeable
			TMP_5532(bool) = HIGH_LEVEL_CALL, dest:TMP_5531(IERC20Upgradeable), function:transfer, arguments:['receiver', 'amount']  
		Expression: Withdraw(msg.sender,receiver,holder,amount - fee,shares)
		IRs:
			TMP_5533(uint256) = amount (c)- fee
			Emit Withdraw(msg.sender,receiver,holder,TMP_5533,shares)
		Expression: retAmount = amount - fee
		IRs:
			TMP_5535(uint256) = amount (c)- fee
			retAmount(uint256) := TMP_5535(uint256)
	Function Vault.totalAssets() (*)
		Expression: amount = _strategy.totalAssets()
		IRs:
			TMP_5536(uint256) = HIGH_LEVEL_CALL, dest:_strategy(IStrategy), function:totalAssets, arguments:[]  
			amount(uint256) := TMP_5536(uint256)
	Function Vault.convertToShares(uint256) (*)
		Expression: total = Rebase(totalAssets(),totalSupply())
		IRs:
			TMP_5537(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			TMP_5538(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5539(Rebase) = new Rebase(TMP_5537,TMP_5538)
			total(Rebase) := TMP_5539(Rebase)
		Expression: shares = total.toBase(assets,false)
		IRs:
			TMP_5540(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'assets', 'False'] 
			shares(uint256) := TMP_5540(uint256)
	Function Vault.convertToAssets(uint256) (*)
		Expression: total = Rebase(totalAssets(),totalSupply())
		IRs:
			TMP_5541(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			TMP_5542(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5543(Rebase) = new Rebase(TMP_5541,TMP_5542)
			total(Rebase) := TMP_5543(Rebase)
		Expression: assets = total.toElastic(shares,false)
		IRs:
			TMP_5544(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toElastic(Rebase,uint256,bool), arguments:['total', 'shares', 'False'] 
			assets(uint256) := TMP_5544(uint256)
	Function Vault.tokenPerAsset() (*)
		Expression: totalAssetsValue = totalAssets()
		IRs:
			TMP_5545(uint256) = INTERNAL_CALL, Vault.totalAssets()()
			totalAssetsValue(uint256) := TMP_5545(uint256)
		Expression: totalSupply() == 0 || totalAssetsValue == 0
		IRs:
			TMP_5546(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5547(bool) = TMP_5546 == 0
			TMP_5548(bool) = totalAssetsValue == 0
			TMP_5549(bool) = TMP_5547 || TMP_5548
			CONDITION TMP_5549
		Expression: _ONE
		IRs:
			RETURN _ONE
		Expression: (totalSupply() * _ONE) / totalAssetsValue
		IRs:
			TMP_5550(uint256) = INTERNAL_CALL, ERC20Upgradeable.totalSupply()()
			TMP_5551(uint256) = TMP_5550 (c)* _ONE
			TMP_5552(uint256) = TMP_5551 (c)/ totalAssetsValue
			RETURN TMP_5552
	Function Vault.asset() (*)
		Expression: _asset
		IRs:
			RETURN _asset
	Function Vault.pause() (*)
		Expression: _pause()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._pause()()
		Expression: onlyRole(PAUSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(PAUSER_ROLE)
	Function Vault.unpause() (*)
		Expression: _unpause()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._unpause()()
		Expression: onlyRole(PAUSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControlUpgradeable.onlyRole(bytes32)(PAUSER_ROLE)
	Function Vault.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
		Expression: PAUSER_ROLE = keccak256(bytes)(PAUSER_ROLE)
		IRs:
			TMP_5557(bytes32) = SOLIDITY_CALL keccak256(bytes)(PAUSER_ROLE)
			PAUSER_ROLE(bytes32) := TMP_5557(bytes32)
		Expression: _MINIMUM_SHARE_BALANCE = 1000
		IRs:
			_MINIMUM_SHARE_BALANCE(uint256) := 1000(uint256)
		Expression: _ONE = 1e18
		IRs:
			_ONE(uint256) := 1000000000000000000(uint256)
		Expression: _VAULT_VERSION = 3
		IRs:
			_VAULT_VERSION(uint8) := 3(uint256)
	Modifier AccessControlUpgradeable.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControlUpgradeable._checkRole(bytes32)(role)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_5559 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_5559(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_5560(bool) = _initialized < 1
			TMP_5561(bool) = isTopLevelCall && TMP_5560
			TMP_5562 = CONVERT this to address
			TMP_5563(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_5562'] 
			TMP_5564 = UnaryType.BANG TMP_5563 
			TMP_5565(bool) = _initialized == 1
			TMP_5566(bool) = TMP_5564 && TMP_5565
			TMP_5567(bool) = TMP_5561 || TMP_5566
			TMP_5568(None) = SOLIDITY_CALL require(bool,string)(TMP_5567,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_5570 = UnaryType.BANG _initializing 
			TMP_5571(bool) = _initialized < version
			TMP_5572(bool) = TMP_5570 && TMP_5571
			TMP_5573(None) = SOLIDITY_CALL require(bool,string)(TMP_5572,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_5575(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
	Modifier PausableUpgradeable.whenNotPaused()
		Expression: _requireNotPaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requireNotPaused()()
	Modifier PausableUpgradeable.whenPaused()
		Expression: _requirePaused()
		IRs:
			INTERNAL_CALL, PausableUpgradeable._requirePaused()()
	Modifier Vault.onlyWhiteListed()
		Expression: ! isAccountEnabled(msg.sender)
		IRs:
			TMP_5581(bool) = INTERNAL_CALL, VaultSettings.isAccountEnabled(address)(msg.sender)
			TMP_5582 = UnaryType.BANG TMP_5581 
			CONDITION TMP_5582
		Expression: revert NoPermissions()()
		IRs:
			TMP_5583(None) = SOLIDITY_CALL revert NoPermissions()()
Contract VaultRegistry
	Function IVaultRegistry.registerService(bytes32,address) 
	Function IVaultRegistry.unregisterService(bytes32) 
	Function IVaultRegistry.getServiceFromHash(bytes32) 
	Function IVaultRegistry.getService(string) 
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_5584(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_5584)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_5586(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_5587(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_5588(bool) = TMP_5586 == TMP_5587
			TMP_5589(None) = SOLIDITY_CALL require(bool,string)(TMP_5588,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_5590 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_5590)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_5593 = CONVERT 0 to address
			TMP_5594(bool) = newOwner != TMP_5593
			TMP_5595(None) = SOLIDITY_CALL require(bool,string)(TMP_5594,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function VaultRegistry.constructor(address) (*)
		Expression: ownerToSet == address(0)
		IRs:
			TMP_5599 = CONVERT 0 to address
			TMP_5600(bool) = ownerToSet == TMP_5599
			CONDITION TMP_5600
		Expression: revert InvalidOwner()()
		IRs:
			TMP_5601(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _transferOwnership(ownerToSet)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(ownerToSet)
	Function VaultRegistry.registerService(bytes32,address) (*)
		Expression: _services[serviceNameHash] != address(0)
		IRs:
			REF_1723(address) -> _services[serviceNameHash]
			TMP_5603 = CONVERT 0 to address
			TMP_5604(bool) = REF_1723 != TMP_5603
			CONDITION TMP_5604
		Expression: revert ServiceAlreadySet()()
		IRs:
			TMP_5605(None) = SOLIDITY_CALL revert ServiceAlreadySet()()
		Expression: _services[serviceNameHash] = serviceAddress
		IRs:
			REF_1724(address) -> _services[serviceNameHash]
			REF_1724(address) (->_services) := serviceAddress(address)
		Expression: ServiceRegistered(serviceNameHash,serviceAddress)
		IRs:
			Emit ServiceRegistered(serviceNameHash,serviceAddress)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function VaultRegistry.unregisterService(bytes32) (*)
		Expression: _services[serviceNameHash] == address(0)
		IRs:
			REF_1725(address) -> _services[serviceNameHash]
			TMP_5608 = CONVERT 0 to address
			TMP_5609(bool) = REF_1725 == TMP_5608
			CONDITION TMP_5609
		Expression: revert ServiceUnknown()()
		IRs:
			TMP_5610(None) = SOLIDITY_CALL revert ServiceUnknown()()
		Expression: _services[serviceNameHash] = address(0)
		IRs:
			REF_1726(address) -> _services[serviceNameHash]
			TMP_5611 = CONVERT 0 to address
			REF_1726(address) (->_services) := TMP_5611(address)
		Expression: ServiceUnregistered(serviceNameHash)
		IRs:
			Emit ServiceUnregistered(serviceNameHash)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function VaultRegistry.getServiceNameHash(string) (*)
		Expression: keccak256(bytes)(abi.encodePacked(name))
		IRs:
			TMP_5614(bytes) = SOLIDITY_CALL abi.encodePacked()(name)
			TMP_5615(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5614)
			RETURN TMP_5615
	Function VaultRegistry.getService(string) (*)
		Expression: _services[keccak256(bytes)(abi.encodePacked(serviceName))]
		IRs:
			TMP_5616(bytes) = SOLIDITY_CALL abi.encodePacked()(serviceName)
			TMP_5617(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5616)
			REF_1729(address) -> _services[TMP_5617]
			RETURN REF_1729
	Function VaultRegistry.getServiceFromHash(bytes32) (*)
		Expression: _services[serviceHash]
		IRs:
			REF_1730(address) -> _services[serviceHash]
			RETURN REF_1730
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract VaultRouter
	Function MultiCommand.dispatch(uint256,bytes,uint256[]) 
	Function MultiCommand.execute(Command[]) (*)
		Expression: numCommands = commands.length
		IRs:
			REF_1731 -> LENGTH commands
			numCommands(uint256) := REF_1731(uint256)
		Expression: callStack = new uint256[](Commands.CALL_STACK_SIZE)
		IRs:
			REF_1732(uint256) -> Commands.CALL_STACK_SIZE
			TMP_5620(uint256[])  = new uint256[](REF_1732)
			callStack(uint256[]) = ['TMP_5620(uint256[])']
		Expression: commandIndex = 0
		IRs:
			commandIndex(uint256) := 0(uint256)
		Expression: commandIndex < numCommands
		IRs:
			TMP_5621(bool) = commandIndex < numCommands
			CONDITION TMP_5621
		Expression: (success,output) = dispatch(commands[commandIndex].action,commands[commandIndex].data,callStack)
		IRs:
			REF_1733(Command) -> commands[commandIndex]
			REF_1734(uint256) -> REF_1733.action
			REF_1735(Command) -> commands[commandIndex]
			REF_1736(bytes) -> REF_1735.data
			TUPLE_57(bool,bytes) = INTERNAL_CALL, VaultRouter.dispatch(uint256,bytes,uint256[])(REF_1734,REF_1736,callStack)
			success(bool)= UNPACK TUPLE_57 index: 0 
			output(bytes)= UNPACK TUPLE_57 index: 1 
		Expression: ! success
		IRs:
			TMP_5622 = UnaryType.BANG success 
			CONDITION TMP_5622
		Expression: revert ExecutionFailed(uint256,bytes)({commandIndex:commandIndex,message:output})
		IRs:
			TMP_5623(None) = SOLIDITY_CALL revert ExecutionFailed(uint256,bytes)(commandIndex,output)
		Expression: commandIndex ++
		IRs:
			TMP_5624(uint256) := commandIndex(uint256)
			commandIndex(uint256) = commandIndex + 1
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_5625 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_5625(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_5626 = CONVERT _wETH to address
			TMP_5627 = CONVERT 0 to address
			TMP_5628(bool) = TMP_5626 == TMP_5627
			CONDITION TMP_5628
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_5629(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() (*)
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_5631 = CONVERT _wETH to address
			RETURN TMP_5631
	Function UseWETH.unwrapETH(uint256) (*)
		Expression: wETHAmount == 0
		IRs:
			TMP_5632(bool) = wETHAmount == 0
			CONDITION TMP_5632
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_5633(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_5634 = CONVERT this to address
			TMP_5635(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_5634']  
			wETHBalance(uint256) := TMP_5635(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_5636(bool) = wETHBalance < wETHAmount
			CONDITION TMP_5636
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_5637(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_5638(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_5638(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) (*)
		Expression: address(this).balance < amount
		IRs:
			TMP_5640 = CONVERT this to address
			TMP_5641(uint256) = SOLIDITY_CALL balance(address)(TMP_5640)
			TMP_5642(bool) = TMP_5641 < amount
			CONDITION TMP_5642
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_5643(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_5644(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_5644(IWETH), function:deposit, arguments:[] value:amount 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_5646 = UnaryType.BANG _initializing 
			TMP_5647(None) = SOLIDITY_CALL require(bool,string)(TMP_5646,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_5649(uint8) := 255(uint8)
			TMP_5650(bool) = _initialized != TMP_5649
			CONDITION TMP_5650
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_5652(uint8) := 255(uint8)
			_initialized(uint8) := TMP_5652(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_5654(uint8) := 255(uint8)
			Emit Initialized(TMP_5654)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseIERC4626.initializeUseIERC4626(address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialOwner)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialOwner)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseIERC4626.approveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = true
		IRs:
			REF_1740(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_1741(bool) -> REF_1740[token]
			REF_1741(bool) (->_approvedVaults) := True(bool)
		Expression: ! IERC20(token).approve(address(vault),2 ** 256 - 1)
		IRs:
			TMP_5659 = CONVERT token to IERC20
			TMP_5660 = CONVERT vault to address
			TMP_5661(uint256) = 2 (c)** 256
			TMP_5662(uint256) = TMP_5661 (c)- 1
			TMP_5663(bool) = HIGH_LEVEL_CALL, dest:TMP_5659(IERC20), function:approve, arguments:['TMP_5660', 'TMP_5662']  
			TMP_5664 = UnaryType.BANG TMP_5663 
			CONDITION TMP_5664
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_5665(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.isTokenApprovedForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token]
		IRs:
			REF_1743(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_1744(bool) -> REF_1743[token]
			RETURN REF_1744
	Function UseIERC4626.unapproveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = false
		IRs:
			REF_1745(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_1746(bool) -> REF_1745[token]
			REF_1746(bool) (->_approvedVaults) := False(bool)
		Expression: ! IERC20(token).approve(address(vault),0)
		IRs:
			TMP_5667 = CONVERT token to IERC20
			TMP_5668 = CONVERT vault to address
			TMP_5669(bool) = HIGH_LEVEL_CALL, dest:TMP_5667(IERC20), function:approve, arguments:['TMP_5668', '0']  
			TMP_5670 = UnaryType.BANG TMP_5669 
			CONDITION TMP_5670
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_5671(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.convertToVaultAssets(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5673 = CONVERT vault to address
			TMP_5674 = CONVERT 0 to address
			TMP_5675(bool) = TMP_5673 == TMP_5674
			CONDITION TMP_5675
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5676(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToAssets(shares)
		IRs:
			TMP_5677(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToAssets, arguments:['shares']  
			RETURN TMP_5677
	Function UseIERC4626.convertToVaultShares(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5678 = CONVERT vault to address
			TMP_5679 = CONVERT 0 to address
			TMP_5680(bool) = TMP_5678 == TMP_5679
			CONDITION TMP_5680
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5681(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToShares(assets)
		IRs:
			TMP_5682(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToShares, arguments:['assets']  
			RETURN TMP_5682
	Function UseIERC4626.totalVaultAssets(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5683 = CONVERT vault to address
			TMP_5684 = CONVERT 0 to address
			TMP_5685(bool) = TMP_5683 == TMP_5684
			CONDITION TMP_5685
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5686(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.totalAssets()
		IRs:
			TMP_5687(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:totalAssets, arguments:[]  
			RETURN TMP_5687
	Function UseIERC4626.vaultAsset(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5688 = CONVERT vault to address
			TMP_5689 = CONVERT 0 to address
			TMP_5690(bool) = TMP_5688 == TMP_5689
			CONDITION TMP_5690
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5691(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.asset()
		IRs:
			TMP_5692(address) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:asset, arguments:[]  
			RETURN TMP_5692
	Function UseIERC4626.depositVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5693 = CONVERT vault to address
			TMP_5694 = CONVERT 0 to address
			TMP_5695(bool) = TMP_5693 == TMP_5694
			CONDITION TMP_5695
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5696(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: shares = vault.deposit(assets,receiver)
		IRs:
			TMP_5697(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:deposit, arguments:['assets', 'receiver']  
			shares(uint256) := TMP_5697(uint256)
	Function UseIERC4626.mintVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5698 = CONVERT vault to address
			TMP_5699 = CONVERT 0 to address
			TMP_5700(bool) = TMP_5698 == TMP_5699
			CONDITION TMP_5700
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5701(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.mint(shares,receiver)
		IRs:
			TMP_5702(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:mint, arguments:['shares', 'receiver']  
			assets(uint256) := TMP_5702(uint256)
	Function UseIERC4626.withdrawVault(IERC4626,uint256,address,address) (*)
		Expression: shares = vault.withdraw(assets,receiver,owner)
		IRs:
			TMP_5703(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:withdraw, arguments:['assets', 'receiver', 'owner']  
			shares(uint256) := TMP_5703(uint256)
	Function UseIERC4626.redeemVault(IERC4626,uint256,address,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_5704 = CONVERT vault to address
			TMP_5705 = CONVERT 0 to address
			TMP_5706(bool) = TMP_5704 == TMP_5705
			CONDITION TMP_5706
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_5707(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.redeem(shares,receiver,owner)
		IRs:
			TMP_5708(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:redeem, arguments:['shares', 'receiver', 'owner']  
			assets(uint256) := TMP_5708(uint256)
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_5712 = CONVERT 0 to address
			TMP_5713(bool) = _newGovernor == TMP_5712
			CONDITION TMP_5713
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_5714(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_5720(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_5720)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_5723(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_5724(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_5725(bool) = TMP_5723 == TMP_5724
			TMP_5726(None) = SOLIDITY_CALL require(bool,string)(TMP_5725,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_5727 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_5727)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_5730 = CONVERT 0 to address
			TMP_5731(bool) = newOwner != TMP_5730
			TMP_5732(None) = SOLIDITY_CALL require(bool,string)(TMP_5731,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) (*)
		Expression: IERC20Permit(token).permit(owner,address(this),amount,deadline,v,r,s)
		IRs:
			TMP_5738 = CONVERT token to IERC20Permit
			TMP_5739 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_5738(IERC20Permit), function:permit, arguments:['owner', 'TMP_5739', 'amount', 'deadline', 'v', 'r', 's']  
		Expression: IERC20(address(token)).safeTransferFrom(owner,address(this),amount)
		IRs:
			TMP_5741 = CONVERT token to address
			TMP_5742 = CONVERT TMP_5741 to IERC20
			TMP_5743 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_5742', 'owner', 'TMP_5743', 'amount'] 
	Function UseTokenActions.pullToken(IERC20,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_5745 = CONVERT token to address
			TMP_5746 = CONVERT 0 to address
			TMP_5747(bool) = TMP_5745 == TMP_5746
			CONDITION TMP_5747
		Expression: revert InvalidToken()()
		IRs:
			TMP_5748(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(msg.sender,address(this)) < amount
		IRs:
			TMP_5749 = CONVERT this to address
			TMP_5750(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['msg.sender', 'TMP_5749']  
			TMP_5751(bool) = TMP_5750 < amount
			CONDITION TMP_5751
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_5752(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_5753 = CONVERT token to IERC20
			TMP_5754 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_5753', 'msg.sender', 'TMP_5754', 'amount'] 
	Function UseTokenActions.pullTokenFrom(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_5756 = CONVERT token to address
			TMP_5757 = CONVERT 0 to address
			TMP_5758(bool) = TMP_5756 == TMP_5757
			CONDITION TMP_5758
		Expression: revert InvalidToken()()
		IRs:
			TMP_5759(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_5760 = CONVERT this to address
			TMP_5761(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_5760']  
			TMP_5762(bool) = TMP_5761 < amount
			CONDITION TMP_5762
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_5763(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,address(this),amount)
		IRs:
			TMP_5764 = CONVERT token to IERC20
			TMP_5765 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_5764', 'from', 'TMP_5765', 'amount'] 
	Function UseTokenActions.pushToken(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_5767 = CONVERT token to address
			TMP_5768 = CONVERT 0 to address
			TMP_5769(bool) = TMP_5767 == TMP_5768
			CONDITION TMP_5769
		Expression: revert InvalidToken()()
		IRs:
			TMP_5770(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_5771 = CONVERT to to address
			TMP_5772 = CONVERT 0 to address
			TMP_5773(bool) = TMP_5771 == TMP_5772
			CONDITION TMP_5773
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_5774(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: IERC20(token).safeTransfer(to,amount)
		IRs:
			TMP_5775 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_5775', 'to', 'amount'] 
	Function UseTokenActions.pushTokenFrom(IERC20,address,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_5777 = CONVERT token to address
			TMP_5778 = CONVERT 0 to address
			TMP_5779(bool) = TMP_5777 == TMP_5778
			CONDITION TMP_5779
		Expression: revert InvalidToken()()
		IRs:
			TMP_5780(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_5781 = CONVERT to to address
			TMP_5782 = CONVERT 0 to address
			TMP_5783(bool) = TMP_5781 == TMP_5782
			CONDITION TMP_5783
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_5784(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_5785 = CONVERT this to address
			TMP_5786(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_5785']  
			TMP_5787(bool) = TMP_5786 < amount
			CONDITION TMP_5787
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_5788(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,to,amount)
		IRs:
			TMP_5789 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_5789', 'from', 'to', 'amount'] 
	Function UseTokenActions.sweepTokens(IERC20,address) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_5791 = CONVERT token to address
			TMP_5792 = CONVERT 0 to address
			TMP_5793(bool) = TMP_5791 == TMP_5792
			CONDITION TMP_5793
		Expression: revert InvalidToken()()
		IRs:
			TMP_5794(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_5795 = CONVERT to to address
			TMP_5796 = CONVERT 0 to address
			TMP_5797(bool) = TMP_5795 == TMP_5796
			CONDITION TMP_5797
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_5798(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: sweptAmount = IERC20(token).balanceOf(address(this))
		IRs:
			TMP_5799 = CONVERT token to IERC20
			TMP_5800 = CONVERT this to address
			TMP_5801(uint256) = HIGH_LEVEL_CALL, dest:TMP_5799(IERC20), function:balanceOf, arguments:['TMP_5800']  
			sweptAmount(uint256) := TMP_5801(uint256)
		Expression: IERC20(token).safeTransfer(to,sweptAmount)
		IRs:
			TMP_5802 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_5802', 'to', 'sweptAmount'] 
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_5804(bool) = tokenA < tokenB
			CONDITION TMP_5804
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_5805(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339da287b50>, <slither.core.variables.local_variable.LocalVariable object at 0x7339da287690>])
			TMP_5806(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5805)
			RETURN TMP_5806
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_5807(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339da287690>, <slither.core.variables.local_variable.LocalVariable object at 0x7339da287b50>])
			TMP_5808(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_5807)
			RETURN TMP_5808
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_5809(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_5809(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_1769(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1770(UseUnifiedSwapper.SwapProvider) -> REF_1769.provider
			REF_1771(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_5810(bool) = REF_1770 != REF_1771
			CONDITION TMP_5810
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_5811(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_5812 = CONVERT tokenIn to IERC20
			REF_1773(address) -> routeInfo.router
			TMP_5814(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_5815(uint256) = TMP_5814 (c)- 1
			TMP_5816(bool) = HIGH_LEVEL_CALL, dest:TMP_5812(IERC20), function:approve, arguments:['REF_1773', 'TMP_5815']  
			TMP_5817 = UnaryType.BANG TMP_5816 
			CONDITION TMP_5817
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_5818(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_5819 = CONVERT tokenOut to IERC20
			REF_1775(address) -> routeInfo.router
			TMP_5821(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_5822(uint256) = TMP_5821 (c)- 1
			TMP_5823(bool) = HIGH_LEVEL_CALL, dest:TMP_5819(IERC20), function:approve, arguments:['REF_1775', 'TMP_5822']  
			TMP_5824 = UnaryType.BANG TMP_5823 
			CONDITION TMP_5824
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_5825(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_1776(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1776(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_5827(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_5827(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_1777(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1778(UseUnifiedSwapper.SwapProvider) -> REF_1777.provider
			REF_1779(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_5828(bool) = REF_1778 == REF_1779
			CONDITION TMP_5828
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_5829(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_5830 = CONVERT tokenIn to IERC20
			REF_1781(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1782(address) -> REF_1781.router
			TMP_5831(bool) = HIGH_LEVEL_CALL, dest:TMP_5830(IERC20), function:approve, arguments:['REF_1782', '0']  
			TMP_5832 = UnaryType.BANG TMP_5831 
			CONDITION TMP_5832
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_5833(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_5834 = CONVERT tokenOut to IERC20
			REF_1784(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1785(address) -> REF_1784.router
			TMP_5835(bool) = HIGH_LEVEL_CALL, dest:TMP_5834(IERC20), function:approve, arguments:['REF_1785', '0']  
			TMP_5836 = UnaryType.BANG TMP_5835 
			CONDITION TMP_5836
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_5837(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_1786(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1787(UseUnifiedSwapper.SwapProvider) -> REF_1786.provider
			REF_1788(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_1787(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_1788(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_5839(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_5839(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_1789(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_1790(UseUnifiedSwapper.SwapProvider) -> REF_1789.provider
			REF_1791(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_5840(bool) = REF_1790 != REF_1791
			RETURN TMP_5840
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_1792(address) -> params.underlyingIn
			REF_1793(address) -> params.underlyingOut
			TMP_5841(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_1792,REF_1793)
			key(bytes32) := TMP_5841(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_1794(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_1794(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_1795(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_1796(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_5842(bool) = REF_1795 == REF_1796
			CONDITION TMP_5842
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_5843(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_1797(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_1798(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_5844(bool) = REF_1797 == REF_1798
			CONDITION TMP_5844
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_1799(bytes) -> params.payload
			REF_1801(uint24) -> routeInfo.uniV3Tier
			TMP_5845(bytes) = SOLIDITY_CALL abi.encode()(REF_1801)
			REF_1799(bytes) (->params) := TMP_5845(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_1803(address) -> routeInfo.router
			TMP_5846 = CONVERT REF_1803 to IV3SwapRouter
			TUPLE_58(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_5846', 'params'] 
			RETURN TUPLE_58
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_1804(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_1805(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_5847(bool) = REF_1804 == REF_1805
			CONDITION TMP_5847
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_1807(address) -> routeInfo.router
			TMP_5848 = CONVERT REF_1807 to IUniswapV2Router02
			TUPLE_59(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_5848', 'params'] 
			RETURN TUPLE_59
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_1808(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_1809(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_5849(bool) = REF_1808 == REF_1809
			CONDITION TMP_5849
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_1810(bytes) -> params.payload
			REF_1812(uint24) -> routeInfo.tickSpacing
			TMP_5850(bytes) = SOLIDITY_CALL abi.encode()(REF_1812)
			REF_1810(bytes) (->params) := TMP_5850(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_1814(address) -> routeInfo.router
			TMP_5851 = CONVERT REF_1814 to ISwapRouter
			TUPLE_60(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_5851', 'params'] 
			RETURN TUPLE_60
		Expression: revert InvalidProvider()()
		IRs:
			TMP_5852(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function VaultRouter.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function VaultRouter.initialize(address,IWETH) (*)
		Expression: initializeUseIERC4626(initialOwner)
		IRs:
			INTERNAL_CALL, UseIERC4626.initializeUseIERC4626(address)(initialOwner)
		Expression: _initUseWETH(address(weth))
		IRs:
			TMP_5855 = CONVERT weth to address
			INTERNAL_CALL, UseWETH._initUseWETH(address)(TMP_5855)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function VaultRouter.dispatch(uint256,bytes,uint256[]) (*)
		Expression: success = true
		IRs:
			success(bool) := True(bool)
		Expression: actionToExecute = uint32(action & Commands.THIRTY_TWO_BITS_MASK)
		IRs:
			REF_1815(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_5858(uint256) = action & REF_1815
			TMP_5859 = CONVERT TMP_5858 to uint32
			actionToExecute(uint32) := TMP_5859(uint32)
		Expression: inputMapping = uint16((action >> 32) & Commands.THIRTY_TWO_BITS_MASK)
		IRs:
			TMP_5860(uint256) = action >> 32
			REF_1816(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_5861(uint256) = TMP_5860 & REF_1816
			TMP_5862 = CONVERT TMP_5861 to uint16
			inputMapping(uint32) := TMP_5862(uint16)
		Expression: outputMapping = uint16(((action >> 64) & Commands.THIRTY_TWO_BITS_MASK))
		IRs:
			TMP_5863(uint256) = action >> 64
			REF_1817(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_5864(uint256) = TMP_5863 & REF_1817
			TMP_5865 = CONVERT TMP_5864 to uint16
			outputMapping(uint32) := TMP_5865(uint16)
		Expression: actionToExecute == Commands.V3_UNISWAP_SWAP || actionToExecute == Commands.AERODROME_SWAP || actionToExecute == Commands.V2_UNISWAP_SWAP
		IRs:
			REF_1818(uint8) -> Commands.V3_UNISWAP_SWAP
			TMP_5866(bool) = actionToExecute == REF_1818
			REF_1819(uint8) -> Commands.AERODROME_SWAP
			TMP_5867(bool) = actionToExecute == REF_1819
			TMP_5868(bool) = TMP_5866 || TMP_5867
			REF_1820(uint8) -> Commands.V2_UNISWAP_SWAP
			TMP_5869(bool) = actionToExecute == REF_1820
			TMP_5870(bool) = TMP_5868 || TMP_5869
			CONDITION TMP_5870
		Expression: output = _handleSwap(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5871(bytes) = INTERNAL_CALL, VaultRouter._handleSwap(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5871(bytes)
		Expression: action == Commands.PULL_TOKEN
		IRs:
			REF_1821(uint8) -> Commands.PULL_TOKEN
			TMP_5872(bool) = action == REF_1821
			CONDITION TMP_5872
		Expression: output = _handlePullToken(data,callStack,inputMapping)
		IRs:
			TMP_5873(bytes) = INTERNAL_CALL, VaultRouter._handlePullToken(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5873(bytes)
		Expression: actionToExecute == Commands.PULL_TOKEN_FROM
		IRs:
			REF_1822(uint8) -> Commands.PULL_TOKEN_FROM
			TMP_5874(bool) = actionToExecute == REF_1822
			CONDITION TMP_5874
		Expression: output = _handlePullTokenFrom(data,callStack,inputMapping)
		IRs:
			TMP_5875(bytes) = INTERNAL_CALL, VaultRouter._handlePullTokenFrom(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5875(bytes)
		Expression: actionToExecute == Commands.PUSH_TOKEN
		IRs:
			REF_1823(uint8) -> Commands.PUSH_TOKEN
			TMP_5876(bool) = actionToExecute == REF_1823
			CONDITION TMP_5876
		Expression: output = _handlePushToken(data,callStack,inputMapping)
		IRs:
			TMP_5877(bytes) = INTERNAL_CALL, VaultRouter._handlePushToken(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5877(bytes)
		Expression: actionToExecute == Commands.PUSH_TOKEN_FROM
		IRs:
			REF_1824(uint8) -> Commands.PUSH_TOKEN_FROM
			TMP_5878(bool) = actionToExecute == REF_1824
			CONDITION TMP_5878
		Expression: output = _handlePushTokenFrom(data,callStack,inputMapping)
		IRs:
			TMP_5879(bytes) = INTERNAL_CALL, VaultRouter._handlePushTokenFrom(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5879(bytes)
		Expression: actionToExecute == Commands.SWEEP_TOKENS
		IRs:
			REF_1825(uint8) -> Commands.SWEEP_TOKENS
			TMP_5880(bool) = actionToExecute == REF_1825
			CONDITION TMP_5880
		Expression: output = _handleSweepTokens(data,callStack,outputMapping)
		IRs:
			TMP_5881(bytes) = INTERNAL_CALL, VaultRouter._handleSweepTokens(bytes,uint256[],uint32)(data,callStack,outputMapping)
			output(bytes) := TMP_5881(bytes)
		Expression: actionToExecute == Commands.WRAP_ETH
		IRs:
			REF_1826(uint8) -> Commands.WRAP_ETH
			TMP_5882(bool) = actionToExecute == REF_1826
			CONDITION TMP_5882
		Expression: output = _handleWrapETH(data,callStack,inputMapping)
		IRs:
			TMP_5883(bytes) = INTERNAL_CALL, VaultRouter._handleWrapETH(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5883(bytes)
		Expression: actionToExecute == Commands.UNWRAP_ETH
		IRs:
			REF_1827(uint8) -> Commands.UNWRAP_ETH
			TMP_5884(bool) = actionToExecute == REF_1827
			CONDITION TMP_5884
		Expression: output = _handleUnwrapETH(data,callStack,inputMapping)
		IRs:
			TMP_5885(bytes) = INTERNAL_CALL, VaultRouter._handleUnwrapETH(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5885(bytes)
		Expression: actionToExecute == Commands.PULL_TOKEN_WITH_PERMIT
		IRs:
			REF_1828(uint8) -> Commands.PULL_TOKEN_WITH_PERMIT
			TMP_5886(bool) = actionToExecute == REF_1828
			CONDITION TMP_5886
		Expression: output = _handlePullTokenWithPermit(data,callStack,inputMapping)
		IRs:
			TMP_5887(bytes) = INTERNAL_CALL, VaultRouter._handlePullTokenWithPermit(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_5887(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_DEPOSIT
		IRs:
			REF_1829(uint8) -> Commands.ERC4626_VAULT_DEPOSIT
			TMP_5888(bool) = actionToExecute == REF_1829
			CONDITION TMP_5888
		Expression: output = _handleVaultDeposit(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5889(bytes) = INTERNAL_CALL, VaultRouter._handleVaultDeposit(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5889(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_MINT
		IRs:
			REF_1830(uint8) -> Commands.ERC4626_VAULT_MINT
			TMP_5890(bool) = actionToExecute == REF_1830
			CONDITION TMP_5890
		Expression: output = _handleVaultMint(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5891(bytes) = INTERNAL_CALL, VaultRouter._handleVaultMint(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5891(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_REDEEM
		IRs:
			REF_1831(uint8) -> Commands.ERC4626_VAULT_REDEEM
			TMP_5892(bool) = actionToExecute == REF_1831
			CONDITION TMP_5892
		Expression: output = _handleVaultRedeem(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5893(bytes) = INTERNAL_CALL, VaultRouter._handleVaultRedeem(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5893(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_WITHDRAW
		IRs:
			REF_1832(uint8) -> Commands.ERC4626_VAULT_WITHDRAW
			TMP_5894(bool) = actionToExecute == REF_1832
			CONDITION TMP_5894
		Expression: output = _handleVaultWithdraw(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5895(bytes) = INTERNAL_CALL, VaultRouter._handleVaultWithdraw(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5895(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_CONVERT_TO_SHARES
		IRs:
			REF_1833(uint8) -> Commands.ERC4626_VAULT_CONVERT_TO_SHARES
			TMP_5896(bool) = actionToExecute == REF_1833
			CONDITION TMP_5896
		Expression: output = _handleVaultConvertToShares(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5897(bytes) = INTERNAL_CALL, VaultRouter._handleVaultConvertToShares(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5897(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_CONVERT_TO_ASSETS
		IRs:
			REF_1834(uint8) -> Commands.ERC4626_VAULT_CONVERT_TO_ASSETS
			TMP_5898(bool) = actionToExecute == REF_1834
			CONDITION TMP_5898
		Expression: output = _handleVaultConvertToAssets(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_5899(bytes) = INTERNAL_CALL, VaultRouter._handleVaultConvertToAssets(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_5899(bytes)
		Expression: revert InvalidCommand(uint256)({action:action})
		IRs:
			TMP_5900(None) = SOLIDITY_CALL revert InvalidCommand(uint256)(action)
	Function VaultRouter._handleSwap(bytes,uint256[],uint32,uint32) (*)
		Expression: params = abi.decode(data,(ISwapHandler.SwapParams))
		IRs:
			REF_1836(None) -> ISwapHandler.SwapParams
			TMP_5901(None) = SOLIDITY_CALL abi.decode()(data,REF_1836)
			params(ISwapHandler.SwapParams) := TMP_5901(None)
		Expression: params.amountIn = Commands.pullInputParam(callStack,params.amountIn,inputMapping,1)
		IRs:
			REF_1837(uint256) -> params.amountIn
			REF_1839(uint256) -> params.amountIn
			TMP_5902(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'REF_1839', 'inputMapping', '1'] 
			REF_1837(uint256) (->params) := TMP_5902(uint256)
		Expression: params.amountOut = Commands.pullInputParam(callStack,params.amountOut,inputMapping,2)
		IRs:
			REF_1840(uint256) -> params.amountOut
			REF_1842(uint256) -> params.amountOut
			TMP_5903(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'REF_1842', 'inputMapping', '2'] 
			REF_1840(uint256) (->params) := TMP_5903(uint256)
		Expression: (amountIn,amountOut) = swap(params)
		IRs:
			TUPLE_61(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(params)
			amountIn(uint256)= UNPACK TUPLE_61 index: 0 
			amountOut(uint256)= UNPACK TUPLE_61 index: 1 
		Expression: Commands.pushOutputParam(callStack,amountIn,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amountIn', 'outputMapping', '1'] 
		Expression: Commands.pushOutputParam(callStack,amountOut,outputMapping,2)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amountOut', 'outputMapping', '2'] 
		Expression: abi.encodePacked(amountIn,amountOut)
		IRs:
			TMP_5906(bytes) = SOLIDITY_CALL abi.encodePacked()(amountIn,amountOut)
			RETURN TMP_5906
	Function VaultRouter._handlePullToken(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5907(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_5907(uint256)
		Expression: amount = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5908(bytes) = data + 32
			TMP_5909(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5908)
			amount(uint256) := TMP_5909(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5910(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5910(uint256)
		Expression: pullToken(token,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pullToken(IERC20,uint256)(token,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePullTokenFrom(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5912(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_5912(uint256)
		Expression: from = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5913(bytes) = data + 32
			TMP_5914(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5913)
			from(address) := TMP_5914(uint256)
		Expression: amount = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5915(bytes) = data + 64
			TMP_5916(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5915)
			amount(uint256) := TMP_5916(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5917(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5917(uint256)
		Expression: pullTokenFrom(token,from,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pullTokenFrom(IERC20,address,uint256)(token,from,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePushToken(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5919(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_5919(uint256)
		Expression: to = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5920(bytes) = data + 32
			TMP_5921(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5920)
			to(address) := TMP_5921(uint256)
		Expression: amount = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5922(bytes) = data + 64
			TMP_5923(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5922)
			amount(uint256) := TMP_5923(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5924(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5924(uint256)
		Expression: pushToken(token,to,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pushToken(IERC20,address,uint256)(token,to,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePushTokenFrom(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5926(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_5926(uint256)
		Expression: from = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5927(bytes) = data + 32
			TMP_5928(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5927)
			from(address) := TMP_5928(uint256)
		Expression: to = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5929(bytes) = data + 64
			TMP_5930(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5929)
			to(address) := TMP_5930(uint256)
		Expression: amount = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_5931(bytes) = data + 96
			TMP_5932(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5931)
			amount(uint256) := TMP_5932(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5933(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5933(uint256)
		Expression: pushTokenFrom(token,from,to,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pushTokenFrom(IERC20,address,address,uint256)(token,from,to,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleSweepTokens(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5935(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_5935(uint256)
		Expression: to = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5936(bytes) = data + 32
			TMP_5937(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5936)
			to(address) := TMP_5937(uint256)
		Expression: sweptAmount = sweepTokens(token,to)
		IRs:
			TMP_5938(uint256) = INTERNAL_CALL, UseTokenActions.sweepTokens(IERC20,address)(token,to)
			sweptAmount(uint256) := TMP_5938(uint256)
		Expression: Commands.pushOutputParam(callStack,sweptAmount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'sweptAmount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(sweptAmount)
		IRs:
			TMP_5940(bytes) = SOLIDITY_CALL abi.encodePacked()(sweptAmount)
			RETURN TMP_5940
	Function VaultRouter._handleWrapETH(bytes,uint256[],uint32) (*)
		Expression: amount = calldataload(uint256)(data)
		IRs:
			TMP_5941(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			amount(uint256) := TMP_5941(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5942(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5942(uint256)
		Expression: wrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.wrapETH(uint256)(amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleUnwrapETH(bytes,uint256[],uint32) (*)
		Expression: amount = calldataload(uint256)(data)
		IRs:
			TMP_5944(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			amount(uint256) := TMP_5944(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5945(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5945(uint256)
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePullTokenWithPermit(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_5947(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20Permit) := TMP_5947(uint256)
		Expression: amount = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5948(bytes) = data + 32
			TMP_5949(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5948)
			amount(uint256) := TMP_5949(uint256)
		Expression: owner = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5950(bytes) = data + 64
			TMP_5951(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5950)
			owner(address) := TMP_5951(uint256)
		Expression: deadline = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_5952(bytes) = data + 96
			TMP_5953(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5952)
			deadline(uint256) := TMP_5953(uint256)
		Expression: v = calldataload(uint256)(data + 0x80)
		IRs:
			TMP_5954(bytes) = data + 128
			TMP_5955(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5954)
			v(uint8) := TMP_5955(uint256)
		Expression: r = calldataload(uint256)(data + 0xa0)
		IRs:
			TMP_5956(bytes) = data + 160
			TMP_5957(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5956)
			r(bytes32) := TMP_5957(uint256)
		Expression: s = calldataload(uint256)(data + 0xc0)
		IRs:
			TMP_5958(bytes) = data + 192
			TMP_5959(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5958)
			s(bytes32) := TMP_5959(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_5960(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_5960(uint256)
		Expression: pullTokensWithPermit(token,amount,owner,deadline,v,r,s)
		IRs:
			INTERNAL_CALL, UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32)(token,amount,owner,deadline,v,r,s)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleVaultDeposit(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_5962(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_5962(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5963(bytes) = data + 32
			TMP_5964(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5963)
			assets(uint256) := TMP_5964(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5965(bytes) = data + 64
			TMP_5966(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5965)
			receiver(address) := TMP_5966(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_5967(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_5967(uint256)
		Expression: shares = depositVault(vault,assets,receiver)
		IRs:
			TMP_5968(uint256) = INTERNAL_CALL, UseIERC4626.depositVault(IERC4626,uint256,address)(vault,assets,receiver)
			shares(uint256) := TMP_5968(uint256)
		Expression: Commands.pushOutputParam(callStack,shares,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'outputMapping', '1'] 
		Expression: abi.encodePacked(shares)
		IRs:
			TMP_5970(bytes) = SOLIDITY_CALL abi.encodePacked()(shares)
			RETURN TMP_5970
	Function VaultRouter._handleVaultMint(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_5971(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_5971(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5972(bytes) = data + 32
			TMP_5973(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5972)
			shares(uint256) := TMP_5973(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5974(bytes) = data + 64
			TMP_5975(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5974)
			receiver(address) := TMP_5975(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_5976(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_5976(uint256)
		Expression: assets = mintVault(vault,shares,receiver)
		IRs:
			TMP_5977(uint256) = INTERNAL_CALL, UseIERC4626.mintVault(IERC4626,uint256,address)(vault,shares,receiver)
			assets(uint256) := TMP_5977(uint256)
		Expression: Commands.pushOutputParam(callStack,assets,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'outputMapping', '1'] 
		Expression: abi.encodePacked(assets)
		IRs:
			TMP_5979(bytes) = SOLIDITY_CALL abi.encodePacked()(assets)
			RETURN TMP_5979
	Function VaultRouter._handleVaultRedeem(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_5980(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_5980(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5981(bytes) = data + 32
			TMP_5982(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5981)
			shares(uint256) := TMP_5982(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5983(bytes) = data + 64
			TMP_5984(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5983)
			receiver(address) := TMP_5984(uint256)
		Expression: owner = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_5985(bytes) = data + 96
			TMP_5986(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5985)
			owner(address) := TMP_5986(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_5987(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_5987(uint256)
		Expression: assets = redeemVault(vault,shares,receiver,owner)
		IRs:
			TMP_5988(uint256) = INTERNAL_CALL, UseIERC4626.redeemVault(IERC4626,uint256,address,address)(vault,shares,receiver,owner)
			assets(uint256) := TMP_5988(uint256)
		Expression: Commands.pushOutputParam(callStack,assets,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'outputMapping', '1'] 
		Expression: abi.encodePacked(assets)
		IRs:
			TMP_5990(bytes) = SOLIDITY_CALL abi.encodePacked()(assets)
			RETURN TMP_5990
	Function VaultRouter._handleVaultWithdraw(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_5991(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_5991(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_5992(bytes) = data + 32
			TMP_5993(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5992)
			assets(uint256) := TMP_5993(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_5994(bytes) = data + 64
			TMP_5995(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5994)
			receiver(address) := TMP_5995(uint256)
		Expression: owner = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_5996(bytes) = data + 96
			TMP_5997(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_5996)
			owner(address) := TMP_5997(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_5998(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_5998(uint256)
		Expression: shares = withdrawVault(vault,assets,receiver,owner)
		IRs:
			TMP_5999(uint256) = INTERNAL_CALL, UseIERC4626.withdrawVault(IERC4626,uint256,address,address)(vault,assets,receiver,owner)
			shares(uint256) := TMP_5999(uint256)
		Expression: Commands.pushOutputParam(callStack,shares,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'outputMapping', '1'] 
		Expression: abi.encodePacked(shares)
		IRs:
			TMP_6001(bytes) = SOLIDITY_CALL abi.encodePacked()(shares)
			RETURN TMP_6001
	Function VaultRouter._handleVaultConvertToShares(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_6002(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_6002(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_6003(bytes) = data + 32
			TMP_6004(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6003)
			assets(uint256) := TMP_6004(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_6005(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_6005(uint256)
		Expression: amount = convertToVaultShares(vault,assets)
		IRs:
			TMP_6006(uint256) = INTERNAL_CALL, UseIERC4626.convertToVaultShares(IERC4626,uint256)(vault,assets)
			amount(uint256) := TMP_6006(uint256)
		Expression: Commands.pushOutputParam(callStack,amount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(amount)
		IRs:
			TMP_6008(bytes) = SOLIDITY_CALL abi.encodePacked()(amount)
			RETURN TMP_6008
	Function VaultRouter._handleVaultConvertToAssets(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_6009(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_6009(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_6010(bytes) = data + 32
			TMP_6011(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_6010)
			shares(uint256) := TMP_6011(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_6012(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_6012(uint256)
		Expression: amount = convertToVaultAssets(vault,shares)
		IRs:
			TMP_6013(uint256) = INTERNAL_CALL, UseIERC4626.convertToVaultAssets(IERC4626,uint256)(vault,shares)
			amount(uint256) := TMP_6013(uint256)
		Expression: Commands.pushOutputParam(callStack,amount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(amount)
		IRs:
			TMP_6015(bytes) = SOLIDITY_CALL abi.encodePacked()(amount)
			RETURN TMP_6015
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_6016 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_6016(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_6017(bool) = _initialized < 1
			TMP_6018(bool) = isTopLevelCall && TMP_6017
			TMP_6019 = CONVERT this to address
			TMP_6020(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_6019'] 
			TMP_6021 = UnaryType.BANG TMP_6020 
			TMP_6022(bool) = _initialized == 1
			TMP_6023(bool) = TMP_6021 && TMP_6022
			TMP_6024(bool) = TMP_6018 || TMP_6023
			TMP_6025(None) = SOLIDITY_CALL require(bool,string)(TMP_6024,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_6027 = UnaryType.BANG _initializing 
			TMP_6028(bool) = _initialized < version
			TMP_6029(bool) = TMP_6027 && TMP_6028
			TMP_6030(None) = SOLIDITY_CALL require(bool,string)(TMP_6029,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_6032(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_6033(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_6034(bool) = msg.sender != TMP_6033
			CONDITION TMP_6034
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_6035(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
Contract VaultSettings
	Function IVaultSettings.setWithdrawalFee(uint256) 
	Function IVaultSettings.getWithdrawalFee() 
	Function IVaultSettings.setPerformanceFee(uint256) 
	Function IVaultSettings.getPerformanceFee() 
	Function IVaultSettings.setFeeReceiver(address) 
	Function IVaultSettings.getFeeReceiver() 
	Function IVaultSettings.enableAccount(address,bool) 
	Function IVaultSettings.isAccountEnabled(address) 
	Function IVaultSettings.getMaxDeposit() 
	Function IVaultSettings.setMaxDeposit(uint256) 
	Function Ownable2StepUpgradeable.__Ownable2Step_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.__Ownable2Step_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function Ownable2StepUpgradeable.pendingOwner() (*)
		Expression: _pendingOwner
		IRs:
			RETURN _pendingOwner
	Function Ownable2StepUpgradeable.transferOwnership(address) (*)
		Expression: _pendingOwner = newOwner
		IRs:
			_pendingOwner(address) := newOwner(address)
		Expression: OwnershipTransferStarted(owner(),newOwner)
		IRs:
			TMP_6040(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			Emit OwnershipTransferStarted(TMP_6040,newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function Ownable2StepUpgradeable._transferOwnership(address) (*)
		Expression: delete _pendingOwner
		IRs:
			_pendingOwner = delete _pendingOwner 
		Expression: super._transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
	Function Ownable2StepUpgradeable.acceptOwnership() (*)
		Expression: sender = _msgSender()
		IRs:
			TMP_6044(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			sender(address) := TMP_6044(address)
		Expression: require(bool,string)(pendingOwner() == sender,Ownable2Step: caller is not the new owner)
		IRs:
			TMP_6045(address) = INTERNAL_CALL, Ownable2StepUpgradeable.pendingOwner()()
			TMP_6046(bool) = TMP_6045 == sender
			TMP_6047(None) = SOLIDITY_CALL require(bool,string)(TMP_6046,Ownable2Step: caller is not the new owner)
		Expression: _transferOwnership(sender)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(sender)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_6051(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_6051)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_6054(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_6055(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_6056(bool) = TMP_6054 == TMP_6055
			TMP_6057(None) = SOLIDITY_CALL require(bool,string)(TMP_6056,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_6058 = CONVERT 0 to address
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(TMP_6058)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) 
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_6061 = CONVERT 0 to address
			TMP_6062(bool) = newOwner != TMP_6061
			TMP_6063(None) = SOLIDITY_CALL require(bool,string)(TMP_6062,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable2StepUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) 
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_6069 = UnaryType.BANG _initializing 
			TMP_6070(None) = SOLIDITY_CALL require(bool,string)(TMP_6069,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_6072(uint8) := 255(uint8)
			TMP_6073(bool) = _initialized != TMP_6072
			CONDITION TMP_6073
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_6075(uint8) := 255(uint8)
			_initialized(uint8) := TMP_6075(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_6077(uint8) := 255(uint8)
			Emit Initialized(TMP_6077)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function VaultSettings.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function VaultSettings._initializeVaultSettings() (*)
		Expression: _withdrawalFee = 10 * 1e6
		IRs:
			TMP_6080(uint256) = 10 (c)* 1000000
			_withdrawalFee(uint256) := TMP_6080(uint256)
		Expression: _performanceFee = 10 * 1e6
		IRs:
			TMP_6081(uint256) = 10 (c)* 1000000
			_performanceFee(uint256) := TMP_6081(uint256)
		Expression: _feeReceiver = address(0)
		IRs:
			TMP_6082 = CONVERT 0 to address
			_feeReceiver(address) := TMP_6082(address)
		Expression: _maxDeposit = 0
		IRs:
			_maxDeposit(uint256) := 0(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function VaultSettings.enableAccount(address,bool) (*)
		Expression: enabled
		IRs:
			CONDITION enabled
		Expression: _enabledAccounts.contains(account)
		IRs:
			TMP_6084(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			CONDITION TMP_6084
		Expression: revert WhiteListAlreadyEnabled()()
		IRs:
			TMP_6085(None) = SOLIDITY_CALL revert WhiteListAlreadyEnabled()()
		Expression: ! _enabledAccounts.add(account)
		IRs:
			TMP_6086(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.add(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_6087 = UnaryType.BANG TMP_6086 
			CONDITION TMP_6087
		Expression: revert WhiteListFailedToAdd()()
		IRs:
			TMP_6088(None) = SOLIDITY_CALL revert WhiteListFailedToAdd()()
		Expression: ! _enabledAccounts.contains(account)
		IRs:
			TMP_6089(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_6090 = UnaryType.BANG TMP_6089 
			CONDITION TMP_6090
		Expression: revert WhiteListNotEnabled()()
		IRs:
			TMP_6091(None) = SOLIDITY_CALL revert WhiteListNotEnabled()()
		Expression: ! _enabledAccounts.remove(account)
		IRs:
			TMP_6092(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.remove(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_6093 = UnaryType.BANG TMP_6092 
			CONDITION TMP_6093
		Expression: revert WhiteListFailedToRemove()()
		IRs:
			TMP_6094(None) = SOLIDITY_CALL revert WhiteListFailedToRemove()()
		Expression: AccountWhiteList(account,enabled)
		IRs:
			Emit AccountWhiteList(account,enabled)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.isAccountEnabled(address) (*)
		Expression: _enabledAccounts.length() == 0 || _enabledAccounts.contains(account)
		IRs:
			TMP_6097(uint256) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.length(EnumerableSet.AddressSet), arguments:['_enabledAccounts'] 
			TMP_6098(bool) = TMP_6097 == 0
			TMP_6099(bool) = LIBRARY_CALL, dest:EnumerableSet, function:EnumerableSet.contains(EnumerableSet.AddressSet,address), arguments:['_enabledAccounts', 'account'] 
			TMP_6100(bool) = TMP_6098 || TMP_6099
			RETURN TMP_6100
	Function VaultSettings.setWithdrawalFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_6101(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_6101
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_6102(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _withdrawalFee = fee
		IRs:
			_withdrawalFee(uint256) := fee(uint256)
		Expression: WithdrawalFeeChanged(_withdrawalFee)
		IRs:
			Emit WithdrawalFeeChanged(_withdrawalFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getWithdrawalFee() (*)
		Expression: _withdrawalFee
		IRs:
			RETURN _withdrawalFee
	Function VaultSettings.setPerformanceFee(uint256) (*)
		Expression: fee >= PERCENTAGE_PRECISION
		IRs:
			TMP_6105(bool) = fee >= PERCENTAGE_PRECISION
			CONDITION TMP_6105
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_6106(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _performanceFee = fee
		IRs:
			_performanceFee(uint256) := fee(uint256)
		Expression: PerformanceFeeChanged(_performanceFee)
		IRs:
			Emit PerformanceFeeChanged(_performanceFee)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getPerformanceFee() (*)
		Expression: _performanceFee
		IRs:
			RETURN _performanceFee
	Function VaultSettings.setFeeReceiver(address) (*)
		Expression: receiver == address(0)
		IRs:
			TMP_6109 = CONVERT 0 to address
			TMP_6110(bool) = receiver == TMP_6109
			CONDITION TMP_6110
		Expression: revert InvalidAddress()()
		IRs:
			TMP_6111(None) = SOLIDITY_CALL revert InvalidAddress()()
		Expression: _feeReceiver = receiver
		IRs:
			_feeReceiver(address) := receiver(address)
		Expression: FeeReceiverChanged(_feeReceiver)
		IRs:
			Emit FeeReceiverChanged(_feeReceiver)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function VaultSettings.getFeeReceiver() (*)
		Expression: _feeReceiver
		IRs:
			RETURN _feeReceiver
	Function VaultSettings.getMaxDeposit() (*)
		Expression: _maxDeposit
		IRs:
			RETURN _maxDeposit
	Function VaultSettings.setMaxDeposit(uint256) (*)
		Expression: _maxDeposit = value
		IRs:
			_maxDeposit(uint256) := value(uint256)
		Expression: MaxDepositChanged(value)
		IRs:
			Emit MaxDepositChanged(value)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_6117 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_6117(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_6118(bool) = _initialized < 1
			TMP_6119(bool) = isTopLevelCall && TMP_6118
			TMP_6120 = CONVERT this to address
			TMP_6121(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_6120'] 
			TMP_6122 = UnaryType.BANG TMP_6121 
			TMP_6123(bool) = _initialized == 1
			TMP_6124(bool) = TMP_6122 && TMP_6123
			TMP_6125(bool) = TMP_6119 || TMP_6124
			TMP_6126(None) = SOLIDITY_CALL require(bool,string)(TMP_6125,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_6128 = UnaryType.BANG _initializing 
			TMP_6129(bool) = _initialized < version
			TMP_6130(bool) = TMP_6128 && TMP_6129
			TMP_6131(None) = SOLIDITY_CALL require(bool,string)(TMP_6130,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_6133(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract BalancerFlashLender
	Function IFlashLoanRecipient.receiveFlashLoan(address[],uint256[],uint256[],bytes) 
	Function IERC3156FlashLenderUpgradeable.maxFlashLoan(address) 
	Function IERC3156FlashLenderUpgradeable.flashFee(address,uint256) 
	Function IERC3156FlashLenderUpgradeable.flashLoan(IERC3156FlashBorrowerUpgradeable,address,uint256,bytes) 
	Function BalancerFlashLender.constructor(address) (*)
		Expression: _balancerVault = IVault(balancerVault)
		IRs:
			TMP_6134 = CONVERT balancerVault to IVault
			_balancerVault(IVault) := TMP_6134(IVault)
		Expression: address(_balancerVault) == address(0)
		IRs:
			TMP_6135 = CONVERT _balancerVault to address
			TMP_6136 = CONVERT 0 to address
			TMP_6137(bool) = TMP_6135 == TMP_6136
			CONDITION TMP_6137
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_6138(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
	Function BalancerFlashLender.maxFlashLoan(address) (*)
		Expression: IERC20(token).balanceOf(address(_balancerVault))
		IRs:
			TMP_6139 = CONVERT token to IERC20
			TMP_6140 = CONVERT _balancerVault to address
			TMP_6141(uint256) = HIGH_LEVEL_CALL, dest:TMP_6139(IERC20), function:balanceOf, arguments:['TMP_6140']  
			RETURN TMP_6141
	Function BalancerFlashLender.flashFee(address,uint256) (*)
		Expression: perc = _balancerVault.getProtocolFeesCollector().getFlashLoanFeePercentage()
		IRs:
			TMP_6142(IProtocolFeesCollector) = HIGH_LEVEL_CALL, dest:_balancerVault(IVault), function:getProtocolFeesCollector, arguments:[]  
			TMP_6143(uint256) = HIGH_LEVEL_CALL, dest:TMP_6142(IProtocolFeesCollector), function:getFlashLoanFeePercentage, arguments:[]  
			perc(uint256) := TMP_6143(uint256)
		Expression: perc == 0 || amount == 0
		IRs:
			TMP_6144(bool) = perc == 0
			TMP_6145(bool) = amount == 0
			TMP_6146(bool) = TMP_6144 || TMP_6145
			CONDITION TMP_6146
		Expression: 0
		IRs:
			RETURN 0
		Expression: amount.mulDivUp(perc,_BALANCER_MAX_FEE_PERCENTAGE)
		IRs:
			TMP_6147(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['amount', 'perc', '_BALANCER_MAX_FEE_PERCENTAGE'] 
			RETURN TMP_6147
	Function BalancerFlashLender.flashLoan(IERC3156FlashBorrowerUpgradeable,address,uint256,bytes) (*)
		Expression: msg.sender != address(borrower)
		IRs:
			TMP_6148 = CONVERT borrower to address
			TMP_6149(bool) = msg.sender != TMP_6148
			CONDITION TMP_6149
		Expression: revert InvalidBorrower()()
		IRs:
			TMP_6150(None) = SOLIDITY_CALL revert InvalidBorrower()()
		Expression: tokens = new address[](1)
		IRs:
			TMP_6152(address[])  = new address[](1)
			tokens(address[]) = ['TMP_6152(address[])']
		Expression: tokens[0] = token
		IRs:
			REF_1885(address) -> tokens[0]
			REF_1885(address) (->tokens) := token(address)
		Expression: amounts = new uint256[](1)
		IRs:
			TMP_6154(uint256[])  = new uint256[](1)
			amounts(uint256[]) = ['TMP_6154(uint256[])']
		Expression: amounts[0] = amount
		IRs:
			REF_1886(uint256) -> amounts[0]
			REF_1886(uint256) (->amounts) := amount(uint256)
		Expression: _balancerVault.flashLoan(address(this),tokens,amounts,abi.encode(borrower,data))
		IRs:
			TMP_6155 = CONVERT this to address
			TMP_6156(bytes) = SOLIDITY_CALL abi.encode()(borrower,data)
			HIGH_LEVEL_CALL, dest:_balancerVault(IVault), function:flashLoan, arguments:['TMP_6155', 'tokens', 'amounts', 'TMP_6156']  
		Expression: true
		IRs:
			RETURN True
	Function BalancerFlashLender.receiveFlashLoan(address[],uint256[],uint256[],bytes) (*)
		Expression: msg.sender != address(_balancerVault)
		IRs:
			TMP_6158 = CONVERT _balancerVault to address
			TMP_6159(bool) = msg.sender != TMP_6158
			CONDITION TMP_6159
		Expression: revert InvalidFlashLoadLender()()
		IRs:
			TMP_6160(None) = SOLIDITY_CALL revert InvalidFlashLoadLender()()
		Expression: tokens.length != 1
		IRs:
			REF_1889 -> LENGTH tokens
			TMP_6161(bool) = REF_1889 != 1
			CONDITION TMP_6161
		Expression: revert InvalidTokenList()()
		IRs:
			TMP_6162(None) = SOLIDITY_CALL revert InvalidTokenList()()
		Expression: amounts.length != 1
		IRs:
			REF_1890 -> LENGTH amounts
			TMP_6163(bool) = REF_1890 != 1
			CONDITION TMP_6163
		Expression: revert InvalidAmountList()()
		IRs:
			TMP_6164(None) = SOLIDITY_CALL revert InvalidAmountList()()
		Expression: feeAmounts.length != 1
		IRs:
			REF_1891 -> LENGTH feeAmounts
			TMP_6165(bool) = REF_1891 != 1
			CONDITION TMP_6165
		Expression: revert InvalidFeesAmount()()
		IRs:
			TMP_6166(None) = SOLIDITY_CALL revert InvalidFeesAmount()()
		Expression: (borrower,originalCallData) = abi.decode(userData,(address,bytes))
		IRs:
			TUPLE_62(address,bytes) = SOLIDITY_CALL abi.decode()(userData(address,bytes))
			borrower(address)= UNPACK TUPLE_62 index: 0 
			originalCallData(bytes)= UNPACK TUPLE_62 index: 1 
		Expression: asset = tokens[0]
		IRs:
			REF_1893(address) -> tokens[0]
			asset(address) := REF_1893(address)
		Expression: amount = amounts[0]
		IRs:
			REF_1894(uint256) -> amounts[0]
			amount(uint256) := REF_1894(uint256)
		Expression: fee = feeAmounts[0]
		IRs:
			REF_1895(uint256) -> feeAmounts[0]
			fee(uint256) := REF_1895(uint256)
		Expression: IERC20(asset).safeTransfer(borrower,amount)
		IRs:
			TMP_6167 = CONVERT asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_6167', 'borrower', 'amount'] 
		Expression: IERC3156FlashBorrowerUpgradeable(borrower).onFlashLoan(borrower,tokens[0],amounts[0],feeAmounts[0],originalCallData) != CALLBACK_SUCCESS
		IRs:
			TMP_6169 = CONVERT borrower to IERC3156FlashBorrowerUpgradeable
			REF_1898(address) -> tokens[0]
			REF_1899(uint256) -> amounts[0]
			REF_1900(uint256) -> feeAmounts[0]
			TMP_6170(bytes32) = HIGH_LEVEL_CALL, dest:TMP_6169(IERC3156FlashBorrowerUpgradeable), function:onFlashLoan, arguments:['borrower', 'REF_1898', 'REF_1899', 'REF_1900', 'originalCallData']  
			TMP_6171(bool) = TMP_6170 != CALLBACK_SUCCESS
			CONDITION TMP_6171
		Expression: revert BorrowerCallbackFailed()()
		IRs:
			TMP_6172(None) = SOLIDITY_CALL revert BorrowerCallbackFailed()()
		Expression: IERC20(asset).allowance(address(borrower),address(this)) < fee + amount
		IRs:
			TMP_6173 = CONVERT asset to IERC20
			TMP_6174 = CONVERT borrower to address
			TMP_6175 = CONVERT this to address
			TMP_6176(uint256) = HIGH_LEVEL_CALL, dest:TMP_6173(IERC20), function:allowance, arguments:['TMP_6174', 'TMP_6175']  
			TMP_6177(uint256) = fee (c)+ amount
			TMP_6178(bool) = TMP_6176 < TMP_6177
			CONDITION TMP_6178
		Expression: revert NoAllowanceToPayDebt()()
		IRs:
			TMP_6179(None) = SOLIDITY_CALL revert NoAllowanceToPayDebt()()
		Expression: IERC20(asset).safeTransferFrom(address(borrower),address(_balancerVault),amount + fee)
		IRs:
			TMP_6180 = CONVERT asset to IERC20
			TMP_6181 = CONVERT borrower to address
			TMP_6182 = CONVERT _balancerVault to address
			TMP_6183(uint256) = amount (c)+ fee
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_6180', 'TMP_6181', 'TMP_6182', 'TMP_6183'] 
	Function BalancerFlashLender.slitherConstructorConstantVariables() (*)
		Expression: CALLBACK_SUCCESS = keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
		IRs:
			TMP_6185(bytes32) = SOLIDITY_CALL keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
			CALLBACK_SUCCESS(bytes32) := TMP_6185(bytes32)
		Expression: _BALANCER_MAX_FEE_PERCENTAGE = 1e18
		IRs:
			_BALANCER_MAX_FEE_PERCENTAGE(uint256) := 1000000000000000000(uint256)
Contract BKR
	Function ERC20Votes.clock() (*)
		Expression: SafeCast.toUint48(block.number)
		IRs:
			TMP_6186(uint48) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint48(uint256), arguments:['block.number'] 
			RETURN TMP_6186
	Function ERC20Votes.CLOCK_MODE() (*)
		Expression: require(bool,string)(clock() == block.number,ERC20Votes: broken clock mode)
		IRs:
			TMP_6187(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_6188(bool) = TMP_6187 == block.number
			TMP_6189(None) = SOLIDITY_CALL require(bool,string)(TMP_6188,ERC20Votes: broken clock mode)
		Expression: mode=blocknumber&from=default
		IRs:
			RETURN mode=blocknumber&from=default
	Function ERC20Votes.checkpoints(address,uint32) (*)
		Expression: _checkpoints[account][pos]
		IRs:
			REF_1904(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1905(ERC20Votes.Checkpoint) -> REF_1904[pos]
			RETURN REF_1905
	Function ERC20Votes.numCheckpoints(address) (*)
		Expression: SafeCast.toUint32(_checkpoints[account].length)
		IRs:
			REF_1907(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1908 -> LENGTH REF_1907
			TMP_6190(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['REF_1908'] 
			RETURN TMP_6190
	Function ERC20Votes.delegates(address) (*)
		Expression: _delegates[account]
		IRs:
			REF_1909(address) -> _delegates[account]
			RETURN REF_1909
	Function ERC20Votes.getVotes(address) (*)
		Expression: pos = _checkpoints[account].length
		IRs:
			REF_1910(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			REF_1911 -> LENGTH REF_1910
			pos(uint256) := REF_1911(uint256)
		Expression: pos == 0
		IRs:
			TMP_6191(bool) = pos == 0
			CONDITION TMP_6191
		Expression: 0
		IRs:
			RETURN 0
		Expression: _checkpoints[account][pos - 1].votes
		IRs:
			REF_1912(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			TMP_6192(uint256) = pos - 1
			REF_1913(ERC20Votes.Checkpoint) -> REF_1912[TMP_6192]
			REF_1914(uint224) -> REF_1913.votes
			RETURN REF_1914
	Function ERC20Votes.getPastVotes(address,uint256) (*)
		Expression: require(bool,string)(timepoint < clock(),ERC20Votes: future lookup)
		IRs:
			TMP_6193(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_6194(bool) = timepoint < TMP_6193
			TMP_6195(None) = SOLIDITY_CALL require(bool,string)(TMP_6194,ERC20Votes: future lookup)
		Expression: _checkpointsLookup(_checkpoints[account],timepoint)
		IRs:
			REF_1915(ERC20Votes.Checkpoint[]) -> _checkpoints[account]
			TMP_6196(uint256) = INTERNAL_CALL, ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256)(REF_1915,timepoint)
			RETURN TMP_6196
	Function ERC20Votes.getPastTotalSupply(uint256) (*)
		Expression: require(bool,string)(timepoint < clock(),ERC20Votes: future lookup)
		IRs:
			TMP_6197(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_6198(bool) = timepoint < TMP_6197
			TMP_6199(None) = SOLIDITY_CALL require(bool,string)(TMP_6198,ERC20Votes: future lookup)
		Expression: _checkpointsLookup(_totalSupplyCheckpoints,timepoint)
		IRs:
			TMP_6200(uint256) = INTERNAL_CALL, ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256)(_totalSupplyCheckpoints,timepoint)
			RETURN TMP_6200
	Function ERC20Votes._checkpointsLookup(ERC20Votes.Checkpoint[],uint256) (*)
		Expression: length = ckpts.length
		IRs:
			REF_1916 -> LENGTH ckpts
			length(uint256) := REF_1916(uint256)
		Expression: low = 0
		IRs:
			low(uint256) := 0(uint256)
		Expression: high = length
		IRs:
			high(uint256) := length(uint256)
		Expression: length > 5
		IRs:
			TMP_6201(bool) = length > 5
			CONDITION TMP_6201
		Expression: mid = length - Math.sqrt(length)
		IRs:
			TMP_6202(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['length'] 
			TMP_6203(uint256) = length (c)- TMP_6202
			mid(uint256) := TMP_6203(uint256)
		Expression: _unsafeAccess(ckpts,mid).fromBlock > timepoint
		IRs:
			TMP_6204(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,mid)
			REF_1918(uint32) -> TMP_6204.fromBlock
			TMP_6205(bool) = REF_1918 > timepoint
			CONDITION TMP_6205
		Expression: high = mid
		IRs:
			high(uint256) := mid(uint256)
		Expression: low = mid + 1
		IRs:
			TMP_6206(uint256) = mid (c)+ 1
			low(uint256) := TMP_6206(uint256)
		Expression: low < high
		IRs:
			TMP_6207(bool) = low < high
			CONDITION TMP_6207
		Expression: mid_scope_0 = Math.average(low,high)
		IRs:
			TMP_6208(uint256) = LIBRARY_CALL, dest:Math, function:Math.average(uint256,uint256), arguments:['low', 'high'] 
			mid_scope_0(uint256) := TMP_6208(uint256)
		Expression: _unsafeAccess(ckpts,mid_scope_0).fromBlock > timepoint
		IRs:
			TMP_6209(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,mid_scope_0)
			REF_1920(uint32) -> TMP_6209.fromBlock
			TMP_6210(bool) = REF_1920 > timepoint
			CONDITION TMP_6210
		Expression: high = mid_scope_0
		IRs:
			high(uint256) := mid_scope_0(uint256)
		Expression: low = mid_scope_0 + 1
		IRs:
			TMP_6211(uint256) = mid_scope_0 (c)+ 1
			low(uint256) := TMP_6211(uint256)
		Expression: high == 0
		IRs:
			TMP_6212(bool) = high == 0
			CONDITION TMP_6212
		Expression: 0
		IRs:
			RETURN 0
		Expression: _unsafeAccess(ckpts,high - 1).votes
		IRs:
			TMP_6213(uint256) = high - 1
			TMP_6214(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_6213)
			REF_1921(uint224) -> TMP_6214.votes
			RETURN REF_1921
	Function ERC20Votes.delegate(address) (*)
		Expression: _delegate(_msgSender(),delegatee)
		IRs:
			TMP_6215(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20Votes._delegate(address,address)(TMP_6215,delegatee)
	Function ERC20Votes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= expiry,ERC20Votes: signature expired)
		IRs:
			TMP_6217(bool) = block.timestamp <= expiry
			TMP_6218(None) = SOLIDITY_CALL require(bool,string)(TMP_6217,ERC20Votes: signature expired)
		Expression: signer = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(_DELEGATION_TYPEHASH,delegatee,nonce,expiry))),v,r,s)
		IRs:
			TMP_6219(bytes) = SOLIDITY_CALL abi.encode()(_DELEGATION_TYPEHASH,delegatee,nonce,expiry)
			TMP_6220(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6219)
			TMP_6221(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_6220)
			TMP_6222(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_6221', 'v', 'r', 's'] 
			signer(address) := TMP_6222(address)
		Expression: require(bool,string)(nonce == _useNonce(signer),ERC20Votes: invalid nonce)
		IRs:
			TMP_6223(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(signer)
			TMP_6224(bool) = nonce == TMP_6223
			TMP_6225(None) = SOLIDITY_CALL require(bool,string)(TMP_6224,ERC20Votes: invalid nonce)
		Expression: _delegate(signer,delegatee)
		IRs:
			INTERNAL_CALL, ERC20Votes._delegate(address,address)(signer,delegatee)
	Function ERC20Votes._maxSupply() (*)
		Expression: type()(uint224).max
		IRs:
			TMP_6228(uint224) := 26959946667150639794667015087019630673637144422540572481103610249215(uint224)
			RETURN TMP_6228
	Function ERC20Votes._mint(address,uint256) 
		Expression: super._mint(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(account,amount)
		Expression: require(bool,string)(totalSupply() <= _maxSupply(),ERC20Votes: total supply risks overflowing votes)
		IRs:
			TMP_6230(uint256) = INTERNAL_CALL, ERC20.totalSupply()()
			TMP_6231(uint224) = INTERNAL_CALL, ERC20Votes._maxSupply()()
			TMP_6232(bool) = TMP_6230 <= TMP_6231
			TMP_6233(None) = SOLIDITY_CALL require(bool,string)(TMP_6232,ERC20Votes: total supply risks overflowing votes)
		Expression: _writeCheckpoint(_totalSupplyCheckpoints,_add,amount)
		IRs:
			TUPLE_63(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(_totalSupplyCheckpoints,_add,amount)
	Function ERC20Votes._burn(address,uint256) 
		Expression: super._burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account,amount)
		Expression: _writeCheckpoint(_totalSupplyCheckpoints,_subtract,amount)
		IRs:
			TUPLE_64(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(_totalSupplyCheckpoints,_subtract,amount)
	Function ERC20Votes._afterTokenTransfer(address,address,uint256) 
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: _moveVotingPower(delegates(from),delegates(to),amount)
		IRs:
			TMP_6236(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(from)
			TMP_6237(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(to)
			INTERNAL_CALL, ERC20Votes._moveVotingPower(address,address,uint256)(TMP_6236,TMP_6237,amount)
	Function ERC20Votes._delegate(address,address) (*)
		Expression: currentDelegate = delegates(delegator)
		IRs:
			TMP_6239(address) = INTERNAL_CALL, ERC20Votes.delegates(address)(delegator)
			currentDelegate(address) := TMP_6239(address)
		Expression: delegatorBalance = balanceOf(delegator)
		IRs:
			TMP_6240(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(delegator)
			delegatorBalance(uint256) := TMP_6240(uint256)
		Expression: _delegates[delegator] = delegatee
		IRs:
			REF_1924(address) -> _delegates[delegator]
			REF_1924(address) (->_delegates) := delegatee(address)
		Expression: DelegateChanged(delegator,currentDelegate,delegatee)
		IRs:
			Emit DelegateChanged(delegator,currentDelegate,delegatee)
		Expression: _moveVotingPower(currentDelegate,delegatee,delegatorBalance)
		IRs:
			INTERNAL_CALL, ERC20Votes._moveVotingPower(address,address,uint256)(currentDelegate,delegatee,delegatorBalance)
	Function ERC20Votes._moveVotingPower(address,address,uint256) (*)
		Expression: src != dst && amount > 0
		IRs:
			TMP_6243(bool) = src != dst
			TMP_6244(bool) = amount > 0
			TMP_6245(bool) = TMP_6243 && TMP_6244
			CONDITION TMP_6245
		Expression: src != address(0)
		IRs:
			TMP_6246 = CONVERT 0 to address
			TMP_6247(bool) = src != TMP_6246
			CONDITION TMP_6247
		Expression: (oldWeight,newWeight) = _writeCheckpoint(_checkpoints[src],_subtract,amount)
		IRs:
			REF_1925(ERC20Votes.Checkpoint[]) -> _checkpoints[src]
			TUPLE_65(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(REF_1925,_subtract,amount)
			oldWeight(uint256)= UNPACK TUPLE_65 index: 0 
			newWeight(uint256)= UNPACK TUPLE_65 index: 1 
		Expression: DelegateVotesChanged(src,oldWeight,newWeight)
		IRs:
			Emit DelegateVotesChanged(src,oldWeight,newWeight)
		Expression: dst != address(0)
		IRs:
			TMP_6249 = CONVERT 0 to address
			TMP_6250(bool) = dst != TMP_6249
			CONDITION TMP_6250
		Expression: (oldWeight_scope_0,newWeight_scope_1) = _writeCheckpoint(_checkpoints[dst],_add,amount)
		IRs:
			REF_1926(ERC20Votes.Checkpoint[]) -> _checkpoints[dst]
			TUPLE_66(uint256,uint256) = INTERNAL_CALL, ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)(REF_1926,_add,amount)
			oldWeight_scope_0(uint256)= UNPACK TUPLE_66 index: 0 
			newWeight_scope_1(uint256)= UNPACK TUPLE_66 index: 1 
		Expression: DelegateVotesChanged(dst,oldWeight_scope_0,newWeight_scope_1)
		IRs:
			Emit DelegateVotesChanged(dst,oldWeight_scope_0,newWeight_scope_1)
	Function ERC20Votes._writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256) (*)
		Expression: pos = ckpts.length
		IRs:
			REF_1927 -> LENGTH ckpts
			pos(uint256) := REF_1927(uint256)
		Expression: oldWeight = oldCkpt.votes
		IRs:
			REF_1928(uint224) -> oldCkpt.votes
			oldWeight(uint256) := REF_1928(uint224)
		Expression: newWeight = op(oldWeight,delta)
		IRs:
			TMP_6252(uint256) = INTERNAL_DYNAMIC_CALL op(oldWeight,delta)  
			newWeight(uint256) := TMP_6252(uint256)
		Expression: pos > 0 && oldCkpt.fromBlock == clock()
		IRs:
			TMP_6253(bool) = pos > 0
			REF_1929(uint32) -> oldCkpt.fromBlock
			TMP_6254(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_6255(bool) = REF_1929 == TMP_6254
			TMP_6256(bool) = TMP_6253 && TMP_6255
			CONDITION TMP_6256
		Expression: _unsafeAccess(ckpts,pos - 1).votes = SafeCast.toUint224(newWeight)
		IRs:
			TMP_6257(uint256) = pos - 1
			TMP_6258(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_6257)
			REF_1930(uint224) -> TMP_6258.votes
			TMP_6259(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newWeight'] 
			REF_1930(uint224) (->TMP_6258) := TMP_6259(uint224)
		Expression: ckpts.push(Checkpoint({fromBlock:SafeCast.toUint32(clock()),votes:SafeCast.toUint224(newWeight)}))
		IRs:
			TMP_6260(uint48) = INTERNAL_CALL, ERC20Votes.clock()()
			TMP_6261(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['TMP_6260'] 
			TMP_6262(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newWeight'] 
			TMP_6263(ERC20Votes.Checkpoint) = new Checkpoint(TMP_6261,TMP_6262)
			REF_1935 -> LENGTH ckpts
			TMP_6265(uint256) := REF_1935(uint256)
			TMP_6266(uint256) = TMP_6265 + 1
			REF_1935(uint256) (->ckpts) := TMP_6266(uint256)
			REF_1936(ERC20Votes.Checkpoint) -> ckpts[TMP_6265]
			REF_1936(ERC20Votes.Checkpoint) (->ckpts) := TMP_6263(ERC20Votes.Checkpoint)
		Expression: pos == 0
		IRs:
			TMP_6267(bool) = pos == 0
			CONDITION TMP_6267
		Expression: oldCkpt = Checkpoint(0,0)
		IRs:
			TMP_6268(ERC20Votes.Checkpoint) = new Checkpoint(0,0)
			oldCkpt(ERC20Votes.Checkpoint) := TMP_6268(ERC20Votes.Checkpoint)
		Expression: oldCkpt = _unsafeAccess(ckpts,pos - 1)
		IRs:
			TMP_6269(uint256) = pos - 1
			TMP_6270(ERC20Votes.Checkpoint) = INTERNAL_CALL, ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256)(ckpts,TMP_6269)
			oldCkpt(ERC20Votes.Checkpoint) := TMP_6270(ERC20Votes.Checkpoint)
	Function ERC20Votes._add(uint256,uint256) (*)
		Expression: a + b
		IRs:
			TMP_6271(uint256) = a (c)+ b
			RETURN TMP_6271
	Function ERC20Votes._subtract(uint256,uint256) (*)
		Expression: a - b
		IRs:
			TMP_6272(uint256) = a (c)- b
			RETURN TMP_6272
	Function ERC20Votes._unsafeAccess(ERC20Votes.Checkpoint[],uint256) (*)
		Expression: mstore(uint256,uint256)(0,ckpts)
		IRs:
			TMP_6273(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,ckpts)
		Expression: result = keccak256(uint256,uint256)(0,0x20) + pos
		IRs:
			TMP_6274(uint256) = SOLIDITY_CALL keccak256(uint256,uint256)(0,32)
			TMP_6275(uint256) = TMP_6274 + pos
			result(ERC20Votes.Checkpoint) := TMP_6275(uint256)
	Function IVotes.getVotes(address) 
	Function IVotes.getPastVotes(address,uint256) 
	Function IVotes.getPastTotalSupply(uint256) 
	Function IVotes.delegates(address) 
	Function IVotes.delegate(address) 
	Function IVotes.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function ERC20Permit.constructor(string) (*)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_6277(bool) = block.timestamp <= deadline
			TMP_6278(None) = SOLIDITY_CALL require(bool,string)(TMP_6277,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_6279(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner)
			TMP_6280(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_6279,deadline)
			TMP_6281(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6280)
			structHash(bytes32) := TMP_6281(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_6282(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_6282(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_6283(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_6283(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_6284(bool) = signer == owner
			TMP_6285(None) = SOLIDITY_CALL require(bool,string)(TMP_6284,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,value)
	Function ERC20Permit.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_1939(Counters.Counter) -> _nonces[owner]
			TMP_6287(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_1939'] 
			RETURN TMP_6287
	Function ERC20Permit.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_6288(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_6288
	Function ERC20Permit._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_1941(Counters.Counter) -> _nonces[owner]
			nonce(Counters.Counter) := REF_1941(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_6289(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['nonce'] 
			current(uint256) := TMP_6289(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:['nonce'] 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_6291(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_6291(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_6292(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_6292(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_6293 = CONVERT name to bytes
			TMP_6294(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6293)
			_hashedName(bytes32) := TMP_6294(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_6295 = CONVERT version to bytes
			TMP_6296(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6295)
			_hashedVersion(bytes32) := TMP_6296(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_6297(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_6297(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_6298 = CONVERT this to address
			_cachedThis(address) := TMP_6298(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_6299 = CONVERT this to address
			TMP_6300(bool) = TMP_6299 == _cachedThis
			TMP_6301(bool) = block.chainid == _cachedChainId
			TMP_6302(bool) = TMP_6300 && TMP_6301
			CONDITION TMP_6302
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_6303(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_6303
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_6304 = CONVERT this to address
			TMP_6305(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_6304)
			TMP_6306(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6305)
			RETURN TMP_6306
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_6307(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_6308(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_6307', 'structHash'] 
			RETURN TMP_6308
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_6309(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_6310(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_6311 = CONVERT this to address
			TMP_6312 = CONVERT 0 to bytes32
			TMP_6314(uint256[])  = new uint256[](0)
			RETURN ,TMP_6309,TMP_6310,block.chainid,TMP_6311,TMP_6312,TMP_6314
	Function IERC5267.eip712Domain() 
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20Permit.nonces(address) 
	Function IERC20Permit.DOMAIN_SEPARATOR() 
	Function ERC20.constructor(string,string) 
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_1950(uint256) -> _balances[account]
			RETURN REF_1950
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_6315(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_6315(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_1951(mapping(address => uint256)) -> _allowances[owner]
			REF_1952(uint256) -> REF_1951[spender]
			RETURN REF_1952
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_6317(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_6317(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_6319(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_6319(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_6322(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_6322(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_6323(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_6324(uint256) = TMP_6323 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_6324)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_6326(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_6326(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6327(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_6327(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_6328(bool) = currentAllowance >= subtractedValue
			TMP_6329(None) = SOLIDITY_CALL require(bool,string)(TMP_6328,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_6330(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_6330)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_6332 = CONVERT 0 to address
			TMP_6333(bool) = from != TMP_6332
			TMP_6334(None) = SOLIDITY_CALL require(bool,string)(TMP_6333,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_6335 = CONVERT 0 to address
			TMP_6336(bool) = to != TMP_6335
			TMP_6337(None) = SOLIDITY_CALL require(bool,string)(TMP_6336,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_1953(uint256) -> _balances[from]
			fromBalance(uint256) := REF_1953(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_6339(bool) = fromBalance >= amount
			TMP_6340(None) = SOLIDITY_CALL require(bool,string)(TMP_6339,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_1954(uint256) -> _balances[from]
			TMP_6341(uint256) = fromBalance - amount
			REF_1954(uint256) (->_balances) := TMP_6341(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_1955(uint256) -> _balances[to]
			REF_1955(-> _balances) = REF_1955 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, BKR._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) 
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_6344 = CONVERT 0 to address
			TMP_6345(bool) = account != TMP_6344
			TMP_6346(None) = SOLIDITY_CALL require(bool,string)(TMP_6345,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6347 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_6347,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_1956(uint256) -> _balances[account]
			REF_1956(-> _balances) = REF_1956 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_6349 = CONVERT 0 to address
			Emit Transfer(TMP_6349,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_6351 = CONVERT 0 to address
			INTERNAL_CALL, BKR._afterTokenTransfer(address,address,uint256)(TMP_6351,account,amount)
	Function ERC20._burn(address,uint256) 
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_6353 = CONVERT 0 to address
			TMP_6354(bool) = account != TMP_6353
			TMP_6355(None) = SOLIDITY_CALL require(bool,string)(TMP_6354,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6356 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_6356,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_1957(uint256) -> _balances[account]
			accountBalance(uint256) := REF_1957(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_6358(bool) = accountBalance >= amount
			TMP_6359(None) = SOLIDITY_CALL require(bool,string)(TMP_6358,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_1958(uint256) -> _balances[account]
			TMP_6360(uint256) = accountBalance - amount
			REF_1958(uint256) (->_balances) := TMP_6360(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_6361 = CONVERT 0 to address
			Emit Transfer(account,TMP_6361,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_6363 = CONVERT 0 to address
			INTERNAL_CALL, BKR._afterTokenTransfer(address,address,uint256)(account,TMP_6363,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_6365 = CONVERT 0 to address
			TMP_6366(bool) = owner != TMP_6365
			TMP_6367(None) = SOLIDITY_CALL require(bool,string)(TMP_6366,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_6368 = CONVERT 0 to address
			TMP_6369(bool) = spender != TMP_6368
			TMP_6370(None) = SOLIDITY_CALL require(bool,string)(TMP_6369,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_1959(mapping(address => uint256)) -> _allowances[owner]
			REF_1960(uint256) -> REF_1959[spender]
			REF_1960(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_6372(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_6372(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_6374(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_6375(bool) = currentAllowance != TMP_6374
			CONDITION TMP_6375
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_6376(bool) = currentAllowance >= amount
			TMP_6377(None) = SOLIDITY_CALL require(bool,string)(TMP_6376,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_6378(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_6378)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) 
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_6380(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6380)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_6382(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_6383(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6384(bool) = TMP_6382 == TMP_6383
			TMP_6385(None) = SOLIDITY_CALL require(bool,string)(TMP_6384,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_6386 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_6386)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_6389 = CONVERT 0 to address
			TMP_6390(bool) = newOwner != TMP_6389
			TMP_6391(None) = SOLIDITY_CALL require(bool,string)(TMP_6390,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function BKR.constructor(address) (*)
		Expression: _mint(initialOwner,_MAXSUPPLY)
		IRs:
			INTERNAL_CALL, BKR._mint(address,uint256)(initialOwner,_MAXSUPPLY)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ERC20(_NAME,_SYMBOL)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(_NAME,_SYMBOL)
		Expression: ERC20Permit(_NAME)
		IRs:
			INTERNAL_CALL, ERC20Permit.constructor(string)(_NAME)
		Expression: ERC20Votes()
		IRs:
			NOP
	Function BKR._afterTokenTransfer(address,address,uint256) (*)
		Expression: super._afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20Votes._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function BKR._mint(address,uint256) (*)
		Expression: super._mint(to,amount)
		IRs:
			INTERNAL_CALL, ERC20Votes._mint(address,uint256)(to,amount)
	Function BKR._burn(address,uint256) (*)
		Expression: super._burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20Votes._burn(address,uint256)(account,amount)
	Function BKR.slitherConstructorConstantVariables() (*)
		Expression: _NAME = BakerFi
		IRs:
			_NAME(string) := BakerFi(string)
		Expression: _SYMBOL = BKR
		IRs:
			_SYMBOL(string) := BKR(string)
		Expression: _MAXSUPPLY = 500_000_000 * 1e18
		IRs:
			TMP_6403(uint256) = 500000000 (c)* 1000000000000000000
			_MAXSUPPLY(uint256) := TMP_6403(uint256)
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract BakerFiGovernor
	Function GovernorTimelockControl.constructor(TimelockController) (*)
		Expression: _updateTimelock(timelockAddress)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._updateTimelock(TimelockController)(timelockAddress)
	Function GovernorTimelockControl.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IGovernorTimelock).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_6406(type(IGovernorTimelock)) = SOLIDITY_CALL type()(IGovernorTimelock)
			REF_1961(bytes4) (->None) := 2641955390(bytes4)
			TMP_6407(bool) = interfaceId == REF_1961
			TMP_6408(bool) = INTERNAL_CALL, Governor.supportsInterface(bytes4)(interfaceId)
			TMP_6409(bool) = TMP_6407 || TMP_6408
			RETURN TMP_6409
	Function GovernorTimelockControl.state(uint256) 
		Expression: currentState = super.state(proposalId)
		IRs:
			TMP_6410(IGovernor.ProposalState) = INTERNAL_CALL, Governor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_6410(IGovernor.ProposalState)
		Expression: currentState != ProposalState.Succeeded
		IRs:
			REF_1962(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_6411(bool) = currentState != REF_1962
			CONDITION TMP_6411
		Expression: currentState
		IRs:
			RETURN currentState
		Expression: queueid = _timelockIds[proposalId]
		IRs:
			REF_1963(bytes32) -> _timelockIds[proposalId]
			queueid(bytes32) := REF_1963(bytes32)
		Expression: queueid == bytes32(0)
		IRs:
			TMP_6412 = CONVERT 0 to bytes32
			TMP_6413(bool) = queueid == TMP_6412
			CONDITION TMP_6413
		Expression: currentState
		IRs:
			RETURN currentState
		Expression: _timelock.isOperationDone(queueid)
		IRs:
			TMP_6414(bool) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:isOperationDone, arguments:['queueid']  
			CONDITION TMP_6414
		Expression: ProposalState.Executed
		IRs:
			REF_1965(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_1965
		Expression: _timelock.isOperationPending(queueid)
		IRs:
			TMP_6415(bool) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:isOperationPending, arguments:['queueid']  
			CONDITION TMP_6415
		Expression: ProposalState.Queued
		IRs:
			REF_1967(IGovernor.ProposalState) -> ProposalState.Queued
			RETURN REF_1967
		Expression: ProposalState.Canceled
		IRs:
			REF_1968(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_1968
	Function GovernorTimelockControl.timelock() (*)
		Expression: address(_timelock)
		IRs:
			TMP_6416 = CONVERT _timelock to address
			RETURN TMP_6416
	Function GovernorTimelockControl.proposalEta(uint256) (*)
		Expression: eta = _timelock.getTimestamp(_timelockIds[proposalId])
		IRs:
			REF_1970(bytes32) -> _timelockIds[proposalId]
			TMP_6417(uint256) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:getTimestamp, arguments:['REF_1970']  
			eta(uint256) := TMP_6417(uint256)
		Expression: eta == 1
		IRs:
			TMP_6418(bool) = eta == 1
			CONDITION TMP_6418
		Expression: 0
		IRs:
			RETURN 0
		Expression: eta
		IRs:
			RETURN eta
	Function GovernorTimelockControl.queue(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6419(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6419(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Succeeded,Governor: proposal not successful)
		IRs:
			TMP_6420(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			REF_1971(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_6421(bool) = TMP_6420 == REF_1971
			TMP_6422(None) = SOLIDITY_CALL require(bool,string)(TMP_6421,Governor: proposal not successful)
		Expression: delay = _timelock.getMinDelay()
		IRs:
			TMP_6423(uint256) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:getMinDelay, arguments:[]  
			delay(uint256) := TMP_6423(uint256)
		Expression: _timelockIds[proposalId] = _timelock.hashOperationBatch(targets,values,calldatas,0,descriptionHash)
		IRs:
			REF_1973(bytes32) -> _timelockIds[proposalId]
			TMP_6424(bytes32) = HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:hashOperationBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash']  
			REF_1973(bytes32) (->_timelockIds) := TMP_6424(bytes32)
		Expression: _timelock.scheduleBatch(targets,values,calldatas,0,descriptionHash,delay)
		IRs:
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:scheduleBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash', 'delay']  
		Expression: ProposalQueued(proposalId,block.timestamp + delay)
		IRs:
			TMP_6426(uint256) = block.timestamp (c)+ delay
			Emit ProposalQueued(proposalId,TMP_6426)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function GovernorTimelockControl._execute(uint256,address[],uint256[],bytes[],bytes32) 
		Expression: _timelock.executeBatch{value: msg.value}(targets,values,calldatas,0,descriptionHash)
		IRs:
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:executeBatch, arguments:['targets', 'values', 'calldatas', '0', 'descriptionHash'] value:msg.value 
	Function GovernorTimelockControl._cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = super._cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6429(uint256) = INTERNAL_CALL, Governor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6429(uint256)
		Expression: _timelockIds[proposalId] != 0
		IRs:
			REF_1977(bytes32) -> _timelockIds[proposalId]
			TMP_6430(bool) = REF_1977 != 0
			CONDITION TMP_6430
		Expression: _timelock.cancel(_timelockIds[proposalId])
		IRs:
			REF_1979(bytes32) -> _timelockIds[proposalId]
			HIGH_LEVEL_CALL, dest:_timelock(TimelockController), function:cancel, arguments:['REF_1979']  
		Expression: delete _timelockIds[proposalId]
		IRs:
			REF_1980(bytes32) -> _timelockIds[proposalId]
			_timelockIds = delete REF_1980 
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function GovernorTimelockControl._executor() 
		Expression: address(_timelock)
		IRs:
			TMP_6432 = CONVERT _timelock to address
			RETURN TMP_6432
	Function GovernorTimelockControl.updateTimelock(TimelockController) (*)
		Expression: _updateTimelock(newTimelock)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._updateTimelock(TimelockController)(newTimelock)
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function GovernorTimelockControl._updateTimelock(TimelockController) (*)
		Expression: TimelockChange(address(_timelock),address(newTimelock))
		IRs:
			TMP_6435 = CONVERT _timelock to address
			TMP_6436 = CONVERT newTimelock to address
			Emit TimelockChange(TMP_6435,TMP_6436)
		Expression: _timelock = newTimelock
		IRs:
			_timelock(TimelockController) := newTimelock(TimelockController)
	Function Governor.constructor(string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: EIP712(name_,version())
		IRs:
			TMP_6438(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_6438)
		Expression: EIP712(name_,version())
		IRs:
			TMP_6440(string) = INTERNAL_CALL, Governor.version()()
			INTERNAL_CALL, EIP712.constructor(string,string)(name_,TMP_6440)
	Function Governor.receive() (*)
		Expression: require(bool,string)(_executor() == address(this),Governor: must send to executor)
		IRs:
			TMP_6442(address) = INTERNAL_CALL, BakerFiGovernor._executor()()
			TMP_6443 = CONVERT this to address
			TMP_6444(bool) = TMP_6442 == TMP_6443
			TMP_6445(None) = SOLIDITY_CALL require(bool,string)(TMP_6444,Governor: must send to executor)
	Function Governor.supportsInterface(bytes4) 
		Expression: governorCancelId = this.cancel.selector ^ this.proposalProposer.selector
		IRs:
			REF_1981(function(None,None,None,None) returns(None)) -> this.cancel
			REF_1982(None) -> REF_1981.selector
			REF_1983(function(None) returns(None)) -> this.proposalProposer
			REF_1984(None) -> REF_1983.selector
			TMP_6446(None) = REF_1982 ^ REF_1984
			governorCancelId(bytes4) := TMP_6446(None)
		Expression: governorParamsId = this.castVoteWithReasonAndParams.selector ^ this.castVoteWithReasonAndParamsBySig.selector ^ this.getVotesWithParams.selector
		IRs:
			REF_1985(function(None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParams
			REF_1986(None) -> REF_1985.selector
			REF_1987(function(None,None,None,None,None,None,None) returns(None)) -> this.castVoteWithReasonAndParamsBySig
			REF_1988(None) -> REF_1987.selector
			TMP_6447(None) = REF_1986 ^ REF_1988
			REF_1989(function(None,None,None) returns(None)) -> this.getVotesWithParams
			REF_1990(None) -> REF_1989.selector
			TMP_6448(None) = TMP_6447 ^ REF_1990
			governorParamsId(bytes4) := TMP_6448(None)
		Expression: governor43Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId ^ governorParamsId
		IRs:
			TMP_6449(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_1991(bytes4) (->None) := 4078917331(bytes4)
			TMP_6450(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_1992(bytes4) (->None) := 3660085789(bytes4)
			TMP_6451(bytes4) = REF_1991 ^ REF_1992
			TMP_6452(bytes4) = TMP_6451 ^ governorCancelId
			TMP_6453(bytes4) = TMP_6452 ^ governorParamsId
			governor43Id(bytes4) := TMP_6453(bytes4)
		Expression: governor46Id = type()(IGovernor).interfaceId ^ type()(IERC6372).interfaceId ^ governorCancelId
		IRs:
			TMP_6454(type(IGovernor)) = SOLIDITY_CALL type()(IGovernor)
			REF_1993(bytes4) (->None) := 4078917331(bytes4)
			TMP_6455(type(IERC6372)) = SOLIDITY_CALL type()(IERC6372)
			REF_1994(bytes4) (->None) := 3660085789(bytes4)
			TMP_6456(bytes4) = REF_1993 ^ REF_1994
			TMP_6457(bytes4) = TMP_6456 ^ governorCancelId
			governor46Id(bytes4) := TMP_6457(bytes4)
		Expression: interfaceId == governor43Id || interfaceId == governor46Id || interfaceId == governorCancelId || interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_6458(bool) = interfaceId == governor43Id
			TMP_6459(bool) = interfaceId == governor46Id
			TMP_6460(bool) = TMP_6458 || TMP_6459
			TMP_6461(bool) = interfaceId == governorCancelId
			TMP_6462(bool) = TMP_6460 || TMP_6461
			TMP_6463(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_1995(bytes4) (->None) := 1339874119(bytes4)
			TMP_6464(bool) = interfaceId == REF_1995
			TMP_6465(bool) = TMP_6462 || TMP_6464
			TMP_6466(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_6467(bool) = TMP_6465 || TMP_6466
			RETURN TMP_6467
	Function Governor.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function Governor.version() (*)
		Expression: 1
		IRs:
			RETURN 1
	Function Governor.hashProposal(address[],uint256[],bytes[],bytes32) (*)
		Expression: uint256(keccak256(bytes)(abi.encode(targets,values,calldatas,descriptionHash)))
		IRs:
			TMP_6468(bytes) = SOLIDITY_CALL abi.encode()(targets,values,calldatas,descriptionHash)
			TMP_6469(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6468)
			TMP_6470 = CONVERT TMP_6469 to uint256
			RETURN TMP_6470
	Function Governor.state(uint256) 
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_1997(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_1997(Governor.ProposalCore)
		Expression: proposal.executed
		IRs:
			REF_1998(bool) -> proposal.executed
			CONDITION REF_1998
		Expression: ProposalState.Executed
		IRs:
			REF_1999(IGovernor.ProposalState) -> ProposalState.Executed
			RETURN REF_1999
		Expression: proposal.canceled
		IRs:
			REF_2000(bool) -> proposal.canceled
			CONDITION REF_2000
		Expression: ProposalState.Canceled
		IRs:
			REF_2001(IGovernor.ProposalState) -> ProposalState.Canceled
			RETURN REF_2001
		Expression: snapshot = proposalSnapshot(proposalId)
		IRs:
			TMP_6471(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			snapshot(uint256) := TMP_6471(uint256)
		Expression: snapshot == 0
		IRs:
			TMP_6472(bool) = snapshot == 0
			CONDITION TMP_6472
		Expression: revert(string)(Governor: unknown proposal id)
		IRs:
			TMP_6473(None) = SOLIDITY_CALL revert(string)(Governor: unknown proposal id)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_6474(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_6474(uint48)
		Expression: snapshot >= currentTimepoint
		IRs:
			TMP_6475(bool) = snapshot >= currentTimepoint
			CONDITION TMP_6475
		Expression: ProposalState.Pending
		IRs:
			REF_2002(IGovernor.ProposalState) -> ProposalState.Pending
			RETURN REF_2002
		Expression: deadline = proposalDeadline(proposalId)
		IRs:
			TMP_6476(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			deadline(uint256) := TMP_6476(uint256)
		Expression: deadline >= currentTimepoint
		IRs:
			TMP_6477(bool) = deadline >= currentTimepoint
			CONDITION TMP_6477
		Expression: ProposalState.Active
		IRs:
			REF_2003(IGovernor.ProposalState) -> ProposalState.Active
			RETURN REF_2003
		Expression: _quorumReached(proposalId) && _voteSucceeded(proposalId)
		IRs:
			TMP_6478(bool) = INTERNAL_CALL, GovernorCompatibilityBravo._quorumReached(uint256)(proposalId)
			TMP_6479(bool) = INTERNAL_CALL, GovernorCompatibilityBravo._voteSucceeded(uint256)(proposalId)
			TMP_6480(bool) = TMP_6478 && TMP_6479
			CONDITION TMP_6480
		Expression: ProposalState.Succeeded
		IRs:
			REF_2004(IGovernor.ProposalState) -> ProposalState.Succeeded
			RETURN REF_2004
		Expression: ProposalState.Defeated
		IRs:
			REF_2005(IGovernor.ProposalState) -> ProposalState.Defeated
			RETURN REF_2005
	Function Governor.proposalThreshold() 
		Expression: 0
		IRs:
			RETURN 0
	Function Governor.proposalSnapshot(uint256) (*)
		Expression: _proposals[proposalId].voteStart
		IRs:
			REF_2006(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2007(uint64) -> REF_2006.voteStart
			RETURN REF_2007
	Function Governor.proposalDeadline(uint256) (*)
		Expression: _proposals[proposalId].voteEnd
		IRs:
			REF_2008(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2009(uint64) -> REF_2008.voteEnd
			RETURN REF_2009
	Function Governor.proposalProposer(uint256) (*)
		Expression: _proposals[proposalId].proposer
		IRs:
			REF_2010(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2011(address) -> REF_2010.proposer
			RETURN REF_2011
	Function Governor._quorumReached(uint256) 
	Function Governor._voteSucceeded(uint256) 
	Function Governor._getVotes(address,uint256,bytes) 
	Function Governor._countVote(uint256,address,uint8,uint256,bytes) 
	Function Governor._defaultParams() (*)
		Expression: 
		IRs:
			RETURN 
	Function Governor.propose(address[],uint256[],bytes[],string) 
		Expression: proposer = _msgSender()
		IRs:
			TMP_6481(address) = INTERNAL_CALL, Context._msgSender()()
			proposer(address) := TMP_6481(address)
		Expression: require(bool,string)(_isValidDescriptionForProposer(proposer,description),Governor: proposer restricted)
		IRs:
			TMP_6482(bool) = INTERNAL_CALL, Governor._isValidDescriptionForProposer(address,string)(proposer,description)
			TMP_6483(None) = SOLIDITY_CALL require(bool,string)(TMP_6482,Governor: proposer restricted)
		Expression: currentTimepoint = clock()
		IRs:
			TMP_6484(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			currentTimepoint(uint256) := TMP_6484(uint48)
		Expression: require(bool,string)(getVotes(proposer,currentTimepoint - 1) >= proposalThreshold(),Governor: proposer votes below proposal threshold)
		IRs:
			TMP_6485(uint256) = currentTimepoint (c)- 1
			TMP_6486(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_6485)
			TMP_6487(uint256) = INTERNAL_CALL, BakerFiGovernor.proposalThreshold()()
			TMP_6488(bool) = TMP_6486 >= TMP_6487
			TMP_6489(None) = SOLIDITY_CALL require(bool,string)(TMP_6488,Governor: proposer votes below proposal threshold)
		Expression: proposalId = hashProposal(targets,values,calldatas,keccak256(bytes)(bytes(description)))
		IRs:
			TMP_6490 = CONVERT description to bytes
			TMP_6491(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6490)
			TMP_6492(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,TMP_6491)
			proposalId(uint256) := TMP_6492(uint256)
		Expression: require(bool,string)(targets.length == values.length,Governor: invalid proposal length)
		IRs:
			REF_2012 -> LENGTH targets
			REF_2013 -> LENGTH values
			TMP_6493(bool) = REF_2012 == REF_2013
			TMP_6494(None) = SOLIDITY_CALL require(bool,string)(TMP_6493,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length == calldatas.length,Governor: invalid proposal length)
		IRs:
			REF_2014 -> LENGTH targets
			REF_2015 -> LENGTH calldatas
			TMP_6495(bool) = REF_2014 == REF_2015
			TMP_6496(None) = SOLIDITY_CALL require(bool,string)(TMP_6495,Governor: invalid proposal length)
		Expression: require(bool,string)(targets.length > 0,Governor: empty proposal)
		IRs:
			REF_2016 -> LENGTH targets
			TMP_6497(bool) = REF_2016 > 0
			TMP_6498(None) = SOLIDITY_CALL require(bool,string)(TMP_6497,Governor: empty proposal)
		Expression: require(bool,string)(_proposals[proposalId].voteStart == 0,Governor: proposal already exists)
		IRs:
			REF_2017(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2018(uint64) -> REF_2017.voteStart
			TMP_6499(bool) = REF_2018 == 0
			TMP_6500(None) = SOLIDITY_CALL require(bool,string)(TMP_6499,Governor: proposal already exists)
		Expression: snapshot = currentTimepoint + votingDelay()
		IRs:
			TMP_6501(uint256) = INTERNAL_CALL, BakerFiGovernor.votingDelay()()
			TMP_6502(uint256) = currentTimepoint (c)+ TMP_6501
			snapshot(uint256) := TMP_6502(uint256)
		Expression: deadline = snapshot + votingPeriod()
		IRs:
			TMP_6503(uint256) = INTERNAL_CALL, BakerFiGovernor.votingPeriod()()
			TMP_6504(uint256) = snapshot (c)+ TMP_6503
			deadline(uint256) := TMP_6504(uint256)
		Expression: _proposals[proposalId] = ProposalCore({proposer:proposer,voteStart:SafeCast.toUint64(snapshot),voteEnd:SafeCast.toUint64(deadline),executed:false,canceled:false,__gap_unused0:0,__gap_unused1:0})
		IRs:
			REF_2019(Governor.ProposalCore) -> _proposals[proposalId]
			TMP_6505(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['snapshot'] 
			TMP_6506(uint64) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint64(uint256), arguments:['deadline'] 
			TMP_6507(Governor.ProposalCore) = new ProposalCore(TMP_6505,proposer,0,TMP_6506,0,False,False)
			REF_2019(Governor.ProposalCore) (->_proposals) := TMP_6507(Governor.ProposalCore)
		Expression: ProposalCreated(proposalId,proposer,targets,values,new string[](targets.length),calldatas,snapshot,deadline,description)
		IRs:
			REF_2022 -> LENGTH targets
			TMP_6509(string[])  = new string[](REF_2022)
			Emit ProposalCreated(proposalId,proposer,targets,values,TMP_6509,calldatas,snapshot,deadline,description)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.execute(address[],uint256[],bytes[],bytes32) (*)
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6511(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6511(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_6512(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_6512(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,Governor: proposal not successful)
		IRs:
			REF_2023(IGovernor.ProposalState) -> ProposalState.Succeeded
			TMP_6513(bool) = currentState == REF_2023
			REF_2024(IGovernor.ProposalState) -> ProposalState.Queued
			TMP_6514(bool) = currentState == REF_2024
			TMP_6515(bool) = TMP_6513 || TMP_6514
			TMP_6516(None) = SOLIDITY_CALL require(bool,string)(TMP_6515,Governor: proposal not successful)
		Expression: _proposals[proposalId].executed = true
		IRs:
			REF_2025(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2026(bool) -> REF_2025.executed
			REF_2026(bool) (->_proposals) := True(bool)
		Expression: ProposalExecuted(proposalId)
		IRs:
			Emit ProposalExecuted(proposalId)
		Expression: _beforeExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, BakerFiGovernor._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: _afterExecute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6521(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6521(uint256)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Pending,Governor: too late to cancel)
		IRs:
			TMP_6522(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			REF_2027(IGovernor.ProposalState) -> ProposalState.Pending
			TMP_6523(bool) = TMP_6522 == REF_2027
			TMP_6524(None) = SOLIDITY_CALL require(bool,string)(TMP_6523,Governor: too late to cancel)
		Expression: require(bool,string)(_msgSender() == _proposals[proposalId].proposer,Governor: only proposer can cancel)
		IRs:
			TMP_6525(address) = INTERNAL_CALL, Context._msgSender()()
			REF_2028(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2029(address) -> REF_2028.proposer
			TMP_6526(bool) = TMP_6525 == REF_2029
			TMP_6527(None) = SOLIDITY_CALL require(bool,string)(TMP_6526,Governor: only proposer can cancel)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6528(uint256) = INTERNAL_CALL, BakerFiGovernor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_6528
	Function Governor._execute(uint256,address[],uint256[],bytes[],bytes32) 
		Expression: errorMessage = Governor: call reverted without message
		IRs:
			errorMessage(string) := Governor: call reverted without message(string)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_2030 -> LENGTH targets
			TMP_6529(bool) = i < REF_2030
			CONDITION TMP_6529
		Expression: (success,returndata) = targets[i].call{value: values[i]}(calldatas[i])
		IRs:
			REF_2031(address) -> targets[i]
			REF_2033(bytes) -> calldatas[i]
			REF_2034(uint256) -> values[i]
			TUPLE_67(bool,bytes) = LOW_LEVEL_CALL, dest:REF_2031, function:call, arguments:['REF_2033'] value:REF_2034 
			success(bool)= UNPACK TUPLE_67 index: 0 
			returndata(bytes)= UNPACK TUPLE_67 index: 1 
		Expression: Address.verifyCallResult(success,returndata,errorMessage)
		IRs:
			TMP_6530(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'errorMessage'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._beforeExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_6531(address) = INTERNAL_CALL, BakerFiGovernor._executor()()
			TMP_6532 = CONVERT this to address
			TMP_6533(bool) = TMP_6531 != TMP_6532
			CONDITION TMP_6533
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_2036 -> LENGTH targets
			TMP_6534(bool) = i < REF_2036
			CONDITION TMP_6534
		Expression: targets[i] == address(this)
		IRs:
			REF_2037(address) -> targets[i]
			TMP_6535 = CONVERT this to address
			TMP_6536(bool) = REF_2037 == TMP_6535
			CONDITION TMP_6536
		Expression: _governanceCall.pushBack(keccak256(bytes)(calldatas[i]))
		IRs:
			REF_2039(bytes) -> calldatas[i]
			TMP_6537(bytes32) = SOLIDITY_CALL keccak256(bytes)(REF_2039)
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.pushBack(DoubleEndedQueue.Bytes32Deque,bytes32), arguments:['_governanceCall', 'TMP_6537'] 
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
	Function Governor._afterExecute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: _executor() != address(this)
		IRs:
			TMP_6539(address) = INTERNAL_CALL, BakerFiGovernor._executor()()
			TMP_6540 = CONVERT this to address
			TMP_6541(bool) = TMP_6539 != TMP_6540
			CONDITION TMP_6541
		Expression: ! _governanceCall.empty()
		IRs:
			TMP_6542(bool) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.empty(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_6543 = UnaryType.BANG TMP_6542 
			CONDITION TMP_6543
		Expression: _governanceCall.clear()
		IRs:
			LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.clear(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
	Function Governor._cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6545(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6545(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_6546(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_6546(IGovernor.ProposalState)
		Expression: require(bool,string)(currentState != ProposalState.Canceled && currentState != ProposalState.Expired && currentState != ProposalState.Executed,Governor: proposal not active)
		IRs:
			REF_2042(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_6547(bool) = currentState != REF_2042
			REF_2043(IGovernor.ProposalState) -> ProposalState.Expired
			TMP_6548(bool) = currentState != REF_2043
			TMP_6549(bool) = TMP_6547 && TMP_6548
			REF_2044(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_6550(bool) = currentState != REF_2044
			TMP_6551(bool) = TMP_6549 && TMP_6550
			TMP_6552(None) = SOLIDITY_CALL require(bool,string)(TMP_6551,Governor: proposal not active)
		Expression: _proposals[proposalId].canceled = true
		IRs:
			REF_2045(Governor.ProposalCore) -> _proposals[proposalId]
			REF_2046(bool) -> REF_2045.canceled
			REF_2046(bool) (->_proposals) := True(bool)
		Expression: ProposalCanceled(proposalId)
		IRs:
			Emit ProposalCanceled(proposalId)
		Expression: proposalId
		IRs:
			RETURN proposalId
	Function Governor.getVotes(address,uint256) (*)
		Expression: _getVotes(account,timepoint,_defaultParams())
		IRs:
			TMP_6554(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_6555(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,TMP_6554)
			RETURN TMP_6555
	Function Governor.getVotesWithParams(address,uint256,bytes) (*)
		Expression: _getVotes(account,timepoint,params)
		IRs:
			TMP_6556(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,timepoint,params)
			RETURN TMP_6556
	Function Governor.castVote(uint256,uint8) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_6557(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_6557(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_6558(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_6558
	Function Governor.castVoteWithReason(uint256,uint8,string) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_6559(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_6559(address)
		Expression: _castVote(proposalId,voter,support,reason)
		IRs:
			TMP_6560(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,reason)
			RETURN TMP_6560
	Function Governor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) (*)
		Expression: voter = _msgSender()
		IRs:
			TMP_6561(address) = INTERNAL_CALL, Context._msgSender()()
			voter(address) := TMP_6561(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_6562(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_6562
	Function Governor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(BALLOT_TYPEHASH,proposalId,support))),v,r,s)
		IRs:
			TMP_6563(bytes) = SOLIDITY_CALL abi.encode()(BALLOT_TYPEHASH,proposalId,support)
			TMP_6564(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6563)
			TMP_6565(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_6564)
			TMP_6566(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_6565', 'v', 'r', 's'] 
			voter(address) := TMP_6566(address)
		Expression: _castVote(proposalId,voter,support,)
		IRs:
			TMP_6567(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string)(proposalId,voter,support,)
			RETURN TMP_6567
	Function Governor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) (*)
		Expression: voter = ECDSA.recover(_hashTypedDataV4(keccak256(bytes)(abi.encode(EXTENDED_BALLOT_TYPEHASH,proposalId,support,keccak256(bytes)(bytes(reason)),keccak256(bytes)(params)))),v,r,s)
		IRs:
			TMP_6568 = CONVERT reason to bytes
			TMP_6569(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6568)
			TMP_6570(bytes32) = SOLIDITY_CALL keccak256(bytes)(params)
			TMP_6571(bytes) = SOLIDITY_CALL abi.encode()(EXTENDED_BALLOT_TYPEHASH,proposalId,support,TMP_6569,TMP_6570)
			TMP_6572(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6571)
			TMP_6573(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(TMP_6572)
			TMP_6574(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['TMP_6573', 'v', 'r', 's'] 
			voter(address) := TMP_6574(address)
		Expression: _castVote(proposalId,voter,support,reason,params)
		IRs:
			TMP_6575(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,voter,support,reason,params)
			RETURN TMP_6575
	Function Governor._castVote(uint256,address,uint8,string) (*)
		Expression: _castVote(proposalId,account,support,reason,_defaultParams())
		IRs:
			TMP_6576(bytes) = INTERNAL_CALL, Governor._defaultParams()()
			TMP_6577(uint256) = INTERNAL_CALL, Governor._castVote(uint256,address,uint8,string,bytes)(proposalId,account,support,reason,TMP_6576)
			RETURN TMP_6577
	Function Governor._castVote(uint256,address,uint8,string,bytes) (*)
		Expression: proposal = _proposals[proposalId]
		IRs:
			REF_2051(Governor.ProposalCore) -> _proposals[proposalId]
			proposal(Governor.ProposalCore) := REF_2051(Governor.ProposalCore)
		Expression: require(bool,string)(state(proposalId) == ProposalState.Active,Governor: vote not currently active)
		IRs:
			TMP_6578(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			REF_2052(IGovernor.ProposalState) -> ProposalState.Active
			TMP_6579(bool) = TMP_6578 == REF_2052
			TMP_6580(None) = SOLIDITY_CALL require(bool,string)(TMP_6579,Governor: vote not currently active)
		Expression: weight = _getVotes(account,proposal.voteStart,params)
		IRs:
			REF_2053(uint64) -> proposal.voteStart
			TMP_6581(uint256) = INTERNAL_CALL, GovernorVotes._getVotes(address,uint256,bytes)(account,REF_2053,params)
			weight(uint256) := TMP_6581(uint256)
		Expression: _countVote(proposalId,account,support,weight,params)
		IRs:
			INTERNAL_CALL, GovernorCompatibilityBravo._countVote(uint256,address,uint8,uint256,bytes)(proposalId,account,support,weight,params)
		Expression: params.length == 0
		IRs:
			REF_2054 -> LENGTH params
			TMP_6583(bool) = REF_2054 == 0
			CONDITION TMP_6583
		Expression: VoteCast(account,proposalId,support,weight,reason)
		IRs:
			Emit VoteCast(account,proposalId,support,weight,reason)
		Expression: VoteCastWithParams(account,proposalId,support,weight,reason,params)
		IRs:
			Emit VoteCastWithParams(account,proposalId,support,weight,reason,params)
		Expression: weight
		IRs:
			RETURN weight
	Function Governor.relay(address,uint256,bytes) (*)
		Expression: (success,returndata) = target.call{value: value}(data)
		IRs:
			TUPLE_68(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_68 index: 0 
			returndata(bytes)= UNPACK TUPLE_68 index: 1 
		Expression: Address.verifyCallResult(success,returndata,Governor: relay reverted without message)
		IRs:
			TMP_6586(bytes) = LIBRARY_CALL, dest:Address, function:Address.verifyCallResult(bool,bytes,string), arguments:['success', 'returndata', 'Governor: relay reverted without message'] 
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function Governor._executor() 
		Expression: address(this)
		IRs:
			TMP_6588 = CONVERT this to address
			RETURN TMP_6588
	Function Governor.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_2057(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_2058(None) -> REF_2057.selector
			RETURN REF_2058
	Function Governor.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_2059(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_2060(None) -> REF_2059.selector
			RETURN REF_2060
	Function Governor.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_2061(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_2062(None) -> REF_2061.selector
			RETURN REF_2062
	Function Governor._isValidDescriptionForProposer(address,string) (*)
		Expression: len = bytes(description).length
		IRs:
			TMP_6589 = CONVERT description to bytes
			REF_2063 -> LENGTH TMP_6589
			len(uint256) := REF_2063(uint256)
		Expression: len < 52
		IRs:
			TMP_6590(bool) = len < 52
			CONDITION TMP_6590
		Expression: true
		IRs:
			RETURN True
		Expression: marker = mload(uint256)(description + len - 20)
		IRs:
			TMP_6591(uint256) = len - 20
			TMP_6592(string) = description + TMP_6591
			TMP_6593(uint256) = SOLIDITY_CALL mload(uint256)(TMP_6592)
			marker(bytes12) := TMP_6593(uint256)
		Expression: marker != bytes12(#proposer=0x)
		IRs:
			TMP_6594 = CONVERT #proposer=0x to bytes12
			TMP_6595(bool) = marker != TMP_6594
			CONDITION TMP_6595
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = 0
		IRs:
			recovered(uint160) := 0(uint256)
		Expression: i = len - 40
		IRs:
			TMP_6596(uint256) = len (c)- 40
			i(uint256) := TMP_6596(uint256)
		Expression: i < len
		IRs:
			TMP_6597(bool) = i < len
			CONDITION TMP_6597
		Expression: (isHex,value) = _tryHexToUint(bytes(description)[i])
		IRs:
			TMP_6598 = CONVERT description to bytes
			REF_2064(None) -> TMP_6598[i]
			TUPLE_69(bool,uint8) = INTERNAL_CALL, Governor._tryHexToUint(bytes1)(REF_2064)
			isHex(bool)= UNPACK TUPLE_69 index: 0 
			value(uint8)= UNPACK TUPLE_69 index: 1 
		Expression: ! isHex
		IRs:
			TMP_6599 = UnaryType.BANG isHex 
			CONDITION TMP_6599
		Expression: true
		IRs:
			RETURN True
		Expression: recovered = (recovered << 4) | value
		IRs:
			TMP_6600(uint160) = recovered << 4
			TMP_6601(uint160) = TMP_6600 | value
			recovered(uint160) := TMP_6601(uint160)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: recovered == uint160(proposer)
		IRs:
			TMP_6602 = CONVERT proposer to uint160
			TMP_6603(bool) = recovered == TMP_6602
			RETURN TMP_6603
	Function Governor._tryHexToUint(bytes1) (*)
		Expression: c = uint8(char)
		IRs:
			TMP_6604 = CONVERT char to uint8
			c(uint8) := TMP_6604(uint8)
		Expression: 47 < c && c < 58
		IRs:
			TMP_6605(bool) = 47 < c
			TMP_6606(bool) = c < 58
			TMP_6607(bool) = TMP_6605 && TMP_6606
			CONDITION TMP_6607
		Expression: (true,c - 48)
		IRs:
			TMP_6608(uint8) = c - 48
			RETURN True,TMP_6608
		Expression: 64 < c && c < 71
		IRs:
			TMP_6609(bool) = 64 < c
			TMP_6610(bool) = c < 71
			TMP_6611(bool) = TMP_6609 && TMP_6610
			CONDITION TMP_6611
		Expression: (true,c - 55)
		IRs:
			TMP_6612(uint8) = c - 55
			RETURN True,TMP_6612
		Expression: 96 < c && c < 103
		IRs:
			TMP_6613(bool) = 96 < c
			TMP_6614(bool) = c < 103
			TMP_6615(bool) = TMP_6613 && TMP_6614
			CONDITION TMP_6615
		Expression: (true,c - 87)
		IRs:
			TMP_6616(uint8) = c - 87
			RETURN True,TMP_6616
		Expression: (false,0)
		IRs:
			RETURN False,0
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function IGovernor.name() 
	Function IGovernor.version() 
	Function IGovernor.clock() 
	Function IGovernor.CLOCK_MODE() 
	Function IGovernor.COUNTING_MODE() 
	Function IGovernor.hashProposal(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.state(uint256) 
	Function IGovernor.proposalSnapshot(uint256) 
	Function IGovernor.proposalDeadline(uint256) 
	Function IGovernor.proposalProposer(uint256) 
	Function IGovernor.votingDelay() 
	Function IGovernor.votingPeriod() 
	Function IGovernor.quorum(uint256) 
	Function IGovernor.getVotes(address,uint256) 
	Function IGovernor.getVotesWithParams(address,uint256,bytes) 
	Function IGovernor.hasVoted(uint256,address) 
	Function IGovernor.propose(address[],uint256[],bytes[],string) 
	Function IGovernor.execute(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.cancel(address[],uint256[],bytes[],bytes32) 
	Function IGovernor.castVote(uint256,uint8) 
	Function IGovernor.castVoteWithReason(uint256,uint8,string) 
	Function IGovernor.castVoteWithReasonAndParams(uint256,uint8,string,bytes) 
	Function IGovernor.castVoteBySig(uint256,uint8,uint8,bytes32,bytes32) 
	Function IGovernor.castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32) 
	Function IERC6372.clock() 
	Function IERC6372.CLOCK_MODE() 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_6617(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_6617(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_6618(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_6618(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_6619 = CONVERT name to bytes
			TMP_6620(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6619)
			_hashedName(bytes32) := TMP_6620(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_6621 = CONVERT version to bytes
			TMP_6622(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6621)
			_hashedVersion(bytes32) := TMP_6622(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_6623(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_6623(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_6624 = CONVERT this to address
			_cachedThis(address) := TMP_6624(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_6625 = CONVERT this to address
			TMP_6626(bool) = TMP_6625 == _cachedThis
			TMP_6627(bool) = block.chainid == _cachedChainId
			TMP_6628(bool) = TMP_6626 && TMP_6627
			CONDITION TMP_6628
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_6629(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_6629
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_6630 = CONVERT this to address
			TMP_6631(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_6630)
			TMP_6632(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6631)
			RETURN TMP_6632
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_6633(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_6634(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_6633', 'structHash'] 
			RETURN TMP_6634
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_6635(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_6636(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_6637 = CONVERT this to address
			TMP_6638 = CONVERT 0 to bytes32
			TMP_6640(uint256[])  = new uint256[](0)
			RETURN ,TMP_6635,TMP_6636,block.chainid,TMP_6637,TMP_6638,TMP_6640
	Function IERC5267.eip712Domain() 
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_6641(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_2071(bytes4) (->None) := 33540519(bytes4)
			TMP_6642(bool) = interfaceId == REF_2071
			RETURN TMP_6642
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IGovernorTimelock.timelock() 
	Function IGovernorTimelock.proposalEta(uint256) 
	Function IGovernorTimelock.queue(address[],uint256[],bytes[],bytes32) 
	Function GovernorVotesQuorumFraction.constructor(uint256) (*)
		Expression: _updateQuorumNumerator(quorumNumeratorValue)
		IRs:
			INTERNAL_CALL, GovernorVotesQuorumFraction._updateQuorumNumerator(uint256)(quorumNumeratorValue)
	Function GovernorVotesQuorumFraction.quorumNumerator() (*)
		Expression: _quorumNumeratorHistory._checkpoints.length == 0
		IRs:
			REF_2072(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_2073 -> LENGTH REF_2072
			TMP_6644(bool) = REF_2073 == 0
			CONDITION TMP_6644
		Expression: _quorumNumerator
		IRs:
			RETURN _quorumNumerator
		Expression: _quorumNumeratorHistory.latest()
		IRs:
			TMP_6645(uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.latest(Checkpoints.Trace224), arguments:['_quorumNumeratorHistory'] 
			RETURN TMP_6645
	Function GovernorVotesQuorumFraction.quorumNumerator(uint256) (*)
		Expression: length = _quorumNumeratorHistory._checkpoints.length
		IRs:
			REF_2075(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_2076 -> LENGTH REF_2075
			length(uint256) := REF_2076(uint256)
		Expression: length == 0
		IRs:
			TMP_6646(bool) = length == 0
			CONDITION TMP_6646
		Expression: _quorumNumerator
		IRs:
			RETURN _quorumNumerator
		Expression: latest = _quorumNumeratorHistory._checkpoints[length - 1]
		IRs:
			REF_2077(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			TMP_6647(uint256) = length (c)- 1
			REF_2078(Checkpoints.Checkpoint224) -> REF_2077[TMP_6647]
			latest(Checkpoints.Checkpoint224) := REF_2078(Checkpoints.Checkpoint224)
		Expression: latest._key <= timepoint
		IRs:
			REF_2079(uint32) -> latest._key
			TMP_6648(bool) = REF_2079 <= timepoint
			CONDITION TMP_6648
		Expression: latest._value
		IRs:
			REF_2080(uint224) -> latest._value
			RETURN REF_2080
		Expression: _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint32(timepoint))
		IRs:
			TMP_6649(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['timepoint'] 
			TMP_6650(uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.upperLookupRecent(Checkpoints.Trace224,uint32), arguments:['_quorumNumeratorHistory', 'TMP_6649'] 
			RETURN TMP_6650
	Function GovernorVotesQuorumFraction.quorumDenominator() (*)
		Expression: 100
		IRs:
			RETURN 100
	Function GovernorVotesQuorumFraction.quorum(uint256) (*)
		Expression: (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator()
		IRs:
			TMP_6651(uint256) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:getPastTotalSupply, arguments:['timepoint']  
			TMP_6652(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumNumerator(uint256)(timepoint)
			TMP_6653(uint256) = TMP_6651 (c)* TMP_6652
			TMP_6654(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumDenominator()()
			TMP_6655(uint256) = TMP_6653 (c)/ TMP_6654
			RETURN TMP_6655
	Function GovernorVotesQuorumFraction.updateQuorumNumerator(uint256) (*)
		Expression: _updateQuorumNumerator(newQuorumNumerator)
		IRs:
			INTERNAL_CALL, GovernorVotesQuorumFraction._updateQuorumNumerator(uint256)(newQuorumNumerator)
		Expression: onlyGovernance()
		IRs:
			MODIFIER_CALL, Governor.onlyGovernance()()
	Function GovernorVotesQuorumFraction._updateQuorumNumerator(uint256) (*)
		Expression: require(bool,string)(newQuorumNumerator <= quorumDenominator(),GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator)
		IRs:
			TMP_6658(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumDenominator()()
			TMP_6659(bool) = newQuorumNumerator <= TMP_6658
			TMP_6660(None) = SOLIDITY_CALL require(bool,string)(TMP_6659,GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator)
		Expression: oldQuorumNumerator = quorumNumerator()
		IRs:
			TMP_6661(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorumNumerator()()
			oldQuorumNumerator(uint256) := TMP_6661(uint256)
		Expression: oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0
		IRs:
			TMP_6662(bool) = oldQuorumNumerator != 0
			REF_2084(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			REF_2085 -> LENGTH REF_2084
			TMP_6663(bool) = REF_2085 == 0
			TMP_6664(bool) = TMP_6662 && TMP_6663
			CONDITION TMP_6664
		Expression: _quorumNumeratorHistory._checkpoints.push(Checkpoints.Checkpoint224({_key:0,_value:SafeCast.toUint224(oldQuorumNumerator)}))
		IRs:
			REF_2086(Checkpoints.Checkpoint224[]) -> _quorumNumeratorHistory._checkpoints
			TMP_6665(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['oldQuorumNumerator'] 
			TMP_6666(Checkpoints.Checkpoint224) = new Checkpoint224(0,TMP_6665)
			REF_2090 -> LENGTH REF_2086
			TMP_6668(uint256) := REF_2090(uint256)
			TMP_6669(uint256) = TMP_6668 (c)+ 1
			REF_2090(uint256) (->_quorumNumeratorHistory) := TMP_6669(uint256)
			REF_2091(Checkpoints.Checkpoint224) -> REF_2086[TMP_6668]
			REF_2091(Checkpoints.Checkpoint224) (->_quorumNumeratorHistory) := TMP_6666(Checkpoints.Checkpoint224)
		Expression: _quorumNumeratorHistory.push(SafeCast.toUint32(clock()),SafeCast.toUint224(newQuorumNumerator))
		IRs:
			TMP_6670(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			TMP_6671(uint32) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint32(uint256), arguments:['TMP_6670'] 
			TMP_6672(uint224) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint224(uint256), arguments:['newQuorumNumerator'] 
			TUPLE_70(uint224,uint224) = LIBRARY_CALL, dest:Checkpoints, function:Checkpoints.push(Checkpoints.Trace224,uint32,uint224), arguments:['_quorumNumeratorHistory', 'TMP_6671', 'TMP_6672'] 
		Expression: QuorumNumeratorUpdated(oldQuorumNumerator,newQuorumNumerator)
		IRs:
			Emit QuorumNumeratorUpdated(oldQuorumNumerator,newQuorumNumerator)
	Function GovernorVotes.constructor(IVotes) (*)
		Expression: token = IERC5805(address(tokenAddress))
		IRs:
			TMP_6674 = CONVERT tokenAddress to address
			TMP_6675 = CONVERT TMP_6674 to IERC5805
			token(IERC5805) := TMP_6675(IERC5805)
	Function GovernorVotes.clock() (*)
		Expression: timepoint = token.clock()
		IRs:
			TMP_6676(uint48) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:clock, arguments:[]  
			timepoint(uint48) := TMP_6676(uint48)
		Expression: timepoint
		IRs:
			RETURN timepoint
		Expression: SafeCast.toUint48(block.number)
		IRs:
			TMP_6677(uint48) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint48(uint256), arguments:['block.number'] 
			RETURN TMP_6677
	Function GovernorVotes.CLOCK_MODE() (*)
		Expression: clockmode = token.CLOCK_MODE()
		IRs:
			TMP_6678(string) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:CLOCK_MODE, arguments:[]  
			clockmode(string) := TMP_6678(string)
		Expression: clockmode
		IRs:
			RETURN clockmode
		Expression: mode=blocknumber&from=default
		IRs:
			RETURN mode=blocknumber&from=default
	Function GovernorVotes._getVotes(address,uint256,bytes) (*)
		Expression: token.getPastVotes(account,timepoint)
		IRs:
			TMP_6679(uint256) = HIGH_LEVEL_CALL, dest:token(IERC5805), function:getPastVotes, arguments:['account', 'timepoint']  
			RETURN TMP_6679
	Function GovernorCompatibilityBravo.COUNTING_MODE() (*)
		Expression: support=bravo&quorum=bravo
		IRs:
			RETURN support=bravo&quorum=bravo
	Function GovernorCompatibilityBravo.propose(address[],uint256[],bytes[],string) 
		Expression: _storeProposal(_msgSender(),targets,values,new string[](calldatas.length),calldatas,description)
		IRs:
			TMP_6680(address) = INTERNAL_CALL, Context._msgSender()()
			REF_2099 -> LENGTH calldatas
			TMP_6682(string[])  = new string[](REF_2099)
			INTERNAL_CALL, GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string)(TMP_6680,targets,values,TMP_6682,calldatas,description)
		Expression: super.propose(targets,values,calldatas,description)
		IRs:
			TMP_6684(uint256) = INTERNAL_CALL, Governor.propose(address[],uint256[],bytes[],string)(targets,values,calldatas,description)
			RETURN TMP_6684
	Function GovernorCompatibilityBravo.propose(address[],uint256[],string[],bytes[],string) (*)
		Expression: require(bool,string)(signatures.length == calldatas.length,GovernorBravo: invalid signatures length)
		IRs:
			REF_2100 -> LENGTH signatures
			REF_2101 -> LENGTH calldatas
			TMP_6685(bool) = REF_2100 == REF_2101
			TMP_6686(None) = SOLIDITY_CALL require(bool,string)(TMP_6685,GovernorBravo: invalid signatures length)
		Expression: _storeProposal(_msgSender(),targets,values,signatures,calldatas,description)
		IRs:
			TMP_6687(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string)(TMP_6687,targets,values,signatures,calldatas,description)
		Expression: propose(targets,values,_encodeCalldata(signatures,calldatas),description)
		IRs:
			TMP_6689(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(signatures,calldatas)
			TMP_6690(uint256) = INTERNAL_CALL, BakerFiGovernor.propose(address[],uint256[],bytes[],string)(targets,values,TMP_6689,description)
			RETURN TMP_6690
	Function GovernorCompatibilityBravo.queue(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_71(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_71 index: 0 
			values(uint256[])= UNPACK TUPLE_71 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_71 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_71 index: 3 
		Expression: queue(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6691(uint256) = INTERNAL_CALL, GovernorTimelockControl.queue(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.execute(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_72(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_72 index: 0 
			values(uint256[])= UNPACK TUPLE_72 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_72 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_72 index: 3 
		Expression: execute(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6692(uint256) = INTERNAL_CALL, Governor.execute(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.cancel(uint256) (*)
		Expression: (targets,values,calldatas,descriptionHash) = _getProposalParameters(proposalId)
		IRs:
			TUPLE_73(address[],uint256[],bytes[],bytes32) = INTERNAL_CALL, GovernorCompatibilityBravo._getProposalParameters(uint256)(proposalId)
			targets(address[])= UNPACK TUPLE_73 index: 0 
			values(uint256[])= UNPACK TUPLE_73 index: 1 
			calldatas(bytes[])= UNPACK TUPLE_73 index: 2 
			descriptionHash(bytes32)= UNPACK TUPLE_73 index: 3 
		Expression: cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6693(uint256) = INTERNAL_CALL, BakerFiGovernor.cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
	Function GovernorCompatibilityBravo.cancel(address[],uint256[],bytes[],bytes32) 
		Expression: proposalId = hashProposal(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6694(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			proposalId(uint256) := TMP_6694(uint256)
		Expression: proposer = _proposalDetails[proposalId].proposer
		IRs:
			REF_2102(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_2103(address) -> REF_2102.proposer
			proposer(address) := REF_2103(address)
		Expression: require(bool,string)(_msgSender() == proposer || getVotes(proposer,clock() - 1) < proposalThreshold(),GovernorBravo: proposer above threshold)
		IRs:
			TMP_6695(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6696(bool) = TMP_6695 == proposer
			TMP_6697(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			TMP_6698(uint48) = TMP_6697 (c)- 1
			TMP_6699(uint256) = INTERNAL_CALL, Governor.getVotes(address,uint256)(proposer,TMP_6698)
			TMP_6700(uint256) = INTERNAL_CALL, BakerFiGovernor.proposalThreshold()()
			TMP_6701(bool) = TMP_6699 < TMP_6700
			TMP_6702(bool) = TMP_6696 || TMP_6701
			TMP_6703(None) = SOLIDITY_CALL require(bool,string)(TMP_6702,GovernorBravo: proposer above threshold)
		Expression: _cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6704(uint256) = INTERNAL_CALL, BakerFiGovernor._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_6704
	Function GovernorCompatibilityBravo._encodeCalldata(string[],bytes[]) (*)
		Expression: fullcalldatas = new bytes[](calldatas.length)
		IRs:
			REF_2104 -> LENGTH calldatas
			TMP_6706(bytes[])  = new bytes[](REF_2104)
			fullcalldatas(bytes[]) = ['TMP_6706(bytes[])']
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < fullcalldatas.length
		IRs:
			REF_2105 -> LENGTH fullcalldatas
			TMP_6707(bool) = i < REF_2105
			CONDITION TMP_6707
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: fullcalldatas
		IRs:
			RETURN fullcalldatas
		Expression: bytes(signatures[i]).length == 0
		IRs:
			REF_2106(string) -> signatures[i]
			TMP_6708 = CONVERT REF_2106 to bytes
			REF_2107 -> LENGTH TMP_6708
			TMP_6709(bool) = REF_2107 == 0
			CONDITION TMP_6709
		Expression: fullcalldatas[i] = calldatas[i]
		IRs:
			REF_2108(bytes) -> fullcalldatas[i]
			REF_2109(bytes) -> calldatas[i]
			REF_2108(bytes) (->fullcalldatas) := REF_2109(bytes)
		Expression: fullcalldatas[i] = abi.encodePacked(bytes4(keccak256(bytes)(bytes(signatures[i]))),calldatas[i])
		IRs:
			REF_2110(bytes) -> fullcalldatas[i]
			REF_2112(string) -> signatures[i]
			TMP_6710 = CONVERT REF_2112 to bytes
			TMP_6711(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6710)
			TMP_6712 = CONVERT TMP_6711 to bytes4
			REF_2113(bytes) -> calldatas[i]
			TMP_6713(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_6712,REF_2113)
			REF_2110(bytes) (->fullcalldatas) := TMP_6713(bytes)
	Function GovernorCompatibilityBravo._getProposalParameters(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2114(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2114(GovernorCompatibilityBravo.ProposalDetails)
		Expression: (details.targets,details.values,_encodeCalldata(details.signatures,details.calldatas),details.descriptionHash)
		IRs:
			REF_2115(address[]) -> details.targets
			REF_2116(uint256[]) -> details.values
			REF_2117(string[]) -> details.signatures
			REF_2118(bytes[]) -> details.calldatas
			TMP_6714(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(REF_2117,REF_2118)
			REF_2119(bytes32) -> details.descriptionHash
			RETURN REF_2115,REF_2116,TMP_6714,REF_2119
	Function GovernorCompatibilityBravo._storeProposal(address,address[],uint256[],string[],bytes[],string) (*)
		Expression: descriptionHash = keccak256(bytes)(bytes(description))
		IRs:
			TMP_6715 = CONVERT description to bytes
			TMP_6716(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6715)
			descriptionHash(bytes32) := TMP_6716(bytes32)
		Expression: proposalId = hashProposal(targets,values,_encodeCalldata(signatures,calldatas),descriptionHash)
		IRs:
			TMP_6717(bytes[]) = INTERNAL_CALL, GovernorCompatibilityBravo._encodeCalldata(string[],bytes[])(signatures,calldatas)
			TMP_6718(uint256) = INTERNAL_CALL, Governor.hashProposal(address[],uint256[],bytes[],bytes32)(targets,values,TMP_6717,descriptionHash)
			proposalId(uint256) := TMP_6718(uint256)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2120(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2120(GovernorCompatibilityBravo.ProposalDetails)
		Expression: details.descriptionHash == bytes32(0)
		IRs:
			REF_2121(bytes32) -> details.descriptionHash
			TMP_6719 = CONVERT 0 to bytes32
			TMP_6720(bool) = REF_2121 == TMP_6719
			CONDITION TMP_6720
		Expression: details.proposer = proposer
		IRs:
			REF_2122(address) -> details.proposer
			REF_2122(address) (->details) := proposer(address)
		Expression: details.targets = targets
		IRs:
			REF_2123(address[]) -> details.targets
			REF_2123(address[]) (->details) := targets(address[])
		Expression: details.values = values
		IRs:
			REF_2124(uint256[]) -> details.values
			REF_2124(uint256[]) (->details) := values(uint256[])
		Expression: details.signatures = signatures
		IRs:
			REF_2125(string[]) -> details.signatures
			REF_2125(string[]) (->details) := signatures(string[])
		Expression: details.calldatas = calldatas
		IRs:
			REF_2126(bytes[]) -> details.calldatas
			REF_2126(bytes[]) (->details) := calldatas(bytes[])
		Expression: details.descriptionHash = descriptionHash
		IRs:
			REF_2127(bytes32) -> details.descriptionHash
			REF_2127(bytes32) (->details) := descriptionHash(bytes32)
	Function GovernorCompatibilityBravo.proposals(uint256) (*)
		Expression: id = proposalId
		IRs:
			id(uint256) := proposalId(uint256)
		Expression: eta = proposalEta(proposalId)
		IRs:
			TMP_6721(uint256) = INTERNAL_CALL, GovernorTimelockControl.proposalEta(uint256)(proposalId)
			eta(uint256) := TMP_6721(uint256)
		Expression: startBlock = proposalSnapshot(proposalId)
		IRs:
			TMP_6722(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			startBlock(uint256) := TMP_6722(uint256)
		Expression: endBlock = proposalDeadline(proposalId)
		IRs:
			TMP_6723(uint256) = INTERNAL_CALL, Governor.proposalDeadline(uint256)(proposalId)
			endBlock(uint256) := TMP_6723(uint256)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2128(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2128(GovernorCompatibilityBravo.ProposalDetails)
		Expression: proposer = details.proposer
		IRs:
			REF_2129(address) -> details.proposer
			proposer(address) := REF_2129(address)
		Expression: forVotes = details.forVotes
		IRs:
			REF_2130(uint256) -> details.forVotes
			forVotes(uint256) := REF_2130(uint256)
		Expression: againstVotes = details.againstVotes
		IRs:
			REF_2131(uint256) -> details.againstVotes
			againstVotes(uint256) := REF_2131(uint256)
		Expression: abstainVotes = details.abstainVotes
		IRs:
			REF_2132(uint256) -> details.abstainVotes
			abstainVotes(uint256) := REF_2132(uint256)
		Expression: currentState = state(proposalId)
		IRs:
			TMP_6724(IGovernor.ProposalState) = INTERNAL_CALL, BakerFiGovernor.state(uint256)(proposalId)
			currentState(IGovernor.ProposalState) := TMP_6724(IGovernor.ProposalState)
		Expression: canceled = currentState == ProposalState.Canceled
		IRs:
			REF_2133(IGovernor.ProposalState) -> ProposalState.Canceled
			TMP_6725(bool) = currentState == REF_2133
			canceled(bool) := TMP_6725(bool)
		Expression: executed = currentState == ProposalState.Executed
		IRs:
			REF_2134(IGovernor.ProposalState) -> ProposalState.Executed
			TMP_6726(bool) = currentState == REF_2134
			executed(bool) := TMP_6726(bool)
	Function GovernorCompatibilityBravo.getActions(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2135(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2135(GovernorCompatibilityBravo.ProposalDetails)
		Expression: (details.targets,details.values,details.signatures,details.calldatas)
		IRs:
			REF_2136(address[]) -> details.targets
			REF_2137(uint256[]) -> details.values
			REF_2138(string[]) -> details.signatures
			REF_2139(bytes[]) -> details.calldatas
			RETURN REF_2136,REF_2137,REF_2138,REF_2139
	Function GovernorCompatibilityBravo.getReceipt(uint256,address) (*)
		Expression: _proposalDetails[proposalId].receipts[voter]
		IRs:
			REF_2140(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_2141(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> REF_2140.receipts
			REF_2142(IGovernorCompatibilityBravo.Receipt) -> REF_2141[voter]
			RETURN REF_2142
	Function GovernorCompatibilityBravo.quorumVotes() (*)
		Expression: quorum(clock() - 1)
		IRs:
			TMP_6727(uint48) = INTERNAL_CALL, GovernorVotes.clock()()
			TMP_6728(uint48) = TMP_6727 (c)- 1
			TMP_6729(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorum(uint256)(TMP_6728)
			RETURN TMP_6729
	Function GovernorCompatibilityBravo.hasVoted(uint256,address) (*)
		Expression: _proposalDetails[proposalId].receipts[account].hasVoted
		IRs:
			REF_2143(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			REF_2144(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> REF_2143.receipts
			REF_2145(IGovernorCompatibilityBravo.Receipt) -> REF_2144[account]
			REF_2146(bool) -> REF_2145.hasVoted
			RETURN REF_2146
	Function GovernorCompatibilityBravo._quorumReached(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2147(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2147(GovernorCompatibilityBravo.ProposalDetails)
		Expression: quorum(proposalSnapshot(proposalId)) <= details.forVotes
		IRs:
			TMP_6730(uint256) = INTERNAL_CALL, Governor.proposalSnapshot(uint256)(proposalId)
			TMP_6731(uint256) = INTERNAL_CALL, GovernorVotesQuorumFraction.quorum(uint256)(TMP_6730)
			REF_2148(uint256) -> details.forVotes
			TMP_6732(bool) = TMP_6731 <= REF_2148
			RETURN TMP_6732
	Function GovernorCompatibilityBravo._voteSucceeded(uint256) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2149(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2149(GovernorCompatibilityBravo.ProposalDetails)
		Expression: details.forVotes > details.againstVotes
		IRs:
			REF_2150(uint256) -> details.forVotes
			REF_2151(uint256) -> details.againstVotes
			TMP_6733(bool) = REF_2150 > REF_2151
			RETURN TMP_6733
	Function GovernorCompatibilityBravo._countVote(uint256,address,uint8,uint256,bytes) (*)
		Expression: details = _proposalDetails[proposalId]
		IRs:
			REF_2152(GovernorCompatibilityBravo.ProposalDetails) -> _proposalDetails[proposalId]
			details(GovernorCompatibilityBravo.ProposalDetails) := REF_2152(GovernorCompatibilityBravo.ProposalDetails)
		Expression: receipt = details.receipts[account]
		IRs:
			REF_2153(mapping(address => IGovernorCompatibilityBravo.Receipt)) -> details.receipts
			REF_2154(IGovernorCompatibilityBravo.Receipt) -> REF_2153[account]
			receipt(IGovernorCompatibilityBravo.Receipt) := REF_2154(IGovernorCompatibilityBravo.Receipt)
		Expression: require(bool,string)(! receipt.hasVoted,GovernorCompatibilityBravo: vote already cast)
		IRs:
			REF_2155(bool) -> receipt.hasVoted
			TMP_6734 = UnaryType.BANG REF_2155 
			TMP_6735(None) = SOLIDITY_CALL require(bool,string)(TMP_6734,GovernorCompatibilityBravo: vote already cast)
		Expression: receipt.hasVoted = true
		IRs:
			REF_2156(bool) -> receipt.hasVoted
			REF_2156(bool) (->receipt) := True(bool)
		Expression: receipt.support = support
		IRs:
			REF_2157(uint8) -> receipt.support
			REF_2157(uint8) (->receipt) := support(uint8)
		Expression: receipt.votes = SafeCast.toUint96(weight)
		IRs:
			REF_2158(uint96) -> receipt.votes
			TMP_6736(uint96) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint96(uint256), arguments:['weight'] 
			REF_2158(uint96) (->receipt) := TMP_6736(uint96)
		Expression: support == uint8(VoteType.Against)
		IRs:
			REF_2160(GovernorCompatibilityBravo.VoteType) -> VoteType.Against
			TMP_6737 = CONVERT REF_2160 to uint8
			TMP_6738(bool) = support == TMP_6737
			CONDITION TMP_6738
		Expression: details.againstVotes += weight
		IRs:
			REF_2161(uint256) -> details.againstVotes
			REF_2161(-> details) = REF_2161 (c)+ weight
		Expression: support == uint8(VoteType.For)
		IRs:
			REF_2162(GovernorCompatibilityBravo.VoteType) -> VoteType.For
			TMP_6739 = CONVERT REF_2162 to uint8
			TMP_6740(bool) = support == TMP_6739
			CONDITION TMP_6740
		Expression: details.forVotes += weight
		IRs:
			REF_2163(uint256) -> details.forVotes
			REF_2163(-> details) = REF_2163 (c)+ weight
		Expression: support == uint8(VoteType.Abstain)
		IRs:
			REF_2164(GovernorCompatibilityBravo.VoteType) -> VoteType.Abstain
			TMP_6741 = CONVERT REF_2164 to uint8
			TMP_6742(bool) = support == TMP_6741
			CONDITION TMP_6742
		Expression: details.abstainVotes += weight
		IRs:
			REF_2165(uint256) -> details.abstainVotes
			REF_2165(-> details) = REF_2165 (c)+ weight
		Expression: revert(string)(GovernorCompatibilityBravo: invalid vote type)
		IRs:
			TMP_6743(None) = SOLIDITY_CALL revert(string)(GovernorCompatibilityBravo: invalid vote type)
	Function IGovernorCompatibilityBravo.quorumVotes() 
	Function IGovernorCompatibilityBravo.proposals(uint256) 
	Function IGovernorCompatibilityBravo.propose(address[],uint256[],string[],bytes[],string) 
	Function IGovernorCompatibilityBravo.queue(uint256) 
	Function IGovernorCompatibilityBravo.execute(uint256) 
	Function IGovernorCompatibilityBravo.cancel(uint256) 
	Function IGovernorCompatibilityBravo.getActions(uint256) 
	Function IGovernorCompatibilityBravo.getReceipt(uint256,address) 
	Function BakerFiGovernor.constructor(IVotes,TimelockController) (*)
		Expression: Governor(BakerFiGovernor)
		IRs:
			INTERNAL_CALL, Governor.constructor(string)(BakerFiGovernor)
		Expression: GovernorVotes(_token)
		IRs:
			INTERNAL_CALL, GovernorVotes.constructor(IVotes)(_token)
		Expression: GovernorVotesQuorumFraction(_MIN_QUORUM)
		IRs:
			INTERNAL_CALL, GovernorVotesQuorumFraction.constructor(uint256)(_MIN_QUORUM)
		Expression: GovernorTimelockControl(_timelock)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl.constructor(TimelockController)(_timelock)
	Function BakerFiGovernor.votingDelay() (*)
		Expression: _VOTING_DELAY
		IRs:
			RETURN _VOTING_DELAY
	Function BakerFiGovernor.votingPeriod() (*)
		Expression: _VOTING_PERIOD
		IRs:
			RETURN _VOTING_PERIOD
	Function BakerFiGovernor.proposalThreshold() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function BakerFiGovernor.state(uint256) (*)
		Expression: super.state(proposalId)
		IRs:
			TMP_6748(IGovernor.ProposalState) = INTERNAL_CALL, GovernorTimelockControl.state(uint256)(proposalId)
			RETURN TMP_6748
	Function BakerFiGovernor.propose(address[],uint256[],bytes[],string) (*)
		Expression: super.propose(targets,values,calldatas,description)
		IRs:
			TMP_6749(uint256) = INTERNAL_CALL, GovernorCompatibilityBravo.propose(address[],uint256[],bytes[],string)(targets,values,calldatas,description)
			RETURN TMP_6749
	Function BakerFiGovernor.cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: super.cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6750(uint256) = INTERNAL_CALL, GovernorCompatibilityBravo.cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_6750
	Function BakerFiGovernor._execute(uint256,address[],uint256[],bytes[],bytes32) (*)
		Expression: super._execute(proposalId,targets,values,calldatas,descriptionHash)
		IRs:
			INTERNAL_CALL, GovernorTimelockControl._execute(uint256,address[],uint256[],bytes[],bytes32)(proposalId,targets,values,calldatas,descriptionHash)
	Function BakerFiGovernor._cancel(address[],uint256[],bytes[],bytes32) (*)
		Expression: super._cancel(targets,values,calldatas,descriptionHash)
		IRs:
			TMP_6752(uint256) = INTERNAL_CALL, GovernorTimelockControl._cancel(address[],uint256[],bytes[],bytes32)(targets,values,calldatas,descriptionHash)
			RETURN TMP_6752
	Function BakerFiGovernor._executor() (*)
		Expression: super._executor()
		IRs:
			TMP_6753(address) = INTERNAL_CALL, GovernorTimelockControl._executor()()
			RETURN TMP_6753
	Function BakerFiGovernor.supportsInterface(bytes4) (*)
		Expression: super.supportsInterface(interfaceId)
		IRs:
			TMP_6754(bool) = INTERNAL_CALL, GovernorTimelockControl.supportsInterface(bytes4)(interfaceId)
			RETURN TMP_6754
	Function BakerFiGovernor.slitherConstructorConstantVariables() (*)
		Expression: BALLOT_TYPEHASH = keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
		IRs:
			TMP_6755(bytes32) = SOLIDITY_CALL keccak256(bytes)(Ballot(uint256 proposalId,uint8 support))
			BALLOT_TYPEHASH(bytes32) := TMP_6755(bytes32)
		Expression: EXTENDED_BALLOT_TYPEHASH = keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
		IRs:
			TMP_6756(bytes32) = SOLIDITY_CALL keccak256(bytes)(ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params))
			EXTENDED_BALLOT_TYPEHASH(bytes32) := TMP_6756(bytes32)
		Expression: _MIN_QUORUM = 10
		IRs:
			_MIN_QUORUM(uint8) := 10(uint256)
		Expression: _VOTING_DELAY = 86400
		IRs:
			_VOTING_DELAY(uint256) := 86400(uint256)
		Expression: _VOTING_PERIOD = 604800
		IRs:
			_VOTING_PERIOD(uint256) := 604800(uint256)
	Modifier Governor.onlyGovernance()
		Expression: require(bool,string)(_msgSender() == _executor(),Governor: onlyGovernance)
		IRs:
			TMP_6757(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6758(address) = INTERNAL_CALL, BakerFiGovernor._executor()()
			TMP_6759(bool) = TMP_6757 == TMP_6758
			TMP_6760(None) = SOLIDITY_CALL require(bool,string)(TMP_6759,Governor: onlyGovernance)
		Expression: _executor() != address(this)
		IRs:
			TMP_6761(address) = INTERNAL_CALL, BakerFiGovernor._executor()()
			TMP_6762 = CONVERT this to address
			TMP_6763(bool) = TMP_6761 != TMP_6762
			CONDITION TMP_6763
		Expression: msgDataHash = keccak256(bytes)(_msgData())
		IRs:
			TMP_6764(bytes) = INTERNAL_CALL, Context._msgData()()
			TMP_6765(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6764)
			msgDataHash(bytes32) := TMP_6765(bytes32)
		Expression: _governanceCall.popFront() != msgDataHash
		IRs:
			TMP_6766(bytes32) = LIBRARY_CALL, dest:DoubleEndedQueue, function:DoubleEndedQueue.popFront(DoubleEndedQueue.Bytes32Deque), arguments:['_governanceCall'] 
			TMP_6767(bool) = TMP_6766 != msgDataHash
			CONDITION TMP_6767
Contract Timelock
	Function TimelockController.constructor(uint256,address[],address[],address) (*)
		Expression: _setRoleAdmin(TIMELOCK_ADMIN_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(TIMELOCK_ADMIN_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(PROPOSER_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(PROPOSER_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(EXECUTOR_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(EXECUTOR_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setRoleAdmin(CANCELLER_ROLE,TIMELOCK_ADMIN_ROLE)
		IRs:
			INTERNAL_CALL, AccessControl._setRoleAdmin(bytes32,bytes32)(CANCELLER_ROLE,TIMELOCK_ADMIN_ROLE)
		Expression: _setupRole(TIMELOCK_ADMIN_ROLE,address(this))
		IRs:
			TMP_6772 = CONVERT this to address
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(TIMELOCK_ADMIN_ROLE,TMP_6772)
		Expression: admin != address(0)
		IRs:
			TMP_6774 = CONVERT 0 to address
			TMP_6775(bool) = admin != TMP_6774
			CONDITION TMP_6775
		Expression: _setupRole(TIMELOCK_ADMIN_ROLE,admin)
		IRs:
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(TIMELOCK_ADMIN_ROLE,admin)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < proposers.length
		IRs:
			REF_2167 -> LENGTH proposers
			TMP_6777(bool) = i < REF_2167
			CONDITION TMP_6777
		Expression: _setupRole(PROPOSER_ROLE,proposers[i])
		IRs:
			REF_2168(address) -> proposers[i]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(PROPOSER_ROLE,REF_2168)
		Expression: _setupRole(CANCELLER_ROLE,proposers[i])
		IRs:
			REF_2169(address) -> proposers[i]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(CANCELLER_ROLE,REF_2169)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: i_scope_0 = 0
		IRs:
			i_scope_0(uint256) := 0(uint256)
		Expression: i_scope_0 < executors.length
		IRs:
			REF_2170 -> LENGTH executors
			TMP_6780(bool) = i_scope_0 < REF_2170
			CONDITION TMP_6780
		Expression: _setupRole(EXECUTOR_ROLE,executors[i_scope_0])
		IRs:
			REF_2171(address) -> executors[i_scope_0]
			INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(EXECUTOR_ROLE,REF_2171)
		Expression: ++ i_scope_0
		IRs:
			i_scope_0(uint256) = i_scope_0 (c)+ 1
		Expression: _minDelay = minDelay
		IRs:
			_minDelay(uint256) := minDelay(uint256)
		Expression: MinDelayChange(0,minDelay)
		IRs:
			Emit MinDelayChange(0,minDelay)
	Function TimelockController.receive() (*)
	Function TimelockController.supportsInterface(bytes4) (*)
		Expression: interfaceId == type()(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_6783(type(IERC1155Receiver)) = SOLIDITY_CALL type()(IERC1155Receiver)
			REF_2172(bytes4) (->None) := 1339874119(bytes4)
			TMP_6784(bool) = interfaceId == REF_2172
			TMP_6785(bool) = INTERNAL_CALL, AccessControl.supportsInterface(bytes4)(interfaceId)
			TMP_6786(bool) = TMP_6784 || TMP_6785
			RETURN TMP_6786
	Function TimelockController.isOperation(bytes32) (*)
		Expression: getTimestamp(id) > 0
		IRs:
			TMP_6787(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_6788(bool) = TMP_6787 > 0
			RETURN TMP_6788
	Function TimelockController.isOperationPending(bytes32) (*)
		Expression: getTimestamp(id) > _DONE_TIMESTAMP
		IRs:
			TMP_6789(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_6790(bool) = TMP_6789 > _DONE_TIMESTAMP
			RETURN TMP_6790
	Function TimelockController.isOperationReady(bytes32) (*)
		Expression: timestamp = getTimestamp(id)
		IRs:
			TMP_6791(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			timestamp(uint256) := TMP_6791(uint256)
		Expression: timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp
		IRs:
			TMP_6792(bool) = timestamp > _DONE_TIMESTAMP
			TMP_6793(bool) = timestamp <= block.timestamp
			TMP_6794(bool) = TMP_6792 && TMP_6793
			RETURN TMP_6794
	Function TimelockController.isOperationDone(bytes32) (*)
		Expression: getTimestamp(id) == _DONE_TIMESTAMP
		IRs:
			TMP_6795(uint256) = INTERNAL_CALL, TimelockController.getTimestamp(bytes32)(id)
			TMP_6796(bool) = TMP_6795 == _DONE_TIMESTAMP
			RETURN TMP_6796
	Function TimelockController.getTimestamp(bytes32) (*)
		Expression: _timestamps[id]
		IRs:
			REF_2173(uint256) -> _timestamps[id]
			RETURN REF_2173
	Function TimelockController.getMinDelay() (*)
		Expression: _minDelay
		IRs:
			RETURN _minDelay
	Function TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32) (*)
		Expression: keccak256(bytes)(abi.encode(target,value,data,predecessor,salt))
		IRs:
			TMP_6797(bytes) = SOLIDITY_CALL abi.encode()(target,value,data,predecessor,salt)
			TMP_6798(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6797)
			RETURN TMP_6798
	Function TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32) (*)
		Expression: keccak256(bytes)(abi.encode(targets,values,payloads,predecessor,salt))
		IRs:
			TMP_6799(bytes) = SOLIDITY_CALL abi.encode()(targets,values,payloads,predecessor,salt)
			TMP_6800(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_6799)
			RETURN TMP_6800
	Function TimelockController.schedule(address,uint256,bytes,bytes32,bytes32,uint256) (*)
		Expression: id = hashOperation(target,value,data,predecessor,salt)
		IRs:
			TMP_6801(bytes32) = INTERNAL_CALL, TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32)(target,value,data,predecessor,salt)
			id(bytes32) := TMP_6801(bytes32)
		Expression: _schedule(id,delay)
		IRs:
			INTERNAL_CALL, TimelockController._schedule(bytes32,uint256)(id,delay)
		Expression: CallScheduled(id,0,target,value,data,predecessor,delay)
		IRs:
			Emit CallScheduled(id,0,target,value,data,predecessor,delay)
		Expression: salt != bytes32(0)
		IRs:
			TMP_6804 = CONVERT 0 to bytes32
			TMP_6805(bool) = salt != TMP_6804
			CONDITION TMP_6805
		Expression: CallSalt(id,salt)
		IRs:
			Emit CallSalt(id,salt)
		Expression: onlyRole(PROPOSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(PROPOSER_ROLE)
	Function TimelockController.scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256) (*)
		Expression: require(bool,string)(targets.length == values.length,TimelockController: length mismatch)
		IRs:
			REF_2176 -> LENGTH targets
			REF_2177 -> LENGTH values
			TMP_6808(bool) = REF_2176 == REF_2177
			TMP_6809(None) = SOLIDITY_CALL require(bool,string)(TMP_6808,TimelockController: length mismatch)
		Expression: require(bool,string)(targets.length == payloads.length,TimelockController: length mismatch)
		IRs:
			REF_2178 -> LENGTH targets
			REF_2179 -> LENGTH payloads
			TMP_6810(bool) = REF_2178 == REF_2179
			TMP_6811(None) = SOLIDITY_CALL require(bool,string)(TMP_6810,TimelockController: length mismatch)
		Expression: id = hashOperationBatch(targets,values,payloads,predecessor,salt)
		IRs:
			TMP_6812(bytes32) = INTERNAL_CALL, TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)(targets,values,payloads,predecessor,salt)
			id(bytes32) := TMP_6812(bytes32)
		Expression: _schedule(id,delay)
		IRs:
			INTERNAL_CALL, TimelockController._schedule(bytes32,uint256)(id,delay)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_2180 -> LENGTH targets
			TMP_6814(bool) = i < REF_2180
			CONDITION TMP_6814
		Expression: CallScheduled(id,i,targets[i],values[i],payloads[i],predecessor,delay)
		IRs:
			REF_2181(address) -> targets[i]
			REF_2182(uint256) -> values[i]
			REF_2183(bytes) -> payloads[i]
			Emit CallScheduled(id,i,REF_2181,REF_2182,REF_2183,predecessor,delay)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: salt != bytes32(0)
		IRs:
			TMP_6816 = CONVERT 0 to bytes32
			TMP_6817(bool) = salt != TMP_6816
			CONDITION TMP_6817
		Expression: CallSalt(id,salt)
		IRs:
			Emit CallSalt(id,salt)
		Expression: onlyRole(PROPOSER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(PROPOSER_ROLE)
	Function TimelockController._schedule(bytes32,uint256) (*)
		Expression: require(bool,string)(! isOperation(id),TimelockController: operation already scheduled)
		IRs:
			TMP_6820(bool) = INTERNAL_CALL, TimelockController.isOperation(bytes32)(id)
			TMP_6821 = UnaryType.BANG TMP_6820 
			TMP_6822(None) = SOLIDITY_CALL require(bool,string)(TMP_6821,TimelockController: operation already scheduled)
		Expression: require(bool,string)(delay >= getMinDelay(),TimelockController: insufficient delay)
		IRs:
			TMP_6823(uint256) = INTERNAL_CALL, TimelockController.getMinDelay()()
			TMP_6824(bool) = delay >= TMP_6823
			TMP_6825(None) = SOLIDITY_CALL require(bool,string)(TMP_6824,TimelockController: insufficient delay)
		Expression: _timestamps[id] = block.timestamp + delay
		IRs:
			REF_2184(uint256) -> _timestamps[id]
			TMP_6826(uint256) = block.timestamp (c)+ delay
			REF_2184(uint256) (->_timestamps) := TMP_6826(uint256)
	Function TimelockController.cancel(bytes32) (*)
		Expression: require(bool,string)(isOperationPending(id),TimelockController: operation cannot be cancelled)
		IRs:
			TMP_6827(bool) = INTERNAL_CALL, TimelockController.isOperationPending(bytes32)(id)
			TMP_6828(None) = SOLIDITY_CALL require(bool,string)(TMP_6827,TimelockController: operation cannot be cancelled)
		Expression: delete _timestamps[id]
		IRs:
			REF_2185(uint256) -> _timestamps[id]
			_timestamps = delete REF_2185 
		Expression: Cancelled(id)
		IRs:
			Emit Cancelled(id)
		Expression: onlyRole(CANCELLER_ROLE)
		IRs:
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(CANCELLER_ROLE)
	Function TimelockController.execute(address,uint256,bytes,bytes32,bytes32) (*)
		Expression: id = hashOperation(target,value,payload,predecessor,salt)
		IRs:
			TMP_6831(bytes32) = INTERNAL_CALL, TimelockController.hashOperation(address,uint256,bytes,bytes32,bytes32)(target,value,payload,predecessor,salt)
			id(bytes32) := TMP_6831(bytes32)
		Expression: _beforeCall(id,predecessor)
		IRs:
			INTERNAL_CALL, TimelockController._beforeCall(bytes32,bytes32)(id,predecessor)
		Expression: _execute(target,value,payload)
		IRs:
			INTERNAL_CALL, TimelockController._execute(address,uint256,bytes)(target,value,payload)
		Expression: CallExecuted(id,0,target,value,payload)
		IRs:
			Emit CallExecuted(id,0,target,value,payload)
		Expression: _afterCall(id)
		IRs:
			INTERNAL_CALL, TimelockController._afterCall(bytes32)(id)
		Expression: onlyRoleOrOpenRole(EXECUTOR_ROLE)
		IRs:
			MODIFIER_CALL, TimelockController.onlyRoleOrOpenRole(bytes32)(EXECUTOR_ROLE)
	Function TimelockController.executeBatch(address[],uint256[],bytes[],bytes32,bytes32) (*)
		Expression: require(bool,string)(targets.length == values.length,TimelockController: length mismatch)
		IRs:
			REF_2186 -> LENGTH targets
			REF_2187 -> LENGTH values
			TMP_6837(bool) = REF_2186 == REF_2187
			TMP_6838(None) = SOLIDITY_CALL require(bool,string)(TMP_6837,TimelockController: length mismatch)
		Expression: require(bool,string)(targets.length == payloads.length,TimelockController: length mismatch)
		IRs:
			REF_2188 -> LENGTH targets
			REF_2189 -> LENGTH payloads
			TMP_6839(bool) = REF_2188 == REF_2189
			TMP_6840(None) = SOLIDITY_CALL require(bool,string)(TMP_6839,TimelockController: length mismatch)
		Expression: id = hashOperationBatch(targets,values,payloads,predecessor,salt)
		IRs:
			TMP_6841(bytes32) = INTERNAL_CALL, TimelockController.hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)(targets,values,payloads,predecessor,salt)
			id(bytes32) := TMP_6841(bytes32)
		Expression: _beforeCall(id,predecessor)
		IRs:
			INTERNAL_CALL, TimelockController._beforeCall(bytes32,bytes32)(id,predecessor)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < targets.length
		IRs:
			REF_2190 -> LENGTH targets
			TMP_6843(bool) = i < REF_2190
			CONDITION TMP_6843
		Expression: target = targets[i]
		IRs:
			REF_2191(address) -> targets[i]
			target(address) := REF_2191(address)
		Expression: value = values[i]
		IRs:
			REF_2192(uint256) -> values[i]
			value(uint256) := REF_2192(uint256)
		Expression: payload = payloads[i]
		IRs:
			REF_2193(bytes) -> payloads[i]
			payload(bytes) := REF_2193(bytes)
		Expression: _execute(target,value,payload)
		IRs:
			INTERNAL_CALL, TimelockController._execute(address,uint256,bytes)(target,value,payload)
		Expression: CallExecuted(id,i,target,value,payload)
		IRs:
			Emit CallExecuted(id,i,target,value,payload)
		Expression: ++ i
		IRs:
			i(uint256) = i (c)+ 1
		Expression: _afterCall(id)
		IRs:
			INTERNAL_CALL, TimelockController._afterCall(bytes32)(id)
		Expression: onlyRoleOrOpenRole(EXECUTOR_ROLE)
		IRs:
			MODIFIER_CALL, TimelockController.onlyRoleOrOpenRole(bytes32)(EXECUTOR_ROLE)
	Function TimelockController._execute(address,uint256,bytes) (*)
		Expression: (success) = target.call{value: value}(data)
		IRs:
			TUPLE_74(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
			success(bool)= UNPACK TUPLE_74 index: 0 
		Expression: require(bool,string)(success,TimelockController: underlying transaction reverted)
		IRs:
			TMP_6848(None) = SOLIDITY_CALL require(bool,string)(success,TimelockController: underlying transaction reverted)
	Function TimelockController._beforeCall(bytes32,bytes32) (*)
		Expression: require(bool,string)(isOperationReady(id),TimelockController: operation is not ready)
		IRs:
			TMP_6849(bool) = INTERNAL_CALL, TimelockController.isOperationReady(bytes32)(id)
			TMP_6850(None) = SOLIDITY_CALL require(bool,string)(TMP_6849,TimelockController: operation is not ready)
		Expression: require(bool,string)(predecessor == bytes32(0) || isOperationDone(predecessor),TimelockController: missing dependency)
		IRs:
			TMP_6851 = CONVERT 0 to bytes32
			TMP_6852(bool) = predecessor == TMP_6851
			TMP_6853(bool) = INTERNAL_CALL, TimelockController.isOperationDone(bytes32)(predecessor)
			TMP_6854(bool) = TMP_6852 || TMP_6853
			TMP_6855(None) = SOLIDITY_CALL require(bool,string)(TMP_6854,TimelockController: missing dependency)
	Function TimelockController._afterCall(bytes32) (*)
		Expression: require(bool,string)(isOperationReady(id),TimelockController: operation is not ready)
		IRs:
			TMP_6856(bool) = INTERNAL_CALL, TimelockController.isOperationReady(bytes32)(id)
			TMP_6857(None) = SOLIDITY_CALL require(bool,string)(TMP_6856,TimelockController: operation is not ready)
		Expression: _timestamps[id] = _DONE_TIMESTAMP
		IRs:
			REF_2195(uint256) -> _timestamps[id]
			REF_2195(uint256) (->_timestamps) := _DONE_TIMESTAMP(uint256)
	Function TimelockController.updateDelay(uint256) (*)
		Expression: require(bool,string)(msg.sender == address(this),TimelockController: caller must be timelock)
		IRs:
			TMP_6858 = CONVERT this to address
			TMP_6859(bool) = msg.sender == TMP_6858
			TMP_6860(None) = SOLIDITY_CALL require(bool,string)(TMP_6859,TimelockController: caller must be timelock)
		Expression: MinDelayChange(_minDelay,newDelay)
		IRs:
			Emit MinDelayChange(_minDelay,newDelay)
		Expression: _minDelay = newDelay
		IRs:
			_minDelay(uint256) := newDelay(uint256)
	Function TimelockController.onERC721Received(address,address,uint256,bytes) (*)
		Expression: this.onERC721Received.selector
		IRs:
			REF_2196(function(None,None,None,None) returns(None)) -> this.onERC721Received
			REF_2197(None) -> REF_2196.selector
			RETURN REF_2197
	Function TimelockController.onERC1155Received(address,address,uint256,uint256,bytes) (*)
		Expression: this.onERC1155Received.selector
		IRs:
			REF_2198(function(None,None,None,None,None) returns(None)) -> this.onERC1155Received
			REF_2199(None) -> REF_2198.selector
			RETURN REF_2199
	Function TimelockController.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) (*)
		Expression: this.onERC1155BatchReceived.selector
		IRs:
			REF_2200(function(None,None,None,None,None) returns(None)) -> this.onERC1155BatchReceived
			REF_2201(None) -> REF_2200.selector
			RETURN REF_2201
	Function IERC1155Receiver.onERC1155Received(address,address,uint256,uint256,bytes) 
	Function IERC1155Receiver.onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) 
	Function IERC165.supportsInterface(bytes4) 
	Function IERC721Receiver.onERC721Received(address,address,uint256,bytes) 
	Function AccessControl.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IAccessControl).interfaceId || super.supportsInterface(interfaceId)
		IRs:
			TMP_6862(type(IAccessControl)) = SOLIDITY_CALL type()(IAccessControl)
			REF_2202(bytes4) (->None) := 2036718347(bytes4)
			TMP_6863(bool) = interfaceId == REF_2202
			TMP_6864(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
			TMP_6865(bool) = TMP_6863 || TMP_6864
			RETURN TMP_6865
	Function AccessControl.hasRole(bytes32,address) (*)
		Expression: _roles[role].members[account]
		IRs:
			REF_2203(AccessControl.RoleData) -> _roles[role]
			REF_2204(mapping(address => bool)) -> REF_2203.members
			REF_2205(bool) -> REF_2204[account]
			RETURN REF_2205
	Function AccessControl._checkRole(bytes32) (*)
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_6866(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, AccessControl._checkRole(bytes32,address)(role,TMP_6866)
	Function AccessControl._checkRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_6868(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_6869 = UnaryType.BANG TMP_6868 
			CONDITION TMP_6869
		Expression: revert(string)(string(abi.encodePacked(AccessControl: account ,Strings.toHexString(account), is missing role ,Strings.toHexString(uint256(role),32))))
		IRs:
			TMP_6870(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(address), arguments:['account'] 
			TMP_6871 = CONVERT role to uint256
			TMP_6872(string) = LIBRARY_CALL, dest:Strings, function:Strings.toHexString(uint256,uint256), arguments:['TMP_6871', '32'] 
			TMP_6873(bytes) = SOLIDITY_CALL abi.encodePacked()(AccessControl: account ,TMP_6870, is missing role ,TMP_6872)
			TMP_6874 = CONVERT TMP_6873 to string
			TMP_6875(None) = SOLIDITY_CALL revert(string)(TMP_6874)
	Function AccessControl.getRoleAdmin(bytes32) (*)
		Expression: _roles[role].adminRole
		IRs:
			REF_2209(AccessControl.RoleData) -> _roles[role]
			REF_2210(bytes32) -> REF_2209.adminRole
			RETURN REF_2210
	Function AccessControl.grantRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_6877(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_6877)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_6879(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_6879)
	Function AccessControl.revokeRole(bytes32,address) (*)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_6882(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_6882)
		Expression: onlyRole(getRoleAdmin(role))
		IRs:
			TMP_6884(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			MODIFIER_CALL, AccessControl.onlyRole(bytes32)(TMP_6884)
	Function AccessControl.renounceRole(bytes32,address) (*)
		Expression: require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)
		IRs:
			TMP_6886(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_6887(bool) = account == TMP_6886
			TMP_6888(None) = SOLIDITY_CALL require(bool,string)(TMP_6887,AccessControl: can only renounce roles for self)
		Expression: _revokeRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)
	Function AccessControl._setupRole(bytes32,address) (*)
		Expression: _grantRole(role,account)
		IRs:
			INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)
	Function AccessControl._setRoleAdmin(bytes32,bytes32) (*)
		Expression: previousAdminRole = getRoleAdmin(role)
		IRs:
			TMP_6891(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
			previousAdminRole(bytes32) := TMP_6891(bytes32)
		Expression: _roles[role].adminRole = adminRole
		IRs:
			REF_2211(AccessControl.RoleData) -> _roles[role]
			REF_2212(bytes32) -> REF_2211.adminRole
			REF_2212(bytes32) (->_roles) := adminRole(bytes32)
		Expression: RoleAdminChanged(role,previousAdminRole,adminRole)
		IRs:
			Emit RoleAdminChanged(role,previousAdminRole,adminRole)
	Function AccessControl._grantRole(bytes32,address) (*)
		Expression: ! hasRole(role,account)
		IRs:
			TMP_6893(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			TMP_6894 = UnaryType.BANG TMP_6893 
			CONDITION TMP_6894
		Expression: _roles[role].members[account] = true
		IRs:
			REF_2213(AccessControl.RoleData) -> _roles[role]
			REF_2214(mapping(address => bool)) -> REF_2213.members
			REF_2215(bool) -> REF_2214[account]
			REF_2215(bool) (->_roles) := True(bool)
		Expression: RoleGranted(role,account,_msgSender())
		IRs:
			TMP_6895(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleGranted(role,account,TMP_6895)
	Function AccessControl._revokeRole(bytes32,address) (*)
		Expression: hasRole(role,account)
		IRs:
			TMP_6897(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
			CONDITION TMP_6897
		Expression: _roles[role].members[account] = false
		IRs:
			REF_2216(AccessControl.RoleData) -> _roles[role]
			REF_2217(mapping(address => bool)) -> REF_2216.members
			REF_2218(bool) -> REF_2217[account]
			REF_2218(bool) (->_roles) := False(bool)
		Expression: RoleRevoked(role,account,_msgSender())
		IRs:
			TMP_6898(address) = INTERNAL_CALL, Context._msgSender()()
			Emit RoleRevoked(role,account,TMP_6898)
	Function ERC165.supportsInterface(bytes4) 
		Expression: interfaceId == type()(IERC165).interfaceId
		IRs:
			TMP_6900(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
			REF_2219(bytes4) (->None) := 33540519(bytes4)
			TMP_6901(bool) = interfaceId == REF_2219
			RETURN TMP_6901
	Function IAccessControl.hasRole(bytes32,address) 
	Function IAccessControl.getRoleAdmin(bytes32) 
	Function IAccessControl.grantRole(bytes32,address) 
	Function IAccessControl.revokeRole(bytes32,address) 
	Function IAccessControl.renounceRole(bytes32,address) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Timelock.constructor(uint256,address[],address[]) (*)
		Expression: TimelockController(_minDelay,_proposers,_executors,msg.sender)
		IRs:
			INTERNAL_CALL, TimelockController.constructor(uint256,address[],address[],address)(_minDelay,_proposers,_executors,msg.sender)
	Function Timelock.slitherConstructorConstantVariables() (*)
		Expression: DEFAULT_ADMIN_ROLE = 0x00
		IRs:
			DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)
		Expression: TIMELOCK_ADMIN_ROLE = keccak256(bytes)(TIMELOCK_ADMIN_ROLE)
		IRs:
			TMP_6903(bytes32) = SOLIDITY_CALL keccak256(bytes)(TIMELOCK_ADMIN_ROLE)
			TIMELOCK_ADMIN_ROLE(bytes32) := TMP_6903(bytes32)
		Expression: PROPOSER_ROLE = keccak256(bytes)(PROPOSER_ROLE)
		IRs:
			TMP_6904(bytes32) = SOLIDITY_CALL keccak256(bytes)(PROPOSER_ROLE)
			PROPOSER_ROLE(bytes32) := TMP_6904(bytes32)
		Expression: EXECUTOR_ROLE = keccak256(bytes)(EXECUTOR_ROLE)
		IRs:
			TMP_6905(bytes32) = SOLIDITY_CALL keccak256(bytes)(EXECUTOR_ROLE)
			EXECUTOR_ROLE(bytes32) := TMP_6905(bytes32)
		Expression: CANCELLER_ROLE = keccak256(bytes)(CANCELLER_ROLE)
		IRs:
			TMP_6906(bytes32) = SOLIDITY_CALL keccak256(bytes)(CANCELLER_ROLE)
			CANCELLER_ROLE(bytes32) := TMP_6906(bytes32)
		Expression: _DONE_TIMESTAMP = uint256(1)
		IRs:
			TMP_6907 = CONVERT 1 to uint256
			_DONE_TIMESTAMP(uint256) := TMP_6907(uint256)
	Modifier TimelockController.onlyRoleOrOpenRole(bytes32)
		Expression: ! hasRole(role,address(0))
		IRs:
			TMP_6908 = CONVERT 0 to address
			TMP_6909(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,TMP_6908)
			TMP_6910 = UnaryType.BANG TMP_6909 
			CONDITION TMP_6910
		Expression: _checkRole(role,_msgSender())
		IRs:
			TMP_6911(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, AccessControl._checkRole(bytes32,address)(role,TMP_6911)
	Modifier AccessControl.onlyRole(bytes32)
		Expression: _checkRole(role)
		IRs:
			INTERNAL_CALL, AccessControl._checkRole(bytes32)(role)
Contract UseAAVEv3
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_6914 = UnaryType.BANG _initializing 
			TMP_6915(None) = SOLIDITY_CALL require(bool,string)(TMP_6914,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_6917(uint8) := 255(uint8)
			TMP_6918(bool) = _initialized != TMP_6917
			CONDITION TMP_6918
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_6920(uint8) := 255(uint8)
			_initialized(uint8) := TMP_6920(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_6922(uint8) := 255(uint8)
			Emit Initialized(TMP_6922)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseAAVEv3._initUseAAVEv3(address) (*)
		Expression: _aavev3 = IPoolV3(aaveV3Pool)
		IRs:
			TMP_6924 = CONVERT aaveV3Pool to IPoolV3
			_aavev3(IPoolV3) := TMP_6924(IPoolV3)
		Expression: address(_aavev3) == address(0)
		IRs:
			TMP_6925 = CONVERT _aavev3 to address
			TMP_6926 = CONVERT 0 to address
			TMP_6927(bool) = TMP_6925 == TMP_6926
			CONDITION TMP_6927
		Expression: revert InvalidAAVEv3Contract()()
		IRs:
			TMP_6928(None) = SOLIDITY_CALL revert InvalidAAVEv3Contract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseAAVEv3.aaveV3() (*)
		Expression: _aavev3
		IRs:
			RETURN _aavev3
	Function UseAAVEv3.aaveV3A() (*)
		Expression: address(_aavev3)
		IRs:
			TMP_6930 = CONVERT _aavev3 to address
			RETURN TMP_6930
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_6931 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_6931(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_6932(bool) = _initialized < 1
			TMP_6933(bool) = isTopLevelCall && TMP_6932
			TMP_6934 = CONVERT this to address
			TMP_6935(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_6934'] 
			TMP_6936 = UnaryType.BANG TMP_6935 
			TMP_6937(bool) = _initialized == 1
			TMP_6938(bool) = TMP_6936 && TMP_6937
			TMP_6939(bool) = TMP_6933 || TMP_6938
			TMP_6940(None) = SOLIDITY_CALL require(bool,string)(TMP_6939,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_6942 = UnaryType.BANG _initializing 
			TMP_6943(bool) = _initialized < version
			TMP_6944(bool) = TMP_6942 && TMP_6943
			TMP_6945(None) = SOLIDITY_CALL require(bool,string)(TMP_6944,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_6947(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseFlashLender
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_6948 = UnaryType.BANG _initializing 
			TMP_6949(None) = SOLIDITY_CALL require(bool,string)(TMP_6948,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_6951(uint8) := 255(uint8)
			TMP_6952(bool) = _initialized != TMP_6951
			CONDITION TMP_6952
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_6954(uint8) := 255(uint8)
			_initialized(uint8) := TMP_6954(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_6956(uint8) := 255(uint8)
			Emit Initialized(TMP_6956)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_6958 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_6958(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_6959 = CONVERT _fLender to address
			TMP_6960 = CONVERT 0 to address
			TMP_6961(bool) = TMP_6959 == TMP_6960
			CONDITION TMP_6961
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_6962(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_6964 = CONVERT _fLender to address
			RETURN TMP_6964
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_6965 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_6965(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_6966(bool) = _initialized < 1
			TMP_6967(bool) = isTopLevelCall && TMP_6966
			TMP_6968 = CONVERT this to address
			TMP_6969(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_6968'] 
			TMP_6970 = UnaryType.BANG TMP_6969 
			TMP_6971(bool) = _initialized == 1
			TMP_6972(bool) = TMP_6970 && TMP_6971
			TMP_6973(bool) = TMP_6967 || TMP_6972
			TMP_6974(None) = SOLIDITY_CALL require(bool,string)(TMP_6973,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_6976 = UnaryType.BANG _initializing 
			TMP_6977(bool) = _initialized < version
			TMP_6978(bool) = TMP_6976 && TMP_6977
			TMP_6979(None) = SOLIDITY_CALL require(bool,string)(TMP_6978,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_6981(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseIERC20
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_6982 = UnaryType.BANG _initializing 
			TMP_6983(None) = SOLIDITY_CALL require(bool,string)(TMP_6982,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_6985(uint8) := 255(uint8)
			TMP_6986(bool) = _initialized != TMP_6985
			CONDITION TMP_6986
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_6988(uint8) := 255(uint8)
			_initialized(uint8) := TMP_6988(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_6990(uint8) := 255(uint8)
			Emit Initialized(TMP_6990)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseIERC20._initUseIERC20(VaultRegistry,bytes32) (*)
		Expression: _ierc20 = IERC20(registry.getServiceFromHash(name))
		IRs:
			TMP_6992(address) = HIGH_LEVEL_CALL, dest:registry(VaultRegistry), function:getServiceFromHash, arguments:['name']  
			TMP_6993 = CONVERT TMP_6992 to IERC20
			_ierc20(IERC20) := TMP_6993(IERC20)
		Expression: address(_ierc20) == address(0)
		IRs:
			TMP_6994 = CONVERT _ierc20 to address
			TMP_6995 = CONVERT 0 to address
			TMP_6996(bool) = TMP_6994 == TMP_6995
			CONDITION TMP_6996
		Expression: revert InvalidIERC20Contract()()
		IRs:
			TMP_6997(None) = SOLIDITY_CALL revert InvalidIERC20Contract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseIERC20.ierc20() (*)
		Expression: _ierc20
		IRs:
			RETURN _ierc20
	Function UseIERC20.ierc20A() (*)
		Expression: address(_ierc20)
		IRs:
			TMP_6999 = CONVERT _ierc20 to address
			RETURN TMP_6999
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7000 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7000(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7001(bool) = _initialized < 1
			TMP_7002(bool) = isTopLevelCall && TMP_7001
			TMP_7003 = CONVERT this to address
			TMP_7004(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7003'] 
			TMP_7005 = UnaryType.BANG TMP_7004 
			TMP_7006(bool) = _initialized == 1
			TMP_7007(bool) = TMP_7005 && TMP_7006
			TMP_7008(bool) = TMP_7002 || TMP_7007
			TMP_7009(None) = SOLIDITY_CALL require(bool,string)(TMP_7008,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7011 = UnaryType.BANG _initializing 
			TMP_7012(bool) = _initialized < version
			TMP_7013(bool) = TMP_7011 && TMP_7012
			TMP_7014(None) = SOLIDITY_CALL require(bool,string)(TMP_7013,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7016(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseIERC4626
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_7020 = CONVERT 0 to address
			TMP_7021(bool) = _newGovernor == TMP_7020
			CONDITION TMP_7021
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_7022(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_7028(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7028)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_7031(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_7032(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_7033(bool) = TMP_7031 == TMP_7032
			TMP_7034(None) = SOLIDITY_CALL require(bool,string)(TMP_7033,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_7035 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7035)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_7038 = CONVERT 0 to address
			TMP_7039(bool) = newOwner != TMP_7038
			TMP_7040(None) = SOLIDITY_CALL require(bool,string)(TMP_7039,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7046 = UnaryType.BANG _initializing 
			TMP_7047(None) = SOLIDITY_CALL require(bool,string)(TMP_7046,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7049(uint8) := 255(uint8)
			TMP_7050(bool) = _initialized != TMP_7049
			CONDITION TMP_7050
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7052(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7052(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7054(uint8) := 255(uint8)
			Emit Initialized(TMP_7054)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseIERC4626.initializeUseIERC4626(address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialOwner)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialOwner)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseIERC4626.approveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = true
		IRs:
			REF_2224(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2225(bool) -> REF_2224[token]
			REF_2225(bool) (->_approvedVaults) := True(bool)
		Expression: ! IERC20(token).approve(address(vault),2 ** 256 - 1)
		IRs:
			TMP_7059 = CONVERT token to IERC20
			TMP_7060 = CONVERT vault to address
			TMP_7061(uint256) = 2 (c)** 256
			TMP_7062(uint256) = TMP_7061 (c)- 1
			TMP_7063(bool) = HIGH_LEVEL_CALL, dest:TMP_7059(IERC20), function:approve, arguments:['TMP_7060', 'TMP_7062']  
			TMP_7064 = UnaryType.BANG TMP_7063 
			CONDITION TMP_7064
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_7065(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.isTokenApprovedForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token]
		IRs:
			REF_2227(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2228(bool) -> REF_2227[token]
			RETURN REF_2228
	Function UseIERC4626.unapproveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = false
		IRs:
			REF_2229(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2230(bool) -> REF_2229[token]
			REF_2230(bool) (->_approvedVaults) := False(bool)
		Expression: ! IERC20(token).approve(address(vault),0)
		IRs:
			TMP_7067 = CONVERT token to IERC20
			TMP_7068 = CONVERT vault to address
			TMP_7069(bool) = HIGH_LEVEL_CALL, dest:TMP_7067(IERC20), function:approve, arguments:['TMP_7068', '0']  
			TMP_7070 = UnaryType.BANG TMP_7069 
			CONDITION TMP_7070
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_7071(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.convertToVaultAssets(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7073 = CONVERT vault to address
			TMP_7074 = CONVERT 0 to address
			TMP_7075(bool) = TMP_7073 == TMP_7074
			CONDITION TMP_7075
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7076(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToAssets(shares)
		IRs:
			TMP_7077(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToAssets, arguments:['shares']  
			RETURN TMP_7077
	Function UseIERC4626.convertToVaultShares(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7078 = CONVERT vault to address
			TMP_7079 = CONVERT 0 to address
			TMP_7080(bool) = TMP_7078 == TMP_7079
			CONDITION TMP_7080
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7081(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToShares(assets)
		IRs:
			TMP_7082(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToShares, arguments:['assets']  
			RETURN TMP_7082
	Function UseIERC4626.totalVaultAssets(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7083 = CONVERT vault to address
			TMP_7084 = CONVERT 0 to address
			TMP_7085(bool) = TMP_7083 == TMP_7084
			CONDITION TMP_7085
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7086(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.totalAssets()
		IRs:
			TMP_7087(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:totalAssets, arguments:[]  
			RETURN TMP_7087
	Function UseIERC4626.vaultAsset(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7088 = CONVERT vault to address
			TMP_7089 = CONVERT 0 to address
			TMP_7090(bool) = TMP_7088 == TMP_7089
			CONDITION TMP_7090
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7091(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.asset()
		IRs:
			TMP_7092(address) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:asset, arguments:[]  
			RETURN TMP_7092
	Function UseIERC4626.depositVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7093 = CONVERT vault to address
			TMP_7094 = CONVERT 0 to address
			TMP_7095(bool) = TMP_7093 == TMP_7094
			CONDITION TMP_7095
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7096(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: shares = vault.deposit(assets,receiver)
		IRs:
			TMP_7097(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:deposit, arguments:['assets', 'receiver']  
			shares(uint256) := TMP_7097(uint256)
	Function UseIERC4626.mintVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7098 = CONVERT vault to address
			TMP_7099 = CONVERT 0 to address
			TMP_7100(bool) = TMP_7098 == TMP_7099
			CONDITION TMP_7100
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7101(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.mint(shares,receiver)
		IRs:
			TMP_7102(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:mint, arguments:['shares', 'receiver']  
			assets(uint256) := TMP_7102(uint256)
	Function UseIERC4626.withdrawVault(IERC4626,uint256,address,address) (*)
		Expression: shares = vault.withdraw(assets,receiver,owner)
		IRs:
			TMP_7103(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:withdraw, arguments:['assets', 'receiver', 'owner']  
			shares(uint256) := TMP_7103(uint256)
	Function UseIERC4626.redeemVault(IERC4626,uint256,address,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7104 = CONVERT vault to address
			TMP_7105 = CONVERT 0 to address
			TMP_7106(bool) = TMP_7104 == TMP_7105
			CONDITION TMP_7106
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7107(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.redeem(shares,receiver,owner)
		IRs:
			TMP_7108(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:redeem, arguments:['shares', 'receiver', 'owner']  
			assets(uint256) := TMP_7108(uint256)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_7109(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_7110(bool) = msg.sender != TMP_7109
			CONDITION TMP_7110
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_7111(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7113 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7113(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7114(bool) = _initialized < 1
			TMP_7115(bool) = isTopLevelCall && TMP_7114
			TMP_7116 = CONVERT this to address
			TMP_7117(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7116'] 
			TMP_7118 = UnaryType.BANG TMP_7117 
			TMP_7119(bool) = _initialized == 1
			TMP_7120(bool) = TMP_7118 && TMP_7119
			TMP_7121(bool) = TMP_7115 || TMP_7120
			TMP_7122(None) = SOLIDITY_CALL require(bool,string)(TMP_7121,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7124 = UnaryType.BANG _initializing 
			TMP_7125(bool) = _initialized < version
			TMP_7126(bool) = TMP_7124 && TMP_7125
			TMP_7127(None) = SOLIDITY_CALL require(bool,string)(TMP_7126,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7129(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseIERC4626Mock
	Function UseIERC4626.initializeUseIERC4626(address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialOwner)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialOwner)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseIERC4626.approveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = true
		IRs:
			REF_2241(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2242(bool) -> REF_2241[token]
			REF_2242(bool) (->_approvedVaults) := True(bool)
		Expression: ! IERC20(token).approve(address(vault),2 ** 256 - 1)
		IRs:
			TMP_7133 = CONVERT token to IERC20
			TMP_7134 = CONVERT vault to address
			TMP_7135(uint256) = 2 (c)** 256
			TMP_7136(uint256) = TMP_7135 (c)- 1
			TMP_7137(bool) = HIGH_LEVEL_CALL, dest:TMP_7133(IERC20), function:approve, arguments:['TMP_7134', 'TMP_7136']  
			TMP_7138 = UnaryType.BANG TMP_7137 
			CONDITION TMP_7138
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_7139(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.isTokenApprovedForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token]
		IRs:
			REF_2244(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2245(bool) -> REF_2244[token]
			RETURN REF_2245
	Function UseIERC4626.unapproveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = false
		IRs:
			REF_2246(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_2247(bool) -> REF_2246[token]
			REF_2247(bool) (->_approvedVaults) := False(bool)
		Expression: ! IERC20(token).approve(address(vault),0)
		IRs:
			TMP_7141 = CONVERT token to IERC20
			TMP_7142 = CONVERT vault to address
			TMP_7143(bool) = HIGH_LEVEL_CALL, dest:TMP_7141(IERC20), function:approve, arguments:['TMP_7142', '0']  
			TMP_7144 = UnaryType.BANG TMP_7143 
			CONDITION TMP_7144
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_7145(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.convertToVaultAssets(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7147 = CONVERT vault to address
			TMP_7148 = CONVERT 0 to address
			TMP_7149(bool) = TMP_7147 == TMP_7148
			CONDITION TMP_7149
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7150(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToAssets(shares)
		IRs:
			TMP_7151(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToAssets, arguments:['shares']  
			RETURN TMP_7151
	Function UseIERC4626.convertToVaultShares(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7152 = CONVERT vault to address
			TMP_7153 = CONVERT 0 to address
			TMP_7154(bool) = TMP_7152 == TMP_7153
			CONDITION TMP_7154
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7155(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToShares(assets)
		IRs:
			TMP_7156(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToShares, arguments:['assets']  
			RETURN TMP_7156
	Function UseIERC4626.totalVaultAssets(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7157 = CONVERT vault to address
			TMP_7158 = CONVERT 0 to address
			TMP_7159(bool) = TMP_7157 == TMP_7158
			CONDITION TMP_7159
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7160(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.totalAssets()
		IRs:
			TMP_7161(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:totalAssets, arguments:[]  
			RETURN TMP_7161
	Function UseIERC4626.vaultAsset(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7162 = CONVERT vault to address
			TMP_7163 = CONVERT 0 to address
			TMP_7164(bool) = TMP_7162 == TMP_7163
			CONDITION TMP_7164
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7165(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.asset()
		IRs:
			TMP_7166(address) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:asset, arguments:[]  
			RETURN TMP_7166
	Function UseIERC4626.depositVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7167 = CONVERT vault to address
			TMP_7168 = CONVERT 0 to address
			TMP_7169(bool) = TMP_7167 == TMP_7168
			CONDITION TMP_7169
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7170(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: shares = vault.deposit(assets,receiver)
		IRs:
			TMP_7171(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:deposit, arguments:['assets', 'receiver']  
			shares(uint256) := TMP_7171(uint256)
	Function UseIERC4626.mintVault(IERC4626,uint256,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7172 = CONVERT vault to address
			TMP_7173 = CONVERT 0 to address
			TMP_7174(bool) = TMP_7172 == TMP_7173
			CONDITION TMP_7174
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7175(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.mint(shares,receiver)
		IRs:
			TMP_7176(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:mint, arguments:['shares', 'receiver']  
			assets(uint256) := TMP_7176(uint256)
	Function UseIERC4626.withdrawVault(IERC4626,uint256,address,address) (*)
		Expression: shares = vault.withdraw(assets,receiver,owner)
		IRs:
			TMP_7177(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:withdraw, arguments:['assets', 'receiver', 'owner']  
			shares(uint256) := TMP_7177(uint256)
	Function UseIERC4626.redeemVault(IERC4626,uint256,address,address) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_7178 = CONVERT vault to address
			TMP_7179 = CONVERT 0 to address
			TMP_7180(bool) = TMP_7178 == TMP_7179
			CONDITION TMP_7180
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_7181(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.redeem(shares,receiver,owner)
		IRs:
			TMP_7182(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:redeem, arguments:['shares', 'receiver', 'owner']  
			assets(uint256) := TMP_7182(uint256)
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_7186 = CONVERT 0 to address
			TMP_7187(bool) = _newGovernor == TMP_7186
			CONDITION TMP_7187
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_7188(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_7194(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7194)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_7197(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_7198(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_7199(bool) = TMP_7197 == TMP_7198
			TMP_7200(None) = SOLIDITY_CALL require(bool,string)(TMP_7199,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_7201 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7201)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_7204 = CONVERT 0 to address
			TMP_7205(bool) = newOwner != TMP_7204
			TMP_7206(None) = SOLIDITY_CALL require(bool,string)(TMP_7205,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7212 = UnaryType.BANG _initializing 
			TMP_7213(None) = SOLIDITY_CALL require(bool,string)(TMP_7212,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7215(uint8) := 255(uint8)
			TMP_7216(bool) = _initialized != TMP_7215
			CONDITION TMP_7216
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7218(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7218(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7220(uint8) := 255(uint8)
			Emit Initialized(TMP_7220)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseIERC4626Mock.initialize(address) (*)
		Expression: initializeUseIERC4626(initialOwner)
		IRs:
			INTERNAL_CALL, UseIERC4626.initializeUseIERC4626(address)(initialOwner)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function UseIERC4626Mock.test__depositVault(IERC4626,uint256,address) (*)
		Expression: depositVault(vault,assets,receiver)
		IRs:
			TMP_7224(uint256) = INTERNAL_CALL, UseIERC4626.depositVault(IERC4626,uint256,address)(vault,assets,receiver)
			RETURN TMP_7224
	Function UseIERC4626Mock.test__mintVault(IERC4626,uint256,address) (*)
		Expression: mintVault(vault,shares,receiver)
		IRs:
			TMP_7225(uint256) = INTERNAL_CALL, UseIERC4626.mintVault(IERC4626,uint256,address)(vault,shares,receiver)
			RETURN TMP_7225
	Function UseIERC4626Mock.test__withdrawVault(IERC4626,uint256,address,address) (*)
		Expression: withdrawVault(vault,assets,receiver,owner)
		IRs:
			TMP_7226(uint256) = INTERNAL_CALL, UseIERC4626.withdrawVault(IERC4626,uint256,address,address)(vault,assets,receiver,owner)
			RETURN TMP_7226
	Function UseIERC4626Mock.test__redeemVault(IERC4626,uint256,address,address) (*)
		Expression: redeemVault(vault,shares,receiver,owner)
		IRs:
			TMP_7227(uint256) = INTERNAL_CALL, UseIERC4626.redeemVault(IERC4626,uint256,address,address)(vault,shares,receiver,owner)
			RETURN TMP_7227
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_7228(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_7229(bool) = msg.sender != TMP_7228
			CONDITION TMP_7229
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_7230(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7232 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7232(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7233(bool) = _initialized < 1
			TMP_7234(bool) = isTopLevelCall && TMP_7233
			TMP_7235 = CONVERT this to address
			TMP_7236(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7235'] 
			TMP_7237 = UnaryType.BANG TMP_7236 
			TMP_7238(bool) = _initialized == 1
			TMP_7239(bool) = TMP_7237 && TMP_7238
			TMP_7240(bool) = TMP_7234 || TMP_7239
			TMP_7241(None) = SOLIDITY_CALL require(bool,string)(TMP_7240,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7243 = UnaryType.BANG _initializing 
			TMP_7244(bool) = _initialized < version
			TMP_7245(bool) = TMP_7243 && TMP_7244
			TMP_7246(None) = SOLIDITY_CALL require(bool,string)(TMP_7245,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7248(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseLeverage
	Function UseLeverage._calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_7249(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_7249
		Expression: revert InvalidNumberOfLoops()()
		IRs:
			TMP_7250(None) = SOLIDITY_CALL revert InvalidNumberOfLoops()()
		Expression: loanToValue == 0 || loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_7251(bool) = loanToValue == 0
			TMP_7252(bool) = loanToValue > PERCENTAGE_PRECISION
			TMP_7253(bool) = TMP_7251 || TMP_7252
			CONDITION TMP_7253
		Expression: revert InvalidLoanToValue()()
		IRs:
			TMP_7254(None) = SOLIDITY_CALL revert InvalidLoanToValue()()
		Expression: leverage = baseValue
		IRs:
			leverage(uint256) := baseValue(uint256)
		Expression: prev = baseValue
		IRs:
			prev(uint256) := baseValue(uint256)
		Expression: i = 1
		IRs:
			i(uint8) := 1(uint256)
		Expression: i <= nrLoops
		IRs:
			TMP_7255(bool) = i <= nrLoops
			CONDITION TMP_7255
		Expression: inc = (prev * loanToValue) / PERCENTAGE_PRECISION
		IRs:
			TMP_7256(uint256) = prev (c)* loanToValue
			TMP_7257(uint256) = TMP_7256 (c)/ PERCENTAGE_PRECISION
			inc(uint256) := TMP_7257(uint256)
		Expression: leverage += inc
		IRs:
			leverage(uint256) = leverage (c)+ inc
		Expression: prev = inc
		IRs:
			prev(uint256) := inc(uint256)
		Expression: ++ i
		IRs:
			i(uint8) = i + 1
		Expression: leverage
		IRs:
			RETURN leverage
	Function UseLeverage._calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: percentageToBurn == 0 || percentageToBurn > PERCENTAGE_PRECISION
		IRs:
			TMP_7258(bool) = percentageToBurn == 0
			TMP_7259(bool) = percentageToBurn > PERCENTAGE_PRECISION
			TMP_7260(bool) = TMP_7258 || TMP_7259
			CONDITION TMP_7260
		Expression: revert InvalidPercentageValue()()
		IRs:
			TMP_7261(None) = SOLIDITY_CALL revert InvalidPercentageValue()()
		Expression: deltaDebtInETH = (totalDebtBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_7262(uint256) = totalDebtBaseInEth (c)* percentageToBurn
			TMP_7263(uint256) = TMP_7262 (c)/ PERCENTAGE_PRECISION
			deltaDebtInETH(uint256) := TMP_7263(uint256)
		Expression: deltaCollateralInETH = (totalCollateralBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_7264(uint256) = totalCollateralBaseInEth (c)* percentageToBurn
			TMP_7265(uint256) = TMP_7264 (c)/ PERCENTAGE_PRECISION
			deltaCollateralInETH(uint256) := TMP_7265(uint256)
	Function UseLeverage._calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: colValue = ((targetLoanToValue * collateral) / PERCENTAGE_PRECISION)
		IRs:
			TMP_7266(uint256) = targetLoanToValue (c)* collateral
			TMP_7267(uint256) = TMP_7266 (c)/ PERCENTAGE_PRECISION
			colValue(uint256) := TMP_7267(uint256)
		Expression: colValue >= debt
		IRs:
			TMP_7268(bool) = colValue >= debt
			CONDITION TMP_7268
		Expression: revert InvalidTargetValue()()
		IRs:
			TMP_7269(None) = SOLIDITY_CALL revert InvalidTargetValue()()
		Expression: numerator = debt - colValue
		IRs:
			TMP_7270(uint256) = debt (c)- colValue
			numerator(uint256) := TMP_7270(uint256)
		Expression: divisor = (PERCENTAGE_PRECISION - targetLoanToValue)
		IRs:
			TMP_7271(uint256) = PERCENTAGE_PRECISION (c)- targetLoanToValue
			divisor(uint256) := TMP_7271(uint256)
		Expression: divisor == 0
		IRs:
			TMP_7272(bool) = divisor == 0
			CONDITION TMP_7272
		Expression: revert InvalidDivisor()()
		IRs:
			TMP_7273(None) = SOLIDITY_CALL revert InvalidDivisor()()
		Expression: delta = (numerator * PERCENTAGE_PRECISION) / divisor
		IRs:
			TMP_7274(uint256) = numerator (c)* PERCENTAGE_PRECISION
			TMP_7275(uint256) = TMP_7274 (c)/ divisor
			delta(uint256) := TMP_7275(uint256)
Contract UseOracle
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7276 = UnaryType.BANG _initializing 
			TMP_7277(None) = SOLIDITY_CALL require(bool,string)(TMP_7276,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7279(uint8) := 255(uint8)
			TMP_7280(bool) = _initialized != TMP_7279
			CONDITION TMP_7280
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7282(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7282(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7284(uint8) := 255(uint8)
			Emit Initialized(TMP_7284)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseOracle._initUseOracle(address) (*)
		Expression: _oracle = IOracle(oracleAddress)
		IRs:
			TMP_7286 = CONVERT oracleAddress to IOracle
			_oracle(IOracle) := TMP_7286(IOracle)
		Expression: address(_oracle) == address(0)
		IRs:
			TMP_7287 = CONVERT _oracle to address
			TMP_7288 = CONVERT 0 to address
			TMP_7289(bool) = TMP_7287 == TMP_7288
			CONDITION TMP_7289
		Expression: revert InvalidOracleContract()()
		IRs:
			TMP_7290(None) = SOLIDITY_CALL revert InvalidOracleContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseOracle.oracle() (*)
		Expression: _oracle
		IRs:
			RETURN _oracle
	Function UseOracle.getLastPrice() (*)
		Expression: _oracle.getLatestPrice()
		IRs:
			TMP_7292(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getLatestPrice, arguments:[]  
			RETURN TMP_7292
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7293 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7293(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7294(bool) = _initialized < 1
			TMP_7295(bool) = isTopLevelCall && TMP_7294
			TMP_7296 = CONVERT this to address
			TMP_7297(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7296'] 
			TMP_7298 = UnaryType.BANG TMP_7297 
			TMP_7299(bool) = _initialized == 1
			TMP_7300(bool) = TMP_7298 && TMP_7299
			TMP_7301(bool) = TMP_7295 || TMP_7300
			TMP_7302(None) = SOLIDITY_CALL require(bool,string)(TMP_7301,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7304 = UnaryType.BANG _initializing 
			TMP_7305(bool) = _initialized < version
			TMP_7306(bool) = TMP_7304 && TMP_7305
			TMP_7307(None) = SOLIDITY_CALL require(bool,string)(TMP_7306,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7309(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UsePermitTransfers
	Function UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) (*)
		Expression: IERC20Permit(token).permit(owner,address(this),amount,deadline,v,r,s)
		IRs:
			TMP_7310 = CONVERT token to IERC20Permit
			TMP_7311 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_7310(IERC20Permit), function:permit, arguments:['owner', 'TMP_7311', 'amount', 'deadline', 'v', 'r', 's']  
		Expression: IERC20(address(token)).safeTransferFrom(owner,address(this),amount)
		IRs:
			TMP_7313 = CONVERT token to address
			TMP_7314 = CONVERT TMP_7313 to IERC20
			TMP_7315 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7314', 'owner', 'TMP_7315', 'amount'] 
Contract UsePermitTransfersMock
	Function UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) (*)
		Expression: IERC20Permit(token).permit(owner,address(this),amount,deadline,v,r,s)
		IRs:
			TMP_7317 = CONVERT token to IERC20Permit
			TMP_7318 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_7317(IERC20Permit), function:permit, arguments:['owner', 'TMP_7318', 'amount', 'deadline', 'v', 'r', 's']  
		Expression: IERC20(address(token)).safeTransferFrom(owner,address(this),amount)
		IRs:
			TMP_7320 = CONVERT token to address
			TMP_7321 = CONVERT TMP_7320 to IERC20
			TMP_7322 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7321', 'owner', 'TMP_7322', 'amount'] 
	Function UsePermitTransfersMock.test__pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) (*)
		Expression: pullTokensWithPermit(token,amount,owner,deadline,v,r,s)
		IRs:
			INTERNAL_CALL, UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32)(token,amount,owner,deadline,v,r,s)
Contract UseStETH
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7325 = UnaryType.BANG _initializing 
			TMP_7326(None) = SOLIDITY_CALL require(bool,string)(TMP_7325,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7328(uint8) := 255(uint8)
			TMP_7329(bool) = _initialized != TMP_7328
			CONDITION TMP_7329
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7331(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7331(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7333(uint8) := 255(uint8)
			Emit Initialized(TMP_7333)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseStETH._initUseStETH(address) (*)
		Expression: _stETH = IERC20(istETH)
		IRs:
			TMP_7335 = CONVERT istETH to IERC20
			_stETH(IERC20) := TMP_7335(IERC20)
		Expression: address(_stETH) == address(0)
		IRs:
			TMP_7336 = CONVERT _stETH to address
			TMP_7337 = CONVERT 0 to address
			TMP_7338(bool) = TMP_7336 == TMP_7337
			CONDITION TMP_7338
		Expression: revert UseStETHInvalidStETHContract()()
		IRs:
			TMP_7339(None) = SOLIDITY_CALL revert UseStETHInvalidStETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseStETH.stETH() (*)
		Expression: _stETH
		IRs:
			RETURN _stETH
	Function UseStETH.stETHA() (*)
		Expression: address(_stETH)
		IRs:
			TMP_7341 = CONVERT _stETH to address
			RETURN TMP_7341
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7342 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7342(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7343(bool) = _initialized < 1
			TMP_7344(bool) = isTopLevelCall && TMP_7343
			TMP_7345 = CONVERT this to address
			TMP_7346(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7345'] 
			TMP_7347 = UnaryType.BANG TMP_7346 
			TMP_7348(bool) = _initialized == 1
			TMP_7349(bool) = TMP_7347 && TMP_7348
			TMP_7350(bool) = TMP_7344 || TMP_7349
			TMP_7351(None) = SOLIDITY_CALL require(bool,string)(TMP_7350,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7353 = UnaryType.BANG _initializing 
			TMP_7354(bool) = _initialized < version
			TMP_7355(bool) = TMP_7353 && TMP_7354
			TMP_7356(None) = SOLIDITY_CALL require(bool,string)(TMP_7355,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7358(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseStrategy
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7359 = UnaryType.BANG _initializing 
			TMP_7360(None) = SOLIDITY_CALL require(bool,string)(TMP_7359,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7362(uint8) := 255(uint8)
			TMP_7363(bool) = _initialized != TMP_7362
			CONDITION TMP_7363
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7365(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7365(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7367(uint8) := 255(uint8)
			Emit Initialized(TMP_7367)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseStrategy._initUseStrategy(address) (*)
		Expression: _strategy = IStrategy(istrategy)
		IRs:
			TMP_7369 = CONVERT istrategy to IStrategy
			_strategy(IStrategy) := TMP_7369(IStrategy)
		Expression: address(_strategy) == address(0)
		IRs:
			TMP_7370 = CONVERT _strategy to address
			TMP_7371 = CONVERT 0 to address
			TMP_7372(bool) = TMP_7370 == TMP_7371
			CONDITION TMP_7372
		Expression: revert InvalidStrategyContract()()
		IRs:
			TMP_7373(None) = SOLIDITY_CALL revert InvalidStrategyContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseStrategy.strategy() (*)
		Expression: _strategy
		IRs:
			RETURN _strategy
	Function UseStrategy.strategyA() (*)
		Expression: address(_strategy)
		IRs:
			TMP_7375 = CONVERT _strategy to address
			RETURN TMP_7375
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7376 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7376(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7377(bool) = _initialized < 1
			TMP_7378(bool) = isTopLevelCall && TMP_7377
			TMP_7379 = CONVERT this to address
			TMP_7380(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7379'] 
			TMP_7381 = UnaryType.BANG TMP_7380 
			TMP_7382(bool) = _initialized == 1
			TMP_7383(bool) = TMP_7381 && TMP_7382
			TMP_7384(bool) = TMP_7378 || TMP_7383
			TMP_7385(None) = SOLIDITY_CALL require(bool,string)(TMP_7384,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7387 = UnaryType.BANG _initializing 
			TMP_7388(bool) = _initialized < version
			TMP_7389(bool) = TMP_7387 && TMP_7388
			TMP_7390(None) = SOLIDITY_CALL require(bool,string)(TMP_7389,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7392(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseTokenActions
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7393 = UnaryType.BANG _initializing 
			TMP_7394(None) = SOLIDITY_CALL require(bool,string)(TMP_7393,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7396(uint8) := 255(uint8)
			TMP_7397(bool) = _initialized != TMP_7396
			CONDITION TMP_7397
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7399(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7399(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7401(uint8) := 255(uint8)
			Emit Initialized(TMP_7401)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseTokenActions.pullToken(IERC20,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7403 = CONVERT token to address
			TMP_7404 = CONVERT 0 to address
			TMP_7405(bool) = TMP_7403 == TMP_7404
			CONDITION TMP_7405
		Expression: revert InvalidToken()()
		IRs:
			TMP_7406(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(msg.sender,address(this)) < amount
		IRs:
			TMP_7407 = CONVERT this to address
			TMP_7408(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['msg.sender', 'TMP_7407']  
			TMP_7409(bool) = TMP_7408 < amount
			CONDITION TMP_7409
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7410(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_7411 = CONVERT token to IERC20
			TMP_7412 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7411', 'msg.sender', 'TMP_7412', 'amount'] 
	Function UseTokenActions.pullTokenFrom(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7414 = CONVERT token to address
			TMP_7415 = CONVERT 0 to address
			TMP_7416(bool) = TMP_7414 == TMP_7415
			CONDITION TMP_7416
		Expression: revert InvalidToken()()
		IRs:
			TMP_7417(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_7418 = CONVERT this to address
			TMP_7419(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_7418']  
			TMP_7420(bool) = TMP_7419 < amount
			CONDITION TMP_7420
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7421(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,address(this),amount)
		IRs:
			TMP_7422 = CONVERT token to IERC20
			TMP_7423 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7422', 'from', 'TMP_7423', 'amount'] 
	Function UseTokenActions.pushToken(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7425 = CONVERT token to address
			TMP_7426 = CONVERT 0 to address
			TMP_7427(bool) = TMP_7425 == TMP_7426
			CONDITION TMP_7427
		Expression: revert InvalidToken()()
		IRs:
			TMP_7428(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7429 = CONVERT to to address
			TMP_7430 = CONVERT 0 to address
			TMP_7431(bool) = TMP_7429 == TMP_7430
			CONDITION TMP_7431
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7432(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: IERC20(token).safeTransfer(to,amount)
		IRs:
			TMP_7433 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_7433', 'to', 'amount'] 
	Function UseTokenActions.pushTokenFrom(IERC20,address,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7435 = CONVERT token to address
			TMP_7436 = CONVERT 0 to address
			TMP_7437(bool) = TMP_7435 == TMP_7436
			CONDITION TMP_7437
		Expression: revert InvalidToken()()
		IRs:
			TMP_7438(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7439 = CONVERT to to address
			TMP_7440 = CONVERT 0 to address
			TMP_7441(bool) = TMP_7439 == TMP_7440
			CONDITION TMP_7441
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7442(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_7443 = CONVERT this to address
			TMP_7444(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_7443']  
			TMP_7445(bool) = TMP_7444 < amount
			CONDITION TMP_7445
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7446(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,to,amount)
		IRs:
			TMP_7447 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7447', 'from', 'to', 'amount'] 
	Function UseTokenActions.sweepTokens(IERC20,address) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7449 = CONVERT token to address
			TMP_7450 = CONVERT 0 to address
			TMP_7451(bool) = TMP_7449 == TMP_7450
			CONDITION TMP_7451
		Expression: revert InvalidToken()()
		IRs:
			TMP_7452(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7453 = CONVERT to to address
			TMP_7454 = CONVERT 0 to address
			TMP_7455(bool) = TMP_7453 == TMP_7454
			CONDITION TMP_7455
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7456(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: sweptAmount = IERC20(token).balanceOf(address(this))
		IRs:
			TMP_7457 = CONVERT token to IERC20
			TMP_7458 = CONVERT this to address
			TMP_7459(uint256) = HIGH_LEVEL_CALL, dest:TMP_7457(IERC20), function:balanceOf, arguments:['TMP_7458']  
			sweptAmount(uint256) := TMP_7459(uint256)
		Expression: IERC20(token).safeTransfer(to,sweptAmount)
		IRs:
			TMP_7460 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_7460', 'to', 'sweptAmount'] 
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7462 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7462(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7463(bool) = _initialized < 1
			TMP_7464(bool) = isTopLevelCall && TMP_7463
			TMP_7465 = CONVERT this to address
			TMP_7466(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7465'] 
			TMP_7467 = UnaryType.BANG TMP_7466 
			TMP_7468(bool) = _initialized == 1
			TMP_7469(bool) = TMP_7467 && TMP_7468
			TMP_7470(bool) = TMP_7464 || TMP_7469
			TMP_7471(None) = SOLIDITY_CALL require(bool,string)(TMP_7470,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7473 = UnaryType.BANG _initializing 
			TMP_7474(bool) = _initialized < version
			TMP_7475(bool) = TMP_7473 && TMP_7474
			TMP_7476(None) = SOLIDITY_CALL require(bool,string)(TMP_7475,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7478(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseTokenActionsMock
	Function UseTokenActions.pullToken(IERC20,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7479 = CONVERT token to address
			TMP_7480 = CONVERT 0 to address
			TMP_7481(bool) = TMP_7479 == TMP_7480
			CONDITION TMP_7481
		Expression: revert InvalidToken()()
		IRs:
			TMP_7482(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(msg.sender,address(this)) < amount
		IRs:
			TMP_7483 = CONVERT this to address
			TMP_7484(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['msg.sender', 'TMP_7483']  
			TMP_7485(bool) = TMP_7484 < amount
			CONDITION TMP_7485
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7486(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_7487 = CONVERT token to IERC20
			TMP_7488 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7487', 'msg.sender', 'TMP_7488', 'amount'] 
	Function UseTokenActions.pullTokenFrom(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7490 = CONVERT token to address
			TMP_7491 = CONVERT 0 to address
			TMP_7492(bool) = TMP_7490 == TMP_7491
			CONDITION TMP_7492
		Expression: revert InvalidToken()()
		IRs:
			TMP_7493(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_7494 = CONVERT this to address
			TMP_7495(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_7494']  
			TMP_7496(bool) = TMP_7495 < amount
			CONDITION TMP_7496
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7497(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,address(this),amount)
		IRs:
			TMP_7498 = CONVERT token to IERC20
			TMP_7499 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7498', 'from', 'TMP_7499', 'amount'] 
	Function UseTokenActions.pushToken(IERC20,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7501 = CONVERT token to address
			TMP_7502 = CONVERT 0 to address
			TMP_7503(bool) = TMP_7501 == TMP_7502
			CONDITION TMP_7503
		Expression: revert InvalidToken()()
		IRs:
			TMP_7504(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7505 = CONVERT to to address
			TMP_7506 = CONVERT 0 to address
			TMP_7507(bool) = TMP_7505 == TMP_7506
			CONDITION TMP_7507
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7508(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: IERC20(token).safeTransfer(to,amount)
		IRs:
			TMP_7509 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_7509', 'to', 'amount'] 
	Function UseTokenActions.pushTokenFrom(IERC20,address,address,uint256) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7511 = CONVERT token to address
			TMP_7512 = CONVERT 0 to address
			TMP_7513(bool) = TMP_7511 == TMP_7512
			CONDITION TMP_7513
		Expression: revert InvalidToken()()
		IRs:
			TMP_7514(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7515 = CONVERT to to address
			TMP_7516 = CONVERT 0 to address
			TMP_7517(bool) = TMP_7515 == TMP_7516
			CONDITION TMP_7517
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7518(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_7519 = CONVERT this to address
			TMP_7520(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_7519']  
			TMP_7521(bool) = TMP_7520 < amount
			CONDITION TMP_7521
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_7522(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,to,amount)
		IRs:
			TMP_7523 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_7523', 'from', 'to', 'amount'] 
	Function UseTokenActions.sweepTokens(IERC20,address) (*)
		Expression: address(token) == address(0)
		IRs:
			TMP_7525 = CONVERT token to address
			TMP_7526 = CONVERT 0 to address
			TMP_7527(bool) = TMP_7525 == TMP_7526
			CONDITION TMP_7527
		Expression: revert InvalidToken()()
		IRs:
			TMP_7528(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_7529 = CONVERT to to address
			TMP_7530 = CONVERT 0 to address
			TMP_7531(bool) = TMP_7529 == TMP_7530
			CONDITION TMP_7531
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_7532(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: sweptAmount = IERC20(token).balanceOf(address(this))
		IRs:
			TMP_7533 = CONVERT token to IERC20
			TMP_7534 = CONVERT this to address
			TMP_7535(uint256) = HIGH_LEVEL_CALL, dest:TMP_7533(IERC20), function:balanceOf, arguments:['TMP_7534']  
			sweptAmount(uint256) := TMP_7535(uint256)
		Expression: IERC20(token).safeTransfer(to,sweptAmount)
		IRs:
			TMP_7536 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_7536', 'to', 'sweptAmount'] 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7538 = UnaryType.BANG _initializing 
			TMP_7539(None) = SOLIDITY_CALL require(bool,string)(TMP_7538,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7541(uint8) := 255(uint8)
			TMP_7542(bool) = _initialized != TMP_7541
			CONDITION TMP_7542
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7544(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7544(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7546(uint8) := 255(uint8)
			Emit Initialized(TMP_7546)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseTokenActionsMock.test__pullToken(IERC20,uint256) (*)
		Expression: pullToken(token,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pullToken(IERC20,uint256)(token,amount)
	Function UseTokenActionsMock.test__pullTokenFrom(IERC20,address,uint256) (*)
		Expression: pullTokenFrom(token,from,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pullTokenFrom(IERC20,address,uint256)(token,from,amount)
	Function UseTokenActionsMock.test__pushToken(IERC20,address,uint256) (*)
		Expression: pushToken(token,to,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pushToken(IERC20,address,uint256)(token,to,amount)
	Function UseTokenActionsMock.test__pushTokenFrom(IERC20,address,address,uint256) (*)
		Expression: pushTokenFrom(token,from,to,amount)
		IRs:
			INTERNAL_CALL, UseTokenActions.pushTokenFrom(IERC20,address,address,uint256)(token,from,to,amount)
	Function UseTokenActionsMock.test__sweepTokens(IERC20,address) (*)
		Expression: sweepTokens(token,to)
		IRs:
			TMP_7552(uint256) = INTERNAL_CALL, UseTokenActions.sweepTokens(IERC20,address)(token,to)
			RETURN TMP_7552
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7553 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7553(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7554(bool) = _initialized < 1
			TMP_7555(bool) = isTopLevelCall && TMP_7554
			TMP_7556 = CONVERT this to address
			TMP_7557(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7556'] 
			TMP_7558 = UnaryType.BANG TMP_7557 
			TMP_7559(bool) = _initialized == 1
			TMP_7560(bool) = TMP_7558 && TMP_7559
			TMP_7561(bool) = TMP_7555 || TMP_7560
			TMP_7562(None) = SOLIDITY_CALL require(bool,string)(TMP_7561,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7564 = UnaryType.BANG _initializing 
			TMP_7565(bool) = _initialized < version
			TMP_7566(bool) = TMP_7564 && TMP_7565
			TMP_7567(None) = SOLIDITY_CALL require(bool,string)(TMP_7566,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7569(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseUniQuoter
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7570 = UnaryType.BANG _initializing 
			TMP_7571(None) = SOLIDITY_CALL require(bool,string)(TMP_7570,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7573(uint8) := 255(uint8)
			TMP_7574(bool) = _initialized != TMP_7573
			CONDITION TMP_7574
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7576(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7576(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7578(uint8) := 255(uint8)
			Emit Initialized(TMP_7578)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseUniQuoter._initUseUniQuoter(IQuoterV2) (*)
		Expression: _quoter = quoter
		IRs:
			_quoter(IQuoterV2) := quoter(IQuoterV2)
		Expression: address(_quoter) == address(0)
		IRs:
			TMP_7580 = CONVERT _quoter to address
			TMP_7581 = CONVERT 0 to address
			TMP_7582(bool) = TMP_7580 == TMP_7581
			CONDITION TMP_7582
		Expression: revert UseUniQuoter_InvalidUniQuoterContract()()
		IRs:
			TMP_7583(None) = SOLIDITY_CALL revert UseUniQuoter_InvalidUniQuoterContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseUniQuoter.uniQuoter() (*)
		Expression: _quoter
		IRs:
			RETURN _quoter
	Function UseUniQuoter.uniQuoterA() (*)
		Expression: address(_quoter)
		IRs:
			TMP_7585 = CONVERT _quoter to address
			RETURN TMP_7585
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7586 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7586(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7587(bool) = _initialized < 1
			TMP_7588(bool) = isTopLevelCall && TMP_7587
			TMP_7589 = CONVERT this to address
			TMP_7590(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7589'] 
			TMP_7591 = UnaryType.BANG TMP_7590 
			TMP_7592(bool) = _initialized == 1
			TMP_7593(bool) = TMP_7591 && TMP_7592
			TMP_7594(bool) = TMP_7588 || TMP_7593
			TMP_7595(None) = SOLIDITY_CALL require(bool,string)(TMP_7594,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7597 = UnaryType.BANG _initializing 
			TMP_7598(bool) = _initialized < version
			TMP_7599(bool) = TMP_7597 && TMP_7598
			TMP_7600(None) = SOLIDITY_CALL require(bool,string)(TMP_7599,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7602(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseWETH
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7603 = UnaryType.BANG _initializing 
			TMP_7604(None) = SOLIDITY_CALL require(bool,string)(TMP_7603,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7606(uint8) := 255(uint8)
			TMP_7607(bool) = _initialized != TMP_7606
			CONDITION TMP_7607
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7609(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7609(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7611(uint8) := 255(uint8)
			Emit Initialized(TMP_7611)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_7613 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_7613(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_7614 = CONVERT _wETH to address
			TMP_7615 = CONVERT 0 to address
			TMP_7616(bool) = TMP_7614 == TMP_7615
			CONDITION TMP_7616
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_7617(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() (*)
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_7619 = CONVERT _wETH to address
			RETURN TMP_7619
	Function UseWETH.unwrapETH(uint256) (*)
		Expression: wETHAmount == 0
		IRs:
			TMP_7620(bool) = wETHAmount == 0
			CONDITION TMP_7620
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_7621(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_7622 = CONVERT this to address
			TMP_7623(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_7622']  
			wETHBalance(uint256) := TMP_7623(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_7624(bool) = wETHBalance < wETHAmount
			CONDITION TMP_7624
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_7625(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_7626(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_7626(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) (*)
		Expression: address(this).balance < amount
		IRs:
			TMP_7628 = CONVERT this to address
			TMP_7629(uint256) = SOLIDITY_CALL balance(address)(TMP_7628)
			TMP_7630(bool) = TMP_7629 < amount
			CONDITION TMP_7630
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_7631(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_7632(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_7632(IWETH), function:deposit, arguments:[] value:amount 
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7634 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7634(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7635(bool) = _initialized < 1
			TMP_7636(bool) = isTopLevelCall && TMP_7635
			TMP_7637 = CONVERT this to address
			TMP_7638(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7637'] 
			TMP_7639 = UnaryType.BANG TMP_7638 
			TMP_7640(bool) = _initialized == 1
			TMP_7641(bool) = TMP_7639 && TMP_7640
			TMP_7642(bool) = TMP_7636 || TMP_7641
			TMP_7643(None) = SOLIDITY_CALL require(bool,string)(TMP_7642,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7645 = UnaryType.BANG _initializing 
			TMP_7646(bool) = _initialized < version
			TMP_7647(bool) = TMP_7645 && TMP_7646
			TMP_7648(None) = SOLIDITY_CALL require(bool,string)(TMP_7647,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7650(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseWETHMock
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_7651 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_7651(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_7652 = CONVERT _wETH to address
			TMP_7653 = CONVERT 0 to address
			TMP_7654(bool) = TMP_7652 == TMP_7653
			CONDITION TMP_7654
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_7655(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() (*)
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_7657 = CONVERT _wETH to address
			RETURN TMP_7657
	Function UseWETH.unwrapETH(uint256) (*)
		Expression: wETHAmount == 0
		IRs:
			TMP_7658(bool) = wETHAmount == 0
			CONDITION TMP_7658
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_7659(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_7660 = CONVERT this to address
			TMP_7661(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_7660']  
			wETHBalance(uint256) := TMP_7661(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_7662(bool) = wETHBalance < wETHAmount
			CONDITION TMP_7662
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_7663(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_7664(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_7664(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) (*)
		Expression: address(this).balance < amount
		IRs:
			TMP_7666 = CONVERT this to address
			TMP_7667(uint256) = SOLIDITY_CALL balance(address)(TMP_7666)
			TMP_7668(bool) = TMP_7667 < amount
			CONDITION TMP_7668
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_7669(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_7670(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_7670(IWETH), function:deposit, arguments:[] value:amount 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7672 = UnaryType.BANG _initializing 
			TMP_7673(None) = SOLIDITY_CALL require(bool,string)(TMP_7672,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7675(uint8) := 255(uint8)
			TMP_7676(bool) = _initialized != TMP_7675
			CONDITION TMP_7676
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7678(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7678(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7680(uint8) := 255(uint8)
			Emit Initialized(TMP_7680)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseWETHMock.initialize(address) (*)
		Expression: _initUseWETH(initialOwner)
		IRs:
			INTERNAL_CALL, UseWETH._initUseWETH(address)(initialOwner)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function UseWETHMock.test__unwrapETH(uint256) (*)
		Expression: unwrapETH(wETHAmount)
		IRs:
			INTERNAL_CALL, UseWETH.unwrapETH(uint256)(wETHAmount)
	Function UseWETHMock.test__wrapETH(uint256) (*)
		Expression: wrapETH(amount)
		IRs:
			INTERNAL_CALL, UseWETH.wrapETH(uint256)(amount)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7686 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7686(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7687(bool) = _initialized < 1
			TMP_7688(bool) = isTopLevelCall && TMP_7687
			TMP_7689 = CONVERT this to address
			TMP_7690(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7689'] 
			TMP_7691 = UnaryType.BANG TMP_7690 
			TMP_7692(bool) = _initialized == 1
			TMP_7693(bool) = TMP_7691 && TMP_7692
			TMP_7694(bool) = TMP_7688 || TMP_7693
			TMP_7695(None) = SOLIDITY_CALL require(bool,string)(TMP_7694,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7697 = UnaryType.BANG _initializing 
			TMP_7698(bool) = _initialized < version
			TMP_7699(bool) = TMP_7697 && TMP_7698
			TMP_7700(None) = SOLIDITY_CALL require(bool,string)(TMP_7699,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7702(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseWstETH
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7703 = UnaryType.BANG _initializing 
			TMP_7704(None) = SOLIDITY_CALL require(bool,string)(TMP_7703,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7706(uint8) := 255(uint8)
			TMP_7707(bool) = _initialized != TMP_7706
			CONDITION TMP_7707
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7709(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7709(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7711(uint8) := 255(uint8)
			Emit Initialized(TMP_7711)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseWstETH._initUseWstETH(address,address) (*)
		Expression: _wstETH = IWStETH(iwstETH)
		IRs:
			TMP_7713 = CONVERT iwstETH to IWStETH
			_wstETH(IWStETH) := TMP_7713(IWStETH)
		Expression: _stETHToken = IERC20(istETH)
		IRs:
			TMP_7714 = CONVERT istETH to IERC20
			_stETHToken(IERC20) := TMP_7714(IERC20)
		Expression: address(_wstETH) == address(0)
		IRs:
			TMP_7715 = CONVERT _wstETH to address
			TMP_7716 = CONVERT 0 to address
			TMP_7717(bool) = TMP_7715 == TMP_7716
			CONDITION TMP_7717
		Expression: revert InvalidWstETHContract()()
		IRs:
			TMP_7718(None) = SOLIDITY_CALL revert InvalidWstETHContract()()
		Expression: address(_stETHToken) == address(0)
		IRs:
			TMP_7719 = CONVERT _stETHToken to address
			TMP_7720 = CONVERT 0 to address
			TMP_7721(bool) = TMP_7719 == TMP_7720
			CONDITION TMP_7721
		Expression: revert InvalidStETHContract()()
		IRs:
			TMP_7722(None) = SOLIDITY_CALL revert InvalidStETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWstETH.wstETH() (*)
		Expression: _wstETH
		IRs:
			RETURN _wstETH
	Function UseWstETH.wstETHA() (*)
		Expression: address(_wstETH)
		IRs:
			TMP_7724 = CONVERT _wstETH to address
			RETURN TMP_7724
	Function UseWstETH._wrapWstETH(uint256) (*)
		Expression: ! _stETHToken.approve(wstETHA(),amount)
		IRs:
			TMP_7725(address) = INTERNAL_CALL, UseWstETH.wstETHA()()
			TMP_7726(bool) = HIGH_LEVEL_CALL, dest:_stETHToken(IERC20), function:approve, arguments:['TMP_7725', 'amount']  
			TMP_7727 = UnaryType.BANG TMP_7726 
			CONDITION TMP_7727
		Expression: revert FailedToApproveStAllowance()()
		IRs:
			TMP_7728(None) = SOLIDITY_CALL revert FailedToApproveStAllowance()()
		Expression: amountOut = IWStETH(wstETHA()).wrap(amount)
		IRs:
			TMP_7729(address) = INTERNAL_CALL, UseWstETH.wstETHA()()
			TMP_7730 = CONVERT TMP_7729 to IWStETH
			TMP_7731(uint256) = HIGH_LEVEL_CALL, dest:TMP_7730(IWStETH), function:wrap, arguments:['amount']  
			amountOut(uint256) := TMP_7731(uint256)
	Function UseWstETH._unwrapWstETH(uint256) (*)
		Expression: ! IERC20(wstETHA()).approve(wstETHA(),amount)
		IRs:
			TMP_7732(address) = INTERNAL_CALL, UseWstETH.wstETHA()()
			TMP_7733 = CONVERT TMP_7732 to IERC20
			TMP_7734(address) = INTERNAL_CALL, UseWstETH.wstETHA()()
			TMP_7735(bool) = HIGH_LEVEL_CALL, dest:TMP_7733(IERC20), function:approve, arguments:['TMP_7734', 'amount']  
			TMP_7736 = UnaryType.BANG TMP_7735 
			CONDITION TMP_7736
		Expression: revert FailedToApproveWstAllowance()()
		IRs:
			TMP_7737(None) = SOLIDITY_CALL revert FailedToApproveWstAllowance()()
		Expression: stETHAmount = wstETH().unwrap(amount)
		IRs:
			TMP_7738(IWStETH) = INTERNAL_CALL, UseWstETH.wstETH()()
			TMP_7739(uint256) = HIGH_LEVEL_CALL, dest:TMP_7738(IWStETH), function:unwrap, arguments:['amount']  
			stETHAmount(uint256) := TMP_7739(uint256)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7740 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7740(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7741(bool) = _initialized < 1
			TMP_7742(bool) = isTopLevelCall && TMP_7741
			TMP_7743 = CONVERT this to address
			TMP_7744(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7743'] 
			TMP_7745 = UnaryType.BANG TMP_7744 
			TMP_7746(bool) = _initialized == 1
			TMP_7747(bool) = TMP_7745 && TMP_7746
			TMP_7748(bool) = TMP_7742 || TMP_7747
			TMP_7749(None) = SOLIDITY_CALL require(bool,string)(TMP_7748,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7751 = UnaryType.BANG _initializing 
			TMP_7752(bool) = _initialized < version
			TMP_7753(bool) = TMP_7751 && TMP_7752
			TMP_7754(None) = SOLIDITY_CALL require(bool,string)(TMP_7753,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7756(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseAeroSwapper
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseAeroSwapper._initAeroSwapper(ISwapRouter) (*)
		Expression: _aeroRouter = iAeroRouter
		IRs:
			_aeroRouter(ISwapRouter) := iAeroRouter(ISwapRouter)
		Expression: address(_aeroRouter) == address(0)
		IRs:
			TMP_7757 = CONVERT _aeroRouter to address
			TMP_7758 = CONVERT 0 to address
			TMP_7759(bool) = TMP_7757 == TMP_7758
			CONDITION TMP_7759
		Expression: revert InvalidAeroRouterContract()()
		IRs:
			TMP_7760(None) = SOLIDITY_CALL revert InvalidAeroRouterContract()()
	Function UseAeroSwapper.aeroRouter() (*)
		Expression: _aeroRouter
		IRs:
			RETURN _aeroRouter
	Function UseAeroSwapper.aeroRouterA() (*)
		Expression: address(_aeroRouter)
		IRs:
			TMP_7761 = CONVERT _aeroRouter to address
			RETURN TMP_7761
	Function UseAeroSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(_aeroRouter),amount)
		IRs:
			TMP_7762 = CONVERT _aeroRouter to address
			TMP_7763(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7762', 'amount']  
			TMP_7764 = UnaryType.BANG TMP_7763 
			CONDITION TMP_7764
		Expression: revert FailedToApproveAllowanceForSwapRouter()()
		IRs:
			TMP_7765(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForSwapRouter()()
	Function UseAeroSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: AerodromeLibrary.swapAerodrome(aeroRouter(),params)
		IRs:
			TMP_7766(ISwapRouter) = INTERNAL_CALL, UseAeroSwapper.aeroRouter()()
			TUPLE_75(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7766', 'params'] 
			RETURN TUPLE_75
Contract UseAeroSwapperMock
	Function UseAeroSwapper._initAeroSwapper(ISwapRouter) (*)
		Expression: _aeroRouter = iAeroRouter
		IRs:
			_aeroRouter(ISwapRouter) := iAeroRouter(ISwapRouter)
		Expression: address(_aeroRouter) == address(0)
		IRs:
			TMP_7767 = CONVERT _aeroRouter to address
			TMP_7768 = CONVERT 0 to address
			TMP_7769(bool) = TMP_7767 == TMP_7768
			CONDITION TMP_7769
		Expression: revert InvalidAeroRouterContract()()
		IRs:
			TMP_7770(None) = SOLIDITY_CALL revert InvalidAeroRouterContract()()
	Function UseAeroSwapper.aeroRouter() (*)
		Expression: _aeroRouter
		IRs:
			RETURN _aeroRouter
	Function UseAeroSwapper.aeroRouterA() (*)
		Expression: address(_aeroRouter)
		IRs:
			TMP_7771 = CONVERT _aeroRouter to address
			RETURN TMP_7771
	Function UseAeroSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(_aeroRouter),amount)
		IRs:
			TMP_7772 = CONVERT _aeroRouter to address
			TMP_7773(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7772', 'amount']  
			TMP_7774 = UnaryType.BANG TMP_7773 
			CONDITION TMP_7774
		Expression: revert FailedToApproveAllowanceForSwapRouter()()
		IRs:
			TMP_7775(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForSwapRouter()()
	Function UseAeroSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: AerodromeLibrary.swapAerodrome(aeroRouter(),params)
		IRs:
			TMP_7776(ISwapRouter) = INTERNAL_CALL, UseAeroSwapper.aeroRouter()()
			TUPLE_76(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7776', 'params'] 
			RETURN TUPLE_76
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseAeroSwapperMock.constructor(ISwapRouter) (*)
		Expression: _initAeroSwapper(iAeroRouter)
		IRs:
			INTERNAL_CALL, UseAeroSwapper._initAeroSwapper(ISwapRouter)(iAeroRouter)
	Function UseAeroSwapperMock.test__swap(ISwapHandler.SwapParams) (*)
		Expression: swap(params)
		IRs:
			TUPLE_77(uint256,uint256) = INTERNAL_CALL, UseAeroSwapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_77
	Function UseAeroSwapperMock.test_allowRouterSpend(IERC20,uint256) (*)
		Expression: _allowRouterSpend(token,amount)
		IRs:
			INTERNAL_CALL, UseAeroSwapper._allowRouterSpend(IERC20,uint256)(token,amount)
Contract UseCurveSwapper
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseCurveSwapper._initUseCurveSwapper(ICurveRouterNG) (*)
		Expression: address(icurveRouterNG) == address(0)
		IRs:
			TMP_7779 = CONVERT icurveRouterNG to address
			TMP_7780 = CONVERT 0 to address
			TMP_7781(bool) = TMP_7779 == TMP_7780
			CONDITION TMP_7781
		Expression: revert InvalidCurveRouterContract()()
		IRs:
			TMP_7782(None) = SOLIDITY_CALL revert InvalidCurveRouterContract()()
		Expression: sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
		IRs:
			TMP_7783(None) = SOLIDITY_CALL sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
	Function UseCurveSwapper.curveRouter() (*)
		Expression: router = sload(uint256)(_CURVE_ROUTER_SLOT)
		IRs:
			TMP_7784(uint256) = SOLIDITY_CALL sload(uint256)(_CURVE_ROUTER_SLOT)
			router(address) := TMP_7784(uint256)
		Expression: ICurveRouterNG(router)
		IRs:
			TMP_7785 = CONVERT router to ICurveRouterNG
			RETURN TMP_7785
	Function UseCurveSwapper.curveRouterA() (*)
		Expression: address(curveRouter())
		IRs:
			TMP_7786(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TMP_7787 = CONVERT TMP_7786 to address
			RETURN TMP_7787
	Function UseCurveSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(curveRouterA(),amount)
		IRs:
			TMP_7788(address) = INTERNAL_CALL, UseCurveSwapper.curveRouterA()()
			TMP_7789(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7788', 'amount']  
			TMP_7790 = UnaryType.BANG TMP_7789 
			CONDITION TMP_7790
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7791(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function UseCurveSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: CurveFiLibrary.swapCurveFi(curveRouter(),params)
		IRs:
			TMP_7792(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TUPLE_78(uint256,uint256) = LIBRARY_CALL, dest:CurveFiLibrary, function:CurveFiLibrary.swapCurveFi(ICurveRouterNG,ISwapHandler.SwapParams), arguments:['TMP_7792', 'params'] 
			RETURN TUPLE_78
	Function UseCurveSwapper.slitherConstructorConstantVariables() (*)
		Expression: _CURVE_ROUTER_SLOT = 0x12bf5c1f8c71d2ab50ad26cd63e0f5c50ba43161b985f5d4c823c1c5b55e3f1b
		IRs:
			_CURVE_ROUTER_SLOT(bytes32) := 8479734875084262680902722603771659957122315217523620232617646262729918267163(uint256)
		Expression: ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
		IRs:
			ETH_ADDRESS(address) := 1364068194842176056990105843868530818345537040110(address)
Contract UseCurveSwapperMock
	Function UseCurveSwapper._initUseCurveSwapper(ICurveRouterNG) (*)
		Expression: address(icurveRouterNG) == address(0)
		IRs:
			TMP_7793 = CONVERT icurveRouterNG to address
			TMP_7794 = CONVERT 0 to address
			TMP_7795(bool) = TMP_7793 == TMP_7794
			CONDITION TMP_7795
		Expression: revert InvalidCurveRouterContract()()
		IRs:
			TMP_7796(None) = SOLIDITY_CALL revert InvalidCurveRouterContract()()
		Expression: sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
		IRs:
			TMP_7797(None) = SOLIDITY_CALL sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
	Function UseCurveSwapper.curveRouter() (*)
		Expression: router = sload(uint256)(_CURVE_ROUTER_SLOT)
		IRs:
			TMP_7798(uint256) = SOLIDITY_CALL sload(uint256)(_CURVE_ROUTER_SLOT)
			router(address) := TMP_7798(uint256)
		Expression: ICurveRouterNG(router)
		IRs:
			TMP_7799 = CONVERT router to ICurveRouterNG
			RETURN TMP_7799
	Function UseCurveSwapper.curveRouterA() (*)
		Expression: address(curveRouter())
		IRs:
			TMP_7800(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TMP_7801 = CONVERT TMP_7800 to address
			RETURN TMP_7801
	Function UseCurveSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(curveRouterA(),amount)
		IRs:
			TMP_7802(address) = INTERNAL_CALL, UseCurveSwapper.curveRouterA()()
			TMP_7803(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7802', 'amount']  
			TMP_7804 = UnaryType.BANG TMP_7803 
			CONDITION TMP_7804
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7805(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function UseCurveSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: CurveFiLibrary.swapCurveFi(curveRouter(),params)
		IRs:
			TMP_7806(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TUPLE_79(uint256,uint256) = LIBRARY_CALL, dest:CurveFiLibrary, function:CurveFiLibrary.swapCurveFi(ICurveRouterNG,ISwapHandler.SwapParams), arguments:['TMP_7806', 'params'] 
			RETURN TUPLE_79
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseCurveSwapperMock.constructor(ICurveRouterNG) (*)
		Expression: _initUseCurveSwapper(icurveRouterNG)
		IRs:
			INTERNAL_CALL, UseCurveSwapper._initUseCurveSwapper(ICurveRouterNG)(icurveRouterNG)
	Function UseCurveSwapperMock.test__swap(ISwapHandler.SwapParams) (*)
		Expression: swap(params)
		IRs:
			TUPLE_80(uint256,uint256) = INTERNAL_CALL, UseCurveSwapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_80
	Function UseCurveSwapperMock.slitherConstructorConstantVariables() (*)
		Expression: _CURVE_ROUTER_SLOT = 0x12bf5c1f8c71d2ab50ad26cd63e0f5c50ba43161b985f5d4c823c1c5b55e3f1b
		IRs:
			_CURVE_ROUTER_SLOT(bytes32) := 8479734875084262680902722603771659957122315217523620232617646262729918267163(uint256)
		Expression: ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
		IRs:
			ETH_ADDRESS(address) := 1364068194842176056990105843868530818345537040110(address)
Contract UseUniV2Swapper
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseUniV2Swapper._initUseUniV2Swapper(IUniswapV2Router02) (*)
		Expression: address(iV2UniRouter) == address(0)
		IRs:
			TMP_7808 = CONVERT iV2UniRouter to address
			TMP_7809 = CONVERT 0 to address
			TMP_7810(bool) = TMP_7808 == TMP_7809
			CONDITION TMP_7810
		Expression: revert InvalidV2RouterContract()()
		IRs:
			TMP_7811(None) = SOLIDITY_CALL revert InvalidV2RouterContract()()
		Expression: sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
		IRs:
			TMP_7812(None) = SOLIDITY_CALL sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
	Function UseUniV2Swapper.v2UniRouter() (*)
		Expression: router = sload(uint256)(_V2_UNI_ROUTER_SLOT)
		IRs:
			TMP_7813(uint256) = SOLIDITY_CALL sload(uint256)(_V2_UNI_ROUTER_SLOT)
			router(address) := TMP_7813(uint256)
		Expression: IUniswapV2Router02(router)
		IRs:
			TMP_7814 = CONVERT router to IUniswapV2Router02
			RETURN TMP_7814
	Function UseUniV2Swapper.swap(ISwapHandler.SwapParams) (*)
		Expression: UniV2Library.swapUniV2(v2UniRouter(),params)
		IRs:
			TMP_7815(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TUPLE_81(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_7815', 'params'] 
			RETURN TUPLE_81
	Function UseUniV2Swapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(v2UniRouter()),amount)
		IRs:
			TMP_7816(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TMP_7817 = CONVERT TMP_7816 to address
			TMP_7818(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7817', 'amount']  
			TMP_7819 = UnaryType.BANG TMP_7818 
			CONDITION TMP_7819
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7820(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function UseUniV2Swapper.slitherConstructorConstantVariables() (*)
		Expression: _V2_UNI_ROUTER_SLOT = 0x47b2c96b5499f1e2d1a7c2ef4c1a5a1e0d4a0c2e4b6d8f0a2c4e6f8a0c2e4b6d
		IRs:
			_V2_UNI_ROUTER_SLOT(bytes32) := 32430101171582026018922306616332257318775260763489528660905259517821294889837(uint256)
Contract UseUniV2SwapperMock
	Function UseUniV2Swapper._initUseUniV2Swapper(IUniswapV2Router02) (*)
		Expression: address(iV2UniRouter) == address(0)
		IRs:
			TMP_7821 = CONVERT iV2UniRouter to address
			TMP_7822 = CONVERT 0 to address
			TMP_7823(bool) = TMP_7821 == TMP_7822
			CONDITION TMP_7823
		Expression: revert InvalidV2RouterContract()()
		IRs:
			TMP_7824(None) = SOLIDITY_CALL revert InvalidV2RouterContract()()
		Expression: sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
		IRs:
			TMP_7825(None) = SOLIDITY_CALL sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
	Function UseUniV2Swapper.v2UniRouter() (*)
		Expression: router = sload(uint256)(_V2_UNI_ROUTER_SLOT)
		IRs:
			TMP_7826(uint256) = SOLIDITY_CALL sload(uint256)(_V2_UNI_ROUTER_SLOT)
			router(address) := TMP_7826(uint256)
		Expression: IUniswapV2Router02(router)
		IRs:
			TMP_7827 = CONVERT router to IUniswapV2Router02
			RETURN TMP_7827
	Function UseUniV2Swapper.swap(ISwapHandler.SwapParams) (*)
		Expression: UniV2Library.swapUniV2(v2UniRouter(),params)
		IRs:
			TMP_7828(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TUPLE_82(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_7828', 'params'] 
			RETURN TUPLE_82
	Function UseUniV2Swapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(v2UniRouter()),amount)
		IRs:
			TMP_7829(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TMP_7830 = CONVERT TMP_7829 to address
			TMP_7831(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7830', 'amount']  
			TMP_7832 = UnaryType.BANG TMP_7831 
			CONDITION TMP_7832
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7833(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseUniV2SwapperMock.constructor(IUniswapV2Router02) (*)
		Expression: _initUseUniV2Swapper(iV2UniRouter)
		IRs:
			INTERNAL_CALL, UseUniV2Swapper._initUseUniV2Swapper(IUniswapV2Router02)(iV2UniRouter)
	Function UseUniV2SwapperMock.test__swap(ISwapHandler.SwapParams) (*)
		Expression: swap(params)
		IRs:
			TUPLE_83(uint256,uint256) = INTERNAL_CALL, UseUniV2Swapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_83
Contract UseUniV3Swapper
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseUniV3Swapper._initUseUniV3Swapper(IV3SwapRouter) (*)
		Expression: _uniRouter = luniRouter
		IRs:
			_uniRouter(IV3SwapRouter) := luniRouter(IV3SwapRouter)
		Expression: address(_uniRouter) == address(0)
		IRs:
			TMP_7835 = CONVERT _uniRouter to address
			TMP_7836 = CONVERT 0 to address
			TMP_7837(bool) = TMP_7835 == TMP_7836
			CONDITION TMP_7837
		Expression: revert InvalidUniRouterContract()()
		IRs:
			TMP_7838(None) = SOLIDITY_CALL revert InvalidUniRouterContract()()
	Function UseUniV3Swapper.uniRouter() (*)
		Expression: _uniRouter
		IRs:
			RETURN _uniRouter
	Function UseUniV3Swapper.uniRouterA() (*)
		Expression: address(_uniRouter)
		IRs:
			TMP_7839 = CONVERT _uniRouter to address
			RETURN TMP_7839
	Function UseUniV3Swapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(_uniRouter),amount)
		IRs:
			TMP_7840 = CONVERT _uniRouter to address
			TMP_7841(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_7840', 'amount']  
			TMP_7842 = UnaryType.BANG TMP_7841 
			CONDITION TMP_7842
		Expression: revert FailedToApproveAllowanceForRouter()()
		IRs:
			TMP_7843(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForRouter()()
	Function UseUniV3Swapper.swap(ISwapHandler.SwapParams) (*)
		Expression: UniV3Library.swapUniV3(uniRouter(),params)
		IRs:
			TMP_7844(IV3SwapRouter) = INTERNAL_CALL, UseUniV3Swapper.uniRouter()()
			TUPLE_84(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7844', 'params'] 
			RETURN TUPLE_84
Contract UseUnifiedSwapper
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_7848 = CONVERT 0 to address
			TMP_7849(bool) = _newGovernor == TMP_7848
			CONDITION TMP_7849
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_7850(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_7856(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7856)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_7859(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_7860(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_7861(bool) = TMP_7859 == TMP_7860
			TMP_7862(None) = SOLIDITY_CALL require(bool,string)(TMP_7861,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_7863 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_7863)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_7866 = CONVERT 0 to address
			TMP_7867(bool) = newOwner != TMP_7866
			TMP_7868(None) = SOLIDITY_CALL require(bool,string)(TMP_7867,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_7874 = UnaryType.BANG _initializing 
			TMP_7875(None) = SOLIDITY_CALL require(bool,string)(TMP_7874,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_7877(uint8) := 255(uint8)
			TMP_7878(bool) = _initialized != TMP_7877
			CONDITION TMP_7878
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_7880(uint8) := 255(uint8)
			_initialized(uint8) := TMP_7880(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_7882(uint8) := 255(uint8)
			Emit Initialized(TMP_7882)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_7884(bool) = tokenA < tokenB
			CONDITION TMP_7884
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_7885(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339dc806f50>, <slither.core.variables.local_variable.LocalVariable object at 0x7339dc807690>])
			TMP_7886(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_7885)
			RETURN TMP_7886
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_7887(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339dc807690>, <slither.core.variables.local_variable.LocalVariable object at 0x7339dc806f50>])
			TMP_7888(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_7887)
			RETURN TMP_7888
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7889(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7889(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2316(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2317(UseUnifiedSwapper.SwapProvider) -> REF_2316.provider
			REF_2318(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7890(bool) = REF_2317 != REF_2318
			CONDITION TMP_7890
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_7891(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_7892 = CONVERT tokenIn to IERC20
			REF_2320(address) -> routeInfo.router
			TMP_7894(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_7895(uint256) = TMP_7894 (c)- 1
			TMP_7896(bool) = HIGH_LEVEL_CALL, dest:TMP_7892(IERC20), function:approve, arguments:['REF_2320', 'TMP_7895']  
			TMP_7897 = UnaryType.BANG TMP_7896 
			CONDITION TMP_7897
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7898(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_7899 = CONVERT tokenOut to IERC20
			REF_2322(address) -> routeInfo.router
			TMP_7901(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_7902(uint256) = TMP_7901 (c)- 1
			TMP_7903(bool) = HIGH_LEVEL_CALL, dest:TMP_7899(IERC20), function:approve, arguments:['REF_2322', 'TMP_7902']  
			TMP_7904 = UnaryType.BANG TMP_7903 
			CONDITION TMP_7904
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7905(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_2323(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2323(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7907(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7907(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_2324(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2325(UseUnifiedSwapper.SwapProvider) -> REF_2324.provider
			REF_2326(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7908(bool) = REF_2325 == REF_2326
			CONDITION TMP_7908
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_7909(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_7910 = CONVERT tokenIn to IERC20
			REF_2328(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2329(address) -> REF_2328.router
			TMP_7911(bool) = HIGH_LEVEL_CALL, dest:TMP_7910(IERC20), function:approve, arguments:['REF_2329', '0']  
			TMP_7912 = UnaryType.BANG TMP_7911 
			CONDITION TMP_7912
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7913(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_7914 = CONVERT tokenOut to IERC20
			REF_2331(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2332(address) -> REF_2331.router
			TMP_7915(bool) = HIGH_LEVEL_CALL, dest:TMP_7914(IERC20), function:approve, arguments:['REF_2332', '0']  
			TMP_7916 = UnaryType.BANG TMP_7915 
			CONDITION TMP_7916
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7917(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_2333(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2334(UseUnifiedSwapper.SwapProvider) -> REF_2333.provider
			REF_2335(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_2334(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_2335(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7919(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7919(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2336(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2337(UseUnifiedSwapper.SwapProvider) -> REF_2336.provider
			REF_2338(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7920(bool) = REF_2337 != REF_2338
			RETURN TMP_7920
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_2339(address) -> params.underlyingIn
			REF_2340(address) -> params.underlyingOut
			TMP_7921(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_2339,REF_2340)
			key(bytes32) := TMP_7921(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_2341(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_2341(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_2342(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2343(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7922(bool) = REF_2342 == REF_2343
			CONDITION TMP_7922
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_7923(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_2344(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2345(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_7924(bool) = REF_2344 == REF_2345
			CONDITION TMP_7924
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_2346(bytes) -> params.payload
			REF_2348(uint24) -> routeInfo.uniV3Tier
			TMP_7925(bytes) = SOLIDITY_CALL abi.encode()(REF_2348)
			REF_2346(bytes) (->params) := TMP_7925(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_2350(address) -> routeInfo.router
			TMP_7926 = CONVERT REF_2350 to IV3SwapRouter
			TUPLE_85(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7926', 'params'] 
			RETURN TUPLE_85
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_2351(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2352(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_7927(bool) = REF_2351 == REF_2352
			CONDITION TMP_7927
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_2354(address) -> routeInfo.router
			TMP_7928 = CONVERT REF_2354 to IUniswapV2Router02
			TUPLE_86(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_7928', 'params'] 
			RETURN TUPLE_86
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_2355(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2356(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_7929(bool) = REF_2355 == REF_2356
			CONDITION TMP_7929
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_2357(bytes) -> params.payload
			REF_2359(uint24) -> routeInfo.tickSpacing
			TMP_7930(bytes) = SOLIDITY_CALL abi.encode()(REF_2359)
			REF_2357(bytes) (->params) := TMP_7930(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_2361(address) -> routeInfo.router
			TMP_7931 = CONVERT REF_2361 to ISwapRouter
			TUPLE_87(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7931', 'params'] 
			RETURN TUPLE_87
		Expression: revert InvalidProvider()()
		IRs:
			TMP_7932(None) = SOLIDITY_CALL revert InvalidProvider()()
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_7933(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_7934(bool) = msg.sender != TMP_7933
			CONDITION TMP_7934
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_7935(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_7937 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_7937(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_7938(bool) = _initialized < 1
			TMP_7939(bool) = isTopLevelCall && TMP_7938
			TMP_7940 = CONVERT this to address
			TMP_7941(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_7940'] 
			TMP_7942 = UnaryType.BANG TMP_7941 
			TMP_7943(bool) = _initialized == 1
			TMP_7944(bool) = TMP_7942 && TMP_7943
			TMP_7945(bool) = TMP_7939 || TMP_7944
			TMP_7946(None) = SOLIDITY_CALL require(bool,string)(TMP_7945,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_7948 = UnaryType.BANG _initializing 
			TMP_7949(bool) = _initialized < version
			TMP_7950(bool) = TMP_7948 && TMP_7949
			TMP_7951(None) = SOLIDITY_CALL require(bool,string)(TMP_7950,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_7953(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract UseUnifiedSwapperMock
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_7954(bool) = tokenA < tokenB
			CONDITION TMP_7954
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_7955(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339dc6f5150>, <slither.core.variables.local_variable.LocalVariable object at 0x7339dc6f6050>])
			TMP_7956(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_7955)
			RETURN TMP_7956
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_7957(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339dc6f6050>, <slither.core.variables.local_variable.LocalVariable object at 0x7339dc6f5150>])
			TMP_7958(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_7957)
			RETURN TMP_7958
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7959(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7959(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2365(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2366(UseUnifiedSwapper.SwapProvider) -> REF_2365.provider
			REF_2367(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7960(bool) = REF_2366 != REF_2367
			CONDITION TMP_7960
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_7961(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_7962 = CONVERT tokenIn to IERC20
			REF_2369(address) -> routeInfo.router
			TMP_7964(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_7965(uint256) = TMP_7964 (c)- 1
			TMP_7966(bool) = HIGH_LEVEL_CALL, dest:TMP_7962(IERC20), function:approve, arguments:['REF_2369', 'TMP_7965']  
			TMP_7967 = UnaryType.BANG TMP_7966 
			CONDITION TMP_7967
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7968(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_7969 = CONVERT tokenOut to IERC20
			REF_2371(address) -> routeInfo.router
			TMP_7971(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_7972(uint256) = TMP_7971 (c)- 1
			TMP_7973(bool) = HIGH_LEVEL_CALL, dest:TMP_7969(IERC20), function:approve, arguments:['REF_2371', 'TMP_7972']  
			TMP_7974 = UnaryType.BANG TMP_7973 
			CONDITION TMP_7974
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7975(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_2372(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2372(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7977(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7977(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_2373(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2374(UseUnifiedSwapper.SwapProvider) -> REF_2373.provider
			REF_2375(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7978(bool) = REF_2374 == REF_2375
			CONDITION TMP_7978
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_7979(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_7980 = CONVERT tokenIn to IERC20
			REF_2377(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2378(address) -> REF_2377.router
			TMP_7981(bool) = HIGH_LEVEL_CALL, dest:TMP_7980(IERC20), function:approve, arguments:['REF_2378', '0']  
			TMP_7982 = UnaryType.BANG TMP_7981 
			CONDITION TMP_7982
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7983(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_7984 = CONVERT tokenOut to IERC20
			REF_2380(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2381(address) -> REF_2380.router
			TMP_7985(bool) = HIGH_LEVEL_CALL, dest:TMP_7984(IERC20), function:approve, arguments:['REF_2381', '0']  
			TMP_7986 = UnaryType.BANG TMP_7985 
			CONDITION TMP_7986
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_7987(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_2382(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2383(UseUnifiedSwapper.SwapProvider) -> REF_2382.provider
			REF_2384(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_2383(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_2384(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_7989(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_7989(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2385(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2386(UseUnifiedSwapper.SwapProvider) -> REF_2385.provider
			REF_2387(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7990(bool) = REF_2386 != REF_2387
			RETURN TMP_7990
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_2388(address) -> params.underlyingIn
			REF_2389(address) -> params.underlyingOut
			TMP_7991(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_2388,REF_2389)
			key(bytes32) := TMP_7991(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_2390(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_2390(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_2391(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2392(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_7992(bool) = REF_2391 == REF_2392
			CONDITION TMP_7992
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_7993(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_2393(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2394(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_7994(bool) = REF_2393 == REF_2394
			CONDITION TMP_7994
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_2395(bytes) -> params.payload
			REF_2397(uint24) -> routeInfo.uniV3Tier
			TMP_7995(bytes) = SOLIDITY_CALL abi.encode()(REF_2397)
			REF_2395(bytes) (->params) := TMP_7995(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_2399(address) -> routeInfo.router
			TMP_7996 = CONVERT REF_2399 to IV3SwapRouter
			TUPLE_88(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_7996', 'params'] 
			RETURN TUPLE_88
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_2400(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2401(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_7997(bool) = REF_2400 == REF_2401
			CONDITION TMP_7997
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_2403(address) -> routeInfo.router
			TMP_7998 = CONVERT REF_2403 to IUniswapV2Router02
			TUPLE_89(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_7998', 'params'] 
			RETURN TUPLE_89
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_2404(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2405(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_7999(bool) = REF_2404 == REF_2405
			CONDITION TMP_7999
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_2406(bytes) -> params.payload
			REF_2408(uint24) -> routeInfo.tickSpacing
			TMP_8000(bytes) = SOLIDITY_CALL abi.encode()(REF_2408)
			REF_2406(bytes) (->params) := TMP_8000(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_2410(address) -> routeInfo.router
			TMP_8001 = CONVERT REF_2410 to ISwapRouter
			TUPLE_90(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_8001', 'params'] 
			RETURN TUPLE_90
		Expression: revert InvalidProvider()()
		IRs:
			TMP_8002(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_8006 = CONVERT 0 to address
			TMP_8007(bool) = _newGovernor == TMP_8006
			CONDITION TMP_8007
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_8008(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_8014(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_8014)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_8017(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_8018(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_8019(bool) = TMP_8017 == TMP_8018
			TMP_8020(None) = SOLIDITY_CALL require(bool,string)(TMP_8019,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_8021 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_8021)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_8024 = CONVERT 0 to address
			TMP_8025(bool) = newOwner != TMP_8024
			TMP_8026(None) = SOLIDITY_CALL require(bool,string)(TMP_8025,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_8032 = UnaryType.BANG _initializing 
			TMP_8033(None) = SOLIDITY_CALL require(bool,string)(TMP_8032,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_8035(uint8) := 255(uint8)
			TMP_8036(bool) = _initialized != TMP_8035
			CONDITION TMP_8036
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_8038(uint8) := 255(uint8)
			_initialized(uint8) := TMP_8038(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_8040(uint8) := 255(uint8)
			Emit Initialized(TMP_8040)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function UseUnifiedSwapperMock.constructor() (*)
		Expression: _transferOwnership(msg.sender)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(msg.sender)
		Expression: _transferGovernorship(msg.sender)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(msg.sender)
	Function UseUnifiedSwapperMock.test__swap(ISwapHandler.SwapParams) (*)
		Expression: UseUnifiedSwapper.swap(params)
		IRs:
			TUPLE_91(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_91
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_8044(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_8045(bool) = msg.sender != TMP_8044
			CONDITION TMP_8045
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_8046(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_8048 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_8048(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_8049(bool) = _initialized < 1
			TMP_8050(bool) = isTopLevelCall && TMP_8049
			TMP_8051 = CONVERT this to address
			TMP_8052(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_8051'] 
			TMP_8053 = UnaryType.BANG TMP_8052 
			TMP_8054(bool) = _initialized == 1
			TMP_8055(bool) = TMP_8053 && TMP_8054
			TMP_8056(bool) = TMP_8050 || TMP_8055
			TMP_8057(None) = SOLIDITY_CALL require(bool,string)(TMP_8056,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_8059 = UnaryType.BANG _initializing 
			TMP_8060(bool) = _initialized < version
			TMP_8061(bool) = TMP_8059 && TMP_8060
			TMP_8062(None) = SOLIDITY_CALL require(bool,string)(TMP_8061,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_8064(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract Commands
	Function Commands.pullInputParam(uint256[],uint256,uint64,uint8) (*)
		Expression: position > CALL_STACK_SIZE
		IRs:
			TMP_8065(bool) = position > CALL_STACK_SIZE
			CONDITION TMP_8065
		Expression: revert InvalidPosition(uint8)({position:position})
		IRs:
			TMP_8066(None) = SOLIDITY_CALL revert InvalidPosition(uint8)(position)
		Expression: inputIndex = uint8(((inputMapping >> (INDEX_SLOT_SIZE * (position - 1))) & INDEX_SLOT_MASK))
		IRs:
			TMP_8067(uint8) = position (c)- 1
			TMP_8068(uint8) = INDEX_SLOT_SIZE (c)* TMP_8067
			TMP_8069(uint64) = inputMapping >> TMP_8068
			TMP_8070(uint64) = TMP_8069 & INDEX_SLOT_MASK
			TMP_8071 = CONVERT TMP_8070 to uint8
			inputIndex(uint8) := TMP_8071(uint8)
		Expression: inputIndex > CALL_STACK_SIZE
		IRs:
			TMP_8072(bool) = inputIndex > CALL_STACK_SIZE
			CONDITION TMP_8072
		Expression: revert InvalidMappingIndex(uint8)({index:inputIndex})
		IRs:
			TMP_8073(None) = SOLIDITY_CALL revert InvalidMappingIndex(uint8)(inputIndex)
		Expression: inputIndex > 0
		IRs:
			TMP_8074(bool) = inputIndex > 0
			CONDITION TMP_8074
		Expression: result = callStack[inputIndex - 1]
		IRs:
			TMP_8075(uint8) = inputIndex (c)- 1
			REF_2413(uint256) -> callStack[TMP_8075]
			result(uint256) := REF_2413(uint256)
		Expression: result = value
		IRs:
			result(uint256) := value(uint256)
	Function Commands.pushOutputParam(uint256[],uint256,uint64,uint8) (*)
		Expression: position > CALL_STACK_SIZE
		IRs:
			TMP_8076(bool) = position > CALL_STACK_SIZE
			CONDITION TMP_8076
		Expression: revert InvalidPosition(uint8)({position:position})
		IRs:
			TMP_8077(None) = SOLIDITY_CALL revert InvalidPosition(uint8)(position)
		Expression: outputIndex = uint8(((outputMapping >> (INDEX_SLOT_SIZE * (position - 1))) & INDEX_SLOT_MASK))
		IRs:
			TMP_8078(uint8) = position (c)- 1
			TMP_8079(uint8) = INDEX_SLOT_SIZE (c)* TMP_8078
			TMP_8080(uint64) = outputMapping >> TMP_8079
			TMP_8081(uint64) = TMP_8080 & INDEX_SLOT_MASK
			TMP_8082 = CONVERT TMP_8081 to uint8
			outputIndex(uint8) := TMP_8082(uint8)
		Expression: outputIndex > CALL_STACK_SIZE
		IRs:
			TMP_8083(bool) = outputIndex > CALL_STACK_SIZE
			CONDITION TMP_8083
		Expression: revert InvalidMappingIndex(uint8)({index:outputIndex})
		IRs:
			TMP_8084(None) = SOLIDITY_CALL revert InvalidMappingIndex(uint8)(outputIndex)
		Expression: outputIndex > 0
		IRs:
			TMP_8085(bool) = outputIndex > 0
			CONDITION TMP_8085
		Expression: callStack[outputIndex - 1] = value
		IRs:
			TMP_8086(uint8) = outputIndex (c)- 1
			REF_2414(uint256) -> callStack[TMP_8086]
			REF_2414(uint256) (->callStack) := value(uint256)
	Function Commands.slitherConstructorConstantVariables() (*)
		Expression: V3_UNISWAP_SWAP = 0x01
		IRs:
			V3_UNISWAP_SWAP(uint8) := 1(uint256)
		Expression: PULL_TOKEN = 0x02
		IRs:
			PULL_TOKEN(uint8) := 2(uint256)
		Expression: PULL_TOKEN_FROM = 0x03
		IRs:
			PULL_TOKEN_FROM(uint8) := 3(uint256)
		Expression: PUSH_TOKEN = 0x04
		IRs:
			PUSH_TOKEN(uint8) := 4(uint256)
		Expression: PUSH_TOKEN_FROM = 0x05
		IRs:
			PUSH_TOKEN_FROM(uint8) := 5(uint256)
		Expression: SWEEP_TOKENS = 0x06
		IRs:
			SWEEP_TOKENS(uint8) := 6(uint256)
		Expression: WRAP_ETH = 0x07
		IRs:
			WRAP_ETH(uint8) := 7(uint256)
		Expression: UNWRAP_ETH = 0x08
		IRs:
			UNWRAP_ETH(uint8) := 8(uint256)
		Expression: PULL_TOKEN_WITH_PERMIT = 0x09
		IRs:
			PULL_TOKEN_WITH_PERMIT(uint8) := 9(uint256)
		Expression: ERC4626_VAULT_DEPOSIT = 0x10
		IRs:
			ERC4626_VAULT_DEPOSIT(uint8) := 16(uint256)
		Expression: ERC4626_VAULT_MINT = 0x11
		IRs:
			ERC4626_VAULT_MINT(uint8) := 17(uint256)
		Expression: ERC4626_VAULT_REDEEM = 0x12
		IRs:
			ERC4626_VAULT_REDEEM(uint8) := 18(uint256)
		Expression: ERC4626_VAULT_WITHDRAW = 0x13
		IRs:
			ERC4626_VAULT_WITHDRAW(uint8) := 19(uint256)
		Expression: ERC4626_VAULT_CONVERT_TO_SHARES = 0x14
		IRs:
			ERC4626_VAULT_CONVERT_TO_SHARES(uint8) := 20(uint256)
		Expression: ERC4626_VAULT_CONVERT_TO_ASSETS = 0x15
		IRs:
			ERC4626_VAULT_CONVERT_TO_ASSETS(uint8) := 21(uint256)
		Expression: AERODROME_SWAP = 0x20
		IRs:
			AERODROME_SWAP(uint8) := 32(uint256)
		Expression: V2_UNISWAP_SWAP = 0x21
		IRs:
			V2_UNISWAP_SWAP(uint8) := 33(uint256)
		Expression: THIRTY_TWO_BITS_MASK = 0xFFFFFFFF
		IRs:
			THIRTY_TWO_BITS_MASK(uint32) := 4294967295(uint256)
		Expression: INDEX_SLOT_SIZE = 8
		IRs:
			INDEX_SLOT_SIZE(uint8) := 8(uint256)
		Expression: CALL_STACK_SIZE = 8
		IRs:
			CALL_STACK_SIZE(uint256) := 8(uint256)
		Expression: INDEX_SLOT_MASK = 0xFF
		IRs:
			INDEX_SLOT_MASK(uint8) := 255(uint256)
Contract StrategyAeroSwapAnd
	Function UseAeroSwapper._initAeroSwapper(ISwapRouter) (*)
		Expression: _aeroRouter = iAeroRouter
		IRs:
			_aeroRouter(ISwapRouter) := iAeroRouter(ISwapRouter)
		Expression: address(_aeroRouter) == address(0)
		IRs:
			TMP_8087 = CONVERT _aeroRouter to address
			TMP_8088 = CONVERT 0 to address
			TMP_8089(bool) = TMP_8087 == TMP_8088
			CONDITION TMP_8089
		Expression: revert InvalidAeroRouterContract()()
		IRs:
			TMP_8090(None) = SOLIDITY_CALL revert InvalidAeroRouterContract()()
	Function UseAeroSwapper.aeroRouter() (*)
		Expression: _aeroRouter
		IRs:
			RETURN _aeroRouter
	Function UseAeroSwapper.aeroRouterA() (*)
		Expression: address(_aeroRouter)
		IRs:
			TMP_8091 = CONVERT _aeroRouter to address
			RETURN TMP_8091
	Function UseAeroSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(_aeroRouter),amount)
		IRs:
			TMP_8092 = CONVERT _aeroRouter to address
			TMP_8093(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_8092', 'amount']  
			TMP_8094 = UnaryType.BANG TMP_8093 
			CONDITION TMP_8094
		Expression: revert FailedToApproveAllowanceForSwapRouter()()
		IRs:
			TMP_8095(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForSwapRouter()()
	Function UseAeroSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: AerodromeLibrary.swapAerodrome(aeroRouter(),params)
		IRs:
			TMP_8096(ISwapRouter) = INTERNAL_CALL, UseAeroSwapper.aeroRouter()()
			TUPLE_92(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_8096', 'params'] 
			RETURN TUPLE_92
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle) (*)
		Expression: address(iAsset) == address(0) || address(iUnderlyingStrategy.asset()) == address(0) || address(iOracle) == address(0)
		IRs:
			TMP_8097 = CONVERT iAsset to address
			TMP_8098 = CONVERT 0 to address
			TMP_8099(bool) = TMP_8097 == TMP_8098
			TMP_8100(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8101 = CONVERT TMP_8100 to address
			TMP_8102 = CONVERT 0 to address
			TMP_8103(bool) = TMP_8101 == TMP_8102
			TMP_8104(bool) = TMP_8099 || TMP_8103
			TMP_8105 = CONVERT iOracle to address
			TMP_8106 = CONVERT 0 to address
			TMP_8107(bool) = TMP_8105 == TMP_8106
			TMP_8108(bool) = TMP_8104 || TMP_8107
			CONDITION TMP_8108
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_8109(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _asset = iAsset
		IRs:
			_asset(IERC20) := iAsset(IERC20)
		Expression: _oracle = iOracle
		IRs:
			_oracle(IOracle) := iOracle(IOracle)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ! IERC20(iUnderlyingStrategy.asset()).approve(address(iUnderlyingStrategy),2 ** 256 - 1)
		IRs:
			TMP_8111(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8112 = CONVERT TMP_8111 to IERC20
			TMP_8113 = CONVERT iUnderlyingStrategy to address
			TMP_8114(uint256) = 2 (c)** 256
			TMP_8115(uint256) = TMP_8114 (c)- 1
			TMP_8116(bool) = HIGH_LEVEL_CALL, dest:TMP_8112(IERC20), function:approve, arguments:['TMP_8113', 'TMP_8115']  
			TMP_8117 = UnaryType.BANG TMP_8116 
			CONDITION TMP_8117
		Expression: revert FailedToApproveAllowanceFor()()
		IRs:
			TMP_8118(None) = SOLIDITY_CALL revert FailedToApproveAllowanceFor()()
		Expression: _underlyingStrategy = iUnderlyingStrategy
		IRs:
			_underlyingStrategy(IStrategy) := iUnderlyingStrategy(IStrategy)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySwapAnd.underlyingAsset() (*)
		Expression: _underlyingStrategy.asset()
		IRs:
			TMP_8120(address) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:asset, arguments:[]  
			RETURN TMP_8120
	Function StrategySwapAnd.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8121(bool) = amount == 0
			CONDITION TMP_8121
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8122(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:0})
		IRs:
			TMP_8123(IOracle.PriceOptions) = new PriceOptions(3600,0)
			options(IOracle.PriceOptions) := TMP_8123(IOracle.PriceOptions)
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_8124 = CONVERT _asset to IERC20
			TMP_8125 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_8124', 'msg.sender', 'TMP_8125', 'amount'] 
		Expression: calculatedAmountOut = _convertToUnderlying(options,amount)
		IRs:
			TMP_8127(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			calculatedAmountOut(uint256) := TMP_8127(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_8128(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_8129(uint256) = calculatedAmountOut (c)* TMP_8128
			TMP_8130(uint256) = TMP_8129 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_8130(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(_asset),underlyingOut:address(underlyingAsset()),amountIn:amount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_8131 = CONVERT _asset to address
			TMP_8132(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_8133 = CONVERT TMP_8132 to address
			REF_2424(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8134(ISwapHandler.SwapParams) = new SwapParams(TMP_8131,TMP_8133,REF_2424,amount,minAmountOut,)
			TUPLE_93(uint256,uint256) = INTERNAL_CALL, StrategyAeroSwapAnd._swap(ISwapHandler.SwapParams)(TMP_8134)
			amountOut(uint256)= UNPACK TUPLE_93 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_8135(bool) = amountOut < minAmountOut
			CONDITION TMP_8135
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_8136(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _underlyingStrategy.deploy(amountOut)
		IRs:
			TMP_8137(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:deploy, arguments:['amountOut']  
		Expression: _deployedAmount += amountOut
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amountOut
		Expression: amountUsed = _convertFromUnderlying(options,amountOut)
		IRs:
			TMP_8138(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,amountOut)
			amountUsed(uint256) := TMP_8138(uint256)
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_8142(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_8142(IOracle.Price)
		Expression: amountOut_ = (amount * _oracle.getPrecision()) / price.price
		IRs:
			TMP_8143(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8144(uint256) = amount (c)* TMP_8143
			REF_2428(uint256) -> price.price
			TMP_8145(uint256) = TMP_8144 (c)/ REF_2428
			amountOut_(uint256) := TMP_8145(uint256)
	Function StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_8146(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_8146(IOracle.Price)
		Expression: amountOut_ = (amount * price.price) / _oracle.getPrecision()
		IRs:
			REF_2430(uint256) -> price.price
			TMP_8147(uint256) = amount (c)* REF_2430
			TMP_8148(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8149(uint256) = TMP_8147 (c)/ TMP_8148
			amountOut_(uint256) := TMP_8149(uint256)
	Function StrategySwapAnd._swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8150(bool) = amount == 0
			CONDITION TMP_8150
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8151(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_8152(bool) = amount > _deployedAmount
			CONDITION TMP_8152
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8153(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:100})
		IRs:
			TMP_8154(IOracle.PriceOptions) = new PriceOptions(3600,100)
			options(IOracle.PriceOptions) := TMP_8154(IOracle.PriceOptions)
		Expression: undeployedAmount = _underlyingStrategy.undeploy(_convertToUnderlying(options,amount))
		IRs:
			TMP_8155(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			TMP_8156(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:undeploy, arguments:['TMP_8155']  
			undeployedAmount(uint256) := TMP_8156(uint256)
		Expression: calculatedAmountOut = _convertFromUnderlying(options,undeployedAmount)
		IRs:
			TMP_8157(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,undeployedAmount)
			calculatedAmountOut(uint256) := TMP_8157(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_8158(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_8159(uint256) = calculatedAmountOut (c)* TMP_8158
			TMP_8160(uint256) = TMP_8159 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_8160(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(underlyingAsset()),underlyingOut:address(_asset),amountIn:undeployedAmount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_8161(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_8162 = CONVERT TMP_8161 to address
			TMP_8163 = CONVERT _asset to address
			REF_2435(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8164(ISwapHandler.SwapParams) = new SwapParams(TMP_8162,TMP_8163,REF_2435,undeployedAmount,minAmountOut,)
			TUPLE_94(uint256,uint256) = INTERNAL_CALL, StrategyAeroSwapAnd._swap(ISwapHandler.SwapParams)(TMP_8164)
			amountOut(uint256)= UNPACK TUPLE_94 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_8165(bool) = amountOut < minAmountOut
			CONDITION TMP_8165
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_8166(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _deployedAmount -= undeployedAmount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- undeployedAmount
		Expression: undeployedAmount_ = amountOut
		IRs:
			undeployedAmount_(uint256) := amountOut(uint256)
		Expression: IERC20(_asset).safeTransfer(msg.sender,amountOut)
		IRs:
			TMP_8167 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_8167', 'msg.sender', 'amountOut'] 
		Expression: StrategyUndeploy(msg.sender,amountOut)
		IRs:
			Emit StrategyUndeploy(msg.sender,amountOut)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.harvest() (*)
		Expression: newBalance = _totalAssets()
		IRs:
			TMP_8172(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			newBalance(uint256) := TMP_8172(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_8173 = CONVERT newBalance to int256
			TMP_8174 = CONVERT _deployedAmount to int256
			TMP_8175(int256) = TMP_8173 (c)- TMP_8174
			balanceChange(int256) := TMP_8175(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_8176(bool) = balanceChange > 0
			CONDITION TMP_8176
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_8177 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_8177)
		Expression: balanceChange < 0
		IRs:
			TMP_8179(bool) = balanceChange < 0
			CONDITION TMP_8179
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_8180(int256) = 0 (c)- balanceChange
			TMP_8181 = CONVERT TMP_8180 to uint256
			Emit StrategyLoss(TMP_8181)
		Expression: balanceChange != 0
		IRs:
			TMP_8183(bool) = balanceChange != 0
			CONDITION TMP_8183
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.totalAssets() (*)
		Expression: _totalAssets()
		IRs:
			TMP_8186(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			RETURN TMP_8186
	Function StrategySwapAnd._totalAssets() (*)
		Expression: underlyingAssets = _underlyingStrategy.totalAssets()
		IRs:
			TMP_8187(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:totalAssets, arguments:[]  
			underlyingAssets(uint256) := TMP_8187(uint256)
		Expression: amount_ = _convertFromUnderlying(IOracle.PriceOptions({maxAge:0,maxConf:0}),underlyingAssets)
		IRs:
			TMP_8188(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_8189(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(TMP_8188,underlyingAssets)
			amount_(uint256) := TMP_8189(uint256)
		Expression: amount_
		IRs:
			RETURN amount_
	Function StrategySwapAnd.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_8190 = CONVERT _asset to address
			RETURN TMP_8190
	Function StrategySwapAnd.setMaxSlippage(uint256) (*)
		Expression: _maxSlippage = maxSlippage_
		IRs:
			_maxSlippage(uint256) := maxSlippage_(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySwapAnd.maxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategySwapAnd.oracle() (*)
		Expression: address(_oracle)
		IRs:
			TMP_8192 = CONVERT _oracle to address
			RETURN TMP_8192
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_8193(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_8193)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_8195(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_8196(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_8197(bool) = TMP_8195 == TMP_8196
			TMP_8198(None) = SOLIDITY_CALL require(bool,string)(TMP_8197,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_8199 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_8199)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_8202 = CONVERT 0 to address
			TMP_8203(bool) = newOwner != TMP_8202
			TMP_8204(None) = SOLIDITY_CALL require(bool,string)(TMP_8203,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_8208(bool) = _status != _ENTERED
			TMP_8209(None) = SOLIDITY_CALL require(bool,string)(TMP_8208,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_8210(bool) = _status == _ENTERED
			RETURN TMP_8210
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyAeroSwapAnd.constructor(address,IERC20,IStrategy,IOracle,ISwapRouter) (*)
		Expression: _initAeroSwapper(router)
		IRs:
			INTERNAL_CALL, UseAeroSwapper._initAeroSwapper(ISwapRouter)(router)
		Expression: _allowRouterSpend(IERC20(iAsset),2 ** 256 - 1)
		IRs:
			TMP_8212 = CONVERT iAsset to IERC20
			TMP_8213(uint256) = 2 (c)** 256
			TMP_8214(uint256) = TMP_8213 (c)- 1
			INTERNAL_CALL, UseAeroSwapper._allowRouterSpend(IERC20,uint256)(TMP_8212,TMP_8214)
		Expression: _allowRouterSpend(IERC20(iUnderlyingStrategy.asset()),2 ** 256 - 1)
		IRs:
			TMP_8216(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8217 = CONVERT TMP_8216 to IERC20
			TMP_8218(uint256) = 2 (c)** 256
			TMP_8219(uint256) = TMP_8218 (c)- 1
			INTERNAL_CALL, UseAeroSwapper._allowRouterSpend(IERC20,uint256)(TMP_8217,TMP_8219)
		Expression: StrategySwapAnd(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
		IRs:
			INTERNAL_CALL, StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle)(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
	Function StrategyAeroSwapAnd._swap(ISwapHandler.SwapParams) (*)
		Expression: UseAeroSwapper.swap(params)
		IRs:
			TUPLE_95(uint256,uint256) = INTERNAL_CALL, UseAeroSwapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_95
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategyCurveSwapAnd
	Function UseCurveSwapper._initUseCurveSwapper(ICurveRouterNG) (*)
		Expression: address(icurveRouterNG) == address(0)
		IRs:
			TMP_8225 = CONVERT icurveRouterNG to address
			TMP_8226 = CONVERT 0 to address
			TMP_8227(bool) = TMP_8225 == TMP_8226
			CONDITION TMP_8227
		Expression: revert InvalidCurveRouterContract()()
		IRs:
			TMP_8228(None) = SOLIDITY_CALL revert InvalidCurveRouterContract()()
		Expression: sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
		IRs:
			TMP_8229(None) = SOLIDITY_CALL sstore(uint256,uint256)(_CURVE_ROUTER_SLOT,icurveRouterNG)
	Function UseCurveSwapper.curveRouter() (*)
		Expression: router = sload(uint256)(_CURVE_ROUTER_SLOT)
		IRs:
			TMP_8230(uint256) = SOLIDITY_CALL sload(uint256)(_CURVE_ROUTER_SLOT)
			router(address) := TMP_8230(uint256)
		Expression: ICurveRouterNG(router)
		IRs:
			TMP_8231 = CONVERT router to ICurveRouterNG
			RETURN TMP_8231
	Function UseCurveSwapper.curveRouterA() (*)
		Expression: address(curveRouter())
		IRs:
			TMP_8232(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TMP_8233 = CONVERT TMP_8232 to address
			RETURN TMP_8233
	Function UseCurveSwapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(curveRouterA(),amount)
		IRs:
			TMP_8234(address) = INTERNAL_CALL, UseCurveSwapper.curveRouterA()()
			TMP_8235(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_8234', 'amount']  
			TMP_8236 = UnaryType.BANG TMP_8235 
			CONDITION TMP_8236
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8237(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function UseCurveSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: CurveFiLibrary.swapCurveFi(curveRouter(),params)
		IRs:
			TMP_8238(ICurveRouterNG) = INTERNAL_CALL, UseCurveSwapper.curveRouter()()
			TUPLE_96(uint256,uint256) = LIBRARY_CALL, dest:CurveFiLibrary, function:CurveFiLibrary.swapCurveFi(ICurveRouterNG,ISwapHandler.SwapParams), arguments:['TMP_8238', 'params'] 
			RETURN TUPLE_96
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle) (*)
		Expression: address(iAsset) == address(0) || address(iUnderlyingStrategy.asset()) == address(0) || address(iOracle) == address(0)
		IRs:
			TMP_8239 = CONVERT iAsset to address
			TMP_8240 = CONVERT 0 to address
			TMP_8241(bool) = TMP_8239 == TMP_8240
			TMP_8242(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8243 = CONVERT TMP_8242 to address
			TMP_8244 = CONVERT 0 to address
			TMP_8245(bool) = TMP_8243 == TMP_8244
			TMP_8246(bool) = TMP_8241 || TMP_8245
			TMP_8247 = CONVERT iOracle to address
			TMP_8248 = CONVERT 0 to address
			TMP_8249(bool) = TMP_8247 == TMP_8248
			TMP_8250(bool) = TMP_8246 || TMP_8249
			CONDITION TMP_8250
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_8251(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _asset = iAsset
		IRs:
			_asset(IERC20) := iAsset(IERC20)
		Expression: _oracle = iOracle
		IRs:
			_oracle(IOracle) := iOracle(IOracle)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ! IERC20(iUnderlyingStrategy.asset()).approve(address(iUnderlyingStrategy),2 ** 256 - 1)
		IRs:
			TMP_8253(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8254 = CONVERT TMP_8253 to IERC20
			TMP_8255 = CONVERT iUnderlyingStrategy to address
			TMP_8256(uint256) = 2 (c)** 256
			TMP_8257(uint256) = TMP_8256 (c)- 1
			TMP_8258(bool) = HIGH_LEVEL_CALL, dest:TMP_8254(IERC20), function:approve, arguments:['TMP_8255', 'TMP_8257']  
			TMP_8259 = UnaryType.BANG TMP_8258 
			CONDITION TMP_8259
		Expression: revert FailedToApproveAllowanceFor()()
		IRs:
			TMP_8260(None) = SOLIDITY_CALL revert FailedToApproveAllowanceFor()()
		Expression: _underlyingStrategy = iUnderlyingStrategy
		IRs:
			_underlyingStrategy(IStrategy) := iUnderlyingStrategy(IStrategy)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySwapAnd.underlyingAsset() (*)
		Expression: _underlyingStrategy.asset()
		IRs:
			TMP_8262(address) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:asset, arguments:[]  
			RETURN TMP_8262
	Function StrategySwapAnd.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8263(bool) = amount == 0
			CONDITION TMP_8263
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8264(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:0})
		IRs:
			TMP_8265(IOracle.PriceOptions) = new PriceOptions(3600,0)
			options(IOracle.PriceOptions) := TMP_8265(IOracle.PriceOptions)
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_8266 = CONVERT _asset to IERC20
			TMP_8267 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_8266', 'msg.sender', 'TMP_8267', 'amount'] 
		Expression: calculatedAmountOut = _convertToUnderlying(options,amount)
		IRs:
			TMP_8269(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			calculatedAmountOut(uint256) := TMP_8269(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_8270(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_8271(uint256) = calculatedAmountOut (c)* TMP_8270
			TMP_8272(uint256) = TMP_8271 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_8272(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(_asset),underlyingOut:address(underlyingAsset()),amountIn:amount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_8273 = CONVERT _asset to address
			TMP_8274(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_8275 = CONVERT TMP_8274 to address
			REF_2450(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8276(ISwapHandler.SwapParams) = new SwapParams(TMP_8273,TMP_8275,REF_2450,amount,minAmountOut,)
			TUPLE_97(uint256,uint256) = INTERNAL_CALL, StrategyCurveSwapAnd._swap(ISwapHandler.SwapParams)(TMP_8276)
			amountOut(uint256)= UNPACK TUPLE_97 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_8277(bool) = amountOut < minAmountOut
			CONDITION TMP_8277
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_8278(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _underlyingStrategy.deploy(amountOut)
		IRs:
			TMP_8279(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:deploy, arguments:['amountOut']  
		Expression: _deployedAmount += amountOut
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amountOut
		Expression: amountUsed = _convertFromUnderlying(options,amountOut)
		IRs:
			TMP_8280(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,amountOut)
			amountUsed(uint256) := TMP_8280(uint256)
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_8284(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_8284(IOracle.Price)
		Expression: amountOut_ = (amount * _oracle.getPrecision()) / price.price
		IRs:
			TMP_8285(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8286(uint256) = amount (c)* TMP_8285
			REF_2454(uint256) -> price.price
			TMP_8287(uint256) = TMP_8286 (c)/ REF_2454
			amountOut_(uint256) := TMP_8287(uint256)
	Function StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_8288(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_8288(IOracle.Price)
		Expression: amountOut_ = (amount * price.price) / _oracle.getPrecision()
		IRs:
			REF_2456(uint256) -> price.price
			TMP_8289(uint256) = amount (c)* REF_2456
			TMP_8290(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8291(uint256) = TMP_8289 (c)/ TMP_8290
			amountOut_(uint256) := TMP_8291(uint256)
	Function StrategySwapAnd._swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8292(bool) = amount == 0
			CONDITION TMP_8292
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8293(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_8294(bool) = amount > _deployedAmount
			CONDITION TMP_8294
		Expression: revert InvalidAmount()()
		IRs:
			TMP_8295(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:100})
		IRs:
			TMP_8296(IOracle.PriceOptions) = new PriceOptions(3600,100)
			options(IOracle.PriceOptions) := TMP_8296(IOracle.PriceOptions)
		Expression: undeployedAmount = _underlyingStrategy.undeploy(_convertToUnderlying(options,amount))
		IRs:
			TMP_8297(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			TMP_8298(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:undeploy, arguments:['TMP_8297']  
			undeployedAmount(uint256) := TMP_8298(uint256)
		Expression: calculatedAmountOut = _convertFromUnderlying(options,undeployedAmount)
		IRs:
			TMP_8299(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,undeployedAmount)
			calculatedAmountOut(uint256) := TMP_8299(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_8300(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_8301(uint256) = calculatedAmountOut (c)* TMP_8300
			TMP_8302(uint256) = TMP_8301 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_8302(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(underlyingAsset()),underlyingOut:address(_asset),amountIn:undeployedAmount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_8303(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_8304 = CONVERT TMP_8303 to address
			TMP_8305 = CONVERT _asset to address
			REF_2461(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8306(ISwapHandler.SwapParams) = new SwapParams(TMP_8304,TMP_8305,REF_2461,undeployedAmount,minAmountOut,)
			TUPLE_98(uint256,uint256) = INTERNAL_CALL, StrategyCurveSwapAnd._swap(ISwapHandler.SwapParams)(TMP_8306)
			amountOut(uint256)= UNPACK TUPLE_98 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_8307(bool) = amountOut < minAmountOut
			CONDITION TMP_8307
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_8308(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _deployedAmount -= undeployedAmount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- undeployedAmount
		Expression: undeployedAmount_ = amountOut
		IRs:
			undeployedAmount_(uint256) := amountOut(uint256)
		Expression: IERC20(_asset).safeTransfer(msg.sender,amountOut)
		IRs:
			TMP_8309 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_8309', 'msg.sender', 'amountOut'] 
		Expression: StrategyUndeploy(msg.sender,amountOut)
		IRs:
			Emit StrategyUndeploy(msg.sender,amountOut)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.harvest() (*)
		Expression: newBalance = _totalAssets()
		IRs:
			TMP_8314(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			newBalance(uint256) := TMP_8314(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_8315 = CONVERT newBalance to int256
			TMP_8316 = CONVERT _deployedAmount to int256
			TMP_8317(int256) = TMP_8315 (c)- TMP_8316
			balanceChange(int256) := TMP_8317(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_8318(bool) = balanceChange > 0
			CONDITION TMP_8318
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_8319 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_8319)
		Expression: balanceChange < 0
		IRs:
			TMP_8321(bool) = balanceChange < 0
			CONDITION TMP_8321
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_8322(int256) = 0 (c)- balanceChange
			TMP_8323 = CONVERT TMP_8322 to uint256
			Emit StrategyLoss(TMP_8323)
		Expression: balanceChange != 0
		IRs:
			TMP_8325(bool) = balanceChange != 0
			CONDITION TMP_8325
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.totalAssets() (*)
		Expression: _totalAssets()
		IRs:
			TMP_8328(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			RETURN TMP_8328
	Function StrategySwapAnd._totalAssets() (*)
		Expression: underlyingAssets = _underlyingStrategy.totalAssets()
		IRs:
			TMP_8329(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:totalAssets, arguments:[]  
			underlyingAssets(uint256) := TMP_8329(uint256)
		Expression: amount_ = _convertFromUnderlying(IOracle.PriceOptions({maxAge:0,maxConf:0}),underlyingAssets)
		IRs:
			TMP_8330(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_8331(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(TMP_8330,underlyingAssets)
			amount_(uint256) := TMP_8331(uint256)
		Expression: amount_
		IRs:
			RETURN amount_
	Function StrategySwapAnd.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_8332 = CONVERT _asset to address
			RETURN TMP_8332
	Function StrategySwapAnd.setMaxSlippage(uint256) (*)
		Expression: _maxSlippage = maxSlippage_
		IRs:
			_maxSlippage(uint256) := maxSlippage_(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySwapAnd.maxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategySwapAnd.oracle() (*)
		Expression: address(_oracle)
		IRs:
			TMP_8334 = CONVERT _oracle to address
			RETURN TMP_8334
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_8335(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_8335)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_8337(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_8338(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_8339(bool) = TMP_8337 == TMP_8338
			TMP_8340(None) = SOLIDITY_CALL require(bool,string)(TMP_8339,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_8341 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_8341)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_8344 = CONVERT 0 to address
			TMP_8345(bool) = newOwner != TMP_8344
			TMP_8346(None) = SOLIDITY_CALL require(bool,string)(TMP_8345,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_8350(bool) = _status != _ENTERED
			TMP_8351(None) = SOLIDITY_CALL require(bool,string)(TMP_8350,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_8352(bool) = _status == _ENTERED
			RETURN TMP_8352
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyCurveSwapAnd.constructor(address,IERC20,IStrategy,IOracle,ICurveRouterNG,address,uint8,uint8,uint8,uint8) (*)
		Expression: iPool == address(0)
		IRs:
			TMP_8353 = CONVERT 0 to address
			TMP_8354(bool) = iPool == TMP_8353
			CONDITION TMP_8354
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_8355(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _pool = iPool
		IRs:
			_pool(address) := iPool(address)
		Expression: _inTokenPoolIndex = inTokenPoolIndex
		IRs:
			_inTokenPoolIndex(uint8) := inTokenPoolIndex(uint8)
		Expression: _outTokenPoolIndex = outTokenPoolIndex
		IRs:
			_outTokenPoolIndex(uint8) := outTokenPoolIndex(uint8)
		Expression: _swapType = iSwapType
		IRs:
			_swapType(uint8) := iSwapType(uint8)
		Expression: _poolType = iPoolType
		IRs:
			_poolType(uint8) := iPoolType(uint8)
		Expression: _initUseCurveSwapper(router)
		IRs:
			INTERNAL_CALL, UseCurveSwapper._initUseCurveSwapper(ICurveRouterNG)(router)
		Expression: _allowRouterSpend(IERC20(iAsset),type()(uint256).max)
		IRs:
			TMP_8357 = CONVERT iAsset to IERC20
			TMP_8359(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			INTERNAL_CALL, UseCurveSwapper._allowRouterSpend(IERC20,uint256)(TMP_8357,TMP_8359)
		Expression: _allowRouterSpend(IERC20(iUnderlyingStrategy.asset()),type()(uint256).max)
		IRs:
			TMP_8361(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_8362 = CONVERT TMP_8361 to IERC20
			TMP_8364(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			INTERNAL_CALL, UseCurveSwapper._allowRouterSpend(IERC20,uint256)(TMP_8362,TMP_8364)
		Expression: StrategySwapAnd(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
		IRs:
			INTERNAL_CALL, StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle)(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
	Function StrategyCurveSwapAnd._swap(ISwapHandler.SwapParams) (*)
		Expression: UseCurveSwapper.swap(params)
		IRs:
			TUPLE_99(uint256,uint256) = INTERNAL_CALL, UseCurveSwapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_99
		Expression: params.underlyingIn == address(_asset)
		IRs:
			REF_2467(address) -> params.underlyingIn
			TMP_8367 = CONVERT _asset to address
			TMP_8368(bool) = REF_2467 == TMP_8367
			CONDITION TMP_8368
		Expression: params.underlyingOut == address(_asset)
		IRs:
			REF_2468(address) -> params.underlyingOut
			TMP_8369 = CONVERT _asset to address
			TMP_8370(bool) = REF_2468 == TMP_8369
			CONDITION TMP_8370
		Expression: params.payload = abi.encode(uint256(_inTokenPoolIndex),uint256(_inTokenPoolIndex),uint256(_swapType),uint256(_poolType),_pool)
		IRs:
			REF_2469(bytes) -> params.payload
			TMP_8371 = CONVERT _inTokenPoolIndex to uint256
			TMP_8372 = CONVERT _inTokenPoolIndex to uint256
			TMP_8373 = CONVERT _swapType to uint256
			TMP_8374 = CONVERT _poolType to uint256
			TMP_8375(bytes) = SOLIDITY_CALL abi.encode()(TMP_8371,TMP_8372,TMP_8373,TMP_8374,_pool)
			REF_2469(bytes) (->params) := TMP_8375(bytes)
		Expression: params.payload = abi.encode(uint256(_inTokenPoolIndex),uint256(_outTokenPoolIndex),uint256(_swapType),uint256(_poolType),_pool)
		IRs:
			REF_2471(bytes) -> params.payload
			TMP_8376 = CONVERT _inTokenPoolIndex to uint256
			TMP_8377 = CONVERT _outTokenPoolIndex to uint256
			TMP_8378 = CONVERT _swapType to uint256
			TMP_8379 = CONVERT _poolType to uint256
			TMP_8380(bytes) = SOLIDITY_CALL abi.encode()(TMP_8376,TMP_8377,TMP_8378,TMP_8379,_pool)
			REF_2471(bytes) (->params) := TMP_8380(bytes)
		Expression: params.underlyingOut == address(_asset)
		IRs:
			REF_2473(address) -> params.underlyingOut
			TMP_8381 = CONVERT _asset to address
			TMP_8382(bool) = REF_2473 == TMP_8381
			CONDITION TMP_8382
		Expression: params.payload = abi.encode(uint256(_outTokenPoolIndex),uint256(_inTokenPoolIndex),uint256(_swapType),uint256(_poolType),_pool)
		IRs:
			REF_2474(bytes) -> params.payload
			TMP_8383 = CONVERT _outTokenPoolIndex to uint256
			TMP_8384 = CONVERT _inTokenPoolIndex to uint256
			TMP_8385 = CONVERT _swapType to uint256
			TMP_8386 = CONVERT _poolType to uint256
			TMP_8387(bytes) = SOLIDITY_CALL abi.encode()(TMP_8383,TMP_8384,TMP_8385,TMP_8386,_pool)
			REF_2474(bytes) (->params) := TMP_8387(bytes)
		Expression: params.payload = abi.encode(uint256(_outTokenPoolIndex),uint256(_outTokenPoolIndex),uint256(_swapType),uint256(_poolType),_pool)
		IRs:
			REF_2476(bytes) -> params.payload
			TMP_8388 = CONVERT _outTokenPoolIndex to uint256
			TMP_8389 = CONVERT _outTokenPoolIndex to uint256
			TMP_8390 = CONVERT _swapType to uint256
			TMP_8391 = CONVERT _poolType to uint256
			TMP_8392(bytes) = SOLIDITY_CALL abi.encode()(TMP_8388,TMP_8389,TMP_8390,TMP_8391,_pool)
			REF_2476(bytes) (->params) := TMP_8392(bytes)
	Function StrategyCurveSwapAnd.pool() (*)
		Expression: _pool
		IRs:
			RETURN _pool
	Function StrategyCurveSwapAnd.slitherConstructorConstantVariables() (*)
		Expression: _CURVE_ROUTER_SLOT = 0x12bf5c1f8c71d2ab50ad26cd63e0f5c50ba43161b985f5d4c823c1c5b55e3f1b
		IRs:
			_CURVE_ROUTER_SLOT(bytes32) := 8479734875084262680902722603771659957122315217523620232617646262729918267163(uint256)
		Expression: ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
		IRs:
			ETH_ADDRESS(address) := 1364068194842176056990105843868530818345537040110(address)
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategyLeverage
	Function UseLeverage._calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_8396(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_8396
		Expression: revert InvalidNumberOfLoops()()
		IRs:
			TMP_8397(None) = SOLIDITY_CALL revert InvalidNumberOfLoops()()
		Expression: loanToValue == 0 || loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_8398(bool) = loanToValue == 0
			TMP_8399(bool) = loanToValue > PERCENTAGE_PRECISION
			TMP_8400(bool) = TMP_8398 || TMP_8399
			CONDITION TMP_8400
		Expression: revert InvalidLoanToValue()()
		IRs:
			TMP_8401(None) = SOLIDITY_CALL revert InvalidLoanToValue()()
		Expression: leverage = baseValue
		IRs:
			leverage(uint256) := baseValue(uint256)
		Expression: prev = baseValue
		IRs:
			prev(uint256) := baseValue(uint256)
		Expression: i = 1
		IRs:
			i(uint8) := 1(uint256)
		Expression: i <= nrLoops
		IRs:
			TMP_8402(bool) = i <= nrLoops
			CONDITION TMP_8402
		Expression: inc = (prev * loanToValue) / PERCENTAGE_PRECISION
		IRs:
			TMP_8403(uint256) = prev (c)* loanToValue
			TMP_8404(uint256) = TMP_8403 (c)/ PERCENTAGE_PRECISION
			inc(uint256) := TMP_8404(uint256)
		Expression: leverage += inc
		IRs:
			leverage(uint256) = leverage (c)+ inc
		Expression: prev = inc
		IRs:
			prev(uint256) := inc(uint256)
		Expression: ++ i
		IRs:
			i(uint8) = i + 1
		Expression: leverage
		IRs:
			RETURN leverage
	Function UseLeverage._calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: percentageToBurn == 0 || percentageToBurn > PERCENTAGE_PRECISION
		IRs:
			TMP_8405(bool) = percentageToBurn == 0
			TMP_8406(bool) = percentageToBurn > PERCENTAGE_PRECISION
			TMP_8407(bool) = TMP_8405 || TMP_8406
			CONDITION TMP_8407
		Expression: revert InvalidPercentageValue()()
		IRs:
			TMP_8408(None) = SOLIDITY_CALL revert InvalidPercentageValue()()
		Expression: deltaDebtInETH = (totalDebtBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_8409(uint256) = totalDebtBaseInEth (c)* percentageToBurn
			TMP_8410(uint256) = TMP_8409 (c)/ PERCENTAGE_PRECISION
			deltaDebtInETH(uint256) := TMP_8410(uint256)
		Expression: deltaCollateralInETH = (totalCollateralBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_8411(uint256) = totalCollateralBaseInEth (c)* percentageToBurn
			TMP_8412(uint256) = TMP_8411 (c)/ PERCENTAGE_PRECISION
			deltaCollateralInETH(uint256) := TMP_8412(uint256)
	Function UseLeverage._calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: colValue = ((targetLoanToValue * collateral) / PERCENTAGE_PRECISION)
		IRs:
			TMP_8413(uint256) = targetLoanToValue (c)* collateral
			TMP_8414(uint256) = TMP_8413 (c)/ PERCENTAGE_PRECISION
			colValue(uint256) := TMP_8414(uint256)
		Expression: colValue >= debt
		IRs:
			TMP_8415(bool) = colValue >= debt
			CONDITION TMP_8415
		Expression: revert InvalidTargetValue()()
		IRs:
			TMP_8416(None) = SOLIDITY_CALL revert InvalidTargetValue()()
		Expression: numerator = debt - colValue
		IRs:
			TMP_8417(uint256) = debt (c)- colValue
			numerator(uint256) := TMP_8417(uint256)
		Expression: divisor = (PERCENTAGE_PRECISION - targetLoanToValue)
		IRs:
			TMP_8418(uint256) = PERCENTAGE_PRECISION (c)- targetLoanToValue
			divisor(uint256) := TMP_8418(uint256)
		Expression: divisor == 0
		IRs:
			TMP_8419(bool) = divisor == 0
			CONDITION TMP_8419
		Expression: revert InvalidDivisor()()
		IRs:
			TMP_8420(None) = SOLIDITY_CALL revert InvalidDivisor()()
		Expression: delta = (numerator * PERCENTAGE_PRECISION) / divisor
		IRs:
			TMP_8421(uint256) = numerator (c)* PERCENTAGE_PRECISION
			TMP_8422(uint256) = TMP_8421 (c)/ divisor
			delta(uint256) := TMP_8422(uint256)
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_8423 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_8423(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_8424 = CONVERT _fLender to address
			TMP_8425 = CONVERT 0 to address
			TMP_8426(bool) = TMP_8424 == TMP_8425
			CONDITION TMP_8426
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_8427(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_8429 = CONVERT _fLender to address
			RETURN TMP_8429
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_8430 = UnaryType.BANG _initializing 
			TMP_8431(None) = SOLIDITY_CALL require(bool,string)(TMP_8430,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_8433(uint8) := 255(uint8)
			TMP_8434(bool) = _initialized != TMP_8433
			CONDITION TMP_8434
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_8436(uint8) := 255(uint8)
			_initialized(uint8) := TMP_8436(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_8438(uint8) := 255(uint8)
			Emit Initialized(TMP_8438)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_8440(bool) = tokenA < tokenB
			CONDITION TMP_8440
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_8441(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d8286c90>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d82870d0>])
			TMP_8442(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8441)
			RETURN TMP_8442
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_8443(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d82870d0>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d8286c90>])
			TMP_8444(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8443)
			RETURN TMP_8444
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_8445(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_8445(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2480(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2481(UseUnifiedSwapper.SwapProvider) -> REF_2480.provider
			REF_2482(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_8446(bool) = REF_2481 != REF_2482
			CONDITION TMP_8446
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_8447(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_8448 = CONVERT tokenIn to IERC20
			REF_2484(address) -> routeInfo.router
			TMP_8450(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_8451(uint256) = TMP_8450 (c)- 1
			TMP_8452(bool) = HIGH_LEVEL_CALL, dest:TMP_8448(IERC20), function:approve, arguments:['REF_2484', 'TMP_8451']  
			TMP_8453 = UnaryType.BANG TMP_8452 
			CONDITION TMP_8453
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8454(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_8455 = CONVERT tokenOut to IERC20
			REF_2486(address) -> routeInfo.router
			TMP_8457(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_8458(uint256) = TMP_8457 (c)- 1
			TMP_8459(bool) = HIGH_LEVEL_CALL, dest:TMP_8455(IERC20), function:approve, arguments:['REF_2486', 'TMP_8458']  
			TMP_8460 = UnaryType.BANG TMP_8459 
			CONDITION TMP_8460
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8461(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_2487(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2487(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_8463(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_8463(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_2488(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2489(UseUnifiedSwapper.SwapProvider) -> REF_2488.provider
			REF_2490(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_8464(bool) = REF_2489 == REF_2490
			CONDITION TMP_8464
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_8465(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_8466 = CONVERT tokenIn to IERC20
			REF_2492(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2493(address) -> REF_2492.router
			TMP_8467(bool) = HIGH_LEVEL_CALL, dest:TMP_8466(IERC20), function:approve, arguments:['REF_2493', '0']  
			TMP_8468 = UnaryType.BANG TMP_8467 
			CONDITION TMP_8468
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8469(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_8470 = CONVERT tokenOut to IERC20
			REF_2495(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2496(address) -> REF_2495.router
			TMP_8471(bool) = HIGH_LEVEL_CALL, dest:TMP_8470(IERC20), function:approve, arguments:['REF_2496', '0']  
			TMP_8472 = UnaryType.BANG TMP_8471 
			CONDITION TMP_8472
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8473(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_2497(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2498(UseUnifiedSwapper.SwapProvider) -> REF_2497.provider
			REF_2499(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_2498(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_2499(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_8475(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_8475(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2500(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2501(UseUnifiedSwapper.SwapProvider) -> REF_2500.provider
			REF_2502(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_8476(bool) = REF_2501 != REF_2502
			RETURN TMP_8476
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_2503(address) -> params.underlyingIn
			REF_2504(address) -> params.underlyingOut
			TMP_8477(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_2503,REF_2504)
			key(bytes32) := TMP_8477(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_2505(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_2505(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_2506(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2507(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_8478(bool) = REF_2506 == REF_2507
			CONDITION TMP_8478
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_8479(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_2508(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2509(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_8480(bool) = REF_2508 == REF_2509
			CONDITION TMP_8480
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_2510(bytes) -> params.payload
			REF_2512(uint24) -> routeInfo.uniV3Tier
			TMP_8481(bytes) = SOLIDITY_CALL abi.encode()(REF_2512)
			REF_2510(bytes) (->params) := TMP_8481(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_2514(address) -> routeInfo.router
			TMP_8482 = CONVERT REF_2514 to IV3SwapRouter
			TUPLE_100(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_8482', 'params'] 
			RETURN TUPLE_100
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_2515(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2516(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_8483(bool) = REF_2515 == REF_2516
			CONDITION TMP_8483
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_2518(address) -> routeInfo.router
			TMP_8484 = CONVERT REF_2518 to IUniswapV2Router02
			TUPLE_101(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_8484', 'params'] 
			RETURN TUPLE_101
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_2519(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2520(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_8485(bool) = REF_2519 == REF_2520
			CONDITION TMP_8485
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_2521(bytes) -> params.payload
			REF_2523(uint24) -> routeInfo.tickSpacing
			TMP_8486(bytes) = SOLIDITY_CALL abi.encode()(REF_2523)
			REF_2521(bytes) (->params) := TMP_8486(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_2525(address) -> routeInfo.router
			TMP_8487 = CONVERT REF_2525 to ISwapRouter
			TUPLE_102(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_8487', 'params'] 
			RETURN TUPLE_102
		Expression: revert InvalidProvider()()
		IRs:
			TMP_8488(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_8492 = CONVERT 0 to address
			TMP_8493(bool) = _newGovernor == TMP_8492
			CONDITION TMP_8493
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_8494(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_8500(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_8500)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_8503(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_8504(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_8505(bool) = TMP_8503 == TMP_8504
			TMP_8506(None) = SOLIDITY_CALL require(bool,string)(TMP_8505,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() 
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_8507 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_8507)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_8510 = CONVERT 0 to address
			TMP_8511(bool) = newOwner != TMP_8510
			TMP_8512(None) = SOLIDITY_CALL require(bool,string)(TMP_8511,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_8521(bool) = _status != _ENTERED
			TMP_8522(None) = SOLIDITY_CALL require(bool,string)(TMP_8521,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_8523(bool) = _status == _ENTERED
			RETURN TMP_8523
	Function StrategyLeverageSettings._initLeverageSettings(address,address) (*)
		Expression: _initializeGovernableOwnable(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._initializeGovernableOwnable(address,address)(initialOwner,initialGovernor)
		Expression: _initializeStrategySettings()
		IRs:
			INTERNAL_CALL, StrategySettings._initializeStrategySettings()()
		Expression: _loanToValue = 800 * 1e6
		IRs:
			TMP_8526(uint256) = 800 (c)* 1000000
			_loanToValue(uint256) := TMP_8526(uint256)
		Expression: _maxLoanToValue = 850 * 1e6
		IRs:
			TMP_8527(uint256) = 850 (c)* 1000000
			_maxLoanToValue(uint256) := TMP_8527(uint256)
		Expression: _nrLoops = 10
		IRs:
			_nrLoops(uint8) := 10(uint256)
		Expression: _maxSlippage = 0
		IRs:
			_maxSlippage(uint256) := 0(uint256)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageSettings.setMaxLoanToValue(uint256) (*)
		Expression: maxLoanToValue == 0
		IRs:
			TMP_8529(bool) = maxLoanToValue == 0
			CONDITION TMP_8529
		Expression: revert InvalidValue()()
		IRs:
			TMP_8530(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: maxLoanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_8531(bool) = maxLoanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_8531
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_8532(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: maxLoanToValue < _loanToValue
		IRs:
			TMP_8533(bool) = maxLoanToValue < _loanToValue
			CONDITION TMP_8533
		Expression: revert InvalidMaxLoanToValue()()
		IRs:
			TMP_8534(None) = SOLIDITY_CALL revert InvalidMaxLoanToValue()()
		Expression: _maxLoanToValue = maxLoanToValue
		IRs:
			_maxLoanToValue(uint256) := maxLoanToValue(uint256)
		Expression: MaxLoanToValueChanged(_maxLoanToValue)
		IRs:
			Emit MaxLoanToValueChanged(_maxLoanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxLoanToValue() (*)
		Expression: _maxLoanToValue
		IRs:
			RETURN _maxLoanToValue
	Function StrategyLeverageSettings.setLoanToValue(uint256) (*)
		Expression: loanToValue > _maxLoanToValue
		IRs:
			TMP_8537(bool) = loanToValue > _maxLoanToValue
			CONDITION TMP_8537
		Expression: revert InvalidValue()()
		IRs:
			TMP_8538(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_8539(bool) = loanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_8539
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_8540(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: loanToValue == 0
		IRs:
			TMP_8541(bool) = loanToValue == 0
			CONDITION TMP_8541
		Expression: revert InvalidValue()()
		IRs:
			TMP_8542(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: _loanToValue = loanToValue
		IRs:
			_loanToValue(uint256) := loanToValue(uint256)
		Expression: LoanToValueChanged(_loanToValue)
		IRs:
			Emit LoanToValueChanged(_loanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getLoanToValue() (*)
		Expression: _loanToValue
		IRs:
			RETURN _loanToValue
	Function StrategyLeverageSettings.getNrLoops() (*)
		Expression: _nrLoops
		IRs:
			RETURN _nrLoops
	Function StrategyLeverageSettings.setNrLoops(uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_8545(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_8545
		Expression: revert InvalidLoopCount()()
		IRs:
			TMP_8546(None) = SOLIDITY_CALL revert InvalidLoopCount()()
		Expression: _nrLoops = nrLoops
		IRs:
			_nrLoops(uint8) := nrLoops(uint8)
		Expression: NrLoopsChanged(_nrLoops)
		IRs:
			Emit NrLoopsChanged(_nrLoops)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategyLeverageSettings.setMaxSlippage(uint256) (*)
		Expression: slippage > PERCENTAGE_PRECISION
		IRs:
			TMP_8549(bool) = slippage > PERCENTAGE_PRECISION
			CONDITION TMP_8549
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_8550(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _maxSlippage = slippage
		IRs:
			_maxSlippage(uint256) := slippage(uint256)
		Expression: MaxSlippageChanged(slippage)
		IRs:
			Emit MaxSlippageChanged(slippage)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_8560(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_8560
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_8561(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_8561
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_8562(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_8566(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_8566
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_8567(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_8568(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_8568(uint256)
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) 
	Function IStrategyLeverage.getCollateralAsset() 
	Function IStrategyLeverage.getDebAsset() 
	Function IStrategyLeverage.getPosition(IOracle.PriceOptions) 
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyLeverage._initializeStrategyLeverage(address,address,address,address,address,address,address) (*)
		Expression: initialOwner == address(0)
		IRs:
			TMP_8569 = CONVERT 0 to address
			TMP_8570(bool) = initialOwner == TMP_8569
			CONDITION TMP_8570
		Expression: revert InvalidOwner()()
		IRs:
			TMP_8571(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _initLeverageSettings(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, StrategyLeverageSettings._initLeverageSettings(address,address)(initialOwner,initialGovernor)
		Expression: _initUseFlashLender(flashLender)
		IRs:
			INTERNAL_CALL, UseFlashLender._initUseFlashLender(address)(flashLender)
		Expression: _collateralToken = collateralToken
		IRs:
			_collateralToken(address) := collateralToken(address)
		Expression: _debtToken = debtToken
		IRs:
			_debtToken(address) := debtToken(address)
		Expression: _collateralOracle = IOracle(collateralOracle)
		IRs:
			TMP_8574 = CONVERT collateralOracle to IOracle
			_collateralOracle(IOracle) := TMP_8574(IOracle)
		Expression: _debtOracle = IOracle(debtOracle)
		IRs:
			TMP_8575 = CONVERT debtOracle to IOracle
			_debtOracle(IOracle) := TMP_8575(IOracle)
		Expression: _collateralToken == address(0)
		IRs:
			TMP_8576 = CONVERT 0 to address
			TMP_8577(bool) = _collateralToken == TMP_8576
			CONDITION TMP_8577
		Expression: revert InvalidCollateralToken()()
		IRs:
			TMP_8578(None) = SOLIDITY_CALL revert InvalidCollateralToken()()
		Expression: _debtToken == address(0)
		IRs:
			TMP_8579 = CONVERT 0 to address
			TMP_8580(bool) = _debtToken == TMP_8579
			CONDITION TMP_8580
		Expression: revert InvalidDebtToken()()
		IRs:
			TMP_8581(None) = SOLIDITY_CALL revert InvalidDebtToken()()
		Expression: address(_collateralOracle) == address(0)
		IRs:
			TMP_8582 = CONVERT _collateralOracle to address
			TMP_8583 = CONVERT 0 to address
			TMP_8584(bool) = TMP_8582 == TMP_8583
			CONDITION TMP_8584
		Expression: revert InvalidCollateralOracle()()
		IRs:
			TMP_8585(None) = SOLIDITY_CALL revert InvalidCollateralOracle()()
		Expression: address(_debtOracle) == address(0)
		IRs:
			TMP_8586 = CONVERT _debtOracle to address
			TMP_8587 = CONVERT 0 to address
			TMP_8588(bool) = TMP_8586 == TMP_8587
			CONDITION TMP_8588
		Expression: revert InvalidDebtOracle()()
		IRs:
			TMP_8589(None) = SOLIDITY_CALL revert InvalidDebtOracle()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategyLeverage.receive() (*)
		Expression: msg.sender != _debtToken && msg.sender != _collateralToken
		IRs:
			TMP_8591(bool) = msg.sender != _debtToken
			TMP_8592(bool) = msg.sender != _collateralToken
			TMP_8593(bool) = TMP_8591 && TMP_8592
			CONDITION TMP_8593
		Expression: revert ETHTransferNotAllowed(address)(msg.sender)
		IRs:
			TMP_8594(None) = SOLIDITY_CALL revert ETHTransferNotAllowed(address)(msg.sender)
	Function StrategyLeverage.getPosition(IOracle.PriceOptions) (*)
		Expression: (totalCollateralInUSD,totalDebtInUSD) = _getPosition(priceOptions)
		IRs:
			TUPLE_103(uint256,uint256) = INTERNAL_CALL, StrategyLeverage._getPosition(IOracle.PriceOptions)(priceOptions)
			totalCollateralInUSD(uint256)= UNPACK TUPLE_103 index: 0 
			totalDebtInUSD(uint256)= UNPACK TUPLE_103 index: 1 
		Expression: totalCollateralInUSD == 0
		IRs:
			TMP_8595(bool) = totalCollateralInUSD == 0
			CONDITION TMP_8595
		Expression: loanToValue = 0
		IRs:
			loanToValue(uint256) := 0(uint256)
		Expression: loanToValue = (totalDebtInUSD * PERCENTAGE_PRECISION) / totalCollateralInUSD
		IRs:
			TMP_8596(uint256) = totalDebtInUSD (c)* PERCENTAGE_PRECISION
			TMP_8597(uint256) = TMP_8596 (c)/ totalCollateralInUSD
			loanToValue(uint256) := TMP_8597(uint256)
	Function StrategyLeverage.totalAssets() (*)
		Expression: priceOptions = IOracle.PriceOptions({maxAge:0,maxConf:0})
		IRs:
			TMP_8598(IOracle.PriceOptions) = new PriceOptions(0,0)
			priceOptions(IOracle.PriceOptions) := TMP_8598(IOracle.PriceOptions)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_104(uint256,uint256) = INTERNAL_CALL, StrategyLeverage.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_104 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_104 index: 1 
		Expression: totalCollateralInDebt = _toDebt(priceOptions,totalCollateral,false)
		IRs:
			TMP_8599(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(priceOptions,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_8599(uint256)
		Expression: totalCollateralInDebt > totalDebt
		IRs:
			TMP_8600(bool) = totalCollateralInDebt > totalDebt
			CONDITION TMP_8600
		Expression: totalOwnedAssetsInDebt = (totalCollateralInDebt - totalDebt)
		IRs:
			TMP_8601(uint256) = totalCollateralInDebt (c)- totalDebt
			totalOwnedAssetsInDebt(uint256) := TMP_8601(uint256)
		Expression: totalOwnedAssetsInDebt = 0
		IRs:
			totalOwnedAssetsInDebt(uint256) := 0(uint256)
	Function StrategyLeverage.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8602(bool) = amount == 0
			CONDITION TMP_8602
		Expression: revert InvalidDeployAmount()()
		IRs:
			TMP_8603(None) = SOLIDITY_CALL revert InvalidDeployAmount()()
		Expression: IERC20Upgradeable(_debtToken).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_8604 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8605 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_8604', 'msg.sender', 'TMP_8605', 'amount'] 
		Expression: leverage = _calculateLeverageRatio(amount,getLoanToValue(),getNrLoops())
		IRs:
			TMP_8607(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_8608(uint8) = INTERNAL_CALL, StrategyLeverageSettings.getNrLoops()()
			TMP_8609(uint256) = INTERNAL_CALL, UseLeverage._calculateLeverageRatio(uint256,uint256,uint8)(amount,TMP_8607,TMP_8608)
			leverage(uint256) := TMP_8609(uint256)
		Expression: loanAmount = leverage - amount
		IRs:
			TMP_8610(uint256) = leverage (c)- amount
			loanAmount(uint256) := TMP_8610(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,loanAmount)
		IRs:
			TMP_8611(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8612(uint256) = HIGH_LEVEL_CALL, dest:TMP_8611(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'loanAmount']  
			fee(uint256) := TMP_8612(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),loanAmount + fee)
		IRs:
			TMP_8613 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8614(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8615(uint256) = loanAmount (c)+ fee
			TMP_8616(bool) = HIGH_LEVEL_CALL, dest:TMP_8613(IERC20Upgradeable), function:approve, arguments:['TMP_8614', 'TMP_8615']  
			TMP_8617 = UnaryType.BANG TMP_8616 
			CONDITION TMP_8617
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8618(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(amount,msg.sender,FlashLoanAction.SUPPLY_BORROW)
		IRs:
			REF_2531(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_8619(bytes) = SOLIDITY_CALL abi.encode()(amount,msg.sender,REF_2531)
			data(bytes) := TMP_8619(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,loanAmount,data))
		IRs:
			TMP_8620 = CONVERT this to address
			TMP_8621(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_8620,_debtToken,loanAmount,data)
			TMP_8622(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8621)
			_flashLoanArgsHash(bytes32) := TMP_8622(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,loanAmount,data)
		IRs:
			TMP_8623(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8624 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_8625(bool) = HIGH_LEVEL_CALL, dest:TMP_8623(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_8624', '_debtToken', 'loanAmount', 'data']  
			TMP_8626 = UnaryType.BANG TMP_8625 
			CONDITION TMP_8626
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_8627(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deployedAmount = _pendingAmount
		IRs:
			deployedAmount(uint256) := _pendingAmount(uint256)
		Expression: _deployedAssets += deployedAmount
		IRs:
			_deployedAssets(uint256) = _deployedAssets (c)+ deployedAmount
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _pendingAmount = 0
		IRs:
			_pendingAmount(uint256) := 0(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.onFlashLoan(address,address,uint256,uint256,bytes) (*)
		Expression: msg.sender != flashLenderA()
		IRs:
			TMP_8631(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8632(bool) = msg.sender != TMP_8631
			CONDITION TMP_8632
		Expression: revert InvalidFlashLoanSender()()
		IRs:
			TMP_8633(None) = SOLIDITY_CALL revert InvalidFlashLoanSender()()
		Expression: initiator != address(this)
		IRs:
			TMP_8634 = CONVERT this to address
			TMP_8635(bool) = initiator != TMP_8634
			CONDITION TMP_8635
		Expression: revert InvalidLoanInitiator()()
		IRs:
			TMP_8636(None) = SOLIDITY_CALL revert InvalidLoanInitiator()()
		Expression: token != _debtToken
		IRs:
			TMP_8637(bool) = token != _debtToken
			CONDITION TMP_8637
		Expression: revert InvalidFlashLoanAsset()()
		IRs:
			TMP_8638(None) = SOLIDITY_CALL revert InvalidFlashLoanAsset()()
		Expression: expectedHash = keccak256(bytes)(abi.encodePacked(initiator,token,amount,callData))
		IRs:
			TMP_8639(bytes) = SOLIDITY_CALL abi.encodePacked()(initiator,token,amount,callData)
			TMP_8640(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8639)
			expectedHash(bytes32) := TMP_8640(bytes32)
		Expression: _flashLoanArgsHash != expectedHash
		IRs:
			TMP_8641(bool) = _flashLoanArgsHash != expectedHash
			CONDITION TMP_8641
		Expression: revert FailedToAuthenticateArgs()()
		IRs:
			TMP_8642(None) = SOLIDITY_CALL revert FailedToAuthenticateArgs()()
		Expression: data = abi.decode(callData,(FlashLoanData))
		IRs:
			TMP_8643(StrategyLeverage.FlashLoanData) = SOLIDITY_CALL abi.decode()(callData,FlashLoanData)
			data(StrategyLeverage.FlashLoanData) := TMP_8643(StrategyLeverage.FlashLoanData)
		Expression: data.action == FlashLoanAction.SUPPLY_BORROW
		IRs:
			REF_2536(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2537(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_8644(bool) = REF_2536 == REF_2537
			CONDITION TMP_8644
		Expression: _supplyBorrow(data.originalAmount,amount,fee)
		IRs:
			REF_2538(uint256) -> data.originalAmount
			INTERNAL_CALL, StrategyLeverage._supplyBorrow(uint256,uint256,uint256)(REF_2538,amount,fee)
		Expression: data.action == FlashLoanAction.PAY_DEBT_WITHDRAW
		IRs:
			REF_2539(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2540(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_8646(bool) = REF_2539 == REF_2540
			CONDITION TMP_8646
		Expression: _repayAndWithdraw(data.originalAmount,amount,fee,address(data.receiver))
		IRs:
			REF_2541(uint256) -> data.originalAmount
			REF_2542(address) -> data.receiver
			TMP_8647 = CONVERT REF_2542 to address
			INTERNAL_CALL, StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address)(REF_2541,amount,fee,TMP_8647)
		Expression: data.action == FlashLoanAction.PAY_DEBT
		IRs:
			REF_2543(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2544(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_8649(bool) = REF_2543 == REF_2544
			CONDITION TMP_8649
		Expression: _payDebt(amount,fee)
		IRs:
			INTERNAL_CALL, StrategyLeverage._payDebt(uint256,uint256)(amount,fee)
		Expression: revert InvalidFlashLoanAction()()
		IRs:
			TMP_8651(None) = SOLIDITY_CALL revert InvalidFlashLoanAction()()
		Expression: _SUCCESS_MESSAGE
		IRs:
			RETURN _SUCCESS_MESSAGE
	Function StrategyLeverage.undeploy(uint256) (*)
		Expression: undeployedAmount = _undeploy(amount,address(msg.sender))
		IRs:
			TMP_8652 = CONVERT msg.sender to address
			TMP_8653(uint256) = INTERNAL_CALL, StrategyLeverage._undeploy(uint256,address)(amount,TMP_8652)
			undeployedAmount(uint256) := TMP_8653(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage._adjustDebt(uint256,uint256) (*)
		Expression: deltaDebt = _calculateDebtToPay(getLoanToValue(),totalCollateralInDebt,totalDebt)
		IRs:
			TMP_8656(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_8657(uint256) = INTERNAL_CALL, UseLeverage._calculateDebtToPay(uint256,uint256,uint256)(TMP_8656,totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_8657(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_8658(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8659(uint256) = HIGH_LEVEL_CALL, dest:TMP_8658(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_8659(uint256)
		Expression: data = abi.encode(deltaDebt,address(0),FlashLoanAction.PAY_DEBT)
		IRs:
			TMP_8660 = CONVERT 0 to address
			REF_2547(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_8661(bytes) = SOLIDITY_CALL abi.encode()(deltaDebt,TMP_8660,REF_2547)
			data(bytes) := TMP_8661(bytes)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_8662 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8663(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8664(uint256) = deltaDebt (c)+ fee
			TMP_8665(bool) = HIGH_LEVEL_CALL, dest:TMP_8662(IERC20Upgradeable), function:approve, arguments:['TMP_8663', 'TMP_8664']  
			TMP_8666 = UnaryType.BANG TMP_8665 
			CONDITION TMP_8666
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8667(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_8668 = CONVERT this to address
			TMP_8669(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_8668,_debtToken,deltaDebt,data)
			TMP_8670(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8669)
			_flashLoanArgsHash(bytes32) := TMP_8670(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_8671(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8672 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_8673(bool) = HIGH_LEVEL_CALL, dest:TMP_8671(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_8672', '_debtToken', 'deltaDebt', 'data']  
			TMP_8674 = UnaryType.BANG TMP_8673 
			CONDITION TMP_8674
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_8675(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deltaAmount = deltaDebt + fee
		IRs:
			TMP_8676(uint256) = deltaDebt (c)+ fee
			deltaAmount(uint256) := TMP_8676(uint256)
	Function StrategyLeverage.harvest() (*)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_105(uint256,uint256) = INTERNAL_CALL, StrategyLeverage.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_105 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_105 index: 1 
		Expression: totalCollateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),totalCollateral,false)
		IRs:
			TMP_8677(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8678(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8679(IOracle.PriceOptions) = new PriceOptions(TMP_8677,TMP_8678)
			TMP_8680(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_8679,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_8680(uint256)
		Expression: totalCollateralInDebt == 0 || totalDebt == 0
		IRs:
			TMP_8681(bool) = totalCollateralInDebt == 0
			TMP_8682(bool) = totalDebt == 0
			TMP_8683(bool) = TMP_8681 || TMP_8682
			CONDITION TMP_8683
		Expression: 0
		IRs:
			RETURN 0
		Expression: totalCollateralInDebt <= totalDebt
		IRs:
			TMP_8684(bool) = totalCollateralInDebt <= totalDebt
			CONDITION TMP_8684
		Expression: revert CollateralLowerThanDebt()()
		IRs:
			TMP_8685(None) = SOLIDITY_CALL revert CollateralLowerThanDebt()()
		Expression: deployedAmount = _deployedAssets
		IRs:
			deployedAmount(uint256) := _deployedAssets(uint256)
		Expression: deltaDebt = 0
		IRs:
			deltaDebt(uint256) := 0(uint256)
		Expression: ltv = (totalDebt * PERCENTAGE_PRECISION) / totalCollateralInDebt
		IRs:
			TMP_8686(uint256) = totalDebt (c)* PERCENTAGE_PRECISION
			TMP_8687(uint256) = TMP_8686 (c)/ totalCollateralInDebt
			ltv(uint256) := TMP_8687(uint256)
		Expression: ltv > getMaxLoanToValue() && ltv < PERCENTAGE_PRECISION
		IRs:
			TMP_8688(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxLoanToValue()()
			TMP_8689(bool) = ltv > TMP_8688
			TMP_8690(bool) = ltv < PERCENTAGE_PRECISION
			TMP_8691(bool) = TMP_8689 && TMP_8690
			CONDITION TMP_8691
		Expression: deltaDebt = _adjustDebt(totalCollateralInDebt,totalDebt)
		IRs:
			TMP_8692(uint256) = INTERNAL_CALL, StrategyLeverage._adjustDebt(uint256,uint256)(totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_8692(uint256)
		Expression: newDeployedAmount = totalCollateralInDebt - totalDebt
		IRs:
			TMP_8693(uint256) = totalCollateralInDebt (c)- totalDebt
			newDeployedAmount(uint256) := TMP_8693(uint256)
		Expression: deltaDebt >= totalCollateralInDebt
		IRs:
			TMP_8694(bool) = deltaDebt >= totalCollateralInDebt
			CONDITION TMP_8694
		Expression: revert InvalidDeltaDebt()()
		IRs:
			TMP_8695(None) = SOLIDITY_CALL revert InvalidDeltaDebt()()
		Expression: newDeployedAmount == deployedAmount
		IRs:
			TMP_8696(bool) = newDeployedAmount == deployedAmount
			CONDITION TMP_8696
		Expression: 0
		IRs:
			RETURN 0
		Expression: deltaDebt == 0
		IRs:
			TMP_8697(bool) = deltaDebt == 0
			CONDITION TMP_8697
		Expression: newDeployedAmount > deployedAmount
		IRs:
			TMP_8698(bool) = newDeployedAmount > deployedAmount
			CONDITION TMP_8698
		Expression: profit = newDeployedAmount - deployedAmount
		IRs:
			TMP_8699(uint256) = newDeployedAmount (c)- deployedAmount
			profit(uint256) := TMP_8699(uint256)
		Expression: StrategyProfit(profit)
		IRs:
			Emit StrategyProfit(profit)
		Expression: balanceChange = int256(profit)
		IRs:
			TMP_8701 = CONVERT profit to int256
			balanceChange(int256) := TMP_8701(int256)
		Expression: loss = deployedAmount - newDeployedAmount
		IRs:
			TMP_8702(uint256) = deployedAmount (c)- newDeployedAmount
			loss(uint256) := TMP_8702(uint256)
		Expression: StrategyLoss(loss)
		IRs:
			Emit StrategyLoss(loss)
		Expression: balanceChange = - int256(loss)
		IRs:
			TMP_8704 = CONVERT loss to int256
			TMP_8705(int256) = 0 (c)- TMP_8704
			balanceChange(int256) := TMP_8705(int256)
		Expression: _deployedAssets = newDeployedAmount
		IRs:
			_deployedAssets(uint256) := newDeployedAmount(uint256)
		Expression: StrategyAmountUpdate(newDeployedAmount)
		IRs:
			Emit StrategyAmountUpdate(newDeployedAmount)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.getBalances() (*)
	Function StrategyLeverage._getPosition(IOracle.PriceOptions) (*)
		Expression: totalCollateralInUSD = 0
		IRs:
			totalCollateralInUSD(uint256) := 0(uint256)
		Expression: totalDebtInUSD = 0
		IRs:
			totalDebtInUSD(uint256) := 0(uint256)
		Expression: (collateralBalance,debtBalance) = getBalances()
		IRs:
			TUPLE_106(uint256,uint256) = INTERNAL_CALL, StrategyLeverage.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_106 index: 0 
			debtBalance(uint256)= UNPACK TUPLE_106 index: 1 
		Expression: collateralBalance != 0
		IRs:
			TMP_8709(bool) = collateralBalance != 0
			CONDITION TMP_8709
		Expression: collateralPrice = _collateralOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_8710(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			collateralPrice(IOracle.Price) := TMP_8710(IOracle.Price)
		Expression: totalCollateralInUSD = (collateralBalance * collateralPrice.price) / _collateralOracle.getPrecision()
		IRs:
			REF_2553(uint256) -> collateralPrice.price
			TMP_8711(uint256) = collateralBalance (c)* REF_2553
			TMP_8712(uint256) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8713(uint256) = TMP_8711 (c)/ TMP_8712
			totalCollateralInUSD(uint256) := TMP_8713(uint256)
		Expression: debtBalance != 0
		IRs:
			TMP_8714(bool) = debtBalance != 0
			CONDITION TMP_8714
		Expression: debtPrice = _debtOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_8715(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			debtPrice(IOracle.Price) := TMP_8715(IOracle.Price)
		Expression: totalDebtInUSD = (debtBalance * debtPrice.price) / _debtOracle.getPrecision()
		IRs:
			REF_2556(uint256) -> debtPrice.price
			TMP_8716(uint256) = debtBalance (c)* REF_2556
			TMP_8717(uint256) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_8718(uint256) = TMP_8716 (c)/ TMP_8717
			totalDebtInUSD(uint256) := TMP_8718(uint256)
	Function StrategyLeverage._undeploy(uint256,address) (*)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_8719(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8720(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8721(IOracle.PriceOptions) = new PriceOptions(TMP_8719,TMP_8720)
			options(IOracle.PriceOptions) := TMP_8721(IOracle.PriceOptions)
		Expression: (totalCollateralBalance,totalDebtBalance) = getBalances()
		IRs:
			TUPLE_107(uint256,uint256) = INTERNAL_CALL, StrategyLeverage.getBalances()()
			totalCollateralBalance(uint256)= UNPACK TUPLE_107 index: 0 
			totalDebtBalance(uint256)= UNPACK TUPLE_107 index: 1 
		Expression: totalCollateralInDebt = _toDebt(options,totalCollateralBalance,false)
		IRs:
			TMP_8722(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(options,totalCollateralBalance,False)
			totalCollateralInDebt(uint256) := TMP_8722(uint256)
		Expression: totalCollateralInDebt <= totalDebtBalance
		IRs:
			TMP_8723(bool) = totalCollateralInDebt <= totalDebtBalance
			CONDITION TMP_8723
		Expression: revert NoCollateralMarginToScale()()
		IRs:
			TMP_8724(None) = SOLIDITY_CALL revert NoCollateralMarginToScale()()
		Expression: percentageToBurn = (amount * PERCENTAGE_PRECISION) / (totalCollateralInDebt - totalDebtBalance)
		IRs:
			TMP_8725(uint256) = amount (c)* PERCENTAGE_PRECISION
			TMP_8726(uint256) = totalCollateralInDebt (c)- totalDebtBalance
			TMP_8727(uint256) = TMP_8725 (c)/ TMP_8726
			percentageToBurn(uint256) := TMP_8727(uint256)
		Expression: (deltaCollateralInDebt,deltaDebt) = _calcDeltaPosition(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
		IRs:
			TUPLE_108(uint256,uint256) = INTERNAL_CALL, UseLeverage._calcDeltaPosition(uint256,uint256,uint256)(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
			deltaCollateralInDebt(uint256)= UNPACK TUPLE_108 index: 0 
			deltaDebt(uint256)= UNPACK TUPLE_108 index: 1 
		Expression: deltaCollateralAmount = _toCollateral(options,deltaCollateralInDebt,true)
		IRs:
			TMP_8728(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,deltaCollateralInDebt,True)
			deltaCollateralAmount(uint256) := TMP_8728(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_8729(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8730(uint256) = HIGH_LEVEL_CALL, dest:TMP_8729(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_8730(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_8731 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8732(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8733(uint256) = deltaDebt (c)+ fee
			TMP_8734(bool) = HIGH_LEVEL_CALL, dest:TMP_8731(IERC20Upgradeable), function:approve, arguments:['TMP_8732', 'TMP_8733']  
			TMP_8735 = UnaryType.BANG TMP_8734 
			CONDITION TMP_8735
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8736(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(deltaCollateralAmount,receiver,FlashLoanAction.PAY_DEBT_WITHDRAW)
		IRs:
			REF_2562(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_8737(bytes) = SOLIDITY_CALL abi.encode()(deltaCollateralAmount,receiver,REF_2562)
			data(bytes) := TMP_8737(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_8738 = CONVERT this to address
			TMP_8739(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_8738,_debtToken,deltaDebt,data)
			TMP_8740(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8739)
			_flashLoanArgsHash(bytes32) := TMP_8740(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_8741(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8742 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_8743(bool) = HIGH_LEVEL_CALL, dest:TMP_8741(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_8742', '_debtToken', 'deltaDebt', 'data']  
			TMP_8744 = UnaryType.BANG TMP_8743 
			CONDITION TMP_8744
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_8745(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: StrategyUndeploy(msg.sender,deltaCollateralInDebt - deltaDebt)
		IRs:
			TMP_8746(uint256) = deltaCollateralInDebt (c)- deltaDebt
			Emit StrategyUndeploy(msg.sender,TMP_8746)
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: receivedAmount = _pendingAmount
		IRs:
			receivedAmount(uint256) := _pendingAmount(uint256)
		Expression: undeployedAmount = deltaCollateralInDebt - deltaDebt
		IRs:
			TMP_8748(uint256) = deltaCollateralInDebt (c)- deltaDebt
			undeployedAmount(uint256) := TMP_8748(uint256)
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _deployedAssets > undeployedAmount
		IRs:
			TMP_8750(bool) = _deployedAssets > undeployedAmount
			CONDITION TMP_8750
		Expression: _deployedAssets = _deployedAssets - undeployedAmount
		IRs:
			TMP_8751(uint256) = _deployedAssets (c)- undeployedAmount
			_deployedAssets(uint256) := TMP_8751(uint256)
		Expression: _deployedAssets = 0
		IRs:
			_deployedAssets(uint256) := 0(uint256)
	Function StrategyLeverage._payDebt(uint256,uint256) (*)
		Expression: _repay(debtAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverage._repay(uint256)(debtAmount)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_8753(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8754(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8755(IOracle.PriceOptions) = new PriceOptions(TMP_8753,TMP_8754)
			options(IOracle.PriceOptions) := TMP_8755(IOracle.PriceOptions)
		Expression: collateralAmount = _toCollateral(options,debtAmount,true)
		IRs:
			TMP_8756(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,debtAmount,True)
			collateralAmount(uint256) := TMP_8756(uint256)
		Expression: amountInMax = (collateralAmount * (PERCENTAGE_PRECISION + getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_8757(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_8758(uint256) = PERCENTAGE_PRECISION (c)+ TMP_8757
			TMP_8759(uint256) = collateralAmount (c)* TMP_8758
			TMP_8760(uint256) = TMP_8759 (c)/ PERCENTAGE_PRECISION
			amountInMax(uint256) := TMP_8760(uint256)
		Expression: _withdraw(amountInMax,address(this))
		IRs:
			TMP_8761 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverage._withdraw(uint256,address)(amountInMax,TMP_8761)
		Expression: (amountIn) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_OUTPUT,amountInMax,debtAmount + fee,bytes()))
		IRs:
			REF_2567(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_8763(uint256) = debtAmount (c)+ fee
			TMP_8764 = CONVERT  to bytes
			TMP_8765(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2567,amountInMax,TMP_8763,TMP_8764)
			TUPLE_109(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_8765)
			amountIn(uint256)= UNPACK TUPLE_109 index: 0 
		Expression: amountIn < amountInMax
		IRs:
			TMP_8766(bool) = amountIn < amountInMax
			CONDITION TMP_8766
		Expression: swapLeftover = amountInMax - amountIn
		IRs:
			TMP_8767(uint256) = amountInMax (c)- amountIn
			swapLeftover(uint256) := TMP_8767(uint256)
		Expression: _supply(swapLeftover)
		IRs:
			INTERNAL_CALL, StrategyLeverage._supply(uint256)(swapLeftover)
		Expression: StrategyUndeploy(msg.sender,debtAmount)
		IRs:
			Emit StrategyUndeploy(msg.sender,debtAmount)
	Function StrategyLeverage._convertToCollateral(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_8770(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_8771(bool) = TMP_8770 > 0
			CONDITION TMP_8771
		Expression: wsthETHAmount = _toCollateral(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_8772(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8773(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8774(IOracle.PriceOptions) = new PriceOptions(TMP_8772,TMP_8773)
			TMP_8775(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(TMP_8774,amount,False)
			wsthETHAmount(uint256) := TMP_8775(uint256)
		Expression: amountOutMinimum = (wsthETHAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_8776(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_8777(uint256) = PERCENTAGE_PRECISION (c)- TMP_8776
			TMP_8778(uint256) = wsthETHAmount (c)* TMP_8777
			TMP_8779(uint256) = TMP_8778 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_8779(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_debtToken,_collateralToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2570(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8780 = CONVERT  to bytes
			TMP_8781(ISwapHandler.SwapParams) = new SwapParams(_debtToken,_collateralToken,REF_2570,amount,amountOutMinimum,TMP_8780)
			TUPLE_110(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_8781)
			amountOut(uint256)= UNPACK TUPLE_110 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._convertToDebt(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_8782(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_8783(bool) = TMP_8782 > 0
			CONDITION TMP_8783
		Expression: ethAmount = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_8784(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8785(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8786(IOracle.PriceOptions) = new PriceOptions(TMP_8784,TMP_8785)
			TMP_8787(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_8786,amount,False)
			ethAmount(uint256) := TMP_8787(uint256)
		Expression: amountOutMinimum = (ethAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_8788(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_8789(uint256) = PERCENTAGE_PRECISION (c)- TMP_8788
			TMP_8790(uint256) = ethAmount (c)* TMP_8789
			TMP_8791(uint256) = TMP_8790 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_8791(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2573(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_8792 = CONVERT  to bytes
			TMP_8793(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2573,amount,amountOutMinimum,TMP_8792)
			TUPLE_111(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_8793)
			amountOut(uint256)= UNPACK TUPLE_111 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_collateralOracle.getSafeLatestPrice(priceOptions).price,_debtOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_8794(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2576(uint256) -> TMP_8794.price
			TMP_8795(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2578(uint256) -> TMP_8795.price
			TMP_8796(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2576', 'REF_2578', 'roundUp'] 
			amountOut(uint256) := TMP_8796(uint256)
	Function StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_debtOracle.getSafeLatestPrice(priceOptions).price,_collateralOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_8797(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2581(uint256) -> TMP_8797.price
			TMP_8798(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2583(uint256) -> TMP_8798.price
			TMP_8799(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2581', 'REF_2583', 'roundUp'] 
			amountOut(uint256) := TMP_8799(uint256)
	Function StrategyLeverage._supplyBorrow(uint256,uint256,uint256) (*)
		Expression: collateralIn = _convertToCollateral(amount + loanAmount)
		IRs:
			TMP_8800(uint256) = amount (c)+ loanAmount
			TMP_8801(uint256) = INTERNAL_CALL, StrategyLeverage._convertToCollateral(uint256)(TMP_8800)
			collateralIn(uint256) := TMP_8801(uint256)
		Expression: _supplyAndBorrow(collateralIn,loanAmount + fee)
		IRs:
			TMP_8802(uint256) = loanAmount (c)+ fee
			INTERNAL_CALL, StrategyLeverage._supplyAndBorrow(uint256,uint256)(collateralIn,TMP_8802)
		Expression: collateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),collateralIn,false)
		IRs:
			TMP_8804(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8805(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8806(IOracle.PriceOptions) = new PriceOptions(TMP_8804,TMP_8805)
			TMP_8807(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_8806,collateralIn,False)
			collateralInDebt(uint256) := TMP_8807(uint256)
		Expression: deployedAmount = collateralInDebt - loanAmount - fee
		IRs:
			TMP_8808(uint256) = collateralInDebt (c)- loanAmount
			TMP_8809(uint256) = TMP_8808 (c)- fee
			deployedAmount(uint256) := TMP_8809(uint256)
		Expression: _pendingAmount = deployedAmount
		IRs:
			_pendingAmount(uint256) := deployedAmount(uint256)
		Expression: StrategyDeploy(msg.sender,deployedAmount)
		IRs:
			Emit StrategyDeploy(msg.sender,deployedAmount)
	Function StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address) (*)
		Expression: (collateralBalance) = getBalances()
		IRs:
			TUPLE_112(uint256,uint256) = INTERNAL_CALL, StrategyLeverage.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_112 index: 0 
		Expression: _repay(repayAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverage._repay(uint256)(repayAmount)
		Expression: _withdraw(cappedWithdrawAmount,address(this))
		IRs:
			TMP_8812 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverage._withdraw(uint256,address)(cappedWithdrawAmount,TMP_8812)
		Expression: withdrawnAmount = _convertToDebt(cappedWithdrawAmount)
		IRs:
			TMP_8814(uint256) = INTERNAL_CALL, StrategyLeverage._convertToDebt(uint256)(cappedWithdrawAmount)
			withdrawnAmount(uint256) := TMP_8814(uint256)
		Expression: debtToWithdraw > 0
		IRs:
			TMP_8815(bool) = debtToWithdraw > 0
			CONDITION TMP_8815
		Expression: IERC20Upgradeable(_debtToken).safeTransfer(receiver,debtToWithdraw)
		IRs:
			TMP_8816 = CONVERT _debtToken to IERC20Upgradeable
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable,address,uint256), arguments:['TMP_8816', 'receiver', 'debtToWithdraw'] 
		Expression: _pendingAmount = debtToWithdraw
		IRs:
			_pendingAmount(uint256) := debtToWithdraw(uint256)
		Expression: collateralBalance < withdrawAmount
		IRs:
			TMP_8818(bool) = collateralBalance < withdrawAmount
			CONDITION TMP_8818
		Expression: cappedWithdrawAmount = collateralBalance
		IRs:
			cappedWithdrawAmount(uint256) := collateralBalance(uint256)
		Expression: cappedWithdrawAmount = withdrawAmount
		IRs:
			cappedWithdrawAmount(uint256) := withdrawAmount(uint256)
		Expression: withdrawnAmount > (repayAmount + fee)
		IRs:
			TMP_8819(uint256) = repayAmount (c)+ fee
			TMP_8820(bool) = withdrawnAmount > TMP_8819
			CONDITION TMP_8820
		Expression: debtToWithdraw = withdrawnAmount - (repayAmount + fee)
		IRs:
			TMP_8821(uint256) = repayAmount (c)+ fee
			TMP_8822(uint256) = withdrawnAmount (c)- TMP_8821
			debtToWithdraw(uint256) := TMP_8822(uint256)
		Expression: debtToWithdraw = 0
		IRs:
			debtToWithdraw(uint256) := 0(uint256)
	Function StrategyLeverage._supply(uint256) (*)
	Function StrategyLeverage._supplyAndBorrow(uint256,uint256) (*)
	Function StrategyLeverage._repay(uint256) (*)
	Function StrategyLeverage._withdraw(uint256,address) (*)
	Function StrategyLeverage.renounceOwnership() (*)
		Expression: revert InvalidOwner()()
		IRs:
			TMP_8823(None) = SOLIDITY_CALL revert InvalidOwner()()
	Function StrategyLeverage.getCollateralOracle() (*)
		Expression: oracle = address(_collateralOracle)
		IRs:
			TMP_8824 = CONVERT _collateralOracle to address
			oracle(address) := TMP_8824(address)
	Function StrategyLeverage.getDebtOracle() (*)
		Expression: oracle = address(_debtOracle)
		IRs:
			TMP_8825 = CONVERT _debtOracle to address
			oracle(address) := TMP_8825(address)
	Function StrategyLeverage.setCollateralOracle(IOracle) (*)
		Expression: _collateralOracle = oracle
		IRs:
			_collateralOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.setDebtOracle(IOracle) (*)
		Expression: _debtOracle = oracle
		IRs:
			_debtOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.asset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function StrategyLeverage.getCollateralAsset() (*)
		Expression: _collateralToken
		IRs:
			RETURN _collateralToken
	Function StrategyLeverage.getDebAsset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function StrategyLeverage.slitherConstructorVariables() (*)
		Expression: _deployedAssets = 0
		IRs:
			_deployedAssets(uint256) := 0(uint256)
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: _pendingAmount = 0
		IRs:
			_pendingAmount(uint256) := 0(uint256)
	Function StrategyLeverage.slitherConstructorConstantVariables() (*)
		Expression: _SUCCESS_MESSAGE = keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
		IRs:
			TMP_8828(bytes32) = SOLIDITY_CALL keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
			_SUCCESS_MESSAGE(bytes32) := TMP_8828(bytes32)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_8829 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_8829(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_8830(bool) = _initialized < 1
			TMP_8831(bool) = isTopLevelCall && TMP_8830
			TMP_8832 = CONVERT this to address
			TMP_8833(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_8832'] 
			TMP_8834 = UnaryType.BANG TMP_8833 
			TMP_8835(bool) = _initialized == 1
			TMP_8836(bool) = TMP_8834 && TMP_8835
			TMP_8837(bool) = TMP_8831 || TMP_8836
			TMP_8838(None) = SOLIDITY_CALL require(bool,string)(TMP_8837,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_8840 = UnaryType.BANG _initializing 
			TMP_8841(bool) = _initialized < version
			TMP_8842(bool) = TMP_8840 && TMP_8841
			TMP_8843(None) = SOLIDITY_CALL require(bool,string)(TMP_8842,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_8845(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_8846(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_8847(bool) = msg.sender != TMP_8846
			CONDITION TMP_8847
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_8848(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
Contract StrategyLeverageAAVEv3
	Function UseAAVEv3._initUseAAVEv3(address) (*)
		Expression: _aavev3 = IPoolV3(aaveV3Pool)
		IRs:
			TMP_8852 = CONVERT aaveV3Pool to IPoolV3
			_aavev3(IPoolV3) := TMP_8852(IPoolV3)
		Expression: address(_aavev3) == address(0)
		IRs:
			TMP_8853 = CONVERT _aavev3 to address
			TMP_8854 = CONVERT 0 to address
			TMP_8855(bool) = TMP_8853 == TMP_8854
			CONDITION TMP_8855
		Expression: revert InvalidAAVEv3Contract()()
		IRs:
			TMP_8856(None) = SOLIDITY_CALL revert InvalidAAVEv3Contract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseAAVEv3.aaveV3() (*)
		Expression: _aavev3
		IRs:
			RETURN _aavev3
	Function UseAAVEv3.aaveV3A() (*)
		Expression: address(_aavev3)
		IRs:
			TMP_8858 = CONVERT _aavev3 to address
			RETURN TMP_8858
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_8859 = UnaryType.BANG _initializing 
			TMP_8860(None) = SOLIDITY_CALL require(bool,string)(TMP_8859,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_8862(uint8) := 255(uint8)
			TMP_8863(bool) = _initialized != TMP_8862
			CONDITION TMP_8863
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_8865(uint8) := 255(uint8)
			_initialized(uint8) := TMP_8865(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_8867(uint8) := 255(uint8)
			Emit Initialized(TMP_8867)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function StrategyLeverage._initializeStrategyLeverage(address,address,address,address,address,address,address) (*)
		Expression: initialOwner == address(0)
		IRs:
			TMP_8869 = CONVERT 0 to address
			TMP_8870(bool) = initialOwner == TMP_8869
			CONDITION TMP_8870
		Expression: revert InvalidOwner()()
		IRs:
			TMP_8871(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _initLeverageSettings(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, StrategyLeverageSettings._initLeverageSettings(address,address)(initialOwner,initialGovernor)
		Expression: _initUseFlashLender(flashLender)
		IRs:
			INTERNAL_CALL, UseFlashLender._initUseFlashLender(address)(flashLender)
		Expression: _collateralToken = collateralToken
		IRs:
			_collateralToken(address) := collateralToken(address)
		Expression: _debtToken = debtToken
		IRs:
			_debtToken(address) := debtToken(address)
		Expression: _collateralOracle = IOracle(collateralOracle)
		IRs:
			TMP_8874 = CONVERT collateralOracle to IOracle
			_collateralOracle(IOracle) := TMP_8874(IOracle)
		Expression: _debtOracle = IOracle(debtOracle)
		IRs:
			TMP_8875 = CONVERT debtOracle to IOracle
			_debtOracle(IOracle) := TMP_8875(IOracle)
		Expression: _collateralToken == address(0)
		IRs:
			TMP_8876 = CONVERT 0 to address
			TMP_8877(bool) = _collateralToken == TMP_8876
			CONDITION TMP_8877
		Expression: revert InvalidCollateralToken()()
		IRs:
			TMP_8878(None) = SOLIDITY_CALL revert InvalidCollateralToken()()
		Expression: _debtToken == address(0)
		IRs:
			TMP_8879 = CONVERT 0 to address
			TMP_8880(bool) = _debtToken == TMP_8879
			CONDITION TMP_8880
		Expression: revert InvalidDebtToken()()
		IRs:
			TMP_8881(None) = SOLIDITY_CALL revert InvalidDebtToken()()
		Expression: address(_collateralOracle) == address(0)
		IRs:
			TMP_8882 = CONVERT _collateralOracle to address
			TMP_8883 = CONVERT 0 to address
			TMP_8884(bool) = TMP_8882 == TMP_8883
			CONDITION TMP_8884
		Expression: revert InvalidCollateralOracle()()
		IRs:
			TMP_8885(None) = SOLIDITY_CALL revert InvalidCollateralOracle()()
		Expression: address(_debtOracle) == address(0)
		IRs:
			TMP_8886 = CONVERT _debtOracle to address
			TMP_8887 = CONVERT 0 to address
			TMP_8888(bool) = TMP_8886 == TMP_8887
			CONDITION TMP_8888
		Expression: revert InvalidDebtOracle()()
		IRs:
			TMP_8889(None) = SOLIDITY_CALL revert InvalidDebtOracle()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategyLeverage.receive() (*)
		Expression: msg.sender != _debtToken && msg.sender != _collateralToken
		IRs:
			TMP_8891(bool) = msg.sender != _debtToken
			TMP_8892(bool) = msg.sender != _collateralToken
			TMP_8893(bool) = TMP_8891 && TMP_8892
			CONDITION TMP_8893
		Expression: revert ETHTransferNotAllowed(address)(msg.sender)
		IRs:
			TMP_8894(None) = SOLIDITY_CALL revert ETHTransferNotAllowed(address)(msg.sender)
	Function StrategyLeverage.getPosition(IOracle.PriceOptions) (*)
		Expression: (totalCollateralInUSD,totalDebtInUSD) = _getPosition(priceOptions)
		IRs:
			TUPLE_113(uint256,uint256) = INTERNAL_CALL, StrategyLeverage._getPosition(IOracle.PriceOptions)(priceOptions)
			totalCollateralInUSD(uint256)= UNPACK TUPLE_113 index: 0 
			totalDebtInUSD(uint256)= UNPACK TUPLE_113 index: 1 
		Expression: totalCollateralInUSD == 0
		IRs:
			TMP_8895(bool) = totalCollateralInUSD == 0
			CONDITION TMP_8895
		Expression: loanToValue = 0
		IRs:
			loanToValue(uint256) := 0(uint256)
		Expression: loanToValue = (totalDebtInUSD * PERCENTAGE_PRECISION) / totalCollateralInUSD
		IRs:
			TMP_8896(uint256) = totalDebtInUSD (c)* PERCENTAGE_PRECISION
			TMP_8897(uint256) = TMP_8896 (c)/ totalCollateralInUSD
			loanToValue(uint256) := TMP_8897(uint256)
	Function StrategyLeverage.totalAssets() (*)
		Expression: priceOptions = IOracle.PriceOptions({maxAge:0,maxConf:0})
		IRs:
			TMP_8898(IOracle.PriceOptions) = new PriceOptions(0,0)
			priceOptions(IOracle.PriceOptions) := TMP_8898(IOracle.PriceOptions)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_114(uint256,uint256) = INTERNAL_CALL, StrategyLeverageAAVEv3.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_114 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_114 index: 1 
		Expression: totalCollateralInDebt = _toDebt(priceOptions,totalCollateral,false)
		IRs:
			TMP_8899(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(priceOptions,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_8899(uint256)
		Expression: totalCollateralInDebt > totalDebt
		IRs:
			TMP_8900(bool) = totalCollateralInDebt > totalDebt
			CONDITION TMP_8900
		Expression: totalOwnedAssetsInDebt = (totalCollateralInDebt - totalDebt)
		IRs:
			TMP_8901(uint256) = totalCollateralInDebt (c)- totalDebt
			totalOwnedAssetsInDebt(uint256) := TMP_8901(uint256)
		Expression: totalOwnedAssetsInDebt = 0
		IRs:
			totalOwnedAssetsInDebt(uint256) := 0(uint256)
	Function StrategyLeverage.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_8902(bool) = amount == 0
			CONDITION TMP_8902
		Expression: revert InvalidDeployAmount()()
		IRs:
			TMP_8903(None) = SOLIDITY_CALL revert InvalidDeployAmount()()
		Expression: IERC20Upgradeable(_debtToken).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_8904 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8905 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_8904', 'msg.sender', 'TMP_8905', 'amount'] 
		Expression: leverage = _calculateLeverageRatio(amount,getLoanToValue(),getNrLoops())
		IRs:
			TMP_8907(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_8908(uint8) = INTERNAL_CALL, StrategyLeverageSettings.getNrLoops()()
			TMP_8909(uint256) = INTERNAL_CALL, UseLeverage._calculateLeverageRatio(uint256,uint256,uint8)(amount,TMP_8907,TMP_8908)
			leverage(uint256) := TMP_8909(uint256)
		Expression: loanAmount = leverage - amount
		IRs:
			TMP_8910(uint256) = leverage (c)- amount
			loanAmount(uint256) := TMP_8910(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,loanAmount)
		IRs:
			TMP_8911(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8912(uint256) = HIGH_LEVEL_CALL, dest:TMP_8911(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'loanAmount']  
			fee(uint256) := TMP_8912(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),loanAmount + fee)
		IRs:
			TMP_8913 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8914(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8915(uint256) = loanAmount (c)+ fee
			TMP_8916(bool) = HIGH_LEVEL_CALL, dest:TMP_8913(IERC20Upgradeable), function:approve, arguments:['TMP_8914', 'TMP_8915']  
			TMP_8917 = UnaryType.BANG TMP_8916 
			CONDITION TMP_8917
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8918(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(amount,msg.sender,FlashLoanAction.SUPPLY_BORROW)
		IRs:
			REF_2592(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_8919(bytes) = SOLIDITY_CALL abi.encode()(amount,msg.sender,REF_2592)
			data(bytes) := TMP_8919(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,loanAmount,data))
		IRs:
			TMP_8920 = CONVERT this to address
			TMP_8921(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_8920,_debtToken,loanAmount,data)
			TMP_8922(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8921)
			_flashLoanArgsHash(bytes32) := TMP_8922(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,loanAmount,data)
		IRs:
			TMP_8923(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8924 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_8925(bool) = HIGH_LEVEL_CALL, dest:TMP_8923(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_8924', '_debtToken', 'loanAmount', 'data']  
			TMP_8926 = UnaryType.BANG TMP_8925 
			CONDITION TMP_8926
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_8927(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deployedAmount = _pendingAmount
		IRs:
			deployedAmount(uint256) := _pendingAmount(uint256)
		Expression: _deployedAssets += deployedAmount
		IRs:
			_deployedAssets(uint256) = _deployedAssets (c)+ deployedAmount
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _pendingAmount = 0
		IRs:
			_pendingAmount(uint256) := 0(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.onFlashLoan(address,address,uint256,uint256,bytes) (*)
		Expression: msg.sender != flashLenderA()
		IRs:
			TMP_8931(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8932(bool) = msg.sender != TMP_8931
			CONDITION TMP_8932
		Expression: revert InvalidFlashLoanSender()()
		IRs:
			TMP_8933(None) = SOLIDITY_CALL revert InvalidFlashLoanSender()()
		Expression: initiator != address(this)
		IRs:
			TMP_8934 = CONVERT this to address
			TMP_8935(bool) = initiator != TMP_8934
			CONDITION TMP_8935
		Expression: revert InvalidLoanInitiator()()
		IRs:
			TMP_8936(None) = SOLIDITY_CALL revert InvalidLoanInitiator()()
		Expression: token != _debtToken
		IRs:
			TMP_8937(bool) = token != _debtToken
			CONDITION TMP_8937
		Expression: revert InvalidFlashLoanAsset()()
		IRs:
			TMP_8938(None) = SOLIDITY_CALL revert InvalidFlashLoanAsset()()
		Expression: expectedHash = keccak256(bytes)(abi.encodePacked(initiator,token,amount,callData))
		IRs:
			TMP_8939(bytes) = SOLIDITY_CALL abi.encodePacked()(initiator,token,amount,callData)
			TMP_8940(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8939)
			expectedHash(bytes32) := TMP_8940(bytes32)
		Expression: _flashLoanArgsHash != expectedHash
		IRs:
			TMP_8941(bool) = _flashLoanArgsHash != expectedHash
			CONDITION TMP_8941
		Expression: revert FailedToAuthenticateArgs()()
		IRs:
			TMP_8942(None) = SOLIDITY_CALL revert FailedToAuthenticateArgs()()
		Expression: data = abi.decode(callData,(FlashLoanData))
		IRs:
			TMP_8943(StrategyLeverage.FlashLoanData) = SOLIDITY_CALL abi.decode()(callData,FlashLoanData)
			data(StrategyLeverage.FlashLoanData) := TMP_8943(StrategyLeverage.FlashLoanData)
		Expression: data.action == FlashLoanAction.SUPPLY_BORROW
		IRs:
			REF_2597(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2598(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_8944(bool) = REF_2597 == REF_2598
			CONDITION TMP_8944
		Expression: _supplyBorrow(data.originalAmount,amount,fee)
		IRs:
			REF_2599(uint256) -> data.originalAmount
			INTERNAL_CALL, StrategyLeverage._supplyBorrow(uint256,uint256,uint256)(REF_2599,amount,fee)
		Expression: data.action == FlashLoanAction.PAY_DEBT_WITHDRAW
		IRs:
			REF_2600(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2601(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_8946(bool) = REF_2600 == REF_2601
			CONDITION TMP_8946
		Expression: _repayAndWithdraw(data.originalAmount,amount,fee,address(data.receiver))
		IRs:
			REF_2602(uint256) -> data.originalAmount
			REF_2603(address) -> data.receiver
			TMP_8947 = CONVERT REF_2603 to address
			INTERNAL_CALL, StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address)(REF_2602,amount,fee,TMP_8947)
		Expression: data.action == FlashLoanAction.PAY_DEBT
		IRs:
			REF_2604(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2605(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_8949(bool) = REF_2604 == REF_2605
			CONDITION TMP_8949
		Expression: _payDebt(amount,fee)
		IRs:
			INTERNAL_CALL, StrategyLeverage._payDebt(uint256,uint256)(amount,fee)
		Expression: revert InvalidFlashLoanAction()()
		IRs:
			TMP_8951(None) = SOLIDITY_CALL revert InvalidFlashLoanAction()()
		Expression: _SUCCESS_MESSAGE
		IRs:
			RETURN _SUCCESS_MESSAGE
	Function StrategyLeverage.undeploy(uint256) (*)
		Expression: undeployedAmount = _undeploy(amount,address(msg.sender))
		IRs:
			TMP_8952 = CONVERT msg.sender to address
			TMP_8953(uint256) = INTERNAL_CALL, StrategyLeverage._undeploy(uint256,address)(amount,TMP_8952)
			undeployedAmount(uint256) := TMP_8953(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage._adjustDebt(uint256,uint256) (*)
		Expression: deltaDebt = _calculateDebtToPay(getLoanToValue(),totalCollateralInDebt,totalDebt)
		IRs:
			TMP_8956(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_8957(uint256) = INTERNAL_CALL, UseLeverage._calculateDebtToPay(uint256,uint256,uint256)(TMP_8956,totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_8957(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_8958(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8959(uint256) = HIGH_LEVEL_CALL, dest:TMP_8958(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_8959(uint256)
		Expression: data = abi.encode(deltaDebt,address(0),FlashLoanAction.PAY_DEBT)
		IRs:
			TMP_8960 = CONVERT 0 to address
			REF_2608(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_8961(bytes) = SOLIDITY_CALL abi.encode()(deltaDebt,TMP_8960,REF_2608)
			data(bytes) := TMP_8961(bytes)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_8962 = CONVERT _debtToken to IERC20Upgradeable
			TMP_8963(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_8964(uint256) = deltaDebt (c)+ fee
			TMP_8965(bool) = HIGH_LEVEL_CALL, dest:TMP_8962(IERC20Upgradeable), function:approve, arguments:['TMP_8963', 'TMP_8964']  
			TMP_8966 = UnaryType.BANG TMP_8965 
			CONDITION TMP_8966
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_8967(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_8968 = CONVERT this to address
			TMP_8969(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_8968,_debtToken,deltaDebt,data)
			TMP_8970(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_8969)
			_flashLoanArgsHash(bytes32) := TMP_8970(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_8971(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_8972 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_8973(bool) = HIGH_LEVEL_CALL, dest:TMP_8971(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_8972', '_debtToken', 'deltaDebt', 'data']  
			TMP_8974 = UnaryType.BANG TMP_8973 
			CONDITION TMP_8974
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_8975(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deltaAmount = deltaDebt + fee
		IRs:
			TMP_8976(uint256) = deltaDebt (c)+ fee
			deltaAmount(uint256) := TMP_8976(uint256)
	Function StrategyLeverage.harvest() (*)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_115(uint256,uint256) = INTERNAL_CALL, StrategyLeverageAAVEv3.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_115 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_115 index: 1 
		Expression: totalCollateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),totalCollateral,false)
		IRs:
			TMP_8977(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_8978(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_8979(IOracle.PriceOptions) = new PriceOptions(TMP_8977,TMP_8978)
			TMP_8980(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_8979,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_8980(uint256)
		Expression: totalCollateralInDebt == 0 || totalDebt == 0
		IRs:
			TMP_8981(bool) = totalCollateralInDebt == 0
			TMP_8982(bool) = totalDebt == 0
			TMP_8983(bool) = TMP_8981 || TMP_8982
			CONDITION TMP_8983
		Expression: 0
		IRs:
			RETURN 0
		Expression: totalCollateralInDebt <= totalDebt
		IRs:
			TMP_8984(bool) = totalCollateralInDebt <= totalDebt
			CONDITION TMP_8984
		Expression: revert CollateralLowerThanDebt()()
		IRs:
			TMP_8985(None) = SOLIDITY_CALL revert CollateralLowerThanDebt()()
		Expression: deployedAmount = _deployedAssets
		IRs:
			deployedAmount(uint256) := _deployedAssets(uint256)
		Expression: deltaDebt = 0
		IRs:
			deltaDebt(uint256) := 0(uint256)
		Expression: ltv = (totalDebt * PERCENTAGE_PRECISION) / totalCollateralInDebt
		IRs:
			TMP_8986(uint256) = totalDebt (c)* PERCENTAGE_PRECISION
			TMP_8987(uint256) = TMP_8986 (c)/ totalCollateralInDebt
			ltv(uint256) := TMP_8987(uint256)
		Expression: ltv > getMaxLoanToValue() && ltv < PERCENTAGE_PRECISION
		IRs:
			TMP_8988(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxLoanToValue()()
			TMP_8989(bool) = ltv > TMP_8988
			TMP_8990(bool) = ltv < PERCENTAGE_PRECISION
			TMP_8991(bool) = TMP_8989 && TMP_8990
			CONDITION TMP_8991
		Expression: deltaDebt = _adjustDebt(totalCollateralInDebt,totalDebt)
		IRs:
			TMP_8992(uint256) = INTERNAL_CALL, StrategyLeverage._adjustDebt(uint256,uint256)(totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_8992(uint256)
		Expression: newDeployedAmount = totalCollateralInDebt - totalDebt
		IRs:
			TMP_8993(uint256) = totalCollateralInDebt (c)- totalDebt
			newDeployedAmount(uint256) := TMP_8993(uint256)
		Expression: deltaDebt >= totalCollateralInDebt
		IRs:
			TMP_8994(bool) = deltaDebt >= totalCollateralInDebt
			CONDITION TMP_8994
		Expression: revert InvalidDeltaDebt()()
		IRs:
			TMP_8995(None) = SOLIDITY_CALL revert InvalidDeltaDebt()()
		Expression: newDeployedAmount == deployedAmount
		IRs:
			TMP_8996(bool) = newDeployedAmount == deployedAmount
			CONDITION TMP_8996
		Expression: 0
		IRs:
			RETURN 0
		Expression: deltaDebt == 0
		IRs:
			TMP_8997(bool) = deltaDebt == 0
			CONDITION TMP_8997
		Expression: newDeployedAmount > deployedAmount
		IRs:
			TMP_8998(bool) = newDeployedAmount > deployedAmount
			CONDITION TMP_8998
		Expression: profit = newDeployedAmount - deployedAmount
		IRs:
			TMP_8999(uint256) = newDeployedAmount (c)- deployedAmount
			profit(uint256) := TMP_8999(uint256)
		Expression: StrategyProfit(profit)
		IRs:
			Emit StrategyProfit(profit)
		Expression: balanceChange = int256(profit)
		IRs:
			TMP_9001 = CONVERT profit to int256
			balanceChange(int256) := TMP_9001(int256)
		Expression: loss = deployedAmount - newDeployedAmount
		IRs:
			TMP_9002(uint256) = deployedAmount (c)- newDeployedAmount
			loss(uint256) := TMP_9002(uint256)
		Expression: StrategyLoss(loss)
		IRs:
			Emit StrategyLoss(loss)
		Expression: balanceChange = - int256(loss)
		IRs:
			TMP_9004 = CONVERT loss to int256
			TMP_9005(int256) = 0 (c)- TMP_9004
			balanceChange(int256) := TMP_9005(int256)
		Expression: _deployedAssets = newDeployedAmount
		IRs:
			_deployedAssets(uint256) := newDeployedAmount(uint256)
		Expression: StrategyAmountUpdate(newDeployedAmount)
		IRs:
			Emit StrategyAmountUpdate(newDeployedAmount)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.getBalances() 
	Function StrategyLeverage._getPosition(IOracle.PriceOptions) (*)
		Expression: totalCollateralInUSD = 0
		IRs:
			totalCollateralInUSD(uint256) := 0(uint256)
		Expression: totalDebtInUSD = 0
		IRs:
			totalDebtInUSD(uint256) := 0(uint256)
		Expression: (collateralBalance,debtBalance) = getBalances()
		IRs:
			TUPLE_116(uint256,uint256) = INTERNAL_CALL, StrategyLeverageAAVEv3.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_116 index: 0 
			debtBalance(uint256)= UNPACK TUPLE_116 index: 1 
		Expression: collateralBalance != 0
		IRs:
			TMP_9009(bool) = collateralBalance != 0
			CONDITION TMP_9009
		Expression: collateralPrice = _collateralOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_9010(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			collateralPrice(IOracle.Price) := TMP_9010(IOracle.Price)
		Expression: totalCollateralInUSD = (collateralBalance * collateralPrice.price) / _collateralOracle.getPrecision()
		IRs:
			REF_2614(uint256) -> collateralPrice.price
			TMP_9011(uint256) = collateralBalance (c)* REF_2614
			TMP_9012(uint256) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_9013(uint256) = TMP_9011 (c)/ TMP_9012
			totalCollateralInUSD(uint256) := TMP_9013(uint256)
		Expression: debtBalance != 0
		IRs:
			TMP_9014(bool) = debtBalance != 0
			CONDITION TMP_9014
		Expression: debtPrice = _debtOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_9015(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			debtPrice(IOracle.Price) := TMP_9015(IOracle.Price)
		Expression: totalDebtInUSD = (debtBalance * debtPrice.price) / _debtOracle.getPrecision()
		IRs:
			REF_2617(uint256) -> debtPrice.price
			TMP_9016(uint256) = debtBalance (c)* REF_2617
			TMP_9017(uint256) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_9018(uint256) = TMP_9016 (c)/ TMP_9017
			totalDebtInUSD(uint256) := TMP_9018(uint256)
	Function StrategyLeverage._undeploy(uint256,address) (*)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_9019(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9020(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9021(IOracle.PriceOptions) = new PriceOptions(TMP_9019,TMP_9020)
			options(IOracle.PriceOptions) := TMP_9021(IOracle.PriceOptions)
		Expression: (totalCollateralBalance,totalDebtBalance) = getBalances()
		IRs:
			TUPLE_117(uint256,uint256) = INTERNAL_CALL, StrategyLeverageAAVEv3.getBalances()()
			totalCollateralBalance(uint256)= UNPACK TUPLE_117 index: 0 
			totalDebtBalance(uint256)= UNPACK TUPLE_117 index: 1 
		Expression: totalCollateralInDebt = _toDebt(options,totalCollateralBalance,false)
		IRs:
			TMP_9022(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(options,totalCollateralBalance,False)
			totalCollateralInDebt(uint256) := TMP_9022(uint256)
		Expression: totalCollateralInDebt <= totalDebtBalance
		IRs:
			TMP_9023(bool) = totalCollateralInDebt <= totalDebtBalance
			CONDITION TMP_9023
		Expression: revert NoCollateralMarginToScale()()
		IRs:
			TMP_9024(None) = SOLIDITY_CALL revert NoCollateralMarginToScale()()
		Expression: percentageToBurn = (amount * PERCENTAGE_PRECISION) / (totalCollateralInDebt - totalDebtBalance)
		IRs:
			TMP_9025(uint256) = amount (c)* PERCENTAGE_PRECISION
			TMP_9026(uint256) = totalCollateralInDebt (c)- totalDebtBalance
			TMP_9027(uint256) = TMP_9025 (c)/ TMP_9026
			percentageToBurn(uint256) := TMP_9027(uint256)
		Expression: (deltaCollateralInDebt,deltaDebt) = _calcDeltaPosition(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
		IRs:
			TUPLE_118(uint256,uint256) = INTERNAL_CALL, UseLeverage._calcDeltaPosition(uint256,uint256,uint256)(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
			deltaCollateralInDebt(uint256)= UNPACK TUPLE_118 index: 0 
			deltaDebt(uint256)= UNPACK TUPLE_118 index: 1 
		Expression: deltaCollateralAmount = _toCollateral(options,deltaCollateralInDebt,true)
		IRs:
			TMP_9028(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,deltaCollateralInDebt,True)
			deltaCollateralAmount(uint256) := TMP_9028(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_9029(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9030(uint256) = HIGH_LEVEL_CALL, dest:TMP_9029(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_9030(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_9031 = CONVERT _debtToken to IERC20Upgradeable
			TMP_9032(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_9033(uint256) = deltaDebt (c)+ fee
			TMP_9034(bool) = HIGH_LEVEL_CALL, dest:TMP_9031(IERC20Upgradeable), function:approve, arguments:['TMP_9032', 'TMP_9033']  
			TMP_9035 = UnaryType.BANG TMP_9034 
			CONDITION TMP_9035
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9036(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(deltaCollateralAmount,receiver,FlashLoanAction.PAY_DEBT_WITHDRAW)
		IRs:
			REF_2623(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_9037(bytes) = SOLIDITY_CALL abi.encode()(deltaCollateralAmount,receiver,REF_2623)
			data(bytes) := TMP_9037(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_9038 = CONVERT this to address
			TMP_9039(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_9038,_debtToken,deltaDebt,data)
			TMP_9040(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9039)
			_flashLoanArgsHash(bytes32) := TMP_9040(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_9041(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9042 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_9043(bool) = HIGH_LEVEL_CALL, dest:TMP_9041(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_9042', '_debtToken', 'deltaDebt', 'data']  
			TMP_9044 = UnaryType.BANG TMP_9043 
			CONDITION TMP_9044
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_9045(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: StrategyUndeploy(msg.sender,deltaCollateralInDebt - deltaDebt)
		IRs:
			TMP_9046(uint256) = deltaCollateralInDebt (c)- deltaDebt
			Emit StrategyUndeploy(msg.sender,TMP_9046)
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: receivedAmount = _pendingAmount
		IRs:
			receivedAmount(uint256) := _pendingAmount(uint256)
		Expression: undeployedAmount = deltaCollateralInDebt - deltaDebt
		IRs:
			TMP_9048(uint256) = deltaCollateralInDebt (c)- deltaDebt
			undeployedAmount(uint256) := TMP_9048(uint256)
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _deployedAssets > undeployedAmount
		IRs:
			TMP_9050(bool) = _deployedAssets > undeployedAmount
			CONDITION TMP_9050
		Expression: _deployedAssets = _deployedAssets - undeployedAmount
		IRs:
			TMP_9051(uint256) = _deployedAssets (c)- undeployedAmount
			_deployedAssets(uint256) := TMP_9051(uint256)
		Expression: _deployedAssets = 0
		IRs:
			_deployedAssets(uint256) := 0(uint256)
	Function StrategyLeverage._payDebt(uint256,uint256) (*)
		Expression: _repay(debtAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverageAAVEv3._repay(uint256)(debtAmount)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_9053(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9054(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9055(IOracle.PriceOptions) = new PriceOptions(TMP_9053,TMP_9054)
			options(IOracle.PriceOptions) := TMP_9055(IOracle.PriceOptions)
		Expression: collateralAmount = _toCollateral(options,debtAmount,true)
		IRs:
			TMP_9056(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,debtAmount,True)
			collateralAmount(uint256) := TMP_9056(uint256)
		Expression: amountInMax = (collateralAmount * (PERCENTAGE_PRECISION + getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9057(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9058(uint256) = PERCENTAGE_PRECISION (c)+ TMP_9057
			TMP_9059(uint256) = collateralAmount (c)* TMP_9058
			TMP_9060(uint256) = TMP_9059 (c)/ PERCENTAGE_PRECISION
			amountInMax(uint256) := TMP_9060(uint256)
		Expression: _withdraw(amountInMax,address(this))
		IRs:
			TMP_9061 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverageAAVEv3._withdraw(uint256,address)(amountInMax,TMP_9061)
		Expression: (amountIn) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_OUTPUT,amountInMax,debtAmount + fee,bytes()))
		IRs:
			REF_2628(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_9063(uint256) = debtAmount (c)+ fee
			TMP_9064 = CONVERT  to bytes
			TMP_9065(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2628,amountInMax,TMP_9063,TMP_9064)
			TUPLE_119(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9065)
			amountIn(uint256)= UNPACK TUPLE_119 index: 0 
		Expression: amountIn < amountInMax
		IRs:
			TMP_9066(bool) = amountIn < amountInMax
			CONDITION TMP_9066
		Expression: swapLeftover = amountInMax - amountIn
		IRs:
			TMP_9067(uint256) = amountInMax (c)- amountIn
			swapLeftover(uint256) := TMP_9067(uint256)
		Expression: _supply(swapLeftover)
		IRs:
			INTERNAL_CALL, StrategyLeverageAAVEv3._supply(uint256)(swapLeftover)
		Expression: StrategyUndeploy(msg.sender,debtAmount)
		IRs:
			Emit StrategyUndeploy(msg.sender,debtAmount)
	Function StrategyLeverage._convertToCollateral(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_9070(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9071(bool) = TMP_9070 > 0
			CONDITION TMP_9071
		Expression: wsthETHAmount = _toCollateral(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_9072(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9073(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9074(IOracle.PriceOptions) = new PriceOptions(TMP_9072,TMP_9073)
			TMP_9075(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(TMP_9074,amount,False)
			wsthETHAmount(uint256) := TMP_9075(uint256)
		Expression: amountOutMinimum = (wsthETHAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9076(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9077(uint256) = PERCENTAGE_PRECISION (c)- TMP_9076
			TMP_9078(uint256) = wsthETHAmount (c)* TMP_9077
			TMP_9079(uint256) = TMP_9078 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_9079(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_debtToken,_collateralToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2631(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_9080 = CONVERT  to bytes
			TMP_9081(ISwapHandler.SwapParams) = new SwapParams(_debtToken,_collateralToken,REF_2631,amount,amountOutMinimum,TMP_9080)
			TUPLE_120(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9081)
			amountOut(uint256)= UNPACK TUPLE_120 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._convertToDebt(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_9082(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9083(bool) = TMP_9082 > 0
			CONDITION TMP_9083
		Expression: ethAmount = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_9084(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9085(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9086(IOracle.PriceOptions) = new PriceOptions(TMP_9084,TMP_9085)
			TMP_9087(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_9086,amount,False)
			ethAmount(uint256) := TMP_9087(uint256)
		Expression: amountOutMinimum = (ethAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9088(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9089(uint256) = PERCENTAGE_PRECISION (c)- TMP_9088
			TMP_9090(uint256) = ethAmount (c)* TMP_9089
			TMP_9091(uint256) = TMP_9090 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_9091(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2634(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_9092 = CONVERT  to bytes
			TMP_9093(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2634,amount,amountOutMinimum,TMP_9092)
			TUPLE_121(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9093)
			amountOut(uint256)= UNPACK TUPLE_121 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_collateralOracle.getSafeLatestPrice(priceOptions).price,_debtOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_9094(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2637(uint256) -> TMP_9094.price
			TMP_9095(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2639(uint256) -> TMP_9095.price
			TMP_9096(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2637', 'REF_2639', 'roundUp'] 
			amountOut(uint256) := TMP_9096(uint256)
	Function StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_debtOracle.getSafeLatestPrice(priceOptions).price,_collateralOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_9097(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2642(uint256) -> TMP_9097.price
			TMP_9098(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2644(uint256) -> TMP_9098.price
			TMP_9099(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2642', 'REF_2644', 'roundUp'] 
			amountOut(uint256) := TMP_9099(uint256)
	Function StrategyLeverage._supplyBorrow(uint256,uint256,uint256) (*)
		Expression: collateralIn = _convertToCollateral(amount + loanAmount)
		IRs:
			TMP_9100(uint256) = amount (c)+ loanAmount
			TMP_9101(uint256) = INTERNAL_CALL, StrategyLeverage._convertToCollateral(uint256)(TMP_9100)
			collateralIn(uint256) := TMP_9101(uint256)
		Expression: _supplyAndBorrow(collateralIn,loanAmount + fee)
		IRs:
			TMP_9102(uint256) = loanAmount (c)+ fee
			INTERNAL_CALL, StrategyLeverageAAVEv3._supplyAndBorrow(uint256,uint256)(collateralIn,TMP_9102)
		Expression: collateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),collateralIn,false)
		IRs:
			TMP_9104(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9105(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9106(IOracle.PriceOptions) = new PriceOptions(TMP_9104,TMP_9105)
			TMP_9107(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_9106,collateralIn,False)
			collateralInDebt(uint256) := TMP_9107(uint256)
		Expression: deployedAmount = collateralInDebt - loanAmount - fee
		IRs:
			TMP_9108(uint256) = collateralInDebt (c)- loanAmount
			TMP_9109(uint256) = TMP_9108 (c)- fee
			deployedAmount(uint256) := TMP_9109(uint256)
		Expression: _pendingAmount = deployedAmount
		IRs:
			_pendingAmount(uint256) := deployedAmount(uint256)
		Expression: StrategyDeploy(msg.sender,deployedAmount)
		IRs:
			Emit StrategyDeploy(msg.sender,deployedAmount)
	Function StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address) (*)
		Expression: (collateralBalance) = getBalances()
		IRs:
			TUPLE_122(uint256,uint256) = INTERNAL_CALL, StrategyLeverageAAVEv3.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_122 index: 0 
		Expression: _repay(repayAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverageAAVEv3._repay(uint256)(repayAmount)
		Expression: _withdraw(cappedWithdrawAmount,address(this))
		IRs:
			TMP_9112 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverageAAVEv3._withdraw(uint256,address)(cappedWithdrawAmount,TMP_9112)
		Expression: withdrawnAmount = _convertToDebt(cappedWithdrawAmount)
		IRs:
			TMP_9114(uint256) = INTERNAL_CALL, StrategyLeverage._convertToDebt(uint256)(cappedWithdrawAmount)
			withdrawnAmount(uint256) := TMP_9114(uint256)
		Expression: debtToWithdraw > 0
		IRs:
			TMP_9115(bool) = debtToWithdraw > 0
			CONDITION TMP_9115
		Expression: IERC20Upgradeable(_debtToken).safeTransfer(receiver,debtToWithdraw)
		IRs:
			TMP_9116 = CONVERT _debtToken to IERC20Upgradeable
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable,address,uint256), arguments:['TMP_9116', 'receiver', 'debtToWithdraw'] 
		Expression: _pendingAmount = debtToWithdraw
		IRs:
			_pendingAmount(uint256) := debtToWithdraw(uint256)
		Expression: collateralBalance < withdrawAmount
		IRs:
			TMP_9118(bool) = collateralBalance < withdrawAmount
			CONDITION TMP_9118
		Expression: cappedWithdrawAmount = collateralBalance
		IRs:
			cappedWithdrawAmount(uint256) := collateralBalance(uint256)
		Expression: cappedWithdrawAmount = withdrawAmount
		IRs:
			cappedWithdrawAmount(uint256) := withdrawAmount(uint256)
		Expression: withdrawnAmount > (repayAmount + fee)
		IRs:
			TMP_9119(uint256) = repayAmount (c)+ fee
			TMP_9120(bool) = withdrawnAmount > TMP_9119
			CONDITION TMP_9120
		Expression: debtToWithdraw = withdrawnAmount - (repayAmount + fee)
		IRs:
			TMP_9121(uint256) = repayAmount (c)+ fee
			TMP_9122(uint256) = withdrawnAmount (c)- TMP_9121
			debtToWithdraw(uint256) := TMP_9122(uint256)
		Expression: debtToWithdraw = 0
		IRs:
			debtToWithdraw(uint256) := 0(uint256)
	Function StrategyLeverage._supply(uint256) 
	Function StrategyLeverage._supplyAndBorrow(uint256,uint256) 
	Function StrategyLeverage._repay(uint256) 
	Function StrategyLeverage._withdraw(uint256,address) 
	Function StrategyLeverage.renounceOwnership() (*)
		Expression: revert InvalidOwner()()
		IRs:
			TMP_9123(None) = SOLIDITY_CALL revert InvalidOwner()()
	Function StrategyLeverage.getCollateralOracle() (*)
		Expression: oracle = address(_collateralOracle)
		IRs:
			TMP_9124 = CONVERT _collateralOracle to address
			oracle(address) := TMP_9124(address)
	Function StrategyLeverage.getDebtOracle() (*)
		Expression: oracle = address(_debtOracle)
		IRs:
			TMP_9125 = CONVERT _debtOracle to address
			oracle(address) := TMP_9125(address)
	Function StrategyLeverage.setCollateralOracle(IOracle) (*)
		Expression: _collateralOracle = oracle
		IRs:
			_collateralOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.setDebtOracle(IOracle) (*)
		Expression: _debtOracle = oracle
		IRs:
			_debtOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.asset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function StrategyLeverage.getCollateralAsset() (*)
		Expression: _collateralToken
		IRs:
			RETURN _collateralToken
	Function StrategyLeverage.getDebAsset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function UseLeverage._calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_9128(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_9128
		Expression: revert InvalidNumberOfLoops()()
		IRs:
			TMP_9129(None) = SOLIDITY_CALL revert InvalidNumberOfLoops()()
		Expression: loanToValue == 0 || loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9130(bool) = loanToValue == 0
			TMP_9131(bool) = loanToValue > PERCENTAGE_PRECISION
			TMP_9132(bool) = TMP_9130 || TMP_9131
			CONDITION TMP_9132
		Expression: revert InvalidLoanToValue()()
		IRs:
			TMP_9133(None) = SOLIDITY_CALL revert InvalidLoanToValue()()
		Expression: leverage = baseValue
		IRs:
			leverage(uint256) := baseValue(uint256)
		Expression: prev = baseValue
		IRs:
			prev(uint256) := baseValue(uint256)
		Expression: i = 1
		IRs:
			i(uint8) := 1(uint256)
		Expression: i <= nrLoops
		IRs:
			TMP_9134(bool) = i <= nrLoops
			CONDITION TMP_9134
		Expression: inc = (prev * loanToValue) / PERCENTAGE_PRECISION
		IRs:
			TMP_9135(uint256) = prev (c)* loanToValue
			TMP_9136(uint256) = TMP_9135 (c)/ PERCENTAGE_PRECISION
			inc(uint256) := TMP_9136(uint256)
		Expression: leverage += inc
		IRs:
			leverage(uint256) = leverage (c)+ inc
		Expression: prev = inc
		IRs:
			prev(uint256) := inc(uint256)
		Expression: ++ i
		IRs:
			i(uint8) = i + 1
		Expression: leverage
		IRs:
			RETURN leverage
	Function UseLeverage._calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: percentageToBurn == 0 || percentageToBurn > PERCENTAGE_PRECISION
		IRs:
			TMP_9137(bool) = percentageToBurn == 0
			TMP_9138(bool) = percentageToBurn > PERCENTAGE_PRECISION
			TMP_9139(bool) = TMP_9137 || TMP_9138
			CONDITION TMP_9139
		Expression: revert InvalidPercentageValue()()
		IRs:
			TMP_9140(None) = SOLIDITY_CALL revert InvalidPercentageValue()()
		Expression: deltaDebtInETH = (totalDebtBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_9141(uint256) = totalDebtBaseInEth (c)* percentageToBurn
			TMP_9142(uint256) = TMP_9141 (c)/ PERCENTAGE_PRECISION
			deltaDebtInETH(uint256) := TMP_9142(uint256)
		Expression: deltaCollateralInETH = (totalCollateralBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_9143(uint256) = totalCollateralBaseInEth (c)* percentageToBurn
			TMP_9144(uint256) = TMP_9143 (c)/ PERCENTAGE_PRECISION
			deltaCollateralInETH(uint256) := TMP_9144(uint256)
	Function UseLeverage._calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: colValue = ((targetLoanToValue * collateral) / PERCENTAGE_PRECISION)
		IRs:
			TMP_9145(uint256) = targetLoanToValue (c)* collateral
			TMP_9146(uint256) = TMP_9145 (c)/ PERCENTAGE_PRECISION
			colValue(uint256) := TMP_9146(uint256)
		Expression: colValue >= debt
		IRs:
			TMP_9147(bool) = colValue >= debt
			CONDITION TMP_9147
		Expression: revert InvalidTargetValue()()
		IRs:
			TMP_9148(None) = SOLIDITY_CALL revert InvalidTargetValue()()
		Expression: numerator = debt - colValue
		IRs:
			TMP_9149(uint256) = debt (c)- colValue
			numerator(uint256) := TMP_9149(uint256)
		Expression: divisor = (PERCENTAGE_PRECISION - targetLoanToValue)
		IRs:
			TMP_9150(uint256) = PERCENTAGE_PRECISION (c)- targetLoanToValue
			divisor(uint256) := TMP_9150(uint256)
		Expression: divisor == 0
		IRs:
			TMP_9151(bool) = divisor == 0
			CONDITION TMP_9151
		Expression: revert InvalidDivisor()()
		IRs:
			TMP_9152(None) = SOLIDITY_CALL revert InvalidDivisor()()
		Expression: delta = (numerator * PERCENTAGE_PRECISION) / divisor
		IRs:
			TMP_9153(uint256) = numerator (c)* PERCENTAGE_PRECISION
			TMP_9154(uint256) = TMP_9153 (c)/ divisor
			delta(uint256) := TMP_9154(uint256)
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_9155 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_9155(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_9156 = CONVERT _fLender to address
			TMP_9157 = CONVERT 0 to address
			TMP_9158(bool) = TMP_9156 == TMP_9157
			CONDITION TMP_9158
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_9159(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_9161 = CONVERT _fLender to address
			RETURN TMP_9161
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_9162(bool) = tokenA < tokenB
			CONDITION TMP_9162
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_9163(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d7d2bd90>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d7d2ba50>])
			TMP_9164(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9163)
			RETURN TMP_9164
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_9165(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d7d2ba50>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d7d2bd90>])
			TMP_9166(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9165)
			RETURN TMP_9166
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9167(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9167(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2649(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2650(UseUnifiedSwapper.SwapProvider) -> REF_2649.provider
			REF_2651(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9168(bool) = REF_2650 != REF_2651
			CONDITION TMP_9168
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_9169(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_9170 = CONVERT tokenIn to IERC20
			REF_2653(address) -> routeInfo.router
			TMP_9172(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_9173(uint256) = TMP_9172 (c)- 1
			TMP_9174(bool) = HIGH_LEVEL_CALL, dest:TMP_9170(IERC20), function:approve, arguments:['REF_2653', 'TMP_9173']  
			TMP_9175 = UnaryType.BANG TMP_9174 
			CONDITION TMP_9175
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9176(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_9177 = CONVERT tokenOut to IERC20
			REF_2655(address) -> routeInfo.router
			TMP_9179(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_9180(uint256) = TMP_9179 (c)- 1
			TMP_9181(bool) = HIGH_LEVEL_CALL, dest:TMP_9177(IERC20), function:approve, arguments:['REF_2655', 'TMP_9180']  
			TMP_9182 = UnaryType.BANG TMP_9181 
			CONDITION TMP_9182
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9183(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_2656(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2656(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9185(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9185(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_2657(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2658(UseUnifiedSwapper.SwapProvider) -> REF_2657.provider
			REF_2659(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9186(bool) = REF_2658 == REF_2659
			CONDITION TMP_9186
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_9187(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_9188 = CONVERT tokenIn to IERC20
			REF_2661(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2662(address) -> REF_2661.router
			TMP_9189(bool) = HIGH_LEVEL_CALL, dest:TMP_9188(IERC20), function:approve, arguments:['REF_2662', '0']  
			TMP_9190 = UnaryType.BANG TMP_9189 
			CONDITION TMP_9190
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9191(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_9192 = CONVERT tokenOut to IERC20
			REF_2664(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2665(address) -> REF_2664.router
			TMP_9193(bool) = HIGH_LEVEL_CALL, dest:TMP_9192(IERC20), function:approve, arguments:['REF_2665', '0']  
			TMP_9194 = UnaryType.BANG TMP_9193 
			CONDITION TMP_9194
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9195(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_2666(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2667(UseUnifiedSwapper.SwapProvider) -> REF_2666.provider
			REF_2668(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_2667(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_2668(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9197(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9197(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2669(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2670(UseUnifiedSwapper.SwapProvider) -> REF_2669.provider
			REF_2671(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9198(bool) = REF_2670 != REF_2671
			RETURN TMP_9198
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_2672(address) -> params.underlyingIn
			REF_2673(address) -> params.underlyingOut
			TMP_9199(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_2672,REF_2673)
			key(bytes32) := TMP_9199(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_2674(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_2674(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_2675(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2676(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9200(bool) = REF_2675 == REF_2676
			CONDITION TMP_9200
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_9201(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_2677(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2678(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_9202(bool) = REF_2677 == REF_2678
			CONDITION TMP_9202
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_2679(bytes) -> params.payload
			REF_2681(uint24) -> routeInfo.uniV3Tier
			TMP_9203(bytes) = SOLIDITY_CALL abi.encode()(REF_2681)
			REF_2679(bytes) (->params) := TMP_9203(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_2683(address) -> routeInfo.router
			TMP_9204 = CONVERT REF_2683 to IV3SwapRouter
			TUPLE_123(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_9204', 'params'] 
			RETURN TUPLE_123
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_2684(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2685(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_9205(bool) = REF_2684 == REF_2685
			CONDITION TMP_9205
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_2687(address) -> routeInfo.router
			TMP_9206 = CONVERT REF_2687 to IUniswapV2Router02
			TUPLE_124(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_9206', 'params'] 
			RETURN TUPLE_124
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_2688(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2689(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_9207(bool) = REF_2688 == REF_2689
			CONDITION TMP_9207
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_2690(bytes) -> params.payload
			REF_2692(uint24) -> routeInfo.tickSpacing
			TMP_9208(bytes) = SOLIDITY_CALL abi.encode()(REF_2692)
			REF_2690(bytes) (->params) := TMP_9208(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_2694(address) -> routeInfo.router
			TMP_9209 = CONVERT REF_2694 to ISwapRouter
			TUPLE_125(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_9209', 'params'] 
			RETURN TUPLE_125
		Expression: revert InvalidProvider()()
		IRs:
			TMP_9210(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_9214 = CONVERT 0 to address
			TMP_9215(bool) = _newGovernor == TMP_9214
			CONDITION TMP_9215
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_9216(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_9222(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9222)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_9225(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_9226(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_9227(bool) = TMP_9225 == TMP_9226
			TMP_9228(None) = SOLIDITY_CALL require(bool,string)(TMP_9227,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() 
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_9229 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9229)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_9232 = CONVERT 0 to address
			TMP_9233(bool) = newOwner != TMP_9232
			TMP_9234(None) = SOLIDITY_CALL require(bool,string)(TMP_9233,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_9243(bool) = _status != _ENTERED
			TMP_9244(None) = SOLIDITY_CALL require(bool,string)(TMP_9243,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_9245(bool) = _status == _ENTERED
			RETURN TMP_9245
	Function StrategyLeverageSettings._initLeverageSettings(address,address) (*)
		Expression: _initializeGovernableOwnable(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._initializeGovernableOwnable(address,address)(initialOwner,initialGovernor)
		Expression: _initializeStrategySettings()
		IRs:
			INTERNAL_CALL, StrategySettings._initializeStrategySettings()()
		Expression: _loanToValue = 800 * 1e6
		IRs:
			TMP_9248(uint256) = 800 (c)* 1000000
			_loanToValue(uint256) := TMP_9248(uint256)
		Expression: _maxLoanToValue = 850 * 1e6
		IRs:
			TMP_9249(uint256) = 850 (c)* 1000000
			_maxLoanToValue(uint256) := TMP_9249(uint256)
		Expression: _nrLoops = 10
		IRs:
			_nrLoops(uint8) := 10(uint256)
		Expression: _maxSlippage = 0
		IRs:
			_maxSlippage(uint256) := 0(uint256)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageSettings.setMaxLoanToValue(uint256) (*)
		Expression: maxLoanToValue == 0
		IRs:
			TMP_9251(bool) = maxLoanToValue == 0
			CONDITION TMP_9251
		Expression: revert InvalidValue()()
		IRs:
			TMP_9252(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: maxLoanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9253(bool) = maxLoanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9253
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9254(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: maxLoanToValue < _loanToValue
		IRs:
			TMP_9255(bool) = maxLoanToValue < _loanToValue
			CONDITION TMP_9255
		Expression: revert InvalidMaxLoanToValue()()
		IRs:
			TMP_9256(None) = SOLIDITY_CALL revert InvalidMaxLoanToValue()()
		Expression: _maxLoanToValue = maxLoanToValue
		IRs:
			_maxLoanToValue(uint256) := maxLoanToValue(uint256)
		Expression: MaxLoanToValueChanged(_maxLoanToValue)
		IRs:
			Emit MaxLoanToValueChanged(_maxLoanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxLoanToValue() (*)
		Expression: _maxLoanToValue
		IRs:
			RETURN _maxLoanToValue
	Function StrategyLeverageSettings.setLoanToValue(uint256) (*)
		Expression: loanToValue > _maxLoanToValue
		IRs:
			TMP_9259(bool) = loanToValue > _maxLoanToValue
			CONDITION TMP_9259
		Expression: revert InvalidValue()()
		IRs:
			TMP_9260(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9261(bool) = loanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9261
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9262(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: loanToValue == 0
		IRs:
			TMP_9263(bool) = loanToValue == 0
			CONDITION TMP_9263
		Expression: revert InvalidValue()()
		IRs:
			TMP_9264(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: _loanToValue = loanToValue
		IRs:
			_loanToValue(uint256) := loanToValue(uint256)
		Expression: LoanToValueChanged(_loanToValue)
		IRs:
			Emit LoanToValueChanged(_loanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getLoanToValue() (*)
		Expression: _loanToValue
		IRs:
			RETURN _loanToValue
	Function StrategyLeverageSettings.getNrLoops() (*)
		Expression: _nrLoops
		IRs:
			RETURN _nrLoops
	Function StrategyLeverageSettings.setNrLoops(uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_9267(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_9267
		Expression: revert InvalidLoopCount()()
		IRs:
			TMP_9268(None) = SOLIDITY_CALL revert InvalidLoopCount()()
		Expression: _nrLoops = nrLoops
		IRs:
			_nrLoops(uint8) := nrLoops(uint8)
		Expression: NrLoopsChanged(_nrLoops)
		IRs:
			Emit NrLoopsChanged(_nrLoops)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategyLeverageSettings.setMaxSlippage(uint256) (*)
		Expression: slippage > PERCENTAGE_PRECISION
		IRs:
			TMP_9271(bool) = slippage > PERCENTAGE_PRECISION
			CONDITION TMP_9271
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9272(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _maxSlippage = slippage
		IRs:
			_maxSlippage(uint256) := slippage(uint256)
		Expression: MaxSlippageChanged(slippage)
		IRs:
			Emit MaxSlippageChanged(slippage)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.constructor() 
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_9282(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_9282
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_9283(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_9283
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9284(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_9288(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_9288
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_9289(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_9290(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_9290(uint256)
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) 
	Function IStrategyLeverage.getCollateralAsset() 
	Function IStrategyLeverage.getDebAsset() 
	Function IStrategyLeverage.getPosition(IOracle.PriceOptions) 
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyLeverageAAVEv3.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategyLeverageAAVEv3.initialize(address,address,address,address,address,address,address,address,uint8) (*)
		Expression: _initializeStrategyLeverage(initialOwner,initialGovernor,collateralToken,debtToken,collateralOracle,debtOracle,flashLender)
		IRs:
			INTERNAL_CALL, StrategyLeverage._initializeStrategyLeverage(address,address,address,address,address,address,address)(initialOwner,initialGovernor,collateralToken,debtToken,collateralOracle,debtOracle,flashLender)
		Expression: _initUseAAVEv3(aaveV3Pool)
		IRs:
			INTERNAL_CALL, UseAAVEv3._initUseAAVEv3(address)(aaveV3Pool)
		Expression: aaveV3().setUserEMode(eModeCategory)
		IRs:
			TMP_9294(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			HIGH_LEVEL_CALL, dest:TMP_9294(IPoolV3), function:setUserEMode, arguments:['eModeCategory']  
		Expression: aaveV3().getUserEMode(address(this)) != eModeCategory
		IRs:
			TMP_9296(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9297 = CONVERT this to address
			TMP_9298(uint256) = HIGH_LEVEL_CALL, dest:TMP_9296(IPoolV3), function:getUserEMode, arguments:['TMP_9297']  
			TMP_9299(bool) = TMP_9298 != eModeCategory
			CONDITION TMP_9299
		Expression: revert InvalidAAVEEMode()()
		IRs:
			TMP_9300(None) = SOLIDITY_CALL revert InvalidAAVEEMode()()
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageAAVEv3.getBalances() (*)
		Expression: debtReserve = (aaveV3().getReserveData(_debtToken))
		IRs:
			TMP_9302(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9303(DataTypes.ReserveData) = HIGH_LEVEL_CALL, dest:TMP_9302(IPoolV3), function:getReserveData, arguments:['_debtToken']  
			debtReserve(DataTypes.ReserveData) := TMP_9303(DataTypes.ReserveData)
		Expression: collateralReserve = (aaveV3().getReserveData(_collateralToken))
		IRs:
			TMP_9304(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9305(DataTypes.ReserveData) = HIGH_LEVEL_CALL, dest:TMP_9304(IPoolV3), function:getReserveData, arguments:['_collateralToken']  
			collateralReserve(DataTypes.ReserveData) := TMP_9305(DataTypes.ReserveData)
		Expression: debtBalance = ERC20(debtReserve.variableDebtTokenAddress).balanceOf(address(this))
		IRs:
			REF_2699(address) -> debtReserve.variableDebtTokenAddress
			TMP_9306 = CONVERT REF_2699 to ERC20
			TMP_9307 = CONVERT this to address
			TMP_9308(uint256) = HIGH_LEVEL_CALL, dest:TMP_9306(ERC20), function:balanceOf, arguments:['TMP_9307']  
			debtBalance(uint256) := TMP_9308(uint256)
		Expression: debtDecimals = ERC20(debtReserve.variableDebtTokenAddress).decimals()
		IRs:
			REF_2701(address) -> debtReserve.variableDebtTokenAddress
			TMP_9309 = CONVERT REF_2701 to ERC20
			TMP_9310(uint8) = HIGH_LEVEL_CALL, dest:TMP_9309(ERC20), function:decimals, arguments:[]  
			debtDecimals(uint8) := TMP_9310(uint8)
		Expression: collateralDecimals = ERC20(collateralReserve.aTokenAddress).decimals()
		IRs:
			REF_2703(address) -> collateralReserve.aTokenAddress
			TMP_9311 = CONVERT REF_2703 to ERC20
			TMP_9312(uint8) = HIGH_LEVEL_CALL, dest:TMP_9311(ERC20), function:decimals, arguments:[]  
			collateralDecimals(uint8) := TMP_9312(uint8)
		Expression: collateralBalance = ERC20(collateralReserve.aTokenAddress).balanceOf(address(this))
		IRs:
			REF_2705(address) -> collateralReserve.aTokenAddress
			TMP_9313 = CONVERT REF_2705 to ERC20
			TMP_9314 = CONVERT this to address
			TMP_9315(uint256) = HIGH_LEVEL_CALL, dest:TMP_9313(ERC20), function:balanceOf, arguments:['TMP_9314']  
			collateralBalance(uint256) := TMP_9315(uint256)
		Expression: debtBalance = debtBalance.toDecimals(debtDecimals,SYSTEM_DECIMALS)
		IRs:
			TMP_9316(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['debtBalance', 'debtDecimals', 'SYSTEM_DECIMALS'] 
			debtBalance(uint256) := TMP_9316(uint256)
		Expression: collateralBalance = collateralBalance.toDecimals(collateralDecimals,SYSTEM_DECIMALS)
		IRs:
			TMP_9317(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['collateralBalance', 'collateralDecimals', 'SYSTEM_DECIMALS'] 
			collateralBalance(uint256) := TMP_9317(uint256)
	Function StrategyLeverageAAVEv3._supply(uint256) (*)
		Expression: ! ERC20(_collateralToken).approve(aaveV3A(),amountIn)
		IRs:
			TMP_9318 = CONVERT _collateralToken to ERC20
			TMP_9319(address) = INTERNAL_CALL, UseAAVEv3.aaveV3A()()
			TMP_9320(bool) = HIGH_LEVEL_CALL, dest:TMP_9318(ERC20), function:approve, arguments:['TMP_9319', 'amountIn']  
			TMP_9321 = UnaryType.BANG TMP_9320 
			CONDITION TMP_9321
		Expression: revert FailedToApproveAllowanceForAAVE()()
		IRs:
			TMP_9322(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForAAVE()()
		Expression: aaveV3().supply(_collateralToken,amountIn,address(this),0)
		IRs:
			TMP_9323(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9324 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_9323(IPoolV3), function:supply, arguments:['_collateralToken', 'amountIn', 'TMP_9324', '0']  
	Function StrategyLeverageAAVEv3._supplyAndBorrow(uint256,uint256) (*)
		Expression: _supply(collateral)
		IRs:
			INTERNAL_CALL, StrategyLeverageAAVEv3._supply(uint256)(collateral)
		Expression: aaveV3().setUserUseReserveAsCollateral(_collateralToken,true)
		IRs:
			TMP_9327(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			HIGH_LEVEL_CALL, dest:TMP_9327(IPoolV3), function:setUserUseReserveAsCollateral, arguments:['_collateralToken', 'True']  
		Expression: aaveV3().borrow(_debtToken,debt,2,0,address(this))
		IRs:
			TMP_9329(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9330 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_9329(IPoolV3), function:borrow, arguments:['_debtToken', 'debt', '2', '0', 'TMP_9330']  
	Function StrategyLeverageAAVEv3._repay(uint256) (*)
		Expression: ! ERC20(_debtToken).approve(aaveV3A(),amount)
		IRs:
			TMP_9332 = CONVERT _debtToken to ERC20
			TMP_9333(address) = INTERNAL_CALL, UseAAVEv3.aaveV3A()()
			TMP_9334(bool) = HIGH_LEVEL_CALL, dest:TMP_9332(ERC20), function:approve, arguments:['TMP_9333', 'amount']  
			TMP_9335 = UnaryType.BANG TMP_9334 
			CONDITION TMP_9335
		Expression: revert FailedToApproveAllowanceForAAVE()()
		IRs:
			TMP_9336(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForAAVE()()
		Expression: aaveV3().repay(_debtToken,amount,2,address(this)) != amount
		IRs:
			TMP_9337(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9338 = CONVERT this to address
			TMP_9339(uint256) = HIGH_LEVEL_CALL, dest:TMP_9337(IPoolV3), function:repay, arguments:['_debtToken', 'amount', '2', 'TMP_9338']  
			TMP_9340(bool) = TMP_9339 != amount
			CONDITION TMP_9340
		Expression: revert FailedToRepayDebt()()
		IRs:
			TMP_9341(None) = SOLIDITY_CALL revert FailedToRepayDebt()()
	Function StrategyLeverageAAVEv3._withdraw(uint256,address) (*)
		Expression: aaveV3().withdraw(_collateralToken,amount,to) != amount
		IRs:
			TMP_9342(IPoolV3) = INTERNAL_CALL, UseAAVEv3.aaveV3()()
			TMP_9343(uint256) = HIGH_LEVEL_CALL, dest:TMP_9342(IPoolV3), function:withdraw, arguments:['_collateralToken', 'amount', 'to']  
			TMP_9344(bool) = TMP_9343 != amount
			CONDITION TMP_9344
		Expression: revert InvalidWithdrawAmount()()
		IRs:
			TMP_9345(None) = SOLIDITY_CALL revert InvalidWithdrawAmount()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_9346 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_9346(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_9347(bool) = _initialized < 1
			TMP_9348(bool) = isTopLevelCall && TMP_9347
			TMP_9349 = CONVERT this to address
			TMP_9350(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_9349'] 
			TMP_9351 = UnaryType.BANG TMP_9350 
			TMP_9352(bool) = _initialized == 1
			TMP_9353(bool) = TMP_9351 && TMP_9352
			TMP_9354(bool) = TMP_9348 || TMP_9353
			TMP_9355(None) = SOLIDITY_CALL require(bool,string)(TMP_9354,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_9357 = UnaryType.BANG _initializing 
			TMP_9358(bool) = _initialized < version
			TMP_9359(bool) = TMP_9357 && TMP_9358
			TMP_9360(None) = SOLIDITY_CALL require(bool,string)(TMP_9359,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_9362(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_9363(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_9364(bool) = msg.sender != TMP_9363
			CONDITION TMP_9364
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_9365(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
Contract StrategyLeverageMorphoBlue
	Function StrategyLeverage._initializeStrategyLeverage(address,address,address,address,address,address,address) (*)
		Expression: initialOwner == address(0)
		IRs:
			TMP_9369 = CONVERT 0 to address
			TMP_9370(bool) = initialOwner == TMP_9369
			CONDITION TMP_9370
		Expression: revert InvalidOwner()()
		IRs:
			TMP_9371(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _initLeverageSettings(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, StrategyLeverageSettings._initLeverageSettings(address,address)(initialOwner,initialGovernor)
		Expression: _initUseFlashLender(flashLender)
		IRs:
			INTERNAL_CALL, UseFlashLender._initUseFlashLender(address)(flashLender)
		Expression: _collateralToken = collateralToken
		IRs:
			_collateralToken(address) := collateralToken(address)
		Expression: _debtToken = debtToken
		IRs:
			_debtToken(address) := debtToken(address)
		Expression: _collateralOracle = IOracle(collateralOracle)
		IRs:
			TMP_9374 = CONVERT collateralOracle to IOracle
			_collateralOracle(IOracle) := TMP_9374(IOracle)
		Expression: _debtOracle = IOracle(debtOracle)
		IRs:
			TMP_9375 = CONVERT debtOracle to IOracle
			_debtOracle(IOracle) := TMP_9375(IOracle)
		Expression: _collateralToken == address(0)
		IRs:
			TMP_9376 = CONVERT 0 to address
			TMP_9377(bool) = _collateralToken == TMP_9376
			CONDITION TMP_9377
		Expression: revert InvalidCollateralToken()()
		IRs:
			TMP_9378(None) = SOLIDITY_CALL revert InvalidCollateralToken()()
		Expression: _debtToken == address(0)
		IRs:
			TMP_9379 = CONVERT 0 to address
			TMP_9380(bool) = _debtToken == TMP_9379
			CONDITION TMP_9380
		Expression: revert InvalidDebtToken()()
		IRs:
			TMP_9381(None) = SOLIDITY_CALL revert InvalidDebtToken()()
		Expression: address(_collateralOracle) == address(0)
		IRs:
			TMP_9382 = CONVERT _collateralOracle to address
			TMP_9383 = CONVERT 0 to address
			TMP_9384(bool) = TMP_9382 == TMP_9383
			CONDITION TMP_9384
		Expression: revert InvalidCollateralOracle()()
		IRs:
			TMP_9385(None) = SOLIDITY_CALL revert InvalidCollateralOracle()()
		Expression: address(_debtOracle) == address(0)
		IRs:
			TMP_9386 = CONVERT _debtOracle to address
			TMP_9387 = CONVERT 0 to address
			TMP_9388(bool) = TMP_9386 == TMP_9387
			CONDITION TMP_9388
		Expression: revert InvalidDebtOracle()()
		IRs:
			TMP_9389(None) = SOLIDITY_CALL revert InvalidDebtOracle()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategyLeverage.receive() (*)
		Expression: msg.sender != _debtToken && msg.sender != _collateralToken
		IRs:
			TMP_9391(bool) = msg.sender != _debtToken
			TMP_9392(bool) = msg.sender != _collateralToken
			TMP_9393(bool) = TMP_9391 && TMP_9392
			CONDITION TMP_9393
		Expression: revert ETHTransferNotAllowed(address)(msg.sender)
		IRs:
			TMP_9394(None) = SOLIDITY_CALL revert ETHTransferNotAllowed(address)(msg.sender)
	Function StrategyLeverage.getPosition(IOracle.PriceOptions) (*)
		Expression: (totalCollateralInUSD,totalDebtInUSD) = _getPosition(priceOptions)
		IRs:
			TUPLE_126(uint256,uint256) = INTERNAL_CALL, StrategyLeverage._getPosition(IOracle.PriceOptions)(priceOptions)
			totalCollateralInUSD(uint256)= UNPACK TUPLE_126 index: 0 
			totalDebtInUSD(uint256)= UNPACK TUPLE_126 index: 1 
		Expression: totalCollateralInUSD == 0
		IRs:
			TMP_9395(bool) = totalCollateralInUSD == 0
			CONDITION TMP_9395
		Expression: loanToValue = 0
		IRs:
			loanToValue(uint256) := 0(uint256)
		Expression: loanToValue = (totalDebtInUSD * PERCENTAGE_PRECISION) / totalCollateralInUSD
		IRs:
			TMP_9396(uint256) = totalDebtInUSD (c)* PERCENTAGE_PRECISION
			TMP_9397(uint256) = TMP_9396 (c)/ totalCollateralInUSD
			loanToValue(uint256) := TMP_9397(uint256)
	Function StrategyLeverage.totalAssets() (*)
		Expression: priceOptions = IOracle.PriceOptions({maxAge:0,maxConf:0})
		IRs:
			TMP_9398(IOracle.PriceOptions) = new PriceOptions(0,0)
			priceOptions(IOracle.PriceOptions) := TMP_9398(IOracle.PriceOptions)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_127(uint256,uint256) = INTERNAL_CALL, StrategyLeverageMorphoBlue.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_127 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_127 index: 1 
		Expression: totalCollateralInDebt = _toDebt(priceOptions,totalCollateral,false)
		IRs:
			TMP_9399(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(priceOptions,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_9399(uint256)
		Expression: totalCollateralInDebt > totalDebt
		IRs:
			TMP_9400(bool) = totalCollateralInDebt > totalDebt
			CONDITION TMP_9400
		Expression: totalOwnedAssetsInDebt = (totalCollateralInDebt - totalDebt)
		IRs:
			TMP_9401(uint256) = totalCollateralInDebt (c)- totalDebt
			totalOwnedAssetsInDebt(uint256) := TMP_9401(uint256)
		Expression: totalOwnedAssetsInDebt = 0
		IRs:
			totalOwnedAssetsInDebt(uint256) := 0(uint256)
	Function StrategyLeverage.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_9402(bool) = amount == 0
			CONDITION TMP_9402
		Expression: revert InvalidDeployAmount()()
		IRs:
			TMP_9403(None) = SOLIDITY_CALL revert InvalidDeployAmount()()
		Expression: IERC20Upgradeable(_debtToken).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_9404 = CONVERT _debtToken to IERC20Upgradeable
			TMP_9405 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable,address,address,uint256), arguments:['TMP_9404', 'msg.sender', 'TMP_9405', 'amount'] 
		Expression: leverage = _calculateLeverageRatio(amount,getLoanToValue(),getNrLoops())
		IRs:
			TMP_9407(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_9408(uint8) = INTERNAL_CALL, StrategyLeverageSettings.getNrLoops()()
			TMP_9409(uint256) = INTERNAL_CALL, UseLeverage._calculateLeverageRatio(uint256,uint256,uint8)(amount,TMP_9407,TMP_9408)
			leverage(uint256) := TMP_9409(uint256)
		Expression: loanAmount = leverage - amount
		IRs:
			TMP_9410(uint256) = leverage (c)- amount
			loanAmount(uint256) := TMP_9410(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,loanAmount)
		IRs:
			TMP_9411(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9412(uint256) = HIGH_LEVEL_CALL, dest:TMP_9411(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'loanAmount']  
			fee(uint256) := TMP_9412(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),loanAmount + fee)
		IRs:
			TMP_9413 = CONVERT _debtToken to IERC20Upgradeable
			TMP_9414(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_9415(uint256) = loanAmount (c)+ fee
			TMP_9416(bool) = HIGH_LEVEL_CALL, dest:TMP_9413(IERC20Upgradeable), function:approve, arguments:['TMP_9414', 'TMP_9415']  
			TMP_9417 = UnaryType.BANG TMP_9416 
			CONDITION TMP_9417
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9418(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(amount,msg.sender,FlashLoanAction.SUPPLY_BORROW)
		IRs:
			REF_2722(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_9419(bytes) = SOLIDITY_CALL abi.encode()(amount,msg.sender,REF_2722)
			data(bytes) := TMP_9419(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,loanAmount,data))
		IRs:
			TMP_9420 = CONVERT this to address
			TMP_9421(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_9420,_debtToken,loanAmount,data)
			TMP_9422(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9421)
			_flashLoanArgsHash(bytes32) := TMP_9422(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,loanAmount,data)
		IRs:
			TMP_9423(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9424 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_9425(bool) = HIGH_LEVEL_CALL, dest:TMP_9423(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_9424', '_debtToken', 'loanAmount', 'data']  
			TMP_9426 = UnaryType.BANG TMP_9425 
			CONDITION TMP_9426
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_9427(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deployedAmount = _pendingAmount
		IRs:
			deployedAmount(uint256) := _pendingAmount(uint256)
		Expression: _deployedAssets += deployedAmount
		IRs:
			_deployedAssets(uint256) = _deployedAssets (c)+ deployedAmount
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _pendingAmount = 0
		IRs:
			_pendingAmount(uint256) := 0(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.onFlashLoan(address,address,uint256,uint256,bytes) (*)
		Expression: msg.sender != flashLenderA()
		IRs:
			TMP_9431(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_9432(bool) = msg.sender != TMP_9431
			CONDITION TMP_9432
		Expression: revert InvalidFlashLoanSender()()
		IRs:
			TMP_9433(None) = SOLIDITY_CALL revert InvalidFlashLoanSender()()
		Expression: initiator != address(this)
		IRs:
			TMP_9434 = CONVERT this to address
			TMP_9435(bool) = initiator != TMP_9434
			CONDITION TMP_9435
		Expression: revert InvalidLoanInitiator()()
		IRs:
			TMP_9436(None) = SOLIDITY_CALL revert InvalidLoanInitiator()()
		Expression: token != _debtToken
		IRs:
			TMP_9437(bool) = token != _debtToken
			CONDITION TMP_9437
		Expression: revert InvalidFlashLoanAsset()()
		IRs:
			TMP_9438(None) = SOLIDITY_CALL revert InvalidFlashLoanAsset()()
		Expression: expectedHash = keccak256(bytes)(abi.encodePacked(initiator,token,amount,callData))
		IRs:
			TMP_9439(bytes) = SOLIDITY_CALL abi.encodePacked()(initiator,token,amount,callData)
			TMP_9440(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9439)
			expectedHash(bytes32) := TMP_9440(bytes32)
		Expression: _flashLoanArgsHash != expectedHash
		IRs:
			TMP_9441(bool) = _flashLoanArgsHash != expectedHash
			CONDITION TMP_9441
		Expression: revert FailedToAuthenticateArgs()()
		IRs:
			TMP_9442(None) = SOLIDITY_CALL revert FailedToAuthenticateArgs()()
		Expression: data = abi.decode(callData,(FlashLoanData))
		IRs:
			TMP_9443(StrategyLeverage.FlashLoanData) = SOLIDITY_CALL abi.decode()(callData,FlashLoanData)
			data(StrategyLeverage.FlashLoanData) := TMP_9443(StrategyLeverage.FlashLoanData)
		Expression: data.action == FlashLoanAction.SUPPLY_BORROW
		IRs:
			REF_2727(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2728(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.SUPPLY_BORROW
			TMP_9444(bool) = REF_2727 == REF_2728
			CONDITION TMP_9444
		Expression: _supplyBorrow(data.originalAmount,amount,fee)
		IRs:
			REF_2729(uint256) -> data.originalAmount
			INTERNAL_CALL, StrategyLeverage._supplyBorrow(uint256,uint256,uint256)(REF_2729,amount,fee)
		Expression: data.action == FlashLoanAction.PAY_DEBT_WITHDRAW
		IRs:
			REF_2730(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2731(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_9446(bool) = REF_2730 == REF_2731
			CONDITION TMP_9446
		Expression: _repayAndWithdraw(data.originalAmount,amount,fee,address(data.receiver))
		IRs:
			REF_2732(uint256) -> data.originalAmount
			REF_2733(address) -> data.receiver
			TMP_9447 = CONVERT REF_2733 to address
			INTERNAL_CALL, StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address)(REF_2732,amount,fee,TMP_9447)
		Expression: data.action == FlashLoanAction.PAY_DEBT
		IRs:
			REF_2734(StrategyLeverage.FlashLoanAction) -> data.action
			REF_2735(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_9449(bool) = REF_2734 == REF_2735
			CONDITION TMP_9449
		Expression: _payDebt(amount,fee)
		IRs:
			INTERNAL_CALL, StrategyLeverage._payDebt(uint256,uint256)(amount,fee)
		Expression: revert InvalidFlashLoanAction()()
		IRs:
			TMP_9451(None) = SOLIDITY_CALL revert InvalidFlashLoanAction()()
		Expression: _SUCCESS_MESSAGE
		IRs:
			RETURN _SUCCESS_MESSAGE
	Function StrategyLeverage.undeploy(uint256) (*)
		Expression: undeployedAmount = _undeploy(amount,address(msg.sender))
		IRs:
			TMP_9452 = CONVERT msg.sender to address
			TMP_9453(uint256) = INTERNAL_CALL, StrategyLeverage._undeploy(uint256,address)(amount,TMP_9452)
			undeployedAmount(uint256) := TMP_9453(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage._adjustDebt(uint256,uint256) (*)
		Expression: deltaDebt = _calculateDebtToPay(getLoanToValue(),totalCollateralInDebt,totalDebt)
		IRs:
			TMP_9456(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getLoanToValue()()
			TMP_9457(uint256) = INTERNAL_CALL, UseLeverage._calculateDebtToPay(uint256,uint256,uint256)(TMP_9456,totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_9457(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_9458(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9459(uint256) = HIGH_LEVEL_CALL, dest:TMP_9458(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_9459(uint256)
		Expression: data = abi.encode(deltaDebt,address(0),FlashLoanAction.PAY_DEBT)
		IRs:
			TMP_9460 = CONVERT 0 to address
			REF_2738(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT
			TMP_9461(bytes) = SOLIDITY_CALL abi.encode()(deltaDebt,TMP_9460,REF_2738)
			data(bytes) := TMP_9461(bytes)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_9462 = CONVERT _debtToken to IERC20Upgradeable
			TMP_9463(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_9464(uint256) = deltaDebt (c)+ fee
			TMP_9465(bool) = HIGH_LEVEL_CALL, dest:TMP_9462(IERC20Upgradeable), function:approve, arguments:['TMP_9463', 'TMP_9464']  
			TMP_9466 = UnaryType.BANG TMP_9465 
			CONDITION TMP_9466
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9467(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_9468 = CONVERT this to address
			TMP_9469(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_9468,_debtToken,deltaDebt,data)
			TMP_9470(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9469)
			_flashLoanArgsHash(bytes32) := TMP_9470(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_9471(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9472 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_9473(bool) = HIGH_LEVEL_CALL, dest:TMP_9471(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_9472', '_debtToken', 'deltaDebt', 'data']  
			TMP_9474 = UnaryType.BANG TMP_9473 
			CONDITION TMP_9474
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_9475(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: deltaAmount = deltaDebt + fee
		IRs:
			TMP_9476(uint256) = deltaDebt (c)+ fee
			deltaAmount(uint256) := TMP_9476(uint256)
	Function StrategyLeverage.harvest() (*)
		Expression: (totalCollateral,totalDebt) = getBalances()
		IRs:
			TUPLE_128(uint256,uint256) = INTERNAL_CALL, StrategyLeverageMorphoBlue.getBalances()()
			totalCollateral(uint256)= UNPACK TUPLE_128 index: 0 
			totalDebt(uint256)= UNPACK TUPLE_128 index: 1 
		Expression: totalCollateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),totalCollateral,false)
		IRs:
			TMP_9477(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9478(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9479(IOracle.PriceOptions) = new PriceOptions(TMP_9477,TMP_9478)
			TMP_9480(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_9479,totalCollateral,False)
			totalCollateralInDebt(uint256) := TMP_9480(uint256)
		Expression: totalCollateralInDebt == 0 || totalDebt == 0
		IRs:
			TMP_9481(bool) = totalCollateralInDebt == 0
			TMP_9482(bool) = totalDebt == 0
			TMP_9483(bool) = TMP_9481 || TMP_9482
			CONDITION TMP_9483
		Expression: 0
		IRs:
			RETURN 0
		Expression: totalCollateralInDebt <= totalDebt
		IRs:
			TMP_9484(bool) = totalCollateralInDebt <= totalDebt
			CONDITION TMP_9484
		Expression: revert CollateralLowerThanDebt()()
		IRs:
			TMP_9485(None) = SOLIDITY_CALL revert CollateralLowerThanDebt()()
		Expression: deployedAmount = _deployedAssets
		IRs:
			deployedAmount(uint256) := _deployedAssets(uint256)
		Expression: deltaDebt = 0
		IRs:
			deltaDebt(uint256) := 0(uint256)
		Expression: ltv = (totalDebt * PERCENTAGE_PRECISION) / totalCollateralInDebt
		IRs:
			TMP_9486(uint256) = totalDebt (c)* PERCENTAGE_PRECISION
			TMP_9487(uint256) = TMP_9486 (c)/ totalCollateralInDebt
			ltv(uint256) := TMP_9487(uint256)
		Expression: ltv > getMaxLoanToValue() && ltv < PERCENTAGE_PRECISION
		IRs:
			TMP_9488(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxLoanToValue()()
			TMP_9489(bool) = ltv > TMP_9488
			TMP_9490(bool) = ltv < PERCENTAGE_PRECISION
			TMP_9491(bool) = TMP_9489 && TMP_9490
			CONDITION TMP_9491
		Expression: deltaDebt = _adjustDebt(totalCollateralInDebt,totalDebt)
		IRs:
			TMP_9492(uint256) = INTERNAL_CALL, StrategyLeverage._adjustDebt(uint256,uint256)(totalCollateralInDebt,totalDebt)
			deltaDebt(uint256) := TMP_9492(uint256)
		Expression: newDeployedAmount = totalCollateralInDebt - totalDebt
		IRs:
			TMP_9493(uint256) = totalCollateralInDebt (c)- totalDebt
			newDeployedAmount(uint256) := TMP_9493(uint256)
		Expression: deltaDebt >= totalCollateralInDebt
		IRs:
			TMP_9494(bool) = deltaDebt >= totalCollateralInDebt
			CONDITION TMP_9494
		Expression: revert InvalidDeltaDebt()()
		IRs:
			TMP_9495(None) = SOLIDITY_CALL revert InvalidDeltaDebt()()
		Expression: newDeployedAmount == deployedAmount
		IRs:
			TMP_9496(bool) = newDeployedAmount == deployedAmount
			CONDITION TMP_9496
		Expression: 0
		IRs:
			RETURN 0
		Expression: deltaDebt == 0
		IRs:
			TMP_9497(bool) = deltaDebt == 0
			CONDITION TMP_9497
		Expression: newDeployedAmount > deployedAmount
		IRs:
			TMP_9498(bool) = newDeployedAmount > deployedAmount
			CONDITION TMP_9498
		Expression: profit = newDeployedAmount - deployedAmount
		IRs:
			TMP_9499(uint256) = newDeployedAmount (c)- deployedAmount
			profit(uint256) := TMP_9499(uint256)
		Expression: StrategyProfit(profit)
		IRs:
			Emit StrategyProfit(profit)
		Expression: balanceChange = int256(profit)
		IRs:
			TMP_9501 = CONVERT profit to int256
			balanceChange(int256) := TMP_9501(int256)
		Expression: loss = deployedAmount - newDeployedAmount
		IRs:
			TMP_9502(uint256) = deployedAmount (c)- newDeployedAmount
			loss(uint256) := TMP_9502(uint256)
		Expression: StrategyLoss(loss)
		IRs:
			Emit StrategyLoss(loss)
		Expression: balanceChange = - int256(loss)
		IRs:
			TMP_9504 = CONVERT loss to int256
			TMP_9505(int256) = 0 (c)- TMP_9504
			balanceChange(int256) := TMP_9505(int256)
		Expression: _deployedAssets = newDeployedAmount
		IRs:
			_deployedAssets(uint256) := newDeployedAmount(uint256)
		Expression: StrategyAmountUpdate(newDeployedAmount)
		IRs:
			Emit StrategyAmountUpdate(newDeployedAmount)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuardUpgradeable.nonReentrant()()
	Function StrategyLeverage.getBalances() 
	Function StrategyLeverage._getPosition(IOracle.PriceOptions) (*)
		Expression: totalCollateralInUSD = 0
		IRs:
			totalCollateralInUSD(uint256) := 0(uint256)
		Expression: totalDebtInUSD = 0
		IRs:
			totalDebtInUSD(uint256) := 0(uint256)
		Expression: (collateralBalance,debtBalance) = getBalances()
		IRs:
			TUPLE_129(uint256,uint256) = INTERNAL_CALL, StrategyLeverageMorphoBlue.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_129 index: 0 
			debtBalance(uint256)= UNPACK TUPLE_129 index: 1 
		Expression: collateralBalance != 0
		IRs:
			TMP_9509(bool) = collateralBalance != 0
			CONDITION TMP_9509
		Expression: collateralPrice = _collateralOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_9510(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			collateralPrice(IOracle.Price) := TMP_9510(IOracle.Price)
		Expression: totalCollateralInUSD = (collateralBalance * collateralPrice.price) / _collateralOracle.getPrecision()
		IRs:
			REF_2744(uint256) -> collateralPrice.price
			TMP_9511(uint256) = collateralBalance (c)* REF_2744
			TMP_9512(uint256) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_9513(uint256) = TMP_9511 (c)/ TMP_9512
			totalCollateralInUSD(uint256) := TMP_9513(uint256)
		Expression: debtBalance != 0
		IRs:
			TMP_9514(bool) = debtBalance != 0
			CONDITION TMP_9514
		Expression: debtPrice = _debtOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_9515(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			debtPrice(IOracle.Price) := TMP_9515(IOracle.Price)
		Expression: totalDebtInUSD = (debtBalance * debtPrice.price) / _debtOracle.getPrecision()
		IRs:
			REF_2747(uint256) -> debtPrice.price
			TMP_9516(uint256) = debtBalance (c)* REF_2747
			TMP_9517(uint256) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getPrecision, arguments:[]  
			TMP_9518(uint256) = TMP_9516 (c)/ TMP_9517
			totalDebtInUSD(uint256) := TMP_9518(uint256)
	Function StrategyLeverage._undeploy(uint256,address) (*)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_9519(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9520(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9521(IOracle.PriceOptions) = new PriceOptions(TMP_9519,TMP_9520)
			options(IOracle.PriceOptions) := TMP_9521(IOracle.PriceOptions)
		Expression: (totalCollateralBalance,totalDebtBalance) = getBalances()
		IRs:
			TUPLE_130(uint256,uint256) = INTERNAL_CALL, StrategyLeverageMorphoBlue.getBalances()()
			totalCollateralBalance(uint256)= UNPACK TUPLE_130 index: 0 
			totalDebtBalance(uint256)= UNPACK TUPLE_130 index: 1 
		Expression: totalCollateralInDebt = _toDebt(options,totalCollateralBalance,false)
		IRs:
			TMP_9522(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(options,totalCollateralBalance,False)
			totalCollateralInDebt(uint256) := TMP_9522(uint256)
		Expression: totalCollateralInDebt <= totalDebtBalance
		IRs:
			TMP_9523(bool) = totalCollateralInDebt <= totalDebtBalance
			CONDITION TMP_9523
		Expression: revert NoCollateralMarginToScale()()
		IRs:
			TMP_9524(None) = SOLIDITY_CALL revert NoCollateralMarginToScale()()
		Expression: percentageToBurn = (amount * PERCENTAGE_PRECISION) / (totalCollateralInDebt - totalDebtBalance)
		IRs:
			TMP_9525(uint256) = amount (c)* PERCENTAGE_PRECISION
			TMP_9526(uint256) = totalCollateralInDebt (c)- totalDebtBalance
			TMP_9527(uint256) = TMP_9525 (c)/ TMP_9526
			percentageToBurn(uint256) := TMP_9527(uint256)
		Expression: (deltaCollateralInDebt,deltaDebt) = _calcDeltaPosition(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
		IRs:
			TUPLE_131(uint256,uint256) = INTERNAL_CALL, UseLeverage._calcDeltaPosition(uint256,uint256,uint256)(percentageToBurn,totalCollateralInDebt,totalDebtBalance)
			deltaCollateralInDebt(uint256)= UNPACK TUPLE_131 index: 0 
			deltaDebt(uint256)= UNPACK TUPLE_131 index: 1 
		Expression: deltaCollateralAmount = _toCollateral(options,deltaCollateralInDebt,true)
		IRs:
			TMP_9528(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,deltaCollateralInDebt,True)
			deltaCollateralAmount(uint256) := TMP_9528(uint256)
		Expression: fee = flashLender().flashFee(_debtToken,deltaDebt)
		IRs:
			TMP_9529(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9530(uint256) = HIGH_LEVEL_CALL, dest:TMP_9529(IERC3156FlashLenderUpgradeable), function:flashFee, arguments:['_debtToken', 'deltaDebt']  
			fee(uint256) := TMP_9530(uint256)
		Expression: ! IERC20Upgradeable(_debtToken).approve(flashLenderA(),deltaDebt + fee)
		IRs:
			TMP_9531 = CONVERT _debtToken to IERC20Upgradeable
			TMP_9532(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_9533(uint256) = deltaDebt (c)+ fee
			TMP_9534(bool) = HIGH_LEVEL_CALL, dest:TMP_9531(IERC20Upgradeable), function:approve, arguments:['TMP_9532', 'TMP_9533']  
			TMP_9535 = UnaryType.BANG TMP_9534 
			CONDITION TMP_9535
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9536(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: data = abi.encode(deltaCollateralAmount,receiver,FlashLoanAction.PAY_DEBT_WITHDRAW)
		IRs:
			REF_2753(StrategyLeverage.FlashLoanAction) -> FlashLoanAction.PAY_DEBT_WITHDRAW
			TMP_9537(bytes) = SOLIDITY_CALL abi.encode()(deltaCollateralAmount,receiver,REF_2753)
			data(bytes) := TMP_9537(bytes)
		Expression: _flashLoanArgsHash = keccak256(bytes)(abi.encodePacked(address(this),_debtToken,deltaDebt,data))
		IRs:
			TMP_9538 = CONVERT this to address
			TMP_9539(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_9538,_debtToken,deltaDebt,data)
			TMP_9540(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9539)
			_flashLoanArgsHash(bytes32) := TMP_9540(bytes32)
		Expression: ! flashLender().flashLoan(IERC3156FlashBorrowerUpgradeable(this),_debtToken,deltaDebt,data)
		IRs:
			TMP_9541(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_9542 = CONVERT this to IERC3156FlashBorrowerUpgradeable
			TMP_9543(bool) = HIGH_LEVEL_CALL, dest:TMP_9541(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['TMP_9542', '_debtToken', 'deltaDebt', 'data']  
			TMP_9544 = UnaryType.BANG TMP_9543 
			CONDITION TMP_9544
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: revert FailedToRunFlashLoan()()
		IRs:
			TMP_9545(None) = SOLIDITY_CALL revert FailedToRunFlashLoan()()
		Expression: StrategyUndeploy(msg.sender,deltaCollateralInDebt - deltaDebt)
		IRs:
			TMP_9546(uint256) = deltaCollateralInDebt (c)- deltaDebt
			Emit StrategyUndeploy(msg.sender,TMP_9546)
		Expression: _flashLoanArgsHash = 0
		IRs:
			_flashLoanArgsHash(bytes32) := 0(uint256)
		Expression: receivedAmount = _pendingAmount
		IRs:
			receivedAmount(uint256) := _pendingAmount(uint256)
		Expression: undeployedAmount = deltaCollateralInDebt - deltaDebt
		IRs:
			TMP_9548(uint256) = deltaCollateralInDebt (c)- deltaDebt
			undeployedAmount(uint256) := TMP_9548(uint256)
		Expression: StrategyAmountUpdate(_deployedAssets)
		IRs:
			Emit StrategyAmountUpdate(_deployedAssets)
		Expression: _deployedAssets > undeployedAmount
		IRs:
			TMP_9550(bool) = _deployedAssets > undeployedAmount
			CONDITION TMP_9550
		Expression: _deployedAssets = _deployedAssets - undeployedAmount
		IRs:
			TMP_9551(uint256) = _deployedAssets (c)- undeployedAmount
			_deployedAssets(uint256) := TMP_9551(uint256)
		Expression: _deployedAssets = 0
		IRs:
			_deployedAssets(uint256) := 0(uint256)
	Function StrategyLeverage._payDebt(uint256,uint256) (*)
		Expression: _repay(debtAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverageMorphoBlue._repay(uint256)(debtAmount)
		Expression: options = IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()})
		IRs:
			TMP_9553(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9554(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9555(IOracle.PriceOptions) = new PriceOptions(TMP_9553,TMP_9554)
			options(IOracle.PriceOptions) := TMP_9555(IOracle.PriceOptions)
		Expression: collateralAmount = _toCollateral(options,debtAmount,true)
		IRs:
			TMP_9556(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(options,debtAmount,True)
			collateralAmount(uint256) := TMP_9556(uint256)
		Expression: amountInMax = (collateralAmount * (PERCENTAGE_PRECISION + getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9557(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9558(uint256) = PERCENTAGE_PRECISION (c)+ TMP_9557
			TMP_9559(uint256) = collateralAmount (c)* TMP_9558
			TMP_9560(uint256) = TMP_9559 (c)/ PERCENTAGE_PRECISION
			amountInMax(uint256) := TMP_9560(uint256)
		Expression: _withdraw(amountInMax,address(this))
		IRs:
			TMP_9561 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverageMorphoBlue._withdraw(uint256,address)(amountInMax,TMP_9561)
		Expression: (amountIn) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_OUTPUT,amountInMax,debtAmount + fee,bytes()))
		IRs:
			REF_2758(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_9563(uint256) = debtAmount (c)+ fee
			TMP_9564 = CONVERT  to bytes
			TMP_9565(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2758,amountInMax,TMP_9563,TMP_9564)
			TUPLE_132(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9565)
			amountIn(uint256)= UNPACK TUPLE_132 index: 0 
		Expression: amountIn < amountInMax
		IRs:
			TMP_9566(bool) = amountIn < amountInMax
			CONDITION TMP_9566
		Expression: swapLeftover = amountInMax - amountIn
		IRs:
			TMP_9567(uint256) = amountInMax (c)- amountIn
			swapLeftover(uint256) := TMP_9567(uint256)
		Expression: _supply(swapLeftover)
		IRs:
			INTERNAL_CALL, StrategyLeverageMorphoBlue._supply(uint256)(swapLeftover)
		Expression: StrategyUndeploy(msg.sender,debtAmount)
		IRs:
			Emit StrategyUndeploy(msg.sender,debtAmount)
	Function StrategyLeverage._convertToCollateral(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_9570(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9571(bool) = TMP_9570 > 0
			CONDITION TMP_9571
		Expression: wsthETHAmount = _toCollateral(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_9572(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9573(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9574(IOracle.PriceOptions) = new PriceOptions(TMP_9572,TMP_9573)
			TMP_9575(uint256) = INTERNAL_CALL, StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool)(TMP_9574,amount,False)
			wsthETHAmount(uint256) := TMP_9575(uint256)
		Expression: amountOutMinimum = (wsthETHAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9576(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9577(uint256) = PERCENTAGE_PRECISION (c)- TMP_9576
			TMP_9578(uint256) = wsthETHAmount (c)* TMP_9577
			TMP_9579(uint256) = TMP_9578 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_9579(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_debtToken,_collateralToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2761(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_9580 = CONVERT  to bytes
			TMP_9581(ISwapHandler.SwapParams) = new SwapParams(_debtToken,_collateralToken,REF_2761,amount,amountOutMinimum,TMP_9580)
			TUPLE_133(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9581)
			amountOut(uint256)= UNPACK TUPLE_133 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._convertToDebt(uint256) (*)
		Expression: amountOutMinimum = 0
		IRs:
			amountOutMinimum(uint256) := 0(uint256)
		Expression: getMaxSlippage() > 0
		IRs:
			TMP_9582(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9583(bool) = TMP_9582 > 0
			CONDITION TMP_9583
		Expression: ethAmount = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),amount,false)
		IRs:
			TMP_9584(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9585(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9586(IOracle.PriceOptions) = new PriceOptions(TMP_9584,TMP_9585)
			TMP_9587(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_9586,amount,False)
			ethAmount(uint256) := TMP_9587(uint256)
		Expression: amountOutMinimum = (ethAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION
		IRs:
			TMP_9588(uint256) = INTERNAL_CALL, StrategyLeverageSettings.getMaxSlippage()()
			TMP_9589(uint256) = PERCENTAGE_PRECISION (c)- TMP_9588
			TMP_9590(uint256) = ethAmount (c)* TMP_9589
			TMP_9591(uint256) = TMP_9590 (c)/ PERCENTAGE_PRECISION
			amountOutMinimum(uint256) := TMP_9591(uint256)
		Expression: (amountOut) = swap(ISwapHandler.SwapParams(_collateralToken,_debtToken,ISwapHandler.SwapType.EXACT_INPUT,amount,amountOutMinimum,bytes()))
		IRs:
			REF_2764(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_9592 = CONVERT  to bytes
			TMP_9593(ISwapHandler.SwapParams) = new SwapParams(_collateralToken,_debtToken,REF_2764,amount,amountOutMinimum,TMP_9592)
			TUPLE_134(uint256,uint256) = INTERNAL_CALL, UseUnifiedSwapper.swap(ISwapHandler.SwapParams)(TMP_9593)
			amountOut(uint256)= UNPACK TUPLE_134 index: 1 
		Expression: amountOut
		IRs:
			RETURN amountOut
	Function StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_collateralOracle.getSafeLatestPrice(priceOptions).price,_debtOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_9594(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2767(uint256) -> TMP_9594.price
			TMP_9595(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2769(uint256) -> TMP_9595.price
			TMP_9596(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2767', 'REF_2769', 'roundUp'] 
			amountOut(uint256) := TMP_9596(uint256)
	Function StrategyLeverage._toCollateral(IOracle.PriceOptions,uint256,bool) (*)
		Expression: amountOut = amountIn.mulDiv(_debtOracle.getSafeLatestPrice(priceOptions).price,_collateralOracle.getSafeLatestPrice(priceOptions).price,roundUp)
		IRs:
			TMP_9597(IOracle.Price) = HIGH_LEVEL_CALL, dest:_debtOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2772(uint256) -> TMP_9597.price
			TMP_9598(IOracle.Price) = HIGH_LEVEL_CALL, dest:_collateralOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			REF_2774(uint256) -> TMP_9598.price
			TMP_9599(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['amountIn', 'REF_2772', 'REF_2774', 'roundUp'] 
			amountOut(uint256) := TMP_9599(uint256)
	Function StrategyLeverage._supplyBorrow(uint256,uint256,uint256) (*)
		Expression: collateralIn = _convertToCollateral(amount + loanAmount)
		IRs:
			TMP_9600(uint256) = amount (c)+ loanAmount
			TMP_9601(uint256) = INTERNAL_CALL, StrategyLeverage._convertToCollateral(uint256)(TMP_9600)
			collateralIn(uint256) := TMP_9601(uint256)
		Expression: _supplyAndBorrow(collateralIn,loanAmount + fee)
		IRs:
			TMP_9602(uint256) = loanAmount (c)+ fee
			INTERNAL_CALL, StrategyLeverageMorphoBlue._supplyAndBorrow(uint256,uint256)(collateralIn,TMP_9602)
		Expression: collateralInDebt = _toDebt(IOracle.PriceOptions({maxAge:getPriceMaxAge(),maxConf:getPriceMaxConf()}),collateralIn,false)
		IRs:
			TMP_9604(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxAge()()
			TMP_9605(uint256) = INTERNAL_CALL, StrategySettings.getPriceMaxConf()()
			TMP_9606(IOracle.PriceOptions) = new PriceOptions(TMP_9604,TMP_9605)
			TMP_9607(uint256) = INTERNAL_CALL, StrategyLeverage._toDebt(IOracle.PriceOptions,uint256,bool)(TMP_9606,collateralIn,False)
			collateralInDebt(uint256) := TMP_9607(uint256)
		Expression: deployedAmount = collateralInDebt - loanAmount - fee
		IRs:
			TMP_9608(uint256) = collateralInDebt (c)- loanAmount
			TMP_9609(uint256) = TMP_9608 (c)- fee
			deployedAmount(uint256) := TMP_9609(uint256)
		Expression: _pendingAmount = deployedAmount
		IRs:
			_pendingAmount(uint256) := deployedAmount(uint256)
		Expression: StrategyDeploy(msg.sender,deployedAmount)
		IRs:
			Emit StrategyDeploy(msg.sender,deployedAmount)
	Function StrategyLeverage._repayAndWithdraw(uint256,uint256,uint256,address) (*)
		Expression: (collateralBalance) = getBalances()
		IRs:
			TUPLE_135(uint256,uint256) = INTERNAL_CALL, StrategyLeverageMorphoBlue.getBalances()()
			collateralBalance(uint256)= UNPACK TUPLE_135 index: 0 
		Expression: _repay(repayAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverageMorphoBlue._repay(uint256)(repayAmount)
		Expression: _withdraw(cappedWithdrawAmount,address(this))
		IRs:
			TMP_9612 = CONVERT this to address
			INTERNAL_CALL, StrategyLeverageMorphoBlue._withdraw(uint256,address)(cappedWithdrawAmount,TMP_9612)
		Expression: withdrawnAmount = _convertToDebt(cappedWithdrawAmount)
		IRs:
			TMP_9614(uint256) = INTERNAL_CALL, StrategyLeverage._convertToDebt(uint256)(cappedWithdrawAmount)
			withdrawnAmount(uint256) := TMP_9614(uint256)
		Expression: debtToWithdraw > 0
		IRs:
			TMP_9615(bool) = debtToWithdraw > 0
			CONDITION TMP_9615
		Expression: IERC20Upgradeable(_debtToken).safeTransfer(receiver,debtToWithdraw)
		IRs:
			TMP_9616 = CONVERT _debtToken to IERC20Upgradeable
			LIBRARY_CALL, dest:SafeERC20Upgradeable, function:SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable,address,uint256), arguments:['TMP_9616', 'receiver', 'debtToWithdraw'] 
		Expression: _pendingAmount = debtToWithdraw
		IRs:
			_pendingAmount(uint256) := debtToWithdraw(uint256)
		Expression: collateralBalance < withdrawAmount
		IRs:
			TMP_9618(bool) = collateralBalance < withdrawAmount
			CONDITION TMP_9618
		Expression: cappedWithdrawAmount = collateralBalance
		IRs:
			cappedWithdrawAmount(uint256) := collateralBalance(uint256)
		Expression: cappedWithdrawAmount = withdrawAmount
		IRs:
			cappedWithdrawAmount(uint256) := withdrawAmount(uint256)
		Expression: withdrawnAmount > (repayAmount + fee)
		IRs:
			TMP_9619(uint256) = repayAmount (c)+ fee
			TMP_9620(bool) = withdrawnAmount > TMP_9619
			CONDITION TMP_9620
		Expression: debtToWithdraw = withdrawnAmount - (repayAmount + fee)
		IRs:
			TMP_9621(uint256) = repayAmount (c)+ fee
			TMP_9622(uint256) = withdrawnAmount (c)- TMP_9621
			debtToWithdraw(uint256) := TMP_9622(uint256)
		Expression: debtToWithdraw = 0
		IRs:
			debtToWithdraw(uint256) := 0(uint256)
	Function StrategyLeverage._supply(uint256) 
	Function StrategyLeverage._supplyAndBorrow(uint256,uint256) 
	Function StrategyLeverage._repay(uint256) 
	Function StrategyLeverage._withdraw(uint256,address) 
	Function StrategyLeverage.renounceOwnership() (*)
		Expression: revert InvalidOwner()()
		IRs:
			TMP_9623(None) = SOLIDITY_CALL revert InvalidOwner()()
	Function StrategyLeverage.getCollateralOracle() (*)
		Expression: oracle = address(_collateralOracle)
		IRs:
			TMP_9624 = CONVERT _collateralOracle to address
			oracle(address) := TMP_9624(address)
	Function StrategyLeverage.getDebtOracle() (*)
		Expression: oracle = address(_debtOracle)
		IRs:
			TMP_9625 = CONVERT _debtOracle to address
			oracle(address) := TMP_9625(address)
	Function StrategyLeverage.setCollateralOracle(IOracle) (*)
		Expression: _collateralOracle = oracle
		IRs:
			_collateralOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.setDebtOracle(IOracle) (*)
		Expression: _debtOracle = oracle
		IRs:
			_debtOracle(IOracle) := oracle(IOracle)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverage.asset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function StrategyLeverage.getCollateralAsset() (*)
		Expression: _collateralToken
		IRs:
			RETURN _collateralToken
	Function StrategyLeverage.getDebAsset() (*)
		Expression: _debtToken
		IRs:
			RETURN _debtToken
	Function UseLeverage._calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_9628(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_9628
		Expression: revert InvalidNumberOfLoops()()
		IRs:
			TMP_9629(None) = SOLIDITY_CALL revert InvalidNumberOfLoops()()
		Expression: loanToValue == 0 || loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9630(bool) = loanToValue == 0
			TMP_9631(bool) = loanToValue > PERCENTAGE_PRECISION
			TMP_9632(bool) = TMP_9630 || TMP_9631
			CONDITION TMP_9632
		Expression: revert InvalidLoanToValue()()
		IRs:
			TMP_9633(None) = SOLIDITY_CALL revert InvalidLoanToValue()()
		Expression: leverage = baseValue
		IRs:
			leverage(uint256) := baseValue(uint256)
		Expression: prev = baseValue
		IRs:
			prev(uint256) := baseValue(uint256)
		Expression: i = 1
		IRs:
			i(uint8) := 1(uint256)
		Expression: i <= nrLoops
		IRs:
			TMP_9634(bool) = i <= nrLoops
			CONDITION TMP_9634
		Expression: inc = (prev * loanToValue) / PERCENTAGE_PRECISION
		IRs:
			TMP_9635(uint256) = prev (c)* loanToValue
			TMP_9636(uint256) = TMP_9635 (c)/ PERCENTAGE_PRECISION
			inc(uint256) := TMP_9636(uint256)
		Expression: leverage += inc
		IRs:
			leverage(uint256) = leverage (c)+ inc
		Expression: prev = inc
		IRs:
			prev(uint256) := inc(uint256)
		Expression: ++ i
		IRs:
			i(uint8) = i + 1
		Expression: leverage
		IRs:
			RETURN leverage
	Function UseLeverage._calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: percentageToBurn == 0 || percentageToBurn > PERCENTAGE_PRECISION
		IRs:
			TMP_9637(bool) = percentageToBurn == 0
			TMP_9638(bool) = percentageToBurn > PERCENTAGE_PRECISION
			TMP_9639(bool) = TMP_9637 || TMP_9638
			CONDITION TMP_9639
		Expression: revert InvalidPercentageValue()()
		IRs:
			TMP_9640(None) = SOLIDITY_CALL revert InvalidPercentageValue()()
		Expression: deltaDebtInETH = (totalDebtBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_9641(uint256) = totalDebtBaseInEth (c)* percentageToBurn
			TMP_9642(uint256) = TMP_9641 (c)/ PERCENTAGE_PRECISION
			deltaDebtInETH(uint256) := TMP_9642(uint256)
		Expression: deltaCollateralInETH = (totalCollateralBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_9643(uint256) = totalCollateralBaseInEth (c)* percentageToBurn
			TMP_9644(uint256) = TMP_9643 (c)/ PERCENTAGE_PRECISION
			deltaCollateralInETH(uint256) := TMP_9644(uint256)
	Function UseLeverage._calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: colValue = ((targetLoanToValue * collateral) / PERCENTAGE_PRECISION)
		IRs:
			TMP_9645(uint256) = targetLoanToValue (c)* collateral
			TMP_9646(uint256) = TMP_9645 (c)/ PERCENTAGE_PRECISION
			colValue(uint256) := TMP_9646(uint256)
		Expression: colValue >= debt
		IRs:
			TMP_9647(bool) = colValue >= debt
			CONDITION TMP_9647
		Expression: revert InvalidTargetValue()()
		IRs:
			TMP_9648(None) = SOLIDITY_CALL revert InvalidTargetValue()()
		Expression: numerator = debt - colValue
		IRs:
			TMP_9649(uint256) = debt (c)- colValue
			numerator(uint256) := TMP_9649(uint256)
		Expression: divisor = (PERCENTAGE_PRECISION - targetLoanToValue)
		IRs:
			TMP_9650(uint256) = PERCENTAGE_PRECISION (c)- targetLoanToValue
			divisor(uint256) := TMP_9650(uint256)
		Expression: divisor == 0
		IRs:
			TMP_9651(bool) = divisor == 0
			CONDITION TMP_9651
		Expression: revert InvalidDivisor()()
		IRs:
			TMP_9652(None) = SOLIDITY_CALL revert InvalidDivisor()()
		Expression: delta = (numerator * PERCENTAGE_PRECISION) / divisor
		IRs:
			TMP_9653(uint256) = numerator (c)* PERCENTAGE_PRECISION
			TMP_9654(uint256) = TMP_9653 (c)/ divisor
			delta(uint256) := TMP_9654(uint256)
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_9655 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_9655(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_9656 = CONVERT _fLender to address
			TMP_9657 = CONVERT 0 to address
			TMP_9658(bool) = TMP_9656 == TMP_9657
			CONDITION TMP_9658
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_9659(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_9661 = CONVERT _fLender to address
			RETURN TMP_9661
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_9662 = UnaryType.BANG _initializing 
			TMP_9663(None) = SOLIDITY_CALL require(bool,string)(TMP_9662,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_9665(uint8) := 255(uint8)
			TMP_9666(bool) = _initialized != TMP_9665
			CONDITION TMP_9666
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_9668(uint8) := 255(uint8)
			_initialized(uint8) := TMP_9668(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_9670(uint8) := 255(uint8)
			Emit Initialized(TMP_9670)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_9672(bool) = tokenA < tokenB
			CONDITION TMP_9672
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_9673(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d780e850>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d780f050>])
			TMP_9674(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9673)
			RETURN TMP_9674
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_9675(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d780f050>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d780e850>])
			TMP_9676(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_9675)
			RETURN TMP_9676
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9677(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9677(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2779(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2780(UseUnifiedSwapper.SwapProvider) -> REF_2779.provider
			REF_2781(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9678(bool) = REF_2780 != REF_2781
			CONDITION TMP_9678
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_9679(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_9680 = CONVERT tokenIn to IERC20
			REF_2783(address) -> routeInfo.router
			TMP_9682(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_9683(uint256) = TMP_9682 (c)- 1
			TMP_9684(bool) = HIGH_LEVEL_CALL, dest:TMP_9680(IERC20), function:approve, arguments:['REF_2783', 'TMP_9683']  
			TMP_9685 = UnaryType.BANG TMP_9684 
			CONDITION TMP_9685
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9686(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_9687 = CONVERT tokenOut to IERC20
			REF_2785(address) -> routeInfo.router
			TMP_9689(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_9690(uint256) = TMP_9689 (c)- 1
			TMP_9691(bool) = HIGH_LEVEL_CALL, dest:TMP_9687(IERC20), function:approve, arguments:['REF_2785', 'TMP_9690']  
			TMP_9692 = UnaryType.BANG TMP_9691 
			CONDITION TMP_9692
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9693(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_2786(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2786(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9695(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9695(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_2787(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2788(UseUnifiedSwapper.SwapProvider) -> REF_2787.provider
			REF_2789(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9696(bool) = REF_2788 == REF_2789
			CONDITION TMP_9696
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_9697(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_9698 = CONVERT tokenIn to IERC20
			REF_2791(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2792(address) -> REF_2791.router
			TMP_9699(bool) = HIGH_LEVEL_CALL, dest:TMP_9698(IERC20), function:approve, arguments:['REF_2792', '0']  
			TMP_9700 = UnaryType.BANG TMP_9699 
			CONDITION TMP_9700
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9701(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_9702 = CONVERT tokenOut to IERC20
			REF_2794(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2795(address) -> REF_2794.router
			TMP_9703(bool) = HIGH_LEVEL_CALL, dest:TMP_9702(IERC20), function:approve, arguments:['REF_2795', '0']  
			TMP_9704 = UnaryType.BANG TMP_9703 
			CONDITION TMP_9704
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9705(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_2796(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2797(UseUnifiedSwapper.SwapProvider) -> REF_2796.provider
			REF_2798(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_2797(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_2798(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_9707(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_9707(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_2799(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_2800(UseUnifiedSwapper.SwapProvider) -> REF_2799.provider
			REF_2801(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9708(bool) = REF_2800 != REF_2801
			RETURN TMP_9708
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) (*)
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_2802(address) -> params.underlyingIn
			REF_2803(address) -> params.underlyingOut
			TMP_9709(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_2802,REF_2803)
			key(bytes32) := TMP_9709(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_2804(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_2804(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_2805(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2806(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_9710(bool) = REF_2805 == REF_2806
			CONDITION TMP_9710
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_9711(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_2807(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2808(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_9712(bool) = REF_2807 == REF_2808
			CONDITION TMP_9712
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_2809(bytes) -> params.payload
			REF_2811(uint24) -> routeInfo.uniV3Tier
			TMP_9713(bytes) = SOLIDITY_CALL abi.encode()(REF_2811)
			REF_2809(bytes) (->params) := TMP_9713(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_2813(address) -> routeInfo.router
			TMP_9714 = CONVERT REF_2813 to IV3SwapRouter
			TUPLE_136(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_9714', 'params'] 
			RETURN TUPLE_136
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_2814(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2815(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_9715(bool) = REF_2814 == REF_2815
			CONDITION TMP_9715
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_2817(address) -> routeInfo.router
			TMP_9716 = CONVERT REF_2817 to IUniswapV2Router02
			TUPLE_137(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_9716', 'params'] 
			RETURN TUPLE_137
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_2818(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_2819(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_9717(bool) = REF_2818 == REF_2819
			CONDITION TMP_9717
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_2820(bytes) -> params.payload
			REF_2822(uint24) -> routeInfo.tickSpacing
			TMP_9718(bytes) = SOLIDITY_CALL abi.encode()(REF_2822)
			REF_2820(bytes) (->params) := TMP_9718(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_2824(address) -> routeInfo.router
			TMP_9719 = CONVERT REF_2824 to ISwapRouter
			TUPLE_138(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_9719', 'params'] 
			RETURN TUPLE_138
		Expression: revert InvalidProvider()()
		IRs:
			TMP_9720(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_9724 = CONVERT 0 to address
			TMP_9725(bool) = _newGovernor == TMP_9724
			CONDITION TMP_9725
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_9726(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_9732(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9732)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_9735(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_9736(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_9737(bool) = TMP_9735 == TMP_9736
			TMP_9738(None) = SOLIDITY_CALL require(bool,string)(TMP_9737,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() 
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_9739 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9739)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_9742 = CONVERT 0 to address
			TMP_9743(bool) = newOwner != TMP_9742
			TMP_9744(None) = SOLIDITY_CALL require(bool,string)(TMP_9743,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init() (*)
		Expression: __ReentrancyGuard_init_unchained()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ReentrancyGuardUpgradeable._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_9753(bool) = _status != _ENTERED
			TMP_9754(None) = SOLIDITY_CALL require(bool,string)(TMP_9753,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuardUpgradeable._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_9755(bool) = _status == _ENTERED
			RETURN TMP_9755
	Function StrategyLeverageSettings._initLeverageSettings(address,address) (*)
		Expression: _initializeGovernableOwnable(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._initializeGovernableOwnable(address,address)(initialOwner,initialGovernor)
		Expression: _initializeStrategySettings()
		IRs:
			INTERNAL_CALL, StrategySettings._initializeStrategySettings()()
		Expression: _loanToValue = 800 * 1e6
		IRs:
			TMP_9758(uint256) = 800 (c)* 1000000
			_loanToValue(uint256) := TMP_9758(uint256)
		Expression: _maxLoanToValue = 850 * 1e6
		IRs:
			TMP_9759(uint256) = 850 (c)* 1000000
			_maxLoanToValue(uint256) := TMP_9759(uint256)
		Expression: _nrLoops = 10
		IRs:
			_nrLoops(uint8) := 10(uint256)
		Expression: _maxSlippage = 0
		IRs:
			_maxSlippage(uint256) := 0(uint256)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageSettings.setMaxLoanToValue(uint256) (*)
		Expression: maxLoanToValue == 0
		IRs:
			TMP_9761(bool) = maxLoanToValue == 0
			CONDITION TMP_9761
		Expression: revert InvalidValue()()
		IRs:
			TMP_9762(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: maxLoanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9763(bool) = maxLoanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9763
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9764(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: maxLoanToValue < _loanToValue
		IRs:
			TMP_9765(bool) = maxLoanToValue < _loanToValue
			CONDITION TMP_9765
		Expression: revert InvalidMaxLoanToValue()()
		IRs:
			TMP_9766(None) = SOLIDITY_CALL revert InvalidMaxLoanToValue()()
		Expression: _maxLoanToValue = maxLoanToValue
		IRs:
			_maxLoanToValue(uint256) := maxLoanToValue(uint256)
		Expression: MaxLoanToValueChanged(_maxLoanToValue)
		IRs:
			Emit MaxLoanToValueChanged(_maxLoanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxLoanToValue() (*)
		Expression: _maxLoanToValue
		IRs:
			RETURN _maxLoanToValue
	Function StrategyLeverageSettings.setLoanToValue(uint256) (*)
		Expression: loanToValue > _maxLoanToValue
		IRs:
			TMP_9769(bool) = loanToValue > _maxLoanToValue
			CONDITION TMP_9769
		Expression: revert InvalidValue()()
		IRs:
			TMP_9770(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9771(bool) = loanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9771
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9772(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: loanToValue == 0
		IRs:
			TMP_9773(bool) = loanToValue == 0
			CONDITION TMP_9773
		Expression: revert InvalidValue()()
		IRs:
			TMP_9774(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: _loanToValue = loanToValue
		IRs:
			_loanToValue(uint256) := loanToValue(uint256)
		Expression: LoanToValueChanged(_loanToValue)
		IRs:
			Emit LoanToValueChanged(_loanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getLoanToValue() (*)
		Expression: _loanToValue
		IRs:
			RETURN _loanToValue
	Function StrategyLeverageSettings.getNrLoops() (*)
		Expression: _nrLoops
		IRs:
			RETURN _nrLoops
	Function StrategyLeverageSettings.setNrLoops(uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_9777(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_9777
		Expression: revert InvalidLoopCount()()
		IRs:
			TMP_9778(None) = SOLIDITY_CALL revert InvalidLoopCount()()
		Expression: _nrLoops = nrLoops
		IRs:
			_nrLoops(uint8) := nrLoops(uint8)
		Expression: NrLoopsChanged(_nrLoops)
		IRs:
			Emit NrLoopsChanged(_nrLoops)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategyLeverageSettings.setMaxSlippage(uint256) (*)
		Expression: slippage > PERCENTAGE_PRECISION
		IRs:
			TMP_9781(bool) = slippage > PERCENTAGE_PRECISION
			CONDITION TMP_9781
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9782(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _maxSlippage = slippage
		IRs:
			_maxSlippage(uint256) := slippage(uint256)
		Expression: MaxSlippageChanged(slippage)
		IRs:
			Emit MaxSlippageChanged(slippage)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.constructor() 
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_9792(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_9792
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_9793(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_9793
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9794(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_9798(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_9798
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_9799(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_9800(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_9800(uint256)
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) 
	Function IStrategyLeverage.getCollateralAsset() 
	Function IStrategyLeverage.getDebAsset() 
	Function IStrategyLeverage.getPosition(IOracle.PriceOptions) 
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyLeverageMorphoBlue.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategyLeverageMorphoBlue.initialize(address,address,StrategyLeverageMorphoBlue.StrategyLeverageMorphoParams) (*)
		Expression: _initializeStrategyLeverage(initialOwner,initialGovernor,params.collateralToken,params.debtToken,params.collateralOracle,params.debtOracle,params.flashLender)
		IRs:
			REF_2825(address) -> params.collateralToken
			REF_2826(address) -> params.debtToken
			REF_2827(address) -> params.collateralOracle
			REF_2828(address) -> params.debtOracle
			REF_2829(address) -> params.flashLender
			INTERNAL_CALL, StrategyLeverage._initializeStrategyLeverage(address,address,address,address,address,address,address)(initialOwner,initialGovernor,REF_2825,REF_2826,REF_2827,REF_2828,REF_2829)
		Expression: _morpho = IMorpho(params.morphoBlue)
		IRs:
			REF_2830(address) -> params.morphoBlue
			TMP_9803 = CONVERT REF_2830 to IMorpho
			_morpho(IMorpho) := TMP_9803(IMorpho)
		Expression: address(_morpho) == address(0)
		IRs:
			TMP_9804 = CONVERT _morpho to address
			TMP_9805 = CONVERT 0 to address
			TMP_9806(bool) = TMP_9804 == TMP_9805
			CONDITION TMP_9806
		Expression: revert InvalidMorphoBlueContract()()
		IRs:
			TMP_9807(None) = SOLIDITY_CALL revert InvalidMorphoBlueContract()()
		Expression: _marketParams.loanToken = params.debtToken
		IRs:
			REF_2831(address) -> _marketParams.loanToken
			REF_2832(address) -> params.debtToken
			REF_2831(address) (->_marketParams) := REF_2832(address)
		Expression: _marketParams.collateralToken = params.collateralToken
		IRs:
			REF_2833(address) -> _marketParams.collateralToken
			REF_2834(address) -> params.collateralToken
			REF_2833(address) (->_marketParams) := REF_2834(address)
		Expression: _marketParams.oracle = params.morphoOracle
		IRs:
			REF_2835(address) -> _marketParams.oracle
			REF_2836(address) -> params.morphoOracle
			REF_2835(address) (->_marketParams) := REF_2836(address)
		Expression: _marketParams.irm = params.irm
		IRs:
			REF_2837(address) -> _marketParams.irm
			REF_2838(address) -> params.irm
			REF_2837(address) (->_marketParams) := REF_2838(address)
		Expression: _marketParams.lltv = params.lltv
		IRs:
			REF_2839(uint256) -> _marketParams.lltv
			REF_2840(uint256) -> params.lltv
			REF_2839(uint256) (->_marketParams) := REF_2840(uint256)
		Expression: marketId = _marketParams.id()
		IRs:
			TMP_9808(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['_marketParams'] 
			marketId(Id) := TMP_9808(Id)
		Expression: lParams = _morpho.idToMarketParams(marketId)
		IRs:
			TMP_9809(MarketParams) = HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:idToMarketParams, arguments:['marketId']  
			lParams(MarketParams) := TMP_9809(MarketParams)
		Expression: lParams.lltv == 0
		IRs:
			REF_2843(uint256) -> lParams.lltv
			TMP_9810(bool) = REF_2843 == 0
			CONDITION TMP_9810
		Expression: revert InvalidMorphoBlueMarket()()
		IRs:
			TMP_9811(None) = SOLIDITY_CALL revert InvalidMorphoBlueMarket()()
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageMorphoBlue.getBalances() (*)
		Expression: marketId = _marketParams.id()
		IRs:
			TMP_9813(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['_marketParams'] 
			marketId(Id) := TMP_9813(Id)
		Expression: totalSupplyAssets = _morpho.collateral(marketId,address(this))
		IRs:
			TMP_9814 = CONVERT this to address
			TMP_9815(uint256) = LIBRARY_CALL, dest:MorphoLib, function:MorphoLib.collateral(IMorpho,Id,address), arguments:['_morpho', 'marketId', 'TMP_9814'] 
			totalSupplyAssets(uint256) := TMP_9815(uint256)
		Expression: totalBorrowAssets = _morpho.expectedBorrowAssets(_marketParams,address(this))
		IRs:
			TMP_9816 = CONVERT this to address
			TMP_9817(uint256) = LIBRARY_CALL, dest:MorphoBalancesLib, function:MorphoBalancesLib.expectedBorrowAssets(IMorpho,MarketParams,address), arguments:['_morpho', '_marketParams', 'TMP_9816'] 
			totalBorrowAssets(uint256) := TMP_9817(uint256)
		Expression: debtDecimals = ERC20(_marketParams.loanToken).decimals()
		IRs:
			REF_2847(address) -> _marketParams.loanToken
			TMP_9818 = CONVERT REF_2847 to ERC20
			TMP_9819(uint8) = HIGH_LEVEL_CALL, dest:TMP_9818(ERC20), function:decimals, arguments:[]  
			debtDecimals(uint8) := TMP_9819(uint8)
		Expression: collateralDecimals = ERC20(_marketParams.collateralToken).decimals()
		IRs:
			REF_2849(address) -> _marketParams.collateralToken
			TMP_9820 = CONVERT REF_2849 to ERC20
			TMP_9821(uint8) = HIGH_LEVEL_CALL, dest:TMP_9820(ERC20), function:decimals, arguments:[]  
			collateralDecimals(uint8) := TMP_9821(uint8)
		Expression: debtBalance = totalBorrowAssets.toDecimals(debtDecimals,SYSTEM_DECIMALS)
		IRs:
			TMP_9822(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['totalBorrowAssets', 'debtDecimals', 'SYSTEM_DECIMALS'] 
			debtBalance(uint256) := TMP_9822(uint256)
		Expression: collateralBalance = totalSupplyAssets.toDecimals(collateralDecimals,SYSTEM_DECIMALS)
		IRs:
			TMP_9823(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['totalSupplyAssets', 'collateralDecimals', 'SYSTEM_DECIMALS'] 
			collateralBalance(uint256) := TMP_9823(uint256)
	Function StrategyLeverageMorphoBlue._supply(uint256) (*)
		Expression: ! ERC20(_collateralToken).approve(address(_morpho),amountIn)
		IRs:
			TMP_9824 = CONVERT _collateralToken to ERC20
			TMP_9825 = CONVERT _morpho to address
			TMP_9826(bool) = HIGH_LEVEL_CALL, dest:TMP_9824(ERC20), function:approve, arguments:['TMP_9825', 'amountIn']  
			TMP_9827 = UnaryType.BANG TMP_9826 
			CONDITION TMP_9827
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9828(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: onBehalf = address(this)
		IRs:
			TMP_9829 = CONVERT this to address
			onBehalf(address) := TMP_9829(address)
		Expression: _morpho.supplyCollateral(_marketParams,amountIn,onBehalf,)
		IRs:
			HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:supplyCollateral, arguments:['_marketParams', 'amountIn', 'onBehalf', '']  
	Function StrategyLeverageMorphoBlue._supplyAndBorrow(uint256,uint256) (*)
		Expression: _supply(collateralAmount)
		IRs:
			INTERNAL_CALL, StrategyLeverageMorphoBlue._supply(uint256)(collateralAmount)
		Expression: onBehalf = address(this)
		IRs:
			TMP_9832 = CONVERT this to address
			onBehalf(address) := TMP_9832(address)
		Expression: receiver = address(this)
		IRs:
			TMP_9833 = CONVERT this to address
			receiver(address) := TMP_9833(address)
		Expression: _morpho.borrow(_marketParams,debtAmount,shares,onBehalf,receiver)
		IRs:
			TUPLE_139(uint256,uint256) = HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:borrow, arguments:['_marketParams', 'debtAmount', 'shares', 'onBehalf', 'receiver']  
	Function StrategyLeverageMorphoBlue._repay(uint256) (*)
		Expression: ! ERC20(_debtToken).approve(address(_morpho),amount)
		IRs:
			TMP_9834 = CONVERT _debtToken to ERC20
			TMP_9835 = CONVERT _morpho to address
			TMP_9836(bool) = HIGH_LEVEL_CALL, dest:TMP_9834(ERC20), function:approve, arguments:['TMP_9835', 'amount']  
			TMP_9837 = UnaryType.BANG TMP_9836 
			CONDITION TMP_9837
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_9838(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: marketId = _marketParams.id()
		IRs:
			TMP_9839(Id) = LIBRARY_CALL, dest:MarketParamsLib, function:MarketParamsLib.id(MarketParams), arguments:['_marketParams'] 
			marketId(Id) := TMP_9839(Id)
		Expression: onBehalf = address(this)
		IRs:
			TMP_9840 = CONVERT this to address
			onBehalf(address) := TMP_9840(address)
		Expression: shares = 0
		IRs:
			shares(uint256) := 0(uint256)
		Expression: amountPaid = 0
		IRs:
			amountPaid(uint256) := 0(uint256)
		Expression: (totalBorrowAssets,totalBorrowShares) = _morpho.expectedMarketBalances(_marketParams)
		IRs:
			TUPLE_140(uint256,uint256,uint256,uint256) = LIBRARY_CALL, dest:MorphoBalancesLib, function:MorphoBalancesLib.expectedMarketBalances(IMorpho,MarketParams), arguments:['_morpho', '_marketParams'] 
			totalBorrowAssets(uint256)= UNPACK TUPLE_140 index: 2 
			totalBorrowShares(uint256)= UNPACK TUPLE_140 index: 3 
		Expression: borrowShares = _morpho.position(marketId,address(this)).borrowShares
		IRs:
			TMP_9841 = CONVERT this to address
			TMP_9842(Position) = HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:position, arguments:['marketId', 'TMP_9841']  
			REF_2860(uint128) -> TMP_9842.borrowShares
			borrowShares(uint256) := REF_2860(uint128)
		Expression: repaidAmount = borrowShares.toAssetsUp(totalBorrowAssets,totalBorrowShares)
		IRs:
			TMP_9843(uint256) = LIBRARY_CALL, dest:SharesMathLib, function:SharesMathLib.toAssetsUp(uint256,uint256,uint256), arguments:['borrowShares', 'totalBorrowAssets', 'totalBorrowShares'] 
			repaidAmount(uint256) := TMP_9843(uint256)
		Expression: amount >= repaidAmount
		IRs:
			TMP_9844(bool) = amount >= repaidAmount
			CONDITION TMP_9844
		Expression: shares = borrowShares
		IRs:
			shares(uint256) := borrowShares(uint256)
		Expression: amountPaid = amount
		IRs:
			amountPaid(uint256) := amount(uint256)
		Expression: (assetsRepaid) = _morpho.repay(_marketParams,amountPaid,shares,onBehalf,)
		IRs:
			TUPLE_141(uint256,uint256) = HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:repay, arguments:['_marketParams', 'amountPaid', 'shares', 'onBehalf', '']  
			assetsRepaid(uint256)= UNPACK TUPLE_141 index: 0 
		Expression: assetsRepaid < amount
		IRs:
			TMP_9845(bool) = assetsRepaid < amount
			CONDITION TMP_9845
		Expression: revert FailedToRepayDebt()()
		IRs:
			TMP_9846(None) = SOLIDITY_CALL revert FailedToRepayDebt()()
	Function StrategyLeverageMorphoBlue._withdraw(uint256,address) (*)
		Expression: onBehalf = address(this)
		IRs:
			TMP_9847 = CONVERT this to address
			onBehalf(address) := TMP_9847(address)
		Expression: receiver = to
		IRs:
			receiver(address) := to(address)
		Expression: _morpho.withdrawCollateral(_marketParams,amount,onBehalf,receiver)
		IRs:
			HIGH_LEVEL_CALL, dest:_morpho(IMorpho), function:withdrawCollateral, arguments:['_marketParams', 'amount', 'onBehalf', 'receiver']  
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_9849 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_9849(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_9850(bool) = _initialized < 1
			TMP_9851(bool) = isTopLevelCall && TMP_9850
			TMP_9852 = CONVERT this to address
			TMP_9853(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_9852'] 
			TMP_9854 = UnaryType.BANG TMP_9853 
			TMP_9855(bool) = _initialized == 1
			TMP_9856(bool) = TMP_9854 && TMP_9855
			TMP_9857(bool) = TMP_9851 || TMP_9856
			TMP_9858(None) = SOLIDITY_CALL require(bool,string)(TMP_9857,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_9860 = UnaryType.BANG _initializing 
			TMP_9861(bool) = _initialized < version
			TMP_9862(bool) = TMP_9860 && TMP_9861
			TMP_9863(None) = SOLIDITY_CALL require(bool,string)(TMP_9862,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_9865(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_9866(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_9867(bool) = msg.sender != TMP_9866
			CONDITION TMP_9867
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_9868(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier ReentrancyGuardUpgradeable.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuardUpgradeable._nonReentrantAfter()()
Contract StrategyLeverageSettings
	Function StrategySettings.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_9879(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_9879
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_9880(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_9880
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9881(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_9885(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_9885
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_9886(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_9887(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_9887(uint256)
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_9891 = CONVERT 0 to address
			TMP_9892(bool) = _newGovernor == TMP_9891
			CONDITION TMP_9892
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_9893(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_9899(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9899)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_9902(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_9903(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_9904(bool) = TMP_9902 == TMP_9903
			TMP_9905(None) = SOLIDITY_CALL require(bool,string)(TMP_9904,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_9906 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_9906)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_9909 = CONVERT 0 to address
			TMP_9910(bool) = newOwner != TMP_9909
			TMP_9911(None) = SOLIDITY_CALL require(bool,string)(TMP_9910,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_9917 = UnaryType.BANG _initializing 
			TMP_9918(None) = SOLIDITY_CALL require(bool,string)(TMP_9917,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_9920(uint8) := 255(uint8)
			TMP_9921(bool) = _initialized != TMP_9920
			CONDITION TMP_9921
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_9923(uint8) := 255(uint8)
			_initialized(uint8) := TMP_9923(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_9925(uint8) := 255(uint8)
			Emit Initialized(TMP_9925)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function StrategyLeverageSettings._initLeverageSettings(address,address) (*)
		Expression: _initializeGovernableOwnable(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._initializeGovernableOwnable(address,address)(initialOwner,initialGovernor)
		Expression: _initializeStrategySettings()
		IRs:
			INTERNAL_CALL, StrategySettings._initializeStrategySettings()()
		Expression: _loanToValue = 800 * 1e6
		IRs:
			TMP_9929(uint256) = 800 (c)* 1000000
			_loanToValue(uint256) := TMP_9929(uint256)
		Expression: _maxLoanToValue = 850 * 1e6
		IRs:
			TMP_9930(uint256) = 850 (c)* 1000000
			_maxLoanToValue(uint256) := TMP_9930(uint256)
		Expression: _nrLoops = 10
		IRs:
			_nrLoops(uint8) := 10(uint256)
		Expression: _maxSlippage = 0
		IRs:
			_maxSlippage(uint256) := 0(uint256)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageSettings.setMaxLoanToValue(uint256) (*)
		Expression: maxLoanToValue == 0
		IRs:
			TMP_9932(bool) = maxLoanToValue == 0
			CONDITION TMP_9932
		Expression: revert InvalidValue()()
		IRs:
			TMP_9933(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: maxLoanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9934(bool) = maxLoanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9934
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9935(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: maxLoanToValue < _loanToValue
		IRs:
			TMP_9936(bool) = maxLoanToValue < _loanToValue
			CONDITION TMP_9936
		Expression: revert InvalidMaxLoanToValue()()
		IRs:
			TMP_9937(None) = SOLIDITY_CALL revert InvalidMaxLoanToValue()()
		Expression: _maxLoanToValue = maxLoanToValue
		IRs:
			_maxLoanToValue(uint256) := maxLoanToValue(uint256)
		Expression: MaxLoanToValueChanged(_maxLoanToValue)
		IRs:
			Emit MaxLoanToValueChanged(_maxLoanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxLoanToValue() (*)
		Expression: _maxLoanToValue
		IRs:
			RETURN _maxLoanToValue
	Function StrategyLeverageSettings.setLoanToValue(uint256) (*)
		Expression: loanToValue > _maxLoanToValue
		IRs:
			TMP_9940(bool) = loanToValue > _maxLoanToValue
			CONDITION TMP_9940
		Expression: revert InvalidValue()()
		IRs:
			TMP_9941(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_9942(bool) = loanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_9942
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9943(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: loanToValue == 0
		IRs:
			TMP_9944(bool) = loanToValue == 0
			CONDITION TMP_9944
		Expression: revert InvalidValue()()
		IRs:
			TMP_9945(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: _loanToValue = loanToValue
		IRs:
			_loanToValue(uint256) := loanToValue(uint256)
		Expression: LoanToValueChanged(_loanToValue)
		IRs:
			Emit LoanToValueChanged(_loanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getLoanToValue() (*)
		Expression: _loanToValue
		IRs:
			RETURN _loanToValue
	Function StrategyLeverageSettings.getNrLoops() (*)
		Expression: _nrLoops
		IRs:
			RETURN _nrLoops
	Function StrategyLeverageSettings.setNrLoops(uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_9948(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_9948
		Expression: revert InvalidLoopCount()()
		IRs:
			TMP_9949(None) = SOLIDITY_CALL revert InvalidLoopCount()()
		Expression: _nrLoops = nrLoops
		IRs:
			_nrLoops(uint8) := nrLoops(uint8)
		Expression: NrLoopsChanged(_nrLoops)
		IRs:
			Emit NrLoopsChanged(_nrLoops)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategyLeverageSettings.setMaxSlippage(uint256) (*)
		Expression: slippage > PERCENTAGE_PRECISION
		IRs:
			TMP_9952(bool) = slippage > PERCENTAGE_PRECISION
			CONDITION TMP_9952
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_9953(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _maxSlippage = slippage
		IRs:
			_maxSlippage(uint256) := slippage(uint256)
		Expression: MaxSlippageChanged(slippage)
		IRs:
			Emit MaxSlippageChanged(slippage)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_9956(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_9957(bool) = msg.sender != TMP_9956
			CONDITION TMP_9957
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_9958(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_9960 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_9960(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_9961(bool) = _initialized < 1
			TMP_9962(bool) = isTopLevelCall && TMP_9961
			TMP_9963 = CONVERT this to address
			TMP_9964(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_9963'] 
			TMP_9965 = UnaryType.BANG TMP_9964 
			TMP_9966(bool) = _initialized == 1
			TMP_9967(bool) = TMP_9965 && TMP_9966
			TMP_9968(bool) = TMP_9962 || TMP_9967
			TMP_9969(None) = SOLIDITY_CALL require(bool,string)(TMP_9968,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_9971 = UnaryType.BANG _initializing 
			TMP_9972(bool) = _initialized < version
			TMP_9973(bool) = TMP_9971 && TMP_9972
			TMP_9974(None) = SOLIDITY_CALL require(bool,string)(TMP_9973,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_9976(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract StrategyPark
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_9977(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_9977)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_9979(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_9980(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_9981(bool) = TMP_9979 == TMP_9980
			TMP_9982(None) = SOLIDITY_CALL require(bool,string)(TMP_9981,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_9983 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_9983)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_9986 = CONVERT 0 to address
			TMP_9987(bool) = newOwner != TMP_9986
			TMP_9988(None) = SOLIDITY_CALL require(bool,string)(TMP_9987,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_9992(bool) = _status != _ENTERED
			TMP_9993(None) = SOLIDITY_CALL require(bool,string)(TMP_9992,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_9994(bool) = _status == _ENTERED
			RETURN TMP_9994
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyPark.constructor(address,address) (*)
		Expression: asset_ == address(0)
		IRs:
			TMP_9995 = CONVERT 0 to address
			TMP_9996(bool) = asset_ == TMP_9995
			CONDITION TMP_9996
		Expression: revert ZeroAddress()()
		IRs:
			TMP_9997(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: _asset = asset_
		IRs:
			_asset(address) := asset_(address)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(initialOwner)
		Expression: ReentrancyGuard()
		IRs:
			INTERNAL_CALL, ReentrancyGuard.constructor()()
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategyPark.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10001(bool) = amount == 0
			CONDITION TMP_10001
		Expression: revert ZeroAmount()()
		IRs:
			TMP_10002(None) = SOLIDITY_CALL revert ZeroAmount()()
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10003 = CONVERT _asset to IERC20
			TMP_10004 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_10003', 'msg.sender', 'TMP_10004', 'amount'] 
		Expression: _deployedAmount += amount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amount
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: amount
		IRs:
			RETURN amount
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategyPark.harvest() (*)
		Expression: newBalance = IERC20(_asset).balanceOf(address(this))
		IRs:
			TMP_10010 = CONVERT _asset to IERC20
			TMP_10011 = CONVERT this to address
			TMP_10012(uint256) = HIGH_LEVEL_CALL, dest:TMP_10010(IERC20), function:balanceOf, arguments:['TMP_10011']  
			newBalance(uint256) := TMP_10012(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_10013 = CONVERT newBalance to int256
			TMP_10014 = CONVERT _deployedAmount to int256
			TMP_10015(int256) = TMP_10013 (c)- TMP_10014
			balanceChange(int256) := TMP_10015(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_10016(bool) = balanceChange > 0
			CONDITION TMP_10016
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_10017 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_10017)
		Expression: balanceChange < 0
		IRs:
			TMP_10019(bool) = balanceChange < 0
			CONDITION TMP_10019
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_10020(int256) = 0 (c)- balanceChange
			TMP_10021 = CONVERT TMP_10020 to uint256
			Emit StrategyLoss(TMP_10021)
		Expression: balanceChange != 0
		IRs:
			TMP_10023(bool) = balanceChange != 0
			CONDITION TMP_10023
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
	Function StrategyPark.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10025(bool) = amount == 0
			CONDITION TMP_10025
		Expression: revert ZeroAmount()()
		IRs:
			TMP_10026(None) = SOLIDITY_CALL revert ZeroAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_10027(bool) = amount > _deployedAmount
			CONDITION TMP_10027
		Expression: revert InsufficientBalance()()
		IRs:
			TMP_10028(None) = SOLIDITY_CALL revert InsufficientBalance()()
		Expression: IERC20(_asset).safeTransfer(msg.sender,amount)
		IRs:
			TMP_10029 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_10029', 'msg.sender', 'amount'] 
		Expression: _deployedAmount -= amount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- amount
		Expression: StrategyUndeploy(msg.sender,amount)
		IRs:
			Emit StrategyUndeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: amount
		IRs:
			RETURN amount
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategyPark.totalAssets() (*)
		Expression: IERC20(_asset).balanceOf(address(this))
		IRs:
			TMP_10035 = CONVERT _asset to IERC20
			TMP_10036 = CONVERT this to address
			TMP_10037(uint256) = HIGH_LEVEL_CALL, dest:TMP_10035(IERC20), function:balanceOf, arguments:['TMP_10036']  
			RETURN TMP_10037
	Function StrategyPark.asset() (*)
		Expression: _asset
		IRs:
			RETURN _asset
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategySettings
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_10044 = CONVERT 0 to address
			TMP_10045(bool) = _newGovernor == TMP_10044
			CONDITION TMP_10045
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_10046(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10052(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_10052)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10055(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_10056(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_10057(bool) = TMP_10055 == TMP_10056
			TMP_10058(None) = SOLIDITY_CALL require(bool,string)(TMP_10057,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10059 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_10059)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10062 = CONVERT 0 to address
			TMP_10063(bool) = newOwner != TMP_10062
			TMP_10064(None) = SOLIDITY_CALL require(bool,string)(TMP_10063,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_10070 = UnaryType.BANG _initializing 
			TMP_10071(None) = SOLIDITY_CALL require(bool,string)(TMP_10070,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_10073(uint8) := 255(uint8)
			TMP_10074(bool) = _initialized != TMP_10073
			CONDITION TMP_10074
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_10076(uint8) := 255(uint8)
			_initialized(uint8) := TMP_10076(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_10078(uint8) := 255(uint8)
			Emit Initialized(TMP_10078)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function StrategySettings.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_10087(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_10087
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_10088(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_10088
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_10089(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_10093(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_10093
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_10094(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_10095(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_10095(uint256)
	Function StrategySettings.slitherConstructorConstantVariables() (*)
		Expression: PRICE_MAX_AGE_SLOT = keccak256(bytes)(bakerfi.strategy.price.max.age)
		IRs:
			TMP_10096(bytes32) = SOLIDITY_CALL keccak256(bytes)(bakerfi.strategy.price.max.age)
			PRICE_MAX_AGE_SLOT(bytes32) := TMP_10096(bytes32)
		Expression: PRICE_MAX_CONF_SLOT = keccak256(bytes)(bakerfi.strategy.price.max.conf)
		IRs:
			TMP_10097(bytes32) = SOLIDITY_CALL keccak256(bytes)(bakerfi.strategy.price.max.conf)
			PRICE_MAX_CONF_SLOT(bytes32) := TMP_10097(bytes32)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_10098(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_10099(bool) = msg.sender != TMP_10098
			CONDITION TMP_10099
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_10100(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_10102 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_10102(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_10103(bool) = _initialized < 1
			TMP_10104(bool) = isTopLevelCall && TMP_10103
			TMP_10105 = CONVERT this to address
			TMP_10106(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_10105'] 
			TMP_10107 = UnaryType.BANG TMP_10106 
			TMP_10108(bool) = _initialized == 1
			TMP_10109(bool) = TMP_10107 && TMP_10108
			TMP_10110(bool) = TMP_10104 || TMP_10109
			TMP_10111(None) = SOLIDITY_CALL require(bool,string)(TMP_10110,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_10113 = UnaryType.BANG _initializing 
			TMP_10114(bool) = _initialized < version
			TMP_10115(bool) = TMP_10113 && TMP_10114
			TMP_10116(None) = SOLIDITY_CALL require(bool,string)(TMP_10115,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_10118(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract StrategySupplyAAVEv3
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10119(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10119)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10121(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_10122(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_10123(bool) = TMP_10121 == TMP_10122
			TMP_10124(None) = SOLIDITY_CALL require(bool,string)(TMP_10123,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10125 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10125)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10128 = CONVERT 0 to address
			TMP_10129(bool) = newOwner != TMP_10128
			TMP_10130(None) = SOLIDITY_CALL require(bool,string)(TMP_10129,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_10134(bool) = _status != _ENTERED
			TMP_10135(None) = SOLIDITY_CALL require(bool,string)(TMP_10134,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_10136(bool) = _status == _ENTERED
			RETURN TMP_10136
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategySupplyAAVEv3.constructor(address,address,address) (*)
		Expression: initialOwner == address(0) || asset_ == address(0) || aavev3Address == address(0)
		IRs:
			TMP_10137 = CONVERT 0 to address
			TMP_10138(bool) = initialOwner == TMP_10137
			TMP_10139 = CONVERT 0 to address
			TMP_10140(bool) = asset_ == TMP_10139
			TMP_10141(bool) = TMP_10138 || TMP_10140
			TMP_10142 = CONVERT 0 to address
			TMP_10143(bool) = aavev3Address == TMP_10142
			TMP_10144(bool) = TMP_10141 || TMP_10143
			CONDITION TMP_10144
		Expression: revert ZeroAddress()()
		IRs:
			TMP_10145(None) = SOLIDITY_CALL revert ZeroAddress()()
		Expression: _asset = asset_
		IRs:
			_asset(address) := asset_(address)
		Expression: _aavev3 = IPoolV3(aavev3Address)
		IRs:
			TMP_10146 = CONVERT aavev3Address to IPoolV3
			_aavev3(IPoolV3) := TMP_10146(IPoolV3)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(initialOwner)
		Expression: ! ERC20(_asset).approve(aavev3Address,type()(uint256).max)
		IRs:
			TMP_10148 = CONVERT _asset to ERC20
			TMP_10150(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_10151(bool) = HIGH_LEVEL_CALL, dest:TMP_10148(ERC20), function:approve, arguments:['aavev3Address', 'TMP_10150']  
			TMP_10152 = UnaryType.BANG TMP_10151 
			CONDITION TMP_10152
		Expression: revert FailedToApproveAllowanceForAAVE()()
		IRs:
			TMP_10153(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForAAVE()()
		Expression: ReentrancyGuard()
		IRs:
			INTERNAL_CALL, ReentrancyGuard.constructor()()
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySupplyAAVEv3.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10156(bool) = amount == 0
			CONDITION TMP_10156
		Expression: revert ZeroAmount()()
		IRs:
			TMP_10157(None) = SOLIDITY_CALL revert ZeroAmount()()
		Expression: ERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10158 = CONVERT _asset to ERC20
			TMP_10159 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_10158', 'msg.sender', 'TMP_10159', 'amount'] 
		Expression: _aavev3.supply(_asset,amount,address(this),0)
		IRs:
			TMP_10161 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:_aavev3(IPoolV3), function:supply, arguments:['_asset', 'amount', 'TMP_10161', '0']  
		Expression: _deployedAmount += amount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amount
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: _deployedAmount
		IRs:
			RETURN _deployedAmount
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySupplyAAVEv3.harvest() (*)
		Expression: newBalance = getBalance()
		IRs:
			TMP_10167(uint256) = INTERNAL_CALL, StrategySupplyAAVEv3.getBalance()()
			newBalance(uint256) := TMP_10167(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_10168 = CONVERT newBalance to int256
			TMP_10169 = CONVERT _deployedAmount to int256
			TMP_10170(int256) = TMP_10168 (c)- TMP_10169
			balanceChange(int256) := TMP_10170(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_10171(bool) = balanceChange > 0
			CONDITION TMP_10171
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_10172 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_10172)
		Expression: balanceChange < 0
		IRs:
			TMP_10174(bool) = balanceChange < 0
			CONDITION TMP_10174
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_10175(int256) = 0 (c)- balanceChange
			TMP_10176 = CONVERT TMP_10175 to uint256
			Emit StrategyLoss(TMP_10176)
		Expression: balanceChange != 0
		IRs:
			TMP_10178(bool) = balanceChange != 0
			CONDITION TMP_10178
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
	Function StrategySupplyAAVEv3.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10180(bool) = amount == 0
			CONDITION TMP_10180
		Expression: revert ZeroAmount()()
		IRs:
			TMP_10181(None) = SOLIDITY_CALL revert ZeroAmount()()
		Expression: balance = getBalance()
		IRs:
			TMP_10182(uint256) = INTERNAL_CALL, StrategySupplyAAVEv3.getBalance()()
			balance(uint256) := TMP_10182(uint256)
		Expression: amount > balance
		IRs:
			TMP_10183(bool) = amount > balance
			CONDITION TMP_10183
		Expression: revert InsufficientBalance()()
		IRs:
			TMP_10184(None) = SOLIDITY_CALL revert InsufficientBalance()()
		Expression: withdrawalValue = _aavev3.withdraw(_asset,amount,address(this))
		IRs:
			TMP_10185 = CONVERT this to address
			TMP_10186(uint256) = HIGH_LEVEL_CALL, dest:_aavev3(IPoolV3), function:withdraw, arguments:['_asset', 'amount', 'TMP_10185']  
			withdrawalValue(uint256) := TMP_10186(uint256)
		Expression: withdrawalValue != amount
		IRs:
			TMP_10187(bool) = withdrawalValue != amount
			CONDITION TMP_10187
		Expression: revert WithdrawalValueMismatch()()
		IRs:
			TMP_10188(None) = SOLIDITY_CALL revert WithdrawalValueMismatch()()
		Expression: ERC20(_asset).safeTransfer(msg.sender,amount)
		IRs:
			TMP_10189 = CONVERT _asset to ERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_10189', 'msg.sender', 'amount'] 
		Expression: balance -= amount
		IRs:
			balance(uint256) = balance (c)- amount
		Expression: StrategyUndeploy(msg.sender,amount)
		IRs:
			Emit StrategyUndeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(balance)
		IRs:
			Emit StrategyAmountUpdate(balance)
		Expression: amount
		IRs:
			RETURN amount
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySupplyAAVEv3.totalAssets() (*)
		Expression: getBalance()
		IRs:
			TMP_10195(uint256) = INTERNAL_CALL, StrategySupplyAAVEv3.getBalance()()
			RETURN TMP_10195
	Function StrategySupplyAAVEv3.asset() (*)
		Expression: _asset
		IRs:
			RETURN _asset
	Function StrategySupplyAAVEv3.getBalance() (*)
		Expression: reserve = (_aavev3.getReserveData(_asset))
		IRs:
			TMP_10196(DataTypes.ReserveData) = HIGH_LEVEL_CALL, dest:_aavev3(IPoolV3), function:getReserveData, arguments:['_asset']  
			reserve(DataTypes.ReserveData) := TMP_10196(DataTypes.ReserveData)
		Expression: reserveDecimals = ERC20(reserve.aTokenAddress).decimals()
		IRs:
			REF_2877(address) -> reserve.aTokenAddress
			TMP_10197 = CONVERT REF_2877 to ERC20
			TMP_10198(uint8) = HIGH_LEVEL_CALL, dest:TMP_10197(ERC20), function:decimals, arguments:[]  
			reserveDecimals(uint8) := TMP_10198(uint8)
		Expression: reserveBalance = ERC20(reserve.aTokenAddress).balanceOf(address(this))
		IRs:
			REF_2879(address) -> reserve.aTokenAddress
			TMP_10199 = CONVERT REF_2879 to ERC20
			TMP_10200 = CONVERT this to address
			TMP_10201(uint256) = HIGH_LEVEL_CALL, dest:TMP_10199(ERC20), function:balanceOf, arguments:['TMP_10200']  
			reserveBalance(uint256) := TMP_10201(uint256)
		Expression: reserveBalance = reserveBalance.toDecimals(reserveDecimals,SYSTEM_DECIMALS)
		IRs:
			TMP_10202(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['reserveBalance', 'reserveDecimals', 'SYSTEM_DECIMALS'] 
			reserveBalance(uint256) := TMP_10202(uint256)
		Expression: reserveBalance
		IRs:
			RETURN reserveBalance
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategySwapAnd
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10206(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10206)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10208(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_10209(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_10210(bool) = TMP_10208 == TMP_10209
			TMP_10211(None) = SOLIDITY_CALL require(bool,string)(TMP_10210,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10212 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10212)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10215 = CONVERT 0 to address
			TMP_10216(bool) = newOwner != TMP_10215
			TMP_10217(None) = SOLIDITY_CALL require(bool,string)(TMP_10216,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_10221(bool) = _status != _ENTERED
			TMP_10222(None) = SOLIDITY_CALL require(bool,string)(TMP_10221,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_10223(bool) = _status == _ENTERED
			RETURN TMP_10223
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle) (*)
		Expression: address(iAsset) == address(0) || address(iUnderlyingStrategy.asset()) == address(0) || address(iOracle) == address(0)
		IRs:
			TMP_10224 = CONVERT iAsset to address
			TMP_10225 = CONVERT 0 to address
			TMP_10226(bool) = TMP_10224 == TMP_10225
			TMP_10227(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10228 = CONVERT TMP_10227 to address
			TMP_10229 = CONVERT 0 to address
			TMP_10230(bool) = TMP_10228 == TMP_10229
			TMP_10231(bool) = TMP_10226 || TMP_10230
			TMP_10232 = CONVERT iOracle to address
			TMP_10233 = CONVERT 0 to address
			TMP_10234(bool) = TMP_10232 == TMP_10233
			TMP_10235(bool) = TMP_10231 || TMP_10234
			CONDITION TMP_10235
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_10236(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _asset = iAsset
		IRs:
			_asset(IERC20) := iAsset(IERC20)
		Expression: _oracle = iOracle
		IRs:
			_oracle(IOracle) := iOracle(IOracle)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ! IERC20(iUnderlyingStrategy.asset()).approve(address(iUnderlyingStrategy),2 ** 256 - 1)
		IRs:
			TMP_10238(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10239 = CONVERT TMP_10238 to IERC20
			TMP_10240 = CONVERT iUnderlyingStrategy to address
			TMP_10241(uint256) = 2 (c)** 256
			TMP_10242(uint256) = TMP_10241 (c)- 1
			TMP_10243(bool) = HIGH_LEVEL_CALL, dest:TMP_10239(IERC20), function:approve, arguments:['TMP_10240', 'TMP_10242']  
			TMP_10244 = UnaryType.BANG TMP_10243 
			CONDITION TMP_10244
		Expression: revert FailedToApproveAllowanceFor()()
		IRs:
			TMP_10245(None) = SOLIDITY_CALL revert FailedToApproveAllowanceFor()()
		Expression: _underlyingStrategy = iUnderlyingStrategy
		IRs:
			_underlyingStrategy(IStrategy) := iUnderlyingStrategy(IStrategy)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySwapAnd.underlyingAsset() (*)
		Expression: _underlyingStrategy.asset()
		IRs:
			TMP_10247(address) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:asset, arguments:[]  
			RETURN TMP_10247
	Function StrategySwapAnd.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10248(bool) = amount == 0
			CONDITION TMP_10248
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10249(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:0})
		IRs:
			TMP_10250(IOracle.PriceOptions) = new PriceOptions(3600,0)
			options(IOracle.PriceOptions) := TMP_10250(IOracle.PriceOptions)
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10251 = CONVERT _asset to IERC20
			TMP_10252 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_10251', 'msg.sender', 'TMP_10252', 'amount'] 
		Expression: calculatedAmountOut = _convertToUnderlying(options,amount)
		IRs:
			TMP_10254(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			calculatedAmountOut(uint256) := TMP_10254(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10255(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10256(uint256) = calculatedAmountOut (c)* TMP_10255
			TMP_10257(uint256) = TMP_10256 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10257(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(_asset),underlyingOut:address(underlyingAsset()),amountIn:amount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10258 = CONVERT _asset to address
			TMP_10259(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10260 = CONVERT TMP_10259 to address
			REF_2889(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10261(ISwapHandler.SwapParams) = new SwapParams(TMP_10258,TMP_10260,REF_2889,amount,minAmountOut,)
			TUPLE_142(uint256,uint256) = INTERNAL_CALL, StrategySwapAnd._swap(ISwapHandler.SwapParams)(TMP_10261)
			amountOut(uint256)= UNPACK TUPLE_142 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10262(bool) = amountOut < minAmountOut
			CONDITION TMP_10262
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10263(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _underlyingStrategy.deploy(amountOut)
		IRs:
			TMP_10264(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:deploy, arguments:['amountOut']  
		Expression: _deployedAmount += amountOut
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amountOut
		Expression: amountUsed = _convertFromUnderlying(options,amountOut)
		IRs:
			TMP_10265(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,amountOut)
			amountUsed(uint256) := TMP_10265(uint256)
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10269(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10269(IOracle.Price)
		Expression: amountOut_ = (amount * _oracle.getPrecision()) / price.price
		IRs:
			TMP_10270(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10271(uint256) = amount (c)* TMP_10270
			REF_2893(uint256) -> price.price
			TMP_10272(uint256) = TMP_10271 (c)/ REF_2893
			amountOut_(uint256) := TMP_10272(uint256)
	Function StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10273(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10273(IOracle.Price)
		Expression: amountOut_ = (amount * price.price) / _oracle.getPrecision()
		IRs:
			REF_2895(uint256) -> price.price
			TMP_10274(uint256) = amount (c)* REF_2895
			TMP_10275(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10276(uint256) = TMP_10274 (c)/ TMP_10275
			amountOut_(uint256) := TMP_10276(uint256)
	Function StrategySwapAnd._swap(ISwapHandler.SwapParams) (*)
	Function StrategySwapAnd.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10277(bool) = amount == 0
			CONDITION TMP_10277
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10278(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_10279(bool) = amount > _deployedAmount
			CONDITION TMP_10279
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10280(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:100})
		IRs:
			TMP_10281(IOracle.PriceOptions) = new PriceOptions(3600,100)
			options(IOracle.PriceOptions) := TMP_10281(IOracle.PriceOptions)
		Expression: undeployedAmount = _underlyingStrategy.undeploy(_convertToUnderlying(options,amount))
		IRs:
			TMP_10282(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			TMP_10283(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:undeploy, arguments:['TMP_10282']  
			undeployedAmount(uint256) := TMP_10283(uint256)
		Expression: calculatedAmountOut = _convertFromUnderlying(options,undeployedAmount)
		IRs:
			TMP_10284(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,undeployedAmount)
			calculatedAmountOut(uint256) := TMP_10284(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10285(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10286(uint256) = calculatedAmountOut (c)* TMP_10285
			TMP_10287(uint256) = TMP_10286 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10287(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(underlyingAsset()),underlyingOut:address(_asset),amountIn:undeployedAmount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10288(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10289 = CONVERT TMP_10288 to address
			TMP_10290 = CONVERT _asset to address
			REF_2900(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10291(ISwapHandler.SwapParams) = new SwapParams(TMP_10289,TMP_10290,REF_2900,undeployedAmount,minAmountOut,)
			TUPLE_143(uint256,uint256) = INTERNAL_CALL, StrategySwapAnd._swap(ISwapHandler.SwapParams)(TMP_10291)
			amountOut(uint256)= UNPACK TUPLE_143 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10292(bool) = amountOut < minAmountOut
			CONDITION TMP_10292
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10293(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _deployedAmount -= undeployedAmount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- undeployedAmount
		Expression: undeployedAmount_ = amountOut
		IRs:
			undeployedAmount_(uint256) := amountOut(uint256)
		Expression: IERC20(_asset).safeTransfer(msg.sender,amountOut)
		IRs:
			TMP_10294 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_10294', 'msg.sender', 'amountOut'] 
		Expression: StrategyUndeploy(msg.sender,amountOut)
		IRs:
			Emit StrategyUndeploy(msg.sender,amountOut)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.harvest() (*)
		Expression: newBalance = _totalAssets()
		IRs:
			TMP_10299(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			newBalance(uint256) := TMP_10299(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_10300 = CONVERT newBalance to int256
			TMP_10301 = CONVERT _deployedAmount to int256
			TMP_10302(int256) = TMP_10300 (c)- TMP_10301
			balanceChange(int256) := TMP_10302(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_10303(bool) = balanceChange > 0
			CONDITION TMP_10303
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_10304 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_10304)
		Expression: balanceChange < 0
		IRs:
			TMP_10306(bool) = balanceChange < 0
			CONDITION TMP_10306
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_10307(int256) = 0 (c)- balanceChange
			TMP_10308 = CONVERT TMP_10307 to uint256
			Emit StrategyLoss(TMP_10308)
		Expression: balanceChange != 0
		IRs:
			TMP_10310(bool) = balanceChange != 0
			CONDITION TMP_10310
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.totalAssets() (*)
		Expression: _totalAssets()
		IRs:
			TMP_10313(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			RETURN TMP_10313
	Function StrategySwapAnd._totalAssets() (*)
		Expression: underlyingAssets = _underlyingStrategy.totalAssets()
		IRs:
			TMP_10314(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:totalAssets, arguments:[]  
			underlyingAssets(uint256) := TMP_10314(uint256)
		Expression: amount_ = _convertFromUnderlying(IOracle.PriceOptions({maxAge:0,maxConf:0}),underlyingAssets)
		IRs:
			TMP_10315(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_10316(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(TMP_10315,underlyingAssets)
			amount_(uint256) := TMP_10316(uint256)
		Expression: amount_
		IRs:
			RETURN amount_
	Function StrategySwapAnd.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_10317 = CONVERT _asset to address
			RETURN TMP_10317
	Function StrategySwapAnd.setMaxSlippage(uint256) (*)
		Expression: _maxSlippage = maxSlippage_
		IRs:
			_maxSlippage(uint256) := maxSlippage_(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySwapAnd.maxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategySwapAnd.oracle() (*)
		Expression: address(_oracle)
		IRs:
			TMP_10319 = CONVERT _oracle to address
			RETURN TMP_10319
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategyUniV2SwapAnd
	Function UseUniV2Swapper._initUseUniV2Swapper(IUniswapV2Router02) (*)
		Expression: address(iV2UniRouter) == address(0)
		IRs:
			TMP_10323 = CONVERT iV2UniRouter to address
			TMP_10324 = CONVERT 0 to address
			TMP_10325(bool) = TMP_10323 == TMP_10324
			CONDITION TMP_10325
		Expression: revert InvalidV2RouterContract()()
		IRs:
			TMP_10326(None) = SOLIDITY_CALL revert InvalidV2RouterContract()()
		Expression: sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
		IRs:
			TMP_10327(None) = SOLIDITY_CALL sstore(uint256,uint256)(_V2_UNI_ROUTER_SLOT,iV2UniRouter)
	Function UseUniV2Swapper.v2UniRouter() (*)
		Expression: router = sload(uint256)(_V2_UNI_ROUTER_SLOT)
		IRs:
			TMP_10328(uint256) = SOLIDITY_CALL sload(uint256)(_V2_UNI_ROUTER_SLOT)
			router(address) := TMP_10328(uint256)
		Expression: IUniswapV2Router02(router)
		IRs:
			TMP_10329 = CONVERT router to IUniswapV2Router02
			RETURN TMP_10329
	Function UseUniV2Swapper.swap(ISwapHandler.SwapParams) (*)
		Expression: UniV2Library.swapUniV2(v2UniRouter(),params)
		IRs:
			TMP_10330(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TUPLE_144(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_10330', 'params'] 
			RETURN TUPLE_144
	Function UseUniV2Swapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(v2UniRouter()),amount)
		IRs:
			TMP_10331(IUniswapV2Router02) = INTERNAL_CALL, UseUniV2Swapper.v2UniRouter()()
			TMP_10332 = CONVERT TMP_10331 to address
			TMP_10333(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_10332', 'amount']  
			TMP_10334 = UnaryType.BANG TMP_10333 
			CONDITION TMP_10334
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_10335(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle) (*)
		Expression: address(iAsset) == address(0) || address(iUnderlyingStrategy.asset()) == address(0) || address(iOracle) == address(0)
		IRs:
			TMP_10336 = CONVERT iAsset to address
			TMP_10337 = CONVERT 0 to address
			TMP_10338(bool) = TMP_10336 == TMP_10337
			TMP_10339(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10340 = CONVERT TMP_10339 to address
			TMP_10341 = CONVERT 0 to address
			TMP_10342(bool) = TMP_10340 == TMP_10341
			TMP_10343(bool) = TMP_10338 || TMP_10342
			TMP_10344 = CONVERT iOracle to address
			TMP_10345 = CONVERT 0 to address
			TMP_10346(bool) = TMP_10344 == TMP_10345
			TMP_10347(bool) = TMP_10343 || TMP_10346
			CONDITION TMP_10347
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_10348(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _asset = iAsset
		IRs:
			_asset(IERC20) := iAsset(IERC20)
		Expression: _oracle = iOracle
		IRs:
			_oracle(IOracle) := iOracle(IOracle)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ! IERC20(iUnderlyingStrategy.asset()).approve(address(iUnderlyingStrategy),2 ** 256 - 1)
		IRs:
			TMP_10350(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10351 = CONVERT TMP_10350 to IERC20
			TMP_10352 = CONVERT iUnderlyingStrategy to address
			TMP_10353(uint256) = 2 (c)** 256
			TMP_10354(uint256) = TMP_10353 (c)- 1
			TMP_10355(bool) = HIGH_LEVEL_CALL, dest:TMP_10351(IERC20), function:approve, arguments:['TMP_10352', 'TMP_10354']  
			TMP_10356 = UnaryType.BANG TMP_10355 
			CONDITION TMP_10356
		Expression: revert FailedToApproveAllowanceFor()()
		IRs:
			TMP_10357(None) = SOLIDITY_CALL revert FailedToApproveAllowanceFor()()
		Expression: _underlyingStrategy = iUnderlyingStrategy
		IRs:
			_underlyingStrategy(IStrategy) := iUnderlyingStrategy(IStrategy)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySwapAnd.underlyingAsset() (*)
		Expression: _underlyingStrategy.asset()
		IRs:
			TMP_10359(address) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:asset, arguments:[]  
			RETURN TMP_10359
	Function StrategySwapAnd.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10360(bool) = amount == 0
			CONDITION TMP_10360
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10361(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:0})
		IRs:
			TMP_10362(IOracle.PriceOptions) = new PriceOptions(3600,0)
			options(IOracle.PriceOptions) := TMP_10362(IOracle.PriceOptions)
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10363 = CONVERT _asset to IERC20
			TMP_10364 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_10363', 'msg.sender', 'TMP_10364', 'amount'] 
		Expression: calculatedAmountOut = _convertToUnderlying(options,amount)
		IRs:
			TMP_10366(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			calculatedAmountOut(uint256) := TMP_10366(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10367(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10368(uint256) = calculatedAmountOut (c)* TMP_10367
			TMP_10369(uint256) = TMP_10368 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10369(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(_asset),underlyingOut:address(underlyingAsset()),amountIn:amount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10370 = CONVERT _asset to address
			TMP_10371(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10372 = CONVERT TMP_10371 to address
			REF_2913(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10373(ISwapHandler.SwapParams) = new SwapParams(TMP_10370,TMP_10372,REF_2913,amount,minAmountOut,)
			TUPLE_145(uint256,uint256) = INTERNAL_CALL, StrategyUniV2SwapAnd._swap(ISwapHandler.SwapParams)(TMP_10373)
			amountOut(uint256)= UNPACK TUPLE_145 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10374(bool) = amountOut < minAmountOut
			CONDITION TMP_10374
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10375(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _underlyingStrategy.deploy(amountOut)
		IRs:
			TMP_10376(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:deploy, arguments:['amountOut']  
		Expression: _deployedAmount += amountOut
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amountOut
		Expression: amountUsed = _convertFromUnderlying(options,amountOut)
		IRs:
			TMP_10377(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,amountOut)
			amountUsed(uint256) := TMP_10377(uint256)
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10381(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10381(IOracle.Price)
		Expression: amountOut_ = (amount * _oracle.getPrecision()) / price.price
		IRs:
			TMP_10382(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10383(uint256) = amount (c)* TMP_10382
			REF_2917(uint256) -> price.price
			TMP_10384(uint256) = TMP_10383 (c)/ REF_2917
			amountOut_(uint256) := TMP_10384(uint256)
	Function StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10385(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10385(IOracle.Price)
		Expression: amountOut_ = (amount * price.price) / _oracle.getPrecision()
		IRs:
			REF_2919(uint256) -> price.price
			TMP_10386(uint256) = amount (c)* REF_2919
			TMP_10387(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10388(uint256) = TMP_10386 (c)/ TMP_10387
			amountOut_(uint256) := TMP_10388(uint256)
	Function StrategySwapAnd._swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10389(bool) = amount == 0
			CONDITION TMP_10389
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10390(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_10391(bool) = amount > _deployedAmount
			CONDITION TMP_10391
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10392(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:100})
		IRs:
			TMP_10393(IOracle.PriceOptions) = new PriceOptions(3600,100)
			options(IOracle.PriceOptions) := TMP_10393(IOracle.PriceOptions)
		Expression: undeployedAmount = _underlyingStrategy.undeploy(_convertToUnderlying(options,amount))
		IRs:
			TMP_10394(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			TMP_10395(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:undeploy, arguments:['TMP_10394']  
			undeployedAmount(uint256) := TMP_10395(uint256)
		Expression: calculatedAmountOut = _convertFromUnderlying(options,undeployedAmount)
		IRs:
			TMP_10396(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,undeployedAmount)
			calculatedAmountOut(uint256) := TMP_10396(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10397(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10398(uint256) = calculatedAmountOut (c)* TMP_10397
			TMP_10399(uint256) = TMP_10398 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10399(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(underlyingAsset()),underlyingOut:address(_asset),amountIn:undeployedAmount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10400(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10401 = CONVERT TMP_10400 to address
			TMP_10402 = CONVERT _asset to address
			REF_2924(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10403(ISwapHandler.SwapParams) = new SwapParams(TMP_10401,TMP_10402,REF_2924,undeployedAmount,minAmountOut,)
			TUPLE_146(uint256,uint256) = INTERNAL_CALL, StrategyUniV2SwapAnd._swap(ISwapHandler.SwapParams)(TMP_10403)
			amountOut(uint256)= UNPACK TUPLE_146 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10404(bool) = amountOut < minAmountOut
			CONDITION TMP_10404
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10405(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _deployedAmount -= undeployedAmount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- undeployedAmount
		Expression: undeployedAmount_ = amountOut
		IRs:
			undeployedAmount_(uint256) := amountOut(uint256)
		Expression: IERC20(_asset).safeTransfer(msg.sender,amountOut)
		IRs:
			TMP_10406 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_10406', 'msg.sender', 'amountOut'] 
		Expression: StrategyUndeploy(msg.sender,amountOut)
		IRs:
			Emit StrategyUndeploy(msg.sender,amountOut)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.harvest() (*)
		Expression: newBalance = _totalAssets()
		IRs:
			TMP_10411(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			newBalance(uint256) := TMP_10411(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_10412 = CONVERT newBalance to int256
			TMP_10413 = CONVERT _deployedAmount to int256
			TMP_10414(int256) = TMP_10412 (c)- TMP_10413
			balanceChange(int256) := TMP_10414(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_10415(bool) = balanceChange > 0
			CONDITION TMP_10415
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_10416 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_10416)
		Expression: balanceChange < 0
		IRs:
			TMP_10418(bool) = balanceChange < 0
			CONDITION TMP_10418
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_10419(int256) = 0 (c)- balanceChange
			TMP_10420 = CONVERT TMP_10419 to uint256
			Emit StrategyLoss(TMP_10420)
		Expression: balanceChange != 0
		IRs:
			TMP_10422(bool) = balanceChange != 0
			CONDITION TMP_10422
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.totalAssets() (*)
		Expression: _totalAssets()
		IRs:
			TMP_10425(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			RETURN TMP_10425
	Function StrategySwapAnd._totalAssets() (*)
		Expression: underlyingAssets = _underlyingStrategy.totalAssets()
		IRs:
			TMP_10426(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:totalAssets, arguments:[]  
			underlyingAssets(uint256) := TMP_10426(uint256)
		Expression: amount_ = _convertFromUnderlying(IOracle.PriceOptions({maxAge:0,maxConf:0}),underlyingAssets)
		IRs:
			TMP_10427(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_10428(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(TMP_10427,underlyingAssets)
			amount_(uint256) := TMP_10428(uint256)
		Expression: amount_
		IRs:
			RETURN amount_
	Function StrategySwapAnd.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_10429 = CONVERT _asset to address
			RETURN TMP_10429
	Function StrategySwapAnd.setMaxSlippage(uint256) (*)
		Expression: _maxSlippage = maxSlippage_
		IRs:
			_maxSlippage(uint256) := maxSlippage_(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySwapAnd.maxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategySwapAnd.oracle() (*)
		Expression: address(_oracle)
		IRs:
			TMP_10431 = CONVERT _oracle to address
			RETURN TMP_10431
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10432(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10432)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10434(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_10435(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_10436(bool) = TMP_10434 == TMP_10435
			TMP_10437(None) = SOLIDITY_CALL require(bool,string)(TMP_10436,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10438 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10438)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10441 = CONVERT 0 to address
			TMP_10442(bool) = newOwner != TMP_10441
			TMP_10443(None) = SOLIDITY_CALL require(bool,string)(TMP_10442,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_10447(bool) = _status != _ENTERED
			TMP_10448(None) = SOLIDITY_CALL require(bool,string)(TMP_10447,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_10449(bool) = _status == _ENTERED
			RETURN TMP_10449
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyUniV2SwapAnd.constructor(address,IERC20,IStrategy,IOracle,IUniswapV2Router02) (*)
		Expression: _initUseUniV2Swapper(router)
		IRs:
			INTERNAL_CALL, UseUniV2Swapper._initUseUniV2Swapper(IUniswapV2Router02)(router)
		Expression: _allowRouterSpend(IERC20(iAsset),2 ** 256 - 1)
		IRs:
			TMP_10451 = CONVERT iAsset to IERC20
			TMP_10452(uint256) = 2 (c)** 256
			TMP_10453(uint256) = TMP_10452 (c)- 1
			INTERNAL_CALL, UseUniV2Swapper._allowRouterSpend(IERC20,uint256)(TMP_10451,TMP_10453)
		Expression: _allowRouterSpend(IERC20(iUnderlyingStrategy.asset()),2 ** 256 - 1)
		IRs:
			TMP_10455(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10456 = CONVERT TMP_10455 to IERC20
			TMP_10457(uint256) = 2 (c)** 256
			TMP_10458(uint256) = TMP_10457 (c)- 1
			INTERNAL_CALL, UseUniV2Swapper._allowRouterSpend(IERC20,uint256)(TMP_10456,TMP_10458)
		Expression: StrategySwapAnd(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
		IRs:
			INTERNAL_CALL, StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle)(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
	Function StrategyUniV2SwapAnd._swap(ISwapHandler.SwapParams) (*)
		Expression: UseUniV2Swapper.swap(params)
		IRs:
			TUPLE_147(uint256,uint256) = INTERNAL_CALL, UseUniV2Swapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_147
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract StrategyUniV3SwapAnd
	Function UseUniV3Swapper._initUseUniV3Swapper(IV3SwapRouter) (*)
		Expression: _uniRouter = luniRouter
		IRs:
			_uniRouter(IV3SwapRouter) := luniRouter(IV3SwapRouter)
		Expression: address(_uniRouter) == address(0)
		IRs:
			TMP_10464 = CONVERT _uniRouter to address
			TMP_10465 = CONVERT 0 to address
			TMP_10466(bool) = TMP_10464 == TMP_10465
			CONDITION TMP_10466
		Expression: revert InvalidUniRouterContract()()
		IRs:
			TMP_10467(None) = SOLIDITY_CALL revert InvalidUniRouterContract()()
	Function UseUniV3Swapper.uniRouter() (*)
		Expression: _uniRouter
		IRs:
			RETURN _uniRouter
	Function UseUniV3Swapper.uniRouterA() (*)
		Expression: address(_uniRouter)
		IRs:
			TMP_10468 = CONVERT _uniRouter to address
			RETURN TMP_10468
	Function UseUniV3Swapper._allowRouterSpend(IERC20,uint256) (*)
		Expression: ! token.approve(address(_uniRouter),amount)
		IRs:
			TMP_10469 = CONVERT _uniRouter to address
			TMP_10470(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:approve, arguments:['TMP_10469', 'amount']  
			TMP_10471 = UnaryType.BANG TMP_10470 
			CONDITION TMP_10471
		Expression: revert FailedToApproveAllowanceForRouter()()
		IRs:
			TMP_10472(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForRouter()()
	Function UseUniV3Swapper.swap(ISwapHandler.SwapParams) (*)
		Expression: UniV3Library.swapUniV3(uniRouter(),params)
		IRs:
			TMP_10473(IV3SwapRouter) = INTERNAL_CALL, UseUniV3Swapper.uniRouter()()
			TUPLE_148(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_10473', 'params'] 
			RETURN TUPLE_148
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle) (*)
		Expression: address(iAsset) == address(0) || address(iUnderlyingStrategy.asset()) == address(0) || address(iOracle) == address(0)
		IRs:
			TMP_10474 = CONVERT iAsset to address
			TMP_10475 = CONVERT 0 to address
			TMP_10476(bool) = TMP_10474 == TMP_10475
			TMP_10477(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10478 = CONVERT TMP_10477 to address
			TMP_10479 = CONVERT 0 to address
			TMP_10480(bool) = TMP_10478 == TMP_10479
			TMP_10481(bool) = TMP_10476 || TMP_10480
			TMP_10482 = CONVERT iOracle to address
			TMP_10483 = CONVERT 0 to address
			TMP_10484(bool) = TMP_10482 == TMP_10483
			TMP_10485(bool) = TMP_10481 || TMP_10484
			CONDITION TMP_10485
		Expression: revert InvalidConfiguration()()
		IRs:
			TMP_10486(None) = SOLIDITY_CALL revert InvalidConfiguration()()
		Expression: _asset = iAsset
		IRs:
			_asset(IERC20) := iAsset(IERC20)
		Expression: _oracle = iOracle
		IRs:
			_oracle(IOracle) := iOracle(IOracle)
		Expression: transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable.transferOwnership(address)(initialOwner)
		Expression: ! IERC20(iUnderlyingStrategy.asset()).approve(address(iUnderlyingStrategy),2 ** 256 - 1)
		IRs:
			TMP_10488(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10489 = CONVERT TMP_10488 to IERC20
			TMP_10490 = CONVERT iUnderlyingStrategy to address
			TMP_10491(uint256) = 2 (c)** 256
			TMP_10492(uint256) = TMP_10491 (c)- 1
			TMP_10493(bool) = HIGH_LEVEL_CALL, dest:TMP_10489(IERC20), function:approve, arguments:['TMP_10490', 'TMP_10492']  
			TMP_10494 = UnaryType.BANG TMP_10493 
			CONDITION TMP_10494
		Expression: revert FailedToApproveAllowanceFor()()
		IRs:
			TMP_10495(None) = SOLIDITY_CALL revert FailedToApproveAllowanceFor()()
		Expression: _underlyingStrategy = iUnderlyingStrategy
		IRs:
			_underlyingStrategy(IStrategy) := iUnderlyingStrategy(IStrategy)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function StrategySwapAnd.underlyingAsset() (*)
		Expression: _underlyingStrategy.asset()
		IRs:
			TMP_10497(address) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:asset, arguments:[]  
			RETURN TMP_10497
	Function StrategySwapAnd.deploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10498(bool) = amount == 0
			CONDITION TMP_10498
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10499(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:0})
		IRs:
			TMP_10500(IOracle.PriceOptions) = new PriceOptions(3600,0)
			options(IOracle.PriceOptions) := TMP_10500(IOracle.PriceOptions)
		Expression: IERC20(_asset).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10501 = CONVERT _asset to IERC20
			TMP_10502 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_10501', 'msg.sender', 'TMP_10502', 'amount'] 
		Expression: calculatedAmountOut = _convertToUnderlying(options,amount)
		IRs:
			TMP_10504(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			calculatedAmountOut(uint256) := TMP_10504(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10505(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10506(uint256) = calculatedAmountOut (c)* TMP_10505
			TMP_10507(uint256) = TMP_10506 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10507(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(_asset),underlyingOut:address(underlyingAsset()),amountIn:amount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10508 = CONVERT _asset to address
			TMP_10509(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10510 = CONVERT TMP_10509 to address
			REF_2939(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10511(ISwapHandler.SwapParams) = new SwapParams(TMP_10508,TMP_10510,REF_2939,amount,minAmountOut,)
			TUPLE_149(uint256,uint256) = INTERNAL_CALL, StrategyUniV3SwapAnd._swap(ISwapHandler.SwapParams)(TMP_10511)
			amountOut(uint256)= UNPACK TUPLE_149 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10512(bool) = amountOut < minAmountOut
			CONDITION TMP_10512
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10513(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _underlyingStrategy.deploy(amountOut)
		IRs:
			TMP_10514(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:deploy, arguments:['amountOut']  
		Expression: _deployedAmount += amountOut
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)+ amountOut
		Expression: amountUsed = _convertFromUnderlying(options,amountOut)
		IRs:
			TMP_10515(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,amountOut)
			amountUsed(uint256) := TMP_10515(uint256)
		Expression: StrategyDeploy(msg.sender,amount)
		IRs:
			Emit StrategyDeploy(msg.sender,amount)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10519(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10519(IOracle.Price)
		Expression: amountOut_ = (amount * _oracle.getPrecision()) / price.price
		IRs:
			TMP_10520(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10521(uint256) = amount (c)* TMP_10520
			REF_2943(uint256) -> price.price
			TMP_10522(uint256) = TMP_10521 (c)/ REF_2943
			amountOut_(uint256) := TMP_10522(uint256)
	Function StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256) (*)
		Expression: price = _oracle.getSafeLatestPrice(options)
		IRs:
			TMP_10523(IOracle.Price) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getSafeLatestPrice, arguments:['options']  
			price(IOracle.Price) := TMP_10523(IOracle.Price)
		Expression: amountOut_ = (amount * price.price) / _oracle.getPrecision()
		IRs:
			REF_2945(uint256) -> price.price
			TMP_10524(uint256) = amount (c)* REF_2945
			TMP_10525(uint256) = HIGH_LEVEL_CALL, dest:_oracle(IOracle), function:getPrecision, arguments:[]  
			TMP_10526(uint256) = TMP_10524 (c)/ TMP_10525
			amountOut_(uint256) := TMP_10526(uint256)
	Function StrategySwapAnd._swap(ISwapHandler.SwapParams) 
	Function StrategySwapAnd.undeploy(uint256) (*)
		Expression: amount == 0
		IRs:
			TMP_10527(bool) = amount == 0
			CONDITION TMP_10527
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10528(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: amount > _deployedAmount
		IRs:
			TMP_10529(bool) = amount > _deployedAmount
			CONDITION TMP_10529
		Expression: revert InvalidAmount()()
		IRs:
			TMP_10530(None) = SOLIDITY_CALL revert InvalidAmount()()
		Expression: options = IOracle.PriceOptions({maxAge:3600,maxConf:100})
		IRs:
			TMP_10531(IOracle.PriceOptions) = new PriceOptions(3600,100)
			options(IOracle.PriceOptions) := TMP_10531(IOracle.PriceOptions)
		Expression: undeployedAmount = _underlyingStrategy.undeploy(_convertToUnderlying(options,amount))
		IRs:
			TMP_10532(uint256) = INTERNAL_CALL, StrategySwapAnd._convertToUnderlying(IOracle.PriceOptions,uint256)(options,amount)
			TMP_10533(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:undeploy, arguments:['TMP_10532']  
			undeployedAmount(uint256) := TMP_10533(uint256)
		Expression: calculatedAmountOut = _convertFromUnderlying(options,undeployedAmount)
		IRs:
			TMP_10534(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(options,undeployedAmount)
			calculatedAmountOut(uint256) := TMP_10534(uint256)
		Expression: minAmountOut = (calculatedAmountOut * (PERCENTAGE_PRECISION - _maxSlippage)) / PERCENTAGE_PRECISION
		IRs:
			TMP_10535(uint256) = PERCENTAGE_PRECISION (c)- _maxSlippage
			TMP_10536(uint256) = calculatedAmountOut (c)* TMP_10535
			TMP_10537(uint256) = TMP_10536 (c)/ PERCENTAGE_PRECISION
			minAmountOut(uint256) := TMP_10537(uint256)
		Expression: (amountOut) = _swap(ISwapHandler.SwapParams({underlyingIn:address(underlyingAsset()),underlyingOut:address(_asset),amountIn:undeployedAmount,amountOut:minAmountOut,mode:ISwapHandler.SwapType.EXACT_INPUT,payload:}))
		IRs:
			TMP_10538(address) = INTERNAL_CALL, StrategySwapAnd.underlyingAsset()()
			TMP_10539 = CONVERT TMP_10538 to address
			TMP_10540 = CONVERT _asset to address
			REF_2950(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10541(ISwapHandler.SwapParams) = new SwapParams(TMP_10539,TMP_10540,REF_2950,undeployedAmount,minAmountOut,)
			TUPLE_150(uint256,uint256) = INTERNAL_CALL, StrategyUniV3SwapAnd._swap(ISwapHandler.SwapParams)(TMP_10541)
			amountOut(uint256)= UNPACK TUPLE_150 index: 1 
		Expression: amountOut < minAmountOut
		IRs:
			TMP_10542(bool) = amountOut < minAmountOut
			CONDITION TMP_10542
		Expression: revert SlippageExceeded()()
		IRs:
			TMP_10543(None) = SOLIDITY_CALL revert SlippageExceeded()()
		Expression: _deployedAmount -= undeployedAmount
		IRs:
			_deployedAmount(uint256) = _deployedAmount (c)- undeployedAmount
		Expression: undeployedAmount_ = amountOut
		IRs:
			undeployedAmount_(uint256) := amountOut(uint256)
		Expression: IERC20(_asset).safeTransfer(msg.sender,amountOut)
		IRs:
			TMP_10544 = CONVERT _asset to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_10544', 'msg.sender', 'amountOut'] 
		Expression: StrategyUndeploy(msg.sender,amountOut)
		IRs:
			Emit StrategyUndeploy(msg.sender,amountOut)
		Expression: StrategyAmountUpdate(_deployedAmount)
		IRs:
			Emit StrategyAmountUpdate(_deployedAmount)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.harvest() (*)
		Expression: newBalance = _totalAssets()
		IRs:
			TMP_10549(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			newBalance(uint256) := TMP_10549(uint256)
		Expression: balanceChange = int256(newBalance) - int256(_deployedAmount)
		IRs:
			TMP_10550 = CONVERT newBalance to int256
			TMP_10551 = CONVERT _deployedAmount to int256
			TMP_10552(int256) = TMP_10550 (c)- TMP_10551
			balanceChange(int256) := TMP_10552(int256)
		Expression: balanceChange > 0
		IRs:
			TMP_10553(bool) = balanceChange > 0
			CONDITION TMP_10553
		Expression: StrategyProfit(uint256(balanceChange))
		IRs:
			TMP_10554 = CONVERT balanceChange to uint256
			Emit StrategyProfit(TMP_10554)
		Expression: balanceChange < 0
		IRs:
			TMP_10556(bool) = balanceChange < 0
			CONDITION TMP_10556
		Expression: StrategyLoss(uint256(- balanceChange))
		IRs:
			TMP_10557(int256) = 0 (c)- balanceChange
			TMP_10558 = CONVERT TMP_10557 to uint256
			Emit StrategyLoss(TMP_10558)
		Expression: balanceChange != 0
		IRs:
			TMP_10560(bool) = balanceChange != 0
			CONDITION TMP_10560
		Expression: StrategyAmountUpdate(newBalance)
		IRs:
			Emit StrategyAmountUpdate(newBalance)
		Expression: _deployedAmount = newBalance
		IRs:
			_deployedAmount(uint256) := newBalance(uint256)
		Expression: nonReentrant()
		IRs:
			MODIFIER_CALL, ReentrancyGuard.nonReentrant()()
	Function StrategySwapAnd.totalAssets() (*)
		Expression: _totalAssets()
		IRs:
			TMP_10563(uint256) = INTERNAL_CALL, StrategySwapAnd._totalAssets()()
			RETURN TMP_10563
	Function StrategySwapAnd._totalAssets() (*)
		Expression: underlyingAssets = _underlyingStrategy.totalAssets()
		IRs:
			TMP_10564(uint256) = HIGH_LEVEL_CALL, dest:_underlyingStrategy(IStrategy), function:totalAssets, arguments:[]  
			underlyingAssets(uint256) := TMP_10564(uint256)
		Expression: amount_ = _convertFromUnderlying(IOracle.PriceOptions({maxAge:0,maxConf:0}),underlyingAssets)
		IRs:
			TMP_10565(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_10566(uint256) = INTERNAL_CALL, StrategySwapAnd._convertFromUnderlying(IOracle.PriceOptions,uint256)(TMP_10565,underlyingAssets)
			amount_(uint256) := TMP_10566(uint256)
		Expression: amount_
		IRs:
			RETURN amount_
	Function StrategySwapAnd.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_10567 = CONVERT _asset to address
			RETURN TMP_10567
	Function StrategySwapAnd.setMaxSlippage(uint256) (*)
		Expression: _maxSlippage = maxSlippage_
		IRs:
			_maxSlippage(uint256) := maxSlippage_(uint256)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function StrategySwapAnd.maxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategySwapAnd.oracle() (*)
		Expression: address(_oracle)
		IRs:
			TMP_10569 = CONVERT _oracle to address
			RETURN TMP_10569
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10570(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10570)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10572(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_10573(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_10574(bool) = TMP_10572 == TMP_10573
			TMP_10575(None) = SOLIDITY_CALL require(bool,string)(TMP_10574,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10576 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10576)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10579 = CONVERT 0 to address
			TMP_10580(bool) = newOwner != TMP_10579
			TMP_10581(None) = SOLIDITY_CALL require(bool,string)(TMP_10580,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ReentrancyGuard.constructor() 
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantBefore() (*)
		Expression: require(bool,string)(_status != _ENTERED,ReentrancyGuard: reentrant call)
		IRs:
			TMP_10585(bool) = _status != _ENTERED
			TMP_10586(None) = SOLIDITY_CALL require(bool,string)(TMP_10585,ReentrancyGuard: reentrant call)
		Expression: _status = _ENTERED
		IRs:
			_status(uint256) := _ENTERED(uint256)
	Function ReentrancyGuard._nonReentrantAfter() (*)
		Expression: _status = _NOT_ENTERED
		IRs:
			_status(uint256) := _NOT_ENTERED(uint256)
	Function ReentrancyGuard._reentrancyGuardEntered() (*)
		Expression: _status == _ENTERED
		IRs:
			TMP_10587(bool) = _status == _ENTERED
			RETURN TMP_10587
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyUniV3SwapAnd.constructor(address,IERC20,IStrategy,IOracle,IV3SwapRouter,uint24) (*)
		Expression: ifeeTier == 0
		IRs:
			TMP_10588(bool) = ifeeTier == 0
			CONDITION TMP_10588
		Expression: revert InvalidFeeTier()()
		IRs:
			TMP_10589(None) = SOLIDITY_CALL revert InvalidFeeTier()()
		Expression: _feeTier = ifeeTier
		IRs:
			_feeTier(uint24) := ifeeTier(uint24)
		Expression: _initUseUniV3Swapper(router)
		IRs:
			INTERNAL_CALL, UseUniV3Swapper._initUseUniV3Swapper(IV3SwapRouter)(router)
		Expression: _allowRouterSpend(IERC20(iAsset),2 ** 256 - 1)
		IRs:
			TMP_10591 = CONVERT iAsset to IERC20
			TMP_10592(uint256) = 2 (c)** 256
			TMP_10593(uint256) = TMP_10592 (c)- 1
			INTERNAL_CALL, UseUniV3Swapper._allowRouterSpend(IERC20,uint256)(TMP_10591,TMP_10593)
		Expression: _allowRouterSpend(IERC20(iUnderlyingStrategy.asset()),2 ** 256 - 1)
		IRs:
			TMP_10595(address) = HIGH_LEVEL_CALL, dest:iUnderlyingStrategy(IStrategy), function:asset, arguments:[]  
			TMP_10596 = CONVERT TMP_10595 to IERC20
			TMP_10597(uint256) = 2 (c)** 256
			TMP_10598(uint256) = TMP_10597 (c)- 1
			INTERNAL_CALL, UseUniV3Swapper._allowRouterSpend(IERC20,uint256)(TMP_10596,TMP_10598)
		Expression: StrategySwapAnd(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
		IRs:
			INTERNAL_CALL, StrategySwapAnd.constructor(address,IERC20,IStrategy,IOracle)(initialOwner,iAsset,iUnderlyingStrategy,iOracle)
	Function StrategyUniV3SwapAnd._swap(ISwapHandler.SwapParams) (*)
		Expression: params.payload = abi.encode(_feeTier)
		IRs:
			REF_2955(bytes) -> params.payload
			TMP_10601(bytes) = SOLIDITY_CALL abi.encode()(_feeTier)
			REF_2955(bytes) (->params) := TMP_10601(bytes)
		Expression: UseUniV3Swapper.swap(params)
		IRs:
			TUPLE_151(uint256,uint256) = INTERNAL_CALL, UseUniV3Swapper.swap(ISwapHandler.SwapParams)(params)
			RETURN TUPLE_151
	Function StrategyUniV3SwapAnd.feeTier() (*)
		Expression: _feeTier
		IRs:
			RETURN _feeTier
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
	Modifier ReentrancyGuard.nonReentrant()
		Expression: _nonReentrantBefore()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantBefore()()
		Expression: _nonReentrantAfter()
		IRs:
			INTERNAL_CALL, ReentrancyGuard._nonReentrantAfter()()
Contract DataTypes
Contract IPoolAddressesProvider
	Function IPoolAddressesProvider.getMarketId() (*)
	Function IPoolAddressesProvider.setMarketId(string) (*)
	Function IPoolAddressesProvider.getAddress(bytes32) (*)
	Function IPoolAddressesProvider.setAddressAsProxy(bytes32,address) (*)
	Function IPoolAddressesProvider.setAddress(bytes32,address) (*)
	Function IPoolAddressesProvider.getPool() (*)
	Function IPoolAddressesProvider.setPoolImpl(address) (*)
	Function IPoolAddressesProvider.getPoolConfigurator() (*)
	Function IPoolAddressesProvider.setPoolConfiguratorImpl(address) (*)
	Function IPoolAddressesProvider.getPriceOracle() (*)
	Function IPoolAddressesProvider.setPriceOracle(address) (*)
	Function IPoolAddressesProvider.getACLManager() (*)
	Function IPoolAddressesProvider.setACLManager(address) (*)
	Function IPoolAddressesProvider.getACLAdmin() (*)
	Function IPoolAddressesProvider.setACLAdmin(address) (*)
	Function IPoolAddressesProvider.getPriceOracleSentinel() (*)
	Function IPoolAddressesProvider.setPriceOracleSentinel(address) (*)
	Function IPoolAddressesProvider.getPoolDataProvider() (*)
	Function IPoolAddressesProvider.setPoolDataProvider(address) (*)
Contract IPoolV3
	Function IPoolV3.mintUnbacked(address,uint256,address,uint16) (*)
	Function IPoolV3.backUnbacked(address,uint256,uint256) (*)
	Function IPoolV3.supply(address,uint256,address,uint16) (*)
	Function IPoolV3.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)
	Function IPoolV3.withdraw(address,uint256,address) (*)
	Function IPoolV3.borrow(address,uint256,uint256,uint16,address) (*)
	Function IPoolV3.repay(address,uint256,uint256,address) (*)
	Function IPoolV3.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)
	Function IPoolV3.repayWithATokens(address,uint256,uint256) (*)
	Function IPoolV3.swapBorrowRateMode(address,uint256) (*)
	Function IPoolV3.rebalanceStableBorrowRate(address,address) (*)
	Function IPoolV3.setUserUseReserveAsCollateral(address,bool) (*)
	Function IPoolV3.liquidationCall(address,address,address,uint256,bool) (*)
	Function IPoolV3.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)
	Function IPoolV3.flashLoanSimple(address,address,uint256,bytes,uint16) (*)
	Function IPoolV3.getUserAccountData(address) (*)
	Function IPoolV3.initReserve(address,address,address,address,address) (*)
	Function IPoolV3.dropReserve(address) (*)
	Function IPoolV3.setReserveInterestRateStrategyAddress(address,address) (*)
	Function IPoolV3.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)
	Function IPoolV3.getConfiguration(address) (*)
	Function IPoolV3.getUserConfiguration(address) (*)
	Function IPoolV3.getReserveNormalizedIncome(address) (*)
	Function IPoolV3.getReserveNormalizedVariableDebt(address) (*)
	Function IPoolV3.getReserveData(address) (*)
	Function IPoolV3.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)
	Function IPoolV3.getReservesList() (*)
	Function IPoolV3.ADDRESSES_PROVIDER() (*)
	Function IPoolV3.updateBridgeProtocolFee(uint256) (*)
	Function IPoolV3.updateFlashloanPremiums(uint128,uint128) (*)
	Function IPoolV3.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)
	Function IPoolV3.getEModeCategoryData(uint8) (*)
	Function IPoolV3.setUserEMode(uint8) (*)
	Function IPoolV3.getUserEMode(address) (*)
	Function IPoolV3.resetIsolationModeTotalDebt(address) (*)
	Function IPoolV3.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)
	Function IPoolV3.FLASHLOAN_PREMIUM_TOTAL() (*)
	Function IPoolV3.BRIDGE_PROTOCOL_FEE() (*)
	Function IPoolV3.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)
	Function IPoolV3.MAX_NUMBER_RESERVES() (*)
	Function IPoolV3.mintToTreasury(address[]) (*)
	Function IPoolV3.rescueTokens(address,address,uint256) (*)
	Function IPoolV3.deposit(address,uint256,address,uint16) (*)
	Function IPoolV3.getReserveAddressById(uint16) (*)
Contract ICLSwapCallback
	Function ICLSwapCallback.uniswapV3SwapCallback(int256,int256,bytes) (*)
Contract ISwapRouter
	Function ICLSwapCallback.uniswapV3SwapCallback(int256,int256,bytes) (*)
	Function ISwapRouter.exactInputSingle(ISwapRouter.ExactInputSingleParams) (*)
	Function ISwapRouter.exactInput(ISwapRouter.ExactInputParams) (*)
	Function ISwapRouter.exactOutputSingle(ISwapRouter.ExactOutputSingleParams) (*)
	Function ISwapRouter.exactOutput(ISwapRouter.ExactOutputParams) (*)
Contract IFlashLoanRecipient
	Function IFlashLoanRecipient.receiveFlashLoan(address[],uint256[],uint256[],bytes) (*)
Contract IFlashLoans
	Function IFlashLoans.flashLoan(address,address[],uint256[],bytes) (*)
Contract IProtocolFeesCollector
	Function IProtocolFeesCollector.getFlashLoanFeePercentage() (*)
Contract IVault
	Function IFlashLoans.flashLoan(address,address[],uint256[],bytes) (*)
	Function IVault.swap(IVault.SingleSwap,IVault.FundManagement,uint256,uint256) (*)
	Function IVault.querySwap(IVault.SingleSwap,IVault.FundManagement) (*)
	Function IVault.getProtocolFeesCollector() (*)
Contract IChainlinkAggregator
	Function IChainlinkAggregator.decimals() (*)
	Function IChainlinkAggregator.latestAnswer() (*)
	Function IChainlinkAggregator.latestTimestamp() (*)
	Function IChainlinkAggregator.latestRound() (*)
	Function IChainlinkAggregator.getAnswer(uint256) (*)
	Function IChainlinkAggregator.getTimestamp(uint256) (*)
	Function IChainlinkAggregator.latestRoundData() (*)
Contract IOracle
	Function IOracle.getPrecision() (*)
	Function IOracle.getLatestPrice() (*)
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
Contract IStrategy
	Function IStrategy.deploy(uint256) (*)
	Function IStrategy.harvest() (*)
	Function IStrategy.undeploy(uint256) (*)
	Function IStrategy.totalAssets() (*)
	Function IStrategy.asset() (*)
Contract IStrategyLeverage
	Function IStrategy.deploy(uint256) (*)
	Function IStrategy.harvest() (*)
	Function IStrategy.undeploy(uint256) (*)
	Function IStrategy.totalAssets() (*)
	Function IStrategy.asset() (*)
	Function IStrategyLeverage.getCollateralAsset() (*)
	Function IStrategyLeverage.getDebAsset() (*)
	Function IStrategyLeverage.getPosition(IOracle.PriceOptions) (*)
Contract IStrategySettings
	Function IStrategySettings.setPriceMaxAge(uint256) (*)
	Function IStrategySettings.getPriceMaxAge() (*)
	Function IStrategySettings.setPriceMaxConf(uint256) (*)
	Function IStrategySettings.getPriceMaxConf() (*)
Contract ISwapHandler
	Function ISwapHandler.swap(ISwapHandler.SwapParams) (*)
Contract IVault
	Function IERC4626Upgradeable.asset() (*)
	Function IERC4626Upgradeable.totalAssets() (*)
	Function IERC4626Upgradeable.convertToShares(uint256) (*)
	Function IERC4626Upgradeable.convertToAssets(uint256) (*)
	Function IERC4626Upgradeable.maxDeposit(address) (*)
	Function IERC4626Upgradeable.previewDeposit(uint256) (*)
	Function IERC4626Upgradeable.deposit(uint256,address) (*)
	Function IERC4626Upgradeable.maxMint(address) (*)
	Function IERC4626Upgradeable.previewMint(uint256) (*)
	Function IERC4626Upgradeable.mint(uint256,address) (*)
	Function IERC4626Upgradeable.maxWithdraw(address) (*)
	Function IERC4626Upgradeable.previewWithdraw(uint256) (*)
	Function IERC4626Upgradeable.withdraw(uint256,address,address) (*)
	Function IERC4626Upgradeable.maxRedeem(address) (*)
	Function IERC4626Upgradeable.previewRedeem(uint256) (*)
	Function IERC4626Upgradeable.redeem(uint256,address,address) (*)
	Function IERC20MetadataUpgradeable.name() (*)
	Function IERC20MetadataUpgradeable.symbol() (*)
	Function IERC20MetadataUpgradeable.decimals() (*)
	Function IERC20Upgradeable.totalSupply() (*)
	Function IERC20Upgradeable.balanceOf(address) (*)
	Function IERC20Upgradeable.transfer(address,uint256) (*)
	Function IERC20Upgradeable.allowance(address,address) (*)
	Function IERC20Upgradeable.approve(address,uint256) (*)
	Function IERC20Upgradeable.transferFrom(address,address,uint256) (*)
	Function IVault.depositNative(address) (*)
	Function IVault.withdrawNative(uint256) (*)
	Function IVault.redeemNative(uint256) (*)
	Function IVault.tokenPerAsset() (*)
	Function IVault.rebalance() (*)
Contract IVaultRegistry
	Function IVaultRegistry.registerService(bytes32,address) (*)
	Function IVaultRegistry.unregisterService(bytes32) (*)
	Function IVaultRegistry.getServiceFromHash(bytes32) (*)
	Function IVaultRegistry.getService(string) (*)
Contract IVaultSettings
	Function IVaultSettings.setWithdrawalFee(uint256) (*)
	Function IVaultSettings.getWithdrawalFee() (*)
	Function IVaultSettings.setPerformanceFee(uint256) (*)
	Function IVaultSettings.getPerformanceFee() (*)
	Function IVaultSettings.setFeeReceiver(address) (*)
	Function IVaultSettings.getFeeReceiver() (*)
	Function IVaultSettings.enableAccount(address,bool) (*)
	Function IVaultSettings.isAccountEnabled(address) (*)
	Function IVaultSettings.getMaxDeposit() (*)
	Function IVaultSettings.setMaxDeposit(uint256) (*)
Contract ICurvePool
	Function ICurvePool.coins(uint256) (*)
	Function ICurvePool.get_virtual_price() (*)
	Function ICurvePool.lp_token() (*)
	Function ICurvePool.fee() (*)
	Function ICurvePool.admin_fee() (*)
	Function ICurvePool.get_dy(int128,int128,uint256) (*)
	Function ICurvePool.exchange(int128,int128,uint256,uint256) (*)
	Function ICurvePool.add_liquidity(uint256[2],uint256) (*)
	Function ICurvePool.remove_liquidity_one_coin(uint256,int128,uint256) (*)
	Function ICurvePool.calc_token_amount(uint256[2],bool) (*)
	Function ICurvePool.calc_withdraw_one_coin(uint256,int128) (*)
	Function ICurvePool.balances(uint256) (*)
	Function ICurvePool.A_precise() (*)
Contract ICurveRouterNG
	Function ICurveRouterNG.exchange(address[11],uint256[5][5],uint256,uint256,address[5],address) (*)
	Function ICurveRouterNG.get_dy(address[11],uint256[5][5],uint256,address[5]) (*)
	Function ICurveRouterNG.get_dx(address[11],uint256[5][5],uint256,address[5],address[5],address[5]) (*)
Contract IStETH
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) (*)
	Function IERC20.transfer(address,uint256) (*)
	Function IERC20.allowance(address,address) (*)
	Function IERC20.approve(address,uint256) (*)
	Function IERC20.transferFrom(address,address,uint256) (*)
	Function IStETH.getSharesByPooledEth(uint256) (*)
	Function IStETH.getPooledEthByShares(uint256) (*)
	Function IStETH.submit(address) (*)
	Function IStETH.burnShares(address,uint256) (*)
	Function IStETH.sharesOf(address) (*)
	Function IStETH.getTotalShares() (*)
	Function IStETH.getTotalPooledEther() (*)
Contract IWStETH
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) (*)
	Function IERC20.transfer(address,uint256) (*)
	Function IERC20.allowance(address,address) (*)
	Function IERC20.approve(address,uint256) (*)
	Function IERC20.transferFrom(address,address,uint256) (*)
	Function IWStETH.wrap(uint256) (*)
	Function IWStETH.unwrap(uint256) (*)
	Function IWStETH.stETH() (*)
	Function IWStETH.stEthPerToken() (*)
Contract IPyth
	Function IPyth.getValidTimePeriod() (*)
	Function IPyth.getPrice(bytes32) (*)
	Function IPyth.getEmaPrice(bytes32) (*)
	Function IPyth.getPriceUnsafe(bytes32) (*)
	Function IPyth.getPriceNoOlderThan(bytes32,uint256) (*)
	Function IPyth.getEmaPriceUnsafe(bytes32) (*)
	Function IPyth.getEmaPriceNoOlderThan(bytes32,uint256) (*)
	Function IPyth.updatePriceFeeds(bytes[]) (*)
	Function IPyth.updatePriceFeedsIfNecessary(bytes[],bytes32[],uint64[]) (*)
	Function IPyth.getUpdateFee(bytes[]) (*)
	Function IPyth.parsePriceFeedUpdates(bytes[],bytes32[],uint64,uint64) (*)
	Function IPyth.parsePriceFeedUpdatesUnique(bytes[],bytes32[],uint64,uint64) (*)
Contract IPythEvents
Contract PythStructs
Contract IWETH
	Function IERC20.totalSupply() (*)
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function IWETH.allowance(address,address) (*)
	Function IWETH.balanceOf(address) (*)
	Function IWETH.approve(address,uint256) (*)
	Function IWETH.transfer(address,uint256) (*)
	Function IWETH.transferFrom(address,address,uint256) (*)
	Function IWETH.deposit() (*)
	Function IWETH.withdraw(uint256) (*)
Contract IUniswapV2Router01
	Function IUniswapV2Router01.factory() (*)
	Function IUniswapV2Router01.WETH() (*)
	Function IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.addLiquidityETH(address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidity(address,address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidityETH(address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32) (*)
	Function IUniswapV2Router01.removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32) (*)
	Function IUniswapV2Router01.swapExactTokensForTokens(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapTokensForExactTokens(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapExactETHForTokens(uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapTokensForExactETH(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapExactTokensForETH(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapETHForExactTokens(uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.quote(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountOut(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountIn(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountsOut(uint256,address[]) (*)
	Function IUniswapV2Router01.getAmountsIn(uint256,address[]) (*)
Contract IUniswapV2Router02
	Function IUniswapV2Router01.factory() (*)
	Function IUniswapV2Router01.WETH() (*)
	Function IUniswapV2Router01.addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.addLiquidityETH(address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidity(address,address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidityETH(address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router01.removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32) (*)
	Function IUniswapV2Router01.removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32) (*)
	Function IUniswapV2Router01.swapExactTokensForTokens(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapTokensForExactTokens(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapExactETHForTokens(uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapTokensForExactETH(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapExactTokensForETH(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.swapETHForExactTokens(uint256,address[],address,uint256) (*)
	Function IUniswapV2Router01.quote(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountOut(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountIn(uint256,uint256,uint256) (*)
	Function IUniswapV2Router01.getAmountsOut(uint256,address[]) (*)
	Function IUniswapV2Router01.getAmountsIn(uint256,address[]) (*)
	Function IUniswapV2Router02.removeLiquidityETHSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256) (*)
	Function IUniswapV2Router02.removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32) (*)
	Function IUniswapV2Router02.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256) (*)
	Function IUniswapV2Router02.swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256) (*)
	Function IUniswapV2Router02.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256) (*)
Contract IQuoterV2
	Function IQuoterV2.quoteExactInput(bytes,uint256) (*)
	Function IQuoterV2.quoteExactInputSingle(IQuoterV2.QuoteExactInputSingleParams) (*)
	Function IQuoterV2.quoteExactOutput(bytes,uint256) (*)
	Function IQuoterV2.quoteExactOutputSingle(IQuoterV2.QuoteExactOutputSingleParams) (*)
Contract IUniswapV3Pool
	Function IUniswapV3Pool.slot0() (*)
	Function IUniswapV3Pool.fee() (*)
	Function IUniswapV3Pool.flash(address,uint256,uint256,bytes) (*)
Contract IUniswapV3SwapCallback
	Function IUniswapV3SwapCallback.uniswapV3SwapCallback(int256,int256,bytes) (*)
Contract IV3SwapRouter
	Function IUniswapV3SwapCallback.uniswapV3SwapCallback(int256,int256,bytes) (*)
	Function IV3SwapRouter.exactInputSingle(IV3SwapRouter.ExactInputSingleParams) (*)
	Function IV3SwapRouter.exactInput(IV3SwapRouter.ExactInputParams) (*)
	Function IV3SwapRouter.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams) (*)
	Function IV3SwapRouter.exactOutput(IV3SwapRouter.ExactOutputParams) (*)
Contract AerodromeLibrary
	Function AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams) (*)
		Expression: params.underlyingIn == address(0)
		IRs:
			REF_2958(address) -> params.underlyingIn
			TMP_10605 = CONVERT 0 to address
			TMP_10606(bool) = REF_2958 == TMP_10605
			CONDITION TMP_10606
		Expression: revert InvalidInputToken()()
		IRs:
			TMP_10607(None) = SOLIDITY_CALL revert InvalidInputToken()()
		Expression: params.underlyingOut == address(0)
		IRs:
			REF_2959(address) -> params.underlyingOut
			TMP_10608 = CONVERT 0 to address
			TMP_10609(bool) = REF_2959 == TMP_10608
			CONDITION TMP_10609
		Expression: revert InvalidOutputToken()()
		IRs:
			TMP_10610(None) = SOLIDITY_CALL revert InvalidOutputToken()()
		Expression: tickspacing = abi.decode(params.payload,(int24))
		IRs:
			REF_2961(bytes) -> params.payload
			TMP_10611(int24) = SOLIDITY_CALL abi.decode()(REF_2961,int24)
			tickspacing(int24) := TMP_10611(int24)
		Expression: params.mode == ISwapHandler.SwapType.EXACT_INPUT
		IRs:
			REF_2962(ISwapHandler.SwapType) -> params.mode
			REF_2963(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10612(bool) = REF_2962 == REF_2963
			CONDITION TMP_10612
		Expression: amountIn = params.amountIn
		IRs:
			REF_2964(uint256) -> params.amountIn
			amountIn(uint256) := REF_2964(uint256)
		Expression: amountOut = router.exactInputSingle(ISwapRouter.ExactInputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,amountIn:amountIn,amountOutMinimum:params.amountOut,tickSpacing:tickspacing,recipient:address(this),deadline:block.timestamp,sqrtPriceLimitX96:0}))
		IRs:
			REF_2967(address) -> params.underlyingIn
			REF_2968(address) -> params.underlyingOut
			REF_2969(uint256) -> params.amountOut
			TMP_10613 = CONVERT this to address
			TMP_10614(ISwapRouter.ExactInputSingleParams) = new ExactInputSingleParams(REF_2967,REF_2968,tickspacing,TMP_10613,block.timestamp,amountIn,REF_2969,0)
			TMP_10615(uint256) = HIGH_LEVEL_CALL, dest:router(ISwapRouter), function:exactInputSingle, arguments:['TMP_10614']  
			amountOut(uint256) := TMP_10615(uint256)
		Expression: amountOut == 0
		IRs:
			TMP_10616(bool) = amountOut == 0
			CONDITION TMP_10616
		Expression: revert SwapFailed()()
		IRs:
			TMP_10617(None) = SOLIDITY_CALL revert SwapFailed()()
		Expression: params.mode == ISwapHandler.SwapType.EXACT_OUTPUT
		IRs:
			REF_2970(ISwapHandler.SwapType) -> params.mode
			REF_2971(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_10618(bool) = REF_2970 == REF_2971
			CONDITION TMP_10618
		Expression: amountOut = params.amountOut
		IRs:
			REF_2972(uint256) -> params.amountOut
			amountOut(uint256) := REF_2972(uint256)
		Expression: amountIn = router.exactOutputSingle(ISwapRouter.ExactOutputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,tickSpacing:tickspacing,recipient:address(this),deadline:block.timestamp,amountOut:amountOut,amountInMaximum:params.amountIn,sqrtPriceLimitX96:0}))
		IRs:
			REF_2975(address) -> params.underlyingIn
			REF_2976(address) -> params.underlyingOut
			TMP_10619 = CONVERT this to address
			REF_2977(uint256) -> params.amountIn
			TMP_10620(ISwapRouter.ExactOutputSingleParams) = new ExactOutputSingleParams(REF_2975,REF_2976,tickspacing,TMP_10619,block.timestamp,amountOut,REF_2977,0)
			TMP_10621(uint256) = HIGH_LEVEL_CALL, dest:router(ISwapRouter), function:exactOutputSingle, arguments:['TMP_10620']  
			amountIn(uint256) := TMP_10621(uint256)
Contract CurveFiLibrary
	Function CurveFiLibrary.swapCurveFi(ICurveRouterNG,ISwapHandler.SwapParams) (*)
		Expression: params.underlyingIn == address(0)
		IRs:
			REF_2978(address) -> params.underlyingIn
			TMP_10622 = CONVERT 0 to address
			TMP_10623(bool) = REF_2978 == TMP_10622
			CONDITION TMP_10623
		Expression: ISwapHandler.InvalidInputToken()
		IRs:
			TMP_10624(None) = SOLIDITY_CALL revert InvalidInputToken()()
		Expression: params.underlyingOut == address(0)
		IRs:
			REF_2979(address) -> params.underlyingOut
			TMP_10625 = CONVERT 0 to address
			TMP_10626(bool) = REF_2979 == TMP_10625
			CONDITION TMP_10626
		Expression: ISwapHandler.InvalidOutputToken()
		IRs:
			TMP_10627(None) = SOLIDITY_CALL revert InvalidOutputToken()()
		Expression: (i,j,swapType,poolType,pool) = abi.decode(params.payload,(uint256,uint256,uint256,uint256,address))
		IRs:
			REF_2981(bytes) -> params.payload
			TUPLE_152(uint256,uint256,uint256,uint256,address) = SOLIDITY_CALL abi.decode()(REF_2981(uint256,uint256,uint256,uint256,address))
			i(uint256)= UNPACK TUPLE_152 index: 0 
			j(uint256)= UNPACK TUPLE_152 index: 1 
			swapType(uint256)= UNPACK TUPLE_152 index: 2 
			poolType(uint256)= UNPACK TUPLE_152 index: 3 
			pool(address)= UNPACK TUPLE_152 index: 4 
		Expression: route[0] = params.underlyingIn
		IRs:
			REF_2982(address) -> route[0]
			REF_2983(address) -> params.underlyingIn
			REF_2982(address) (->route) := REF_2983(address)
		Expression: route[1] = pool
		IRs:
			REF_2984(address) -> route[1]
			REF_2984(address) (->route) := pool(address)
		Expression: route[2] = params.underlyingOut
		IRs:
			REF_2985(address) -> route[2]
			REF_2986(address) -> params.underlyingOut
			REF_2985(address) (->route) := REF_2986(address)
		Expression: pools[0] = pool
		IRs:
			REF_2987(address) -> pools[0]
			REF_2987(address) (->pools) := pool(address)
		Expression: swapParams[0] = (uint256(i),uint256(j),uint256(swapType),poolType,2)
		IRs:
			REF_2988(uint256[5]) -> swapParams[0]
			TMP_10628 = CONVERT i to uint256
			TMP_10629 = CONVERT j to uint256
			TMP_10630 = CONVERT swapType to uint256
			REF_2988(uint256[5]) = ['TMP_10628(uint256)', 'TMP_10629(uint256)', 'TMP_10630(uint256)', 'poolType(uint256)', '2(uint256)']
		Expression: _executeCurveFiSwap(router,route,swapParams,pools,params)
		IRs:
			TUPLE_153(uint256,uint256) = INTERNAL_CALL, CurveFiLibrary._executeCurveFiSwap(ICurveRouterNG,address[11],uint256[5][5],address[5],ISwapHandler.SwapParams)(router,route,swapParams,pools,params)
			RETURN TUPLE_153
	Function CurveFiLibrary._executeCurveFiSwap(ICurveRouterNG,address[11],uint256[5][5],address[5],ISwapHandler.SwapParams) (*)
		Expression: params.mode == ISwapHandler.SwapType.EXACT_INPUT
		IRs:
			REF_2989(ISwapHandler.SwapType) -> params.mode
			REF_2990(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10631(bool) = REF_2989 == REF_2990
			CONDITION TMP_10631
		Expression: amountOut = router.exchange{value: msg.value}(route,swapParams,amountIn,params.amountOut,pools,address(this))
		IRs:
			REF_2992(uint256) -> params.amountOut
			TMP_10632 = CONVERT this to address
			TMP_10633(uint256) = HIGH_LEVEL_CALL, dest:router(ICurveRouterNG), function:exchange, arguments:['route', 'swapParams', 'amountIn', 'REF_2992', 'pools', 'TMP_10632'] value:msg.value 
			amountOut(uint256) := TMP_10633(uint256)
		Expression: amountOut < params.amountOut
		IRs:
			REF_2993(uint256) -> params.amountOut
			TMP_10634(bool) = amountOut < REF_2993
			CONDITION TMP_10634
		Expression: ISwapHandler.SwapFailed()
		IRs:
			TMP_10635(None) = SOLIDITY_CALL revert SwapFailed()()
		Expression: params.mode == ISwapHandler.SwapType.EXACT_OUTPUT
		IRs:
			REF_2994(ISwapHandler.SwapType) -> params.mode
			REF_2995(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_10636(bool) = REF_2994 == REF_2995
			CONDITION TMP_10636
		Expression: requiredIn = router.get_dx(route,swapParams,params.amountOut,pools,basePools,baseTokens)
		IRs:
			REF_2997(uint256) -> params.amountOut
			TMP_10637(uint256) = HIGH_LEVEL_CALL, dest:router(ICurveRouterNG), function:get_dx, arguments:['route', 'swapParams', 'REF_2997', 'pools', 'basePools', 'baseTokens']  
			requiredIn(uint256) := TMP_10637(uint256)
		Expression: (params.underlyingIn == ETH_ADDRESS && requiredIn > msg.value) || (params.underlyingIn != ETH_ADDRESS && requiredIn > params.amountIn)
		IRs:
			REF_2998(address) -> params.underlyingIn
			TMP_10638(bool) = REF_2998 == ETH_ADDRESS
			TMP_10639(bool) = requiredIn > msg.value
			TMP_10640(bool) = TMP_10638 && TMP_10639
			REF_2999(address) -> params.underlyingIn
			TMP_10641(bool) = REF_2999 != ETH_ADDRESS
			REF_3000(uint256) -> params.amountIn
			TMP_10642(bool) = requiredIn > REF_3000
			TMP_10643(bool) = TMP_10641 && TMP_10642
			TMP_10644(bool) = TMP_10640 || TMP_10643
			CONDITION TMP_10644
		Expression: revert InsufficientBalance()()
		IRs:
			TMP_10645(None) = SOLIDITY_CALL revert InsufficientBalance()()
		Expression: amountOut = router.exchange{value: amountIn}(route,swapParams,amountIn,params.amountOut,pools,address(this))
		IRs:
			REF_3002(uint256) -> params.amountOut
			TMP_10646 = CONVERT this to address
			TMP_10647(uint256) = HIGH_LEVEL_CALL, dest:router(ICurveRouterNG), function:exchange, arguments:['route', 'swapParams', 'amountIn', 'REF_3002', 'pools', 'TMP_10646'] value:amountIn 
			amountOut(uint256) := TMP_10647(uint256)
		Expression: amountOut < params.amountOut
		IRs:
			REF_3003(uint256) -> params.amountOut
			TMP_10648(bool) = amountOut < REF_3003
			CONDITION TMP_10648
		Expression: ISwapHandler.SwapFailed()
		IRs:
			TMP_10649(None) = SOLIDITY_CALL revert SwapFailed()()
		Expression: revert UnsupportedSwapType()()
		IRs:
			TMP_10650(None) = SOLIDITY_CALL revert UnsupportedSwapType()()
		Expression: params.underlyingIn == ETH_ADDRESS
		IRs:
			REF_3004(address) -> params.underlyingIn
			TMP_10651(bool) = REF_3004 == ETH_ADDRESS
			CONDITION TMP_10651
		Expression: amountIn = msg.value
		IRs:
			amountIn(uint256) := msg.value(uint256)
		Expression: amountIn = params.amountIn
		IRs:
			REF_3005(uint256) -> params.amountIn
			amountIn(uint256) := REF_3005(uint256)
		Expression: params.underlyingIn == ETH_ADDRESS
		IRs:
			REF_3006(address) -> params.underlyingIn
			TMP_10652(bool) = REF_3006 == ETH_ADDRESS
			CONDITION TMP_10652
		Expression: amountIn = msg.value
		IRs:
			amountIn(uint256) := msg.value(uint256)
		Expression: amountIn = params.amountIn
		IRs:
			REF_3007(uint256) -> params.amountIn
			amountIn(uint256) := REF_3007(uint256)
	Function CurveFiLibrary.slitherConstructorConstantVariables() (*)
		Expression: ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
		IRs:
			ETH_ADDRESS(address) := 1364068194842176056990105843868530818345537040110(address)
Contract MathLibrary
	Function MathLibrary.toDecimals(uint256,uint8,uint8) (*)
		Expression: from > to
		IRs:
			TMP_10653(bool) = from > to
			CONDITION TMP_10653
		Expression: from - to >= MAX_DIFFERENCE_DECIMALS
		IRs:
			TMP_10654(uint8) = from (c)- to
			TMP_10655(bool) = TMP_10654 >= MAX_DIFFERENCE_DECIMALS
			CONDITION TMP_10655
		Expression: revert OverflowDetected()()
		IRs:
			TMP_10656(None) = SOLIDITY_CALL revert OverflowDetected()()
		Expression: converted = value / (10 ** (from - to))
		IRs:
			TMP_10657(uint8) = from (c)- to
			TMP_10658(uint256) = 10 (c)** TMP_10657
			TMP_10659(uint256) = value (c)/ TMP_10658
			converted(uint256) := TMP_10659(uint256)
		Expression: to > from
		IRs:
			TMP_10660(bool) = to > from
			CONDITION TMP_10660
		Expression: to - from >= MAX_DIFFERENCE_DECIMALS
		IRs:
			TMP_10661(uint8) = to (c)- from
			TMP_10662(bool) = TMP_10661 >= MAX_DIFFERENCE_DECIMALS
			CONDITION TMP_10662
		Expression: revert OverflowDetected()()
		IRs:
			TMP_10663(None) = SOLIDITY_CALL revert OverflowDetected()()
		Expression: factor = 10 ** (to - from)
		IRs:
			TMP_10664(uint8) = to (c)- from
			TMP_10665(uint256) = 10 (c)** TMP_10664
			factor(uint256) := TMP_10665(uint256)
		Expression: value > type()(uint256).max / factor
		IRs:
			TMP_10667(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_10668(uint256) = TMP_10667 (c)/ factor
			TMP_10669(bool) = value > TMP_10668
			CONDITION TMP_10669
		Expression: revert OverflowDetected()()
		IRs:
			TMP_10670(None) = SOLIDITY_CALL revert OverflowDetected()()
		Expression: converted = value * factor
		IRs:
			TMP_10671(uint256) = value (c)* factor
			converted(uint256) := TMP_10671(uint256)
		Expression: converted = value
		IRs:
			converted(uint256) := value(uint256)
	Function MathLibrary.mulDiv(uint256,uint256,uint256,bool) (*)
		Expression: roundUp
		IRs:
			CONDITION roundUp
		Expression: mulDivUp(x,y,denominator)
		IRs:
			TMP_10672(uint256) = INTERNAL_CALL, MathLibrary.mulDivUp(uint256,uint256,uint256)(x,y,denominator)
			RETURN TMP_10672
		Expression: mulDivDown(x,y,denominator)
		IRs:
			TMP_10673(uint256) = INTERNAL_CALL, MathLibrary.mulDivDown(uint256,uint256,uint256)(x,y,denominator)
			RETURN TMP_10673
	Function MathLibrary.mulDivUp(uint256,uint256,uint256) (*)
		Expression: product = x * y
		IRs:
			TMP_10674(uint256) = x (c)* y
			product(uint256) := TMP_10674(uint256)
		Expression: denominator == 0
		IRs:
			TMP_10675(bool) = denominator == 0
			CONDITION TMP_10675
		Expression: revert InvalidDivDenominator()()
		IRs:
			TMP_10676(None) = SOLIDITY_CALL revert InvalidDivDenominator()()
		Expression: x == 0 || y == 0
		IRs:
			TMP_10677(bool) = x == 0
			TMP_10678(bool) = y == 0
			TMP_10679(bool) = TMP_10677 || TMP_10678
			CONDITION TMP_10679
		Expression: 0
		IRs:
			RETURN 0
		Expression: 1 + (product - 1) / denominator
		IRs:
			TMP_10680(uint256) = product (c)- 1
			TMP_10681(uint256) = TMP_10680 (c)/ denominator
			TMP_10682(uint256) = 1 (c)+ TMP_10681
			RETURN TMP_10682
	Function MathLibrary.mulDivDown(uint256,uint256,uint256) (*)
		Expression: product = x * y
		IRs:
			TMP_10683(uint256) = x (c)* y
			product(uint256) := TMP_10683(uint256)
		Expression: denominator == 0
		IRs:
			TMP_10684(bool) = denominator == 0
			CONDITION TMP_10684
		Expression: revert InvalidDivDenominator()()
		IRs:
			TMP_10685(None) = SOLIDITY_CALL revert InvalidDivDenominator()()
		Expression: x == 0 || y == 0
		IRs:
			TMP_10686(bool) = x == 0
			TMP_10687(bool) = y == 0
			TMP_10688(bool) = TMP_10686 || TMP_10687
			CONDITION TMP_10688
		Expression: 0
		IRs:
			RETURN 0
		Expression: product / denominator
		IRs:
			TMP_10689(uint256) = product (c)/ denominator
			RETURN TMP_10689
	Function MathLibrary.slitherConstructorConstantVariables() (*)
		Expression: MAX_DIFFERENCE_DECIMALS = 64
		IRs:
			MAX_DIFFERENCE_DECIMALS(uint256) := 64(uint256)
Contract RebaseLibrary
	Function RebaseLibrary.toBase(Rebase,uint256,bool) (*)
		Expression: total.elastic == 0 || total.base == 0
		IRs:
			REF_3008(uint256) -> total.elastic
			TMP_10690(bool) = REF_3008 == 0
			REF_3009(uint256) -> total.base
			TMP_10691(bool) = REF_3009 == 0
			TMP_10692(bool) = TMP_10690 || TMP_10691
			CONDITION TMP_10692
		Expression: base = elastic
		IRs:
			base(uint256) := elastic(uint256)
		Expression: base = (elastic * total.base) / total.elastic
		IRs:
			REF_3010(uint256) -> total.base
			TMP_10693(uint256) = elastic (c)* REF_3010
			REF_3011(uint256) -> total.elastic
			TMP_10694(uint256) = TMP_10693 (c)/ REF_3011
			base(uint256) := TMP_10694(uint256)
		Expression: roundUp && (base * total.elastic) / total.base < elastic
		IRs:
			REF_3012(uint256) -> total.elastic
			TMP_10695(uint256) = base (c)* REF_3012
			REF_3013(uint256) -> total.base
			TMP_10696(uint256) = TMP_10695 (c)/ REF_3013
			TMP_10697(bool) = TMP_10696 < elastic
			TMP_10698(bool) = roundUp && TMP_10697
			CONDITION TMP_10698
		Expression: base ++
		IRs:
			TMP_10699(uint256) := base(uint256)
			base(uint256) = base (c)+ 1
	Function RebaseLibrary.toElastic(Rebase,uint256,bool) (*)
		Expression: total.base == 0
		IRs:
			REF_3014(uint256) -> total.base
			TMP_10700(bool) = REF_3014 == 0
			CONDITION TMP_10700
		Expression: elastic = base
		IRs:
			elastic(uint256) := base(uint256)
		Expression: elastic = (base * total.elastic) / total.base
		IRs:
			REF_3015(uint256) -> total.elastic
			TMP_10701(uint256) = base (c)* REF_3015
			REF_3016(uint256) -> total.base
			TMP_10702(uint256) = TMP_10701 (c)/ REF_3016
			elastic(uint256) := TMP_10702(uint256)
		Expression: roundUp && (elastic * total.base) / total.elastic < base
		IRs:
			REF_3017(uint256) -> total.base
			TMP_10703(uint256) = elastic (c)* REF_3017
			REF_3018(uint256) -> total.elastic
			TMP_10704(uint256) = TMP_10703 (c)/ REF_3018
			TMP_10705(bool) = TMP_10704 < base
			TMP_10706(bool) = roundUp && TMP_10705
			CONDITION TMP_10706
		Expression: elastic ++
		IRs:
			TMP_10707(uint256) := elastic(uint256)
			elastic(uint256) = elastic (c)+ 1
Contract UniV2Library
	Function UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams) (*)
		Expression: params.underlyingIn == address(0)
		IRs:
			REF_3019(address) -> params.underlyingIn
			TMP_10708 = CONVERT 0 to address
			TMP_10709(bool) = REF_3019 == TMP_10708
			CONDITION TMP_10709
		Expression: revert InvalidInputToken()()
		IRs:
			TMP_10710(None) = SOLIDITY_CALL revert InvalidInputToken()()
		Expression: params.underlyingOut == address(0)
		IRs:
			REF_3020(address) -> params.underlyingOut
			TMP_10711 = CONVERT 0 to address
			TMP_10712(bool) = REF_3020 == TMP_10711
			CONDITION TMP_10712
		Expression: revert InvalidOutputToken()()
		IRs:
			TMP_10713(None) = SOLIDITY_CALL revert InvalidOutputToken()()
		Expression: path = new address[](2)
		IRs:
			TMP_10715(address[])  = new address[](2)
			path(address[]) = ['TMP_10715(address[])']
		Expression: path[0] = params.underlyingIn
		IRs:
			REF_3021(address) -> path[0]
			REF_3022(address) -> params.underlyingIn
			REF_3021(address) (->path) := REF_3022(address)
		Expression: path[1] = params.underlyingOut
		IRs:
			REF_3023(address) -> path[1]
			REF_3024(address) -> params.underlyingOut
			REF_3023(address) (->path) := REF_3024(address)
		Expression: params.mode == ISwapHandler.SwapType.EXACT_INPUT
		IRs:
			REF_3025(ISwapHandler.SwapType) -> params.mode
			REF_3026(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10716(bool) = REF_3025 == REF_3026
			CONDITION TMP_10716
		Expression: ! IERC20(params.underlyingIn).approve(address(router),params.amountIn)
		IRs:
			REF_3027(address) -> params.underlyingIn
			TMP_10717 = CONVERT REF_3027 to IERC20
			TMP_10718 = CONVERT router to address
			REF_3029(uint256) -> params.amountIn
			TMP_10719(bool) = HIGH_LEVEL_CALL, dest:TMP_10717(IERC20), function:approve, arguments:['TMP_10718', 'REF_3029']  
			TMP_10720 = UnaryType.BANG TMP_10719 
			CONDITION TMP_10720
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_10721(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: amountOutMin = 0
		IRs:
			amountOutMin(uint256) := 0(uint256)
		Expression: params.amountOut > 0
		IRs:
			REF_3030(uint256) -> params.amountOut
			TMP_10722(bool) = REF_3030 > 0
			CONDITION TMP_10722
		Expression: amountOutMin = params.amountOut
		IRs:
			REF_3031(uint256) -> params.amountOut
			amountOutMin(uint256) := REF_3031(uint256)
		Expression: amountsOut = router.getAmountsOut(params.amountIn,path)
		IRs:
			REF_3033(uint256) -> params.amountIn
			TMP_10723(uint256[]) = HIGH_LEVEL_CALL, dest:router(IUniswapV2Router02), function:getAmountsOut, arguments:['REF_3033', 'path']  
			amountsOut(uint256[]) = ['TMP_10723(uint256[])']
		Expression: amountOutMin = amountsOut[amountsOut.length - 1]
		IRs:
			REF_3034 -> LENGTH amountsOut
			TMP_10724(uint256) = REF_3034 (c)- 1
			REF_3035(uint256) -> amountsOut[TMP_10724]
			amountOutMin(uint256) := REF_3035(uint256)
		Expression: amountIn = params.amountIn
		IRs:
			REF_3036(uint256) -> params.amountIn
			amountIn(uint256) := REF_3036(uint256)
		Expression: amounts = router.swapExactTokensForTokens(amountIn,amountOutMin,path,address(this),block.timestamp)
		IRs:
			TMP_10725 = CONVERT this to address
			TMP_10726(uint256[]) = HIGH_LEVEL_CALL, dest:router(IUniswapV2Router02), function:swapExactTokensForTokens, arguments:['amountIn', 'amountOutMin', 'path', 'TMP_10725', 'block.timestamp']  
			amounts(uint256[]) = ['TMP_10726(uint256[])']
		Expression: amountOut = amounts[amounts.length - 1]
		IRs:
			REF_3038 -> LENGTH amounts
			TMP_10727(uint256) = REF_3038 (c)- 1
			REF_3039(uint256) -> amounts[TMP_10727]
			amountOut(uint256) := REF_3039(uint256)
		Expression: params.mode == ISwapHandler.SwapType.EXACT_OUTPUT
		IRs:
			REF_3040(ISwapHandler.SwapType) -> params.mode
			REF_3041(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_10728(bool) = REF_3040 == REF_3041
			CONDITION TMP_10728
		Expression: amountOut = params.amountOut
		IRs:
			REF_3042(uint256) -> params.amountOut
			amountOut(uint256) := REF_3042(uint256)
		Expression: amountInMax = 0
		IRs:
			amountInMax(uint256) := 0(uint256)
		Expression: params.amountIn == 0
		IRs:
			REF_3043(uint256) -> params.amountIn
			TMP_10729(bool) = REF_3043 == 0
			CONDITION TMP_10729
		Expression: amountsIn = router.getAmountsIn(amountOut,path)
		IRs:
			TMP_10730(uint256[]) = HIGH_LEVEL_CALL, dest:router(IUniswapV2Router02), function:getAmountsIn, arguments:['amountOut', 'path']  
			amountsIn(uint256[]) = ['TMP_10730(uint256[])']
		Expression: amountInMax = amountsIn[0]
		IRs:
			REF_3045(uint256) -> amountsIn[0]
			amountInMax(uint256) := REF_3045(uint256)
		Expression: amountInMax = params.amountIn
		IRs:
			REF_3046(uint256) -> params.amountIn
			amountInMax(uint256) := REF_3046(uint256)
		Expression: ! IERC20(params.underlyingIn).approve(address(router),amountInMax)
		IRs:
			REF_3047(address) -> params.underlyingIn
			TMP_10731 = CONVERT REF_3047 to IERC20
			TMP_10732 = CONVERT router to address
			TMP_10733(bool) = HIGH_LEVEL_CALL, dest:TMP_10731(IERC20), function:approve, arguments:['TMP_10732', 'amountInMax']  
			TMP_10734 = UnaryType.BANG TMP_10733 
			CONDITION TMP_10734
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_10735(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: amounts_scope_0 = router.swapTokensForExactTokens(amountOut,amountInMax,path,address(this),block.timestamp)
		IRs:
			TMP_10736 = CONVERT this to address
			TMP_10737(uint256[]) = HIGH_LEVEL_CALL, dest:router(IUniswapV2Router02), function:swapTokensForExactTokens, arguments:['amountOut', 'amountInMax', 'path', 'TMP_10736', 'block.timestamp']  
			amounts_scope_0(uint256[]) = ['TMP_10737(uint256[])']
		Expression: amountIn = amounts_scope_0[0]
		IRs:
			REF_3050(uint256) -> amounts_scope_0[0]
			amountIn(uint256) := REF_3050(uint256)
		Expression: amountOut == 0
		IRs:
			TMP_10738(bool) = amountOut == 0
			CONDITION TMP_10738
		Expression: revert SwapFailed()()
		IRs:
			TMP_10739(None) = SOLIDITY_CALL revert SwapFailed()()
Contract UniV3Library
	Function UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams) (*)
		Expression: params.underlyingIn == address(0)
		IRs:
			REF_3051(address) -> params.underlyingIn
			TMP_10740 = CONVERT 0 to address
			TMP_10741(bool) = REF_3051 == TMP_10740
			CONDITION TMP_10741
		Expression: revert InvalidInputToken()()
		IRs:
			TMP_10742(None) = SOLIDITY_CALL revert InvalidInputToken()()
		Expression: params.underlyingOut == address(0)
		IRs:
			REF_3052(address) -> params.underlyingOut
			TMP_10743 = CONVERT 0 to address
			TMP_10744(bool) = REF_3052 == TMP_10743
			CONDITION TMP_10744
		Expression: revert InvalidOutputToken()()
		IRs:
			TMP_10745(None) = SOLIDITY_CALL revert InvalidOutputToken()()
		Expression: fee = abi.decode(params.payload,(uint24))
		IRs:
			REF_3054(bytes) -> params.payload
			TMP_10746(uint24) = SOLIDITY_CALL abi.decode()(REF_3054,uint24)
			fee(uint24) := TMP_10746(uint24)
		Expression: fee == 0
		IRs:
			TMP_10747(bool) = fee == 0
			CONDITION TMP_10747
		Expression: revert InvalidFeeTier()()
		IRs:
			TMP_10748(None) = SOLIDITY_CALL revert InvalidFeeTier()()
		Expression: params.mode == ISwapHandler.SwapType.EXACT_INPUT
		IRs:
			REF_3055(ISwapHandler.SwapType) -> params.mode
			REF_3056(ISwapHandler.SwapType) -> SwapType.EXACT_INPUT
			TMP_10749(bool) = REF_3055 == REF_3056
			CONDITION TMP_10749
		Expression: amountIn = params.amountIn
		IRs:
			REF_3057(uint256) -> params.amountIn
			amountIn(uint256) := REF_3057(uint256)
		Expression: amountOut = router.exactInputSingle(IV3SwapRouter.ExactInputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,amountIn:amountIn,amountOutMinimum:params.amountOut,fee:fee,recipient:address(this),sqrtPriceLimitX96:0}))
		IRs:
			REF_3060(address) -> params.underlyingIn
			REF_3061(address) -> params.underlyingOut
			REF_3062(uint256) -> params.amountOut
			TMP_10750 = CONVERT this to address
			TMP_10751(IV3SwapRouter.ExactInputSingleParams) = new ExactInputSingleParams(REF_3060,REF_3061,fee,TMP_10750,amountIn,REF_3062,0)
			TMP_10752(uint256) = HIGH_LEVEL_CALL, dest:router(IV3SwapRouter), function:exactInputSingle, arguments:['TMP_10751']  
			amountOut(uint256) := TMP_10752(uint256)
		Expression: amountOut == 0
		IRs:
			TMP_10753(bool) = amountOut == 0
			CONDITION TMP_10753
		Expression: revert SwapFailed()()
		IRs:
			TMP_10754(None) = SOLIDITY_CALL revert SwapFailed()()
		Expression: params.mode == ISwapHandler.SwapType.EXACT_OUTPUT
		IRs:
			REF_3063(ISwapHandler.SwapType) -> params.mode
			REF_3064(ISwapHandler.SwapType) -> SwapType.EXACT_OUTPUT
			TMP_10755(bool) = REF_3063 == REF_3064
			CONDITION TMP_10755
		Expression: amountOut = params.amountOut
		IRs:
			REF_3065(uint256) -> params.amountOut
			amountOut(uint256) := REF_3065(uint256)
		Expression: amountIn = router.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,fee:fee,recipient:address(this),amountOut:amountOut,amountInMaximum:params.amountIn,sqrtPriceLimitX96:0}))
		IRs:
			REF_3068(address) -> params.underlyingIn
			REF_3069(address) -> params.underlyingOut
			TMP_10756 = CONVERT this to address
			REF_3070(uint256) -> params.amountIn
			TMP_10757(IV3SwapRouter.ExactOutputSingleParams) = new ExactOutputSingleParams(REF_3068,REF_3069,fee,TMP_10756,amountOut,REF_3070,0)
			TMP_10758(uint256) = HIGH_LEVEL_CALL, dest:router(IV3SwapRouter), function:exactOutputSingle, arguments:['TMP_10757']  
			amountIn(uint256) := TMP_10758(uint256)
Contract AccountToken
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_10759(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10759)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_10761(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_10762(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_10763(bool) = TMP_10761 == TMP_10762
			TMP_10764(None) = SOLIDITY_CALL require(bool,string)(TMP_10763,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_10765 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_10765)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_10768 = CONVERT 0 to address
			TMP_10769(bool) = newOwner != TMP_10768
			TMP_10770(None) = SOLIDITY_CALL require(bool,string)(TMP_10769,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20Burnable.burn(uint256) (*)
		Expression: _burn(_msgSender(),amount)
		IRs:
			TMP_10774(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20._burn(address,uint256)(TMP_10774,amount)
	Function ERC20Burnable.burnFrom(address,uint256) (*)
		Expression: _spendAllowance(account,_msgSender(),amount)
		IRs:
			TMP_10776(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(account,TMP_10776,amount)
		Expression: _burn(account,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(account,amount)
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_3071(uint256) -> _balances[account]
			RETURN REF_3071
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10779(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10779(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_3072(mapping(address => uint256)) -> _allowances[owner]
			REF_3073(uint256) -> REF_3072[spender]
			RETURN REF_3073
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10781(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10781(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_10783(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_10783(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10786(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10786(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_10787(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_10788(uint256) = TMP_10787 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10788)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10790(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10790(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_10791(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_10791(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_10792(bool) = currentAllowance >= subtractedValue
			TMP_10793(None) = SOLIDITY_CALL require(bool,string)(TMP_10792,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_10794(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10794)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_10796 = CONVERT 0 to address
			TMP_10797(bool) = from != TMP_10796
			TMP_10798(None) = SOLIDITY_CALL require(bool,string)(TMP_10797,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_10799 = CONVERT 0 to address
			TMP_10800(bool) = to != TMP_10799
			TMP_10801(None) = SOLIDITY_CALL require(bool,string)(TMP_10800,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_3074(uint256) -> _balances[from]
			fromBalance(uint256) := REF_3074(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_10803(bool) = fromBalance >= amount
			TMP_10804(None) = SOLIDITY_CALL require(bool,string)(TMP_10803,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_3075(uint256) -> _balances[from]
			TMP_10805(uint256) = fromBalance - amount
			REF_3075(uint256) (->_balances) := TMP_10805(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_3076(uint256) -> _balances[to]
			REF_3076(-> _balances) = REF_3076 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_10808 = CONVERT 0 to address
			TMP_10809(bool) = account != TMP_10808
			TMP_10810(None) = SOLIDITY_CALL require(bool,string)(TMP_10809,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_10811 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_10811,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_3077(uint256) -> _balances[account]
			REF_3077(-> _balances) = REF_3077 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_10813 = CONVERT 0 to address
			Emit Transfer(TMP_10813,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_10815 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_10815,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_10817 = CONVERT 0 to address
			TMP_10818(bool) = account != TMP_10817
			TMP_10819(None) = SOLIDITY_CALL require(bool,string)(TMP_10818,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_10820 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_10820,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_3078(uint256) -> _balances[account]
			accountBalance(uint256) := REF_3078(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_10822(bool) = accountBalance >= amount
			TMP_10823(None) = SOLIDITY_CALL require(bool,string)(TMP_10822,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_3079(uint256) -> _balances[account]
			TMP_10824(uint256) = accountBalance - amount
			REF_3079(uint256) (->_balances) := TMP_10824(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_10825 = CONVERT 0 to address
			Emit Transfer(account,TMP_10825,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_10827 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_10827,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_10829 = CONVERT 0 to address
			TMP_10830(bool) = owner != TMP_10829
			TMP_10831(None) = SOLIDITY_CALL require(bool,string)(TMP_10830,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_10832 = CONVERT 0 to address
			TMP_10833(bool) = spender != TMP_10832
			TMP_10834(None) = SOLIDITY_CALL require(bool,string)(TMP_10833,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_3080(mapping(address => uint256)) -> _allowances[owner]
			REF_3081(uint256) -> REF_3080[spender]
			REF_3081(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_10836(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_10836(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_10838(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_10839(bool) = currentAllowance != TMP_10838
			CONDITION TMP_10839
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_10840(bool) = currentAllowance >= amount
			TMP_10841(None) = SOLIDITY_CALL require(bool,string)(TMP_10840,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_10842(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10842)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function AccountToken.constructor(address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(initialOwner)
		Expression: ERC20(MyToken,MTK)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(MyToken,MTK)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Function AccountToken.mint(address,uint256) (*)
		Expression: _mint(to,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(to,amount)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function AccountToken.burn(address,uint256) (*)
		Expression: _burn(from,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(from,amount)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract AaveV3PoolMock
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_3082(uint256) -> _balances[account]
			RETURN REF_3082
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10852(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10852(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_3083(mapping(address => uint256)) -> _allowances[owner]
			REF_3084(uint256) -> REF_3083[spender]
			RETURN REF_3084
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10854(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10854(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_10856(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_10856(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10859(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10859(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_10860(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_10861(uint256) = TMP_10860 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10861)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_10863(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_10863(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_10864(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_10864(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_10865(bool) = currentAllowance >= subtractedValue
			TMP_10866(None) = SOLIDITY_CALL require(bool,string)(TMP_10865,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_10867(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10867)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_10869 = CONVERT 0 to address
			TMP_10870(bool) = from != TMP_10869
			TMP_10871(None) = SOLIDITY_CALL require(bool,string)(TMP_10870,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_10872 = CONVERT 0 to address
			TMP_10873(bool) = to != TMP_10872
			TMP_10874(None) = SOLIDITY_CALL require(bool,string)(TMP_10873,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_3085(uint256) -> _balances[from]
			fromBalance(uint256) := REF_3085(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_10876(bool) = fromBalance >= amount
			TMP_10877(None) = SOLIDITY_CALL require(bool,string)(TMP_10876,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_3086(uint256) -> _balances[from]
			TMP_10878(uint256) = fromBalance - amount
			REF_3086(uint256) (->_balances) := TMP_10878(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_3087(uint256) -> _balances[to]
			REF_3087(-> _balances) = REF_3087 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_10881 = CONVERT 0 to address
			TMP_10882(bool) = account != TMP_10881
			TMP_10883(None) = SOLIDITY_CALL require(bool,string)(TMP_10882,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_10884 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_10884,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_3088(uint256) -> _balances[account]
			REF_3088(-> _balances) = REF_3088 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_10886 = CONVERT 0 to address
			Emit Transfer(TMP_10886,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_10888 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_10888,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_10890 = CONVERT 0 to address
			TMP_10891(bool) = account != TMP_10890
			TMP_10892(None) = SOLIDITY_CALL require(bool,string)(TMP_10891,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_10893 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_10893,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_3089(uint256) -> _balances[account]
			accountBalance(uint256) := REF_3089(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_10895(bool) = accountBalance >= amount
			TMP_10896(None) = SOLIDITY_CALL require(bool,string)(TMP_10895,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_3090(uint256) -> _balances[account]
			TMP_10897(uint256) = accountBalance - amount
			REF_3090(uint256) (->_balances) := TMP_10897(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_10898 = CONVERT 0 to address
			Emit Transfer(account,TMP_10898,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_10900 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_10900,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_10902 = CONVERT 0 to address
			TMP_10903(bool) = owner != TMP_10902
			TMP_10904(None) = SOLIDITY_CALL require(bool,string)(TMP_10903,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_10905 = CONVERT 0 to address
			TMP_10906(bool) = spender != TMP_10905
			TMP_10907(None) = SOLIDITY_CALL require(bool,string)(TMP_10906,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_3091(mapping(address => uint256)) -> _allowances[owner]
			REF_3092(uint256) -> REF_3091[spender]
			REF_3092(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_10909(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_10909(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_10911(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_10912(bool) = currentAllowance != TMP_10911
			CONDITION TMP_10912
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_10913(bool) = currentAllowance >= amount
			TMP_10914(None) = SOLIDITY_CALL require(bool,string)(TMP_10913,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_10915(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_10915)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IPoolV3.mintUnbacked(address,uint256,address,uint16) 
	Function IPoolV3.backUnbacked(address,uint256,uint256) 
	Function IPoolV3.supply(address,uint256,address,uint16) 
	Function IPoolV3.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) 
	Function IPoolV3.withdraw(address,uint256,address) 
	Function IPoolV3.borrow(address,uint256,uint256,uint16,address) 
	Function IPoolV3.repay(address,uint256,uint256,address) 
	Function IPoolV3.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) 
	Function IPoolV3.repayWithATokens(address,uint256,uint256) 
	Function IPoolV3.swapBorrowRateMode(address,uint256) 
	Function IPoolV3.rebalanceStableBorrowRate(address,address) 
	Function IPoolV3.setUserUseReserveAsCollateral(address,bool) 
	Function IPoolV3.liquidationCall(address,address,address,uint256,bool) 
	Function IPoolV3.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) 
	Function IPoolV3.flashLoanSimple(address,address,uint256,bytes,uint16) 
	Function IPoolV3.getUserAccountData(address) 
	Function IPoolV3.initReserve(address,address,address,address,address) 
	Function IPoolV3.dropReserve(address) 
	Function IPoolV3.setReserveInterestRateStrategyAddress(address,address) 
	Function IPoolV3.setConfiguration(address,DataTypes.ReserveConfigurationMap) 
	Function IPoolV3.getConfiguration(address) 
	Function IPoolV3.getUserConfiguration(address) 
	Function IPoolV3.getReserveNormalizedIncome(address) 
	Function IPoolV3.getReserveNormalizedVariableDebt(address) 
	Function IPoolV3.getReserveData(address) 
	Function IPoolV3.finalizeTransfer(address,address,address,uint256,uint256,uint256) 
	Function IPoolV3.getReservesList() 
	Function IPoolV3.ADDRESSES_PROVIDER() 
	Function IPoolV3.updateBridgeProtocolFee(uint256) 
	Function IPoolV3.updateFlashloanPremiums(uint128,uint128) 
	Function IPoolV3.configureEModeCategory(uint8,DataTypes.EModeCategory) 
	Function IPoolV3.getEModeCategoryData(uint8) 
	Function IPoolV3.setUserEMode(uint8) 
	Function IPoolV3.getUserEMode(address) 
	Function IPoolV3.resetIsolationModeTotalDebt(address) 
	Function IPoolV3.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() 
	Function IPoolV3.FLASHLOAN_PREMIUM_TOTAL() 
	Function IPoolV3.BRIDGE_PROTOCOL_FEE() 
	Function IPoolV3.FLASHLOAN_PREMIUM_TO_PROTOCOL() 
	Function IPoolV3.MAX_NUMBER_RESERVES() 
	Function IPoolV3.mintToTreasury(address[]) 
	Function IPoolV3.rescueTokens(address,address,uint256) 
	Function IPoolV3.deposit(address,uint256,address,uint16) 
	Function IPoolV3.getReserveAddressById(uint16) 
	Function AaveV3PoolMock.constructor(IERC20,IERC20) (*)
		Expression: _collateralToken = collateralToken
		IRs:
			_collateralToken(IERC20) := collateralToken(IERC20)
		Expression: _borrowedToken = borrowedToken
		IRs:
			_borrowedToken(IERC20) := borrowedToken(IERC20)
		Expression: _collateralAToken = new AccountToken(address(this))
		IRs:
			TMP_10918 = CONVERT this to address
			TMP_10919(AccountToken) = new AccountToken(TMP_10918) 
			_collateralAToken(AccountToken) := TMP_10919(AccountToken)
		Expression: _borrowedAToken = new AccountToken(address(this))
		IRs:
			TMP_10921 = CONVERT this to address
			TMP_10922(AccountToken) = new AccountToken(TMP_10921) 
			_borrowedAToken(AccountToken) := TMP_10922(AccountToken)
		Expression: ERC20(Collateral ETH,AWETH)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(Collateral ETH,AWETH)
	Function AaveV3PoolMock.mintUnbacked(address,uint256,address,uint16) (*)
	Function AaveV3PoolMock.setCollateralPerEth(uint256) (*)
		Expression: _collateralPerEth = price
		IRs:
			_collateralPerEth(uint256) := price(uint256)
	Function AaveV3PoolMock.setBorrowedPerEth(uint256) (*)
		Expression: _borrowedPerETh = price
		IRs:
			_borrowedPerETh(uint256) := price(uint256)
	Function AaveV3PoolMock.getCollateralPerEth() (*)
		Expression: _collateralPerEth
		IRs:
			RETURN _collateralPerEth
	Function AaveV3PoolMock.getBorrowedPerEth() (*)
		Expression: _borrowedPerETh
		IRs:
			RETURN _borrowedPerETh
	Function AaveV3PoolMock.backUnbacked(address,uint256,uint256) (*)
	Function AaveV3PoolMock.supply(address,uint256,address,uint16) (*)
		Expression: require(bool,string)(asset == address(_collateralToken),Invalid Token for supply)
		IRs:
			TMP_10924 = CONVERT _collateralToken to address
			TMP_10925(bool) = asset == TMP_10924
			TMP_10926(None) = SOLIDITY_CALL require(bool,string)(TMP_10925,Invalid Token for supply)
		Expression: require(bool,string)(amount > 0,Amount must be greater than 0)
		IRs:
			TMP_10927(bool) = amount > 0
			TMP_10928(None) = SOLIDITY_CALL require(bool,string)(TMP_10927,Amount must be greater than 0)
		Expression: _collateralToken.transferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_10929 = CONVERT this to address
			TMP_10930(bool) = HIGH_LEVEL_CALL, dest:_collateralToken(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_10929', 'amount']  
		Expression: _collateralAToken.mint(msg.sender,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:_collateralAToken(AccountToken), function:mint, arguments:['msg.sender', 'amount']  
		Expression: users[msg.sender].depositAmount = users[msg.sender].depositAmount + amount
		IRs:
			REF_3095(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3096(uint256) -> REF_3095.depositAmount
			REF_3097(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3098(uint256) -> REF_3097.depositAmount
			TMP_10932(uint256) = REF_3098 (c)+ amount
			REF_3096(uint256) (->users) := TMP_10932(uint256)
		Expression: _mint(msg.sender,amount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(msg.sender,amount)
		Expression: Supply(asset,msg.sender,msg.sender,amount,0)
		IRs:
			Emit Supply(asset,msg.sender,msg.sender,amount,0)
	Function AaveV3PoolMock.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)
	Function AaveV3PoolMock.withdraw(address,uint256,address) (*)
		Expression: require(bool)(asset == address(_collateralToken))
		IRs:
			TMP_10935 = CONVERT _collateralToken to address
			TMP_10936(bool) = asset == TMP_10935
			TMP_10937(None) = SOLIDITY_CALL require(bool)(TMP_10936)
		Expression: require(bool)(asset == address(_collateralToken))
		IRs:
			TMP_10938 = CONVERT _collateralToken to address
			TMP_10939(bool) = asset == TMP_10938
			TMP_10940(None) = SOLIDITY_CALL require(bool)(TMP_10939)
		Expression: users[msg.sender].depositAmount -= amount
		IRs:
			REF_3099(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3100(uint256) -> REF_3099.depositAmount
			REF_3100(-> users) = REF_3100 (c)- amount
		Expression: (_collateralToken).transfer(msg.sender,amount)
		IRs:
			TMP_10941(bool) = HIGH_LEVEL_CALL, dest:_collateralToken(IERC20), function:transfer, arguments:['msg.sender', 'amount']  
		Expression: _collateralAToken.burn(msg.sender,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:_collateralAToken(AccountToken), function:burn, arguments:['msg.sender', 'amount']  
		Expression: _burn(msg.sender,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,amount)
		Expression: Withdraw(asset,msg.sender,msg.sender,amount)
		IRs:
			Emit Withdraw(asset,msg.sender,msg.sender,amount)
		Expression: amount
		IRs:
			RETURN amount
	Function AaveV3PoolMock.borrow(address,uint256,uint256,uint16,address) (*)
		Expression: require(bool,string)(users[msg.sender].depositAmount - users[msg.sender].borrowedAmount >= amount,Not Enough Balance to Borrow)
		IRs:
			REF_3103(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3104(uint256) -> REF_3103.depositAmount
			REF_3105(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3106(uint256) -> REF_3105.borrowedAmount
			TMP_10945(uint256) = REF_3104 (c)- REF_3106
			TMP_10946(bool) = TMP_10945 >= amount
			TMP_10947(None) = SOLIDITY_CALL require(bool,string)(TMP_10946,Not Enough Balance to Borrow)
		Expression: _borrowedToken.transfer(onBehalfOf,amount)
		IRs:
			TMP_10948(bool) = HIGH_LEVEL_CALL, dest:_borrowedToken(IERC20), function:transfer, arguments:['onBehalfOf', 'amount']  
		Expression: _borrowedAToken.mint(msg.sender,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:_borrowedAToken(AccountToken), function:mint, arguments:['msg.sender', 'amount']  
		Expression: users[msg.sender].borrowedAmount += amount
		IRs:
			REF_3109(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3110(uint256) -> REF_3109.borrowedAmount
			REF_3110(-> users) = REF_3110 (c)+ amount
		Expression: Borrow(asset,msg.sender,msg.sender,amount,DataTypes.InterestRateMode.NONE,0,0)
		IRs:
			REF_3111(DataTypes.InterestRateMode) -> InterestRateMode.NONE
			Emit Borrow(asset,msg.sender,msg.sender,amount,REF_3111,0,0)
	Function AaveV3PoolMock.repay(address,uint256,uint256,address) (*)
		Expression: users[msg.sender].borrowedAmount -= amount
		IRs:
			REF_3112(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3113(uint256) -> REF_3112.borrowedAmount
			REF_3113(-> users) = REF_3113 (c)- amount
		Expression: _borrowedToken.transfer(onBehalfOf,amount)
		IRs:
			TMP_10951(bool) = HIGH_LEVEL_CALL, dest:_borrowedToken(IERC20), function:transfer, arguments:['onBehalfOf', 'amount']  
		Expression: _borrowedAToken.burn(msg.sender,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:_borrowedAToken(AccountToken), function:burn, arguments:['msg.sender', 'amount']  
		Expression: Repay(asset,msg.sender,msg.sender,amount,false)
		IRs:
			Emit Repay(asset,msg.sender,msg.sender,amount,False)
		Expression: amount
		IRs:
			RETURN amount
	Function AaveV3PoolMock.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)
	Function AaveV3PoolMock.repayWithATokens(address,uint256,uint256) (*)
		Expression: users[msg.sender].depositAmount -= amount
		IRs:
			REF_3116(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3117(uint256) -> REF_3116.depositAmount
			REF_3117(-> users) = REF_3117 (c)- amount
		Expression: users[msg.sender].borrowedAmount -= (amount * _collateralPerEth) / 1e9
		IRs:
			REF_3118(AaveV3PoolMock.UserInfo) -> users[msg.sender]
			REF_3119(uint256) -> REF_3118.borrowedAmount
			TMP_10954(uint256) = amount (c)* _collateralPerEth
			TMP_10955(uint256) = TMP_10954 (c)/ 1000000000
			REF_3119(-> users) = REF_3119 (c)- TMP_10955
		Expression: _burn(msg.sender,amount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,amount)
		Expression: amount
		IRs:
			RETURN amount
	Function AaveV3PoolMock.swapBorrowRateMode(address,uint256) (*)
	Function AaveV3PoolMock.rebalanceStableBorrowRate(address,address) (*)
	Function AaveV3PoolMock.setUserUseReserveAsCollateral(address,bool) (*)
	Function AaveV3PoolMock.liquidationCall(address,address,address,uint256,bool) (*)
	Function AaveV3PoolMock.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)
	Function AaveV3PoolMock.flashLoanSimple(address,address,uint256,bytes,uint16) (*)
	Function AaveV3PoolMock.getUserAccountData(address) (*)
		Expression: totalCollateralBase = (users[user].depositAmount * _collateralPerEth) / _pricePrecision / 1e10
		IRs:
			REF_3120(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3121(uint256) -> REF_3120.depositAmount
			TMP_10957(uint256) = REF_3121 (c)* _collateralPerEth
			TMP_10958(uint256) = TMP_10957 (c)/ _pricePrecision
			TMP_10959(uint256) = TMP_10958 (c)/ 10000000000
			totalCollateralBase(uint256) := TMP_10959(uint256)
		Expression: totalDebtBase = (users[user].borrowedAmount * _borrowedPerETh) / _pricePrecision / 1e10
		IRs:
			REF_3122(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3123(uint256) -> REF_3122.borrowedAmount
			TMP_10960(uint256) = REF_3123 (c)* _borrowedPerETh
			TMP_10961(uint256) = TMP_10960 (c)/ _pricePrecision
			TMP_10962(uint256) = TMP_10961 (c)/ 10000000000
			totalDebtBase(uint256) := TMP_10962(uint256)
		Expression: availableBorrowsBase = 0
		IRs:
			availableBorrowsBase(uint256) := 0(uint256)
		Expression: currentLiquidationThreshold = (users[user].depositAmount * LOAN_LIQUIDATION_THRESHOLD) / LOAN_TO_VALUE_PRECISION
		IRs:
			REF_3124(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3125(uint256) -> REF_3124.depositAmount
			TMP_10963(uint256) = REF_3125 (c)* LOAN_LIQUIDATION_THRESHOLD
			TMP_10964(uint256) = TMP_10963 (c)/ LOAN_TO_VALUE_PRECISION
			currentLiquidationThreshold(uint256) := TMP_10964(uint256)
		Expression: users[user].depositAmount > 0
		IRs:
			REF_3126(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3127(uint256) -> REF_3126.depositAmount
			TMP_10965(bool) = REF_3127 > 0
			CONDITION TMP_10965
		Expression: ltv = (users[user].borrowedAmount * LOAN_TO_VALUE_PRECISION) / (users[user].depositAmount)
		IRs:
			REF_3128(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3129(uint256) -> REF_3128.borrowedAmount
			TMP_10966(uint256) = REF_3129 (c)* LOAN_TO_VALUE_PRECISION
			REF_3130(AaveV3PoolMock.UserInfo) -> users[user]
			REF_3131(uint256) -> REF_3130.depositAmount
			TMP_10967(uint256) = TMP_10966 (c)/ REF_3131
			ltv(uint256) := TMP_10967(uint256)
		Expression: ltv = 0
		IRs:
			ltv(uint256) := 0(uint256)
		Expression: healthFactor = 1
		IRs:
			healthFactor(uint256) := 1(uint256)
	Function AaveV3PoolMock.initReserve(address,address,address,address,address) (*)
	Function AaveV3PoolMock.dropReserve(address) (*)
	Function AaveV3PoolMock.setReserveInterestRateStrategyAddress(address,address) (*)
	Function AaveV3PoolMock.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)
	Function AaveV3PoolMock.getConfiguration(address) (*)
	Function AaveV3PoolMock.getUserConfiguration(address) (*)
	Function AaveV3PoolMock.getReserveNormalizedIncome(address) (*)
	Function AaveV3PoolMock.getReserveNormalizedVariableDebt(address) (*)
	Function AaveV3PoolMock.getReserveData(address) (*)
		Expression: asset == address(_collateralToken)
		IRs:
			TMP_10968 = CONVERT _collateralToken to address
			TMP_10969(bool) = asset == TMP_10968
			CONDITION TMP_10969
		Expression: output.aTokenAddress = address(_collateralAToken)
		IRs:
			REF_3132(address) -> output.aTokenAddress
			TMP_10970 = CONVERT _collateralAToken to address
			REF_3132(address) (->output) := TMP_10970(address)
		Expression: asset == address(_borrowedToken)
		IRs:
			TMP_10971 = CONVERT _borrowedToken to address
			TMP_10972(bool) = asset == TMP_10971
			CONDITION TMP_10972
		Expression: output.variableDebtTokenAddress = address(_borrowedAToken)
		IRs:
			REF_3133(address) -> output.variableDebtTokenAddress
			TMP_10973 = CONVERT _borrowedAToken to address
			REF_3133(address) (->output) := TMP_10973(address)
		Expression: output
		IRs:
			RETURN output
	Function AaveV3PoolMock.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)
	Function AaveV3PoolMock.getReservesList() (*)
	Function AaveV3PoolMock.ADDRESSES_PROVIDER() (*)
	Function AaveV3PoolMock.updateBridgeProtocolFee(uint256) (*)
	Function AaveV3PoolMock.updateFlashloanPremiums(uint128,uint128) (*)
	Function AaveV3PoolMock.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)
	Function AaveV3PoolMock.getEModeCategoryData(uint8) (*)
	Function AaveV3PoolMock.setUserEMode(uint8) (*)
		Expression: _emode = categoryId
		IRs:
			_emode(uint8) := categoryId(uint8)
	Function AaveV3PoolMock.getUserEMode(address) (*)
		Expression: _emode
		IRs:
			RETURN _emode
	Function AaveV3PoolMock.resetIsolationModeTotalDebt(address) (*)
	Function AaveV3PoolMock.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)
	Function AaveV3PoolMock.FLASHLOAN_PREMIUM_TOTAL() (*)
	Function AaveV3PoolMock.BRIDGE_PROTOCOL_FEE() (*)
	Function AaveV3PoolMock.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)
	Function AaveV3PoolMock.MAX_NUMBER_RESERVES() (*)
	Function AaveV3PoolMock.mintToTreasury(address[]) (*)
	Function AaveV3PoolMock.rescueTokens(address,address,uint256) (*)
	Function AaveV3PoolMock.deposit(address,uint256,address,uint16) (*)
	Function AaveV3PoolMock.getReserveAddressById(uint16) (*)
	Function AaveV3PoolMock.mintAtokensArbitrarily(address,uint256) (*)
		Expression: _collateralAToken.mint(to,amount)
		IRs:
			HIGH_LEVEL_CALL, dest:_collateralAToken(AccountToken), function:mint, arguments:['to', 'amount']  
	Function AaveV3PoolMock.slitherConstructorVariables() (*)
		Expression: _collateralPerEth = 1130 * (1e6)
		IRs:
			TMP_10975(uint256) = 1130 (c)* 1000000
			_collateralPerEth(uint256) := TMP_10975(uint256)
		Expression: _borrowedPerETh = 1000 * (1e6)
		IRs:
			TMP_10976(uint256) = 1000 (c)* 1000000
			_borrowedPerETh(uint256) := TMP_10976(uint256)
		Expression: _pricePrecision = 1000 * (1e6)
		IRs:
			TMP_10977(uint256) = 1000 (c)* 1000000
			_pricePrecision(uint256) := TMP_10977(uint256)
	Function AaveV3PoolMock.slitherConstructorConstantVariables() (*)
		Expression: LOAN_TO_VALUE_PRECISION = 100000
		IRs:
			LOAN_TO_VALUE_PRECISION(uint256) := 100000(uint256)
		Expression: LOAN_LIQUIDATION_THRESHOLD = 80000
		IRs:
			LOAN_LIQUIDATION_THRESHOLD(uint256) := 80000(uint256)
Contract BalancerVaultMock
	Function IProtocolFeesCollector.getFlashLoanFeePercentage() 
	Function IVault.swap(IVault.SingleSwap,IVault.FundManagement,uint256,uint256) 
	Function IVault.querySwap(IVault.SingleSwap,IVault.FundManagement) 
	Function IVault.getProtocolFeesCollector() 
	Function IFlashLoans.flashLoan(address,address[],uint256[],bytes) 
	Function BalancerVaultMock.constructor(IERC20) (*)
		Expression: _flashLoanToken = flashLoanToken
		IRs:
			_flashLoanToken(IERC20) := flashLoanToken(IERC20)
	Function BalancerVaultMock.getProtocolFeesCollector() (*)
		Expression: this
		IRs:
			RETURN this
	Function BalancerVaultMock.getFlashLoanFeePercentage() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function BalancerVaultMock.flashLoan(address,address[],uint256[],bytes) (*)
		Expression: tokens.length != 1
		IRs:
			REF_3135 -> LENGTH tokens
			TMP_10978(bool) = REF_3135 != 1
			CONDITION TMP_10978
		Expression: revert InvalidTokenList()()
		IRs:
			TMP_10979(None) = SOLIDITY_CALL revert InvalidTokenList()()
		Expression: amounts.length != 1
		IRs:
			REF_3136 -> LENGTH amounts
			TMP_10980(bool) = REF_3136 != 1
			CONDITION TMP_10980
		Expression: revert InvalidAmountList()()
		IRs:
			TMP_10981(None) = SOLIDITY_CALL revert InvalidAmountList()()
		Expression: tokens[0] != address(_flashLoanToken)
		IRs:
			REF_3137(address) -> tokens[0]
			TMP_10982 = CONVERT _flashLoanToken to address
			TMP_10983(bool) = REF_3137 != TMP_10982
			CONDITION TMP_10983
		Expression: revert InvalidToken()()
		IRs:
			TMP_10984(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: balanceBefore = _flashLoanToken.balanceOf(address(this))
		IRs:
			TMP_10985 = CONVERT this to address
			TMP_10986(uint256) = HIGH_LEVEL_CALL, dest:_flashLoanToken(IERC20), function:balanceOf, arguments:['TMP_10985']  
			balanceBefore(uint256) := TMP_10986(uint256)
		Expression: balanceBefore <= amounts[0]
		IRs:
			REF_3139(uint256) -> amounts[0]
			TMP_10987(bool) = balanceBefore <= REF_3139
			CONDITION TMP_10987
		Expression: revert NoEnoughBalance()()
		IRs:
			TMP_10988(None) = SOLIDITY_CALL revert NoEnoughBalance()()
		Expression: fees = new uint256[](1)
		IRs:
			TMP_10990(uint256[])  = new uint256[](1)
			fees(uint256[]) = ['TMP_10990(uint256[])']
		Expression: _flashLoanToken.transfer(recipient,amounts[0])
		IRs:
			REF_3141(uint256) -> amounts[0]
			TMP_10991(bool) = HIGH_LEVEL_CALL, dest:_flashLoanToken(IERC20), function:transfer, arguments:['recipient', 'REF_3141']  
		Expression: IFlashLoanRecipient(recipient).receiveFlashLoan(tokens,amounts,fees,userData)
		IRs:
			TMP_10992 = CONVERT recipient to IFlashLoanRecipient
			HIGH_LEVEL_CALL, dest:TMP_10992(IFlashLoanRecipient), function:receiveFlashLoan, arguments:['tokens', 'amounts', 'fees', 'userData']  
		Expression: balanceAfter = _flashLoanToken.balanceOf(address(this))
		IRs:
			TMP_10994 = CONVERT this to address
			TMP_10995(uint256) = HIGH_LEVEL_CALL, dest:_flashLoanToken(IERC20), function:balanceOf, arguments:['TMP_10994']  
			balanceAfter(uint256) := TMP_10995(uint256)
		Expression: balanceAfter < balanceBefore
		IRs:
			TMP_10996(bool) = balanceAfter < balanceBefore
			CONDITION TMP_10996
		Expression: revert LoanNotPaid()()
		IRs:
			TMP_10997(None) = SOLIDITY_CALL revert LoanNotPaid()()
	Function BalancerVaultMock.swap(IVault.SingleSwap,IVault.FundManagement,uint256,uint256) (*)
		Expression: 0
		IRs:
			RETURN 0
	Function BalancerVaultMock.querySwap(IVault.SingleSwap,IVault.FundManagement) (*)
		Expression: 0
		IRs:
			RETURN 0
Contract BorrowerAttacker
	Function UseStrategy._initUseStrategy(address) (*)
		Expression: _strategy = IStrategy(istrategy)
		IRs:
			TMP_10998 = CONVERT istrategy to IStrategy
			_strategy(IStrategy) := TMP_10998(IStrategy)
		Expression: address(_strategy) == address(0)
		IRs:
			TMP_10999 = CONVERT _strategy to address
			TMP_11000 = CONVERT 0 to address
			TMP_11001(bool) = TMP_10999 == TMP_11000
			CONDITION TMP_11001
		Expression: revert InvalidStrategyContract()()
		IRs:
			TMP_11002(None) = SOLIDITY_CALL revert InvalidStrategyContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseStrategy.strategy() (*)
		Expression: _strategy
		IRs:
			RETURN _strategy
	Function UseStrategy.strategyA() (*)
		Expression: address(_strategy)
		IRs:
			TMP_11004 = CONVERT _strategy to address
			RETURN TMP_11004
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_11005 = UnaryType.BANG _initializing 
			TMP_11006(None) = SOLIDITY_CALL require(bool,string)(TMP_11005,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_11008(uint8) := 255(uint8)
			TMP_11009(bool) = _initialized != TMP_11008
			CONDITION TMP_11009
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_11011(uint8) := 255(uint8)
			_initialized(uint8) := TMP_11011(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_11013(uint8) := 255(uint8)
			Emit Initialized(TMP_11013)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_11015 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_11015(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_11016 = CONVERT _fLender to address
			TMP_11017 = CONVERT 0 to address
			TMP_11018(bool) = TMP_11016 == TMP_11017
			CONDITION TMP_11018
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_11019(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_11021 = CONVERT _fLender to address
			RETURN TMP_11021
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) 
	Function BorrowerAttacker.initialize(address,address) (*)
		Expression: _initUseFlashLender(flashLender)
		IRs:
			INTERNAL_CALL, UseFlashLender._initUseFlashLender(address)(flashLender)
		Expression: _initUseStrategy(istrategy)
		IRs:
			INTERNAL_CALL, UseStrategy._initUseStrategy(address)(istrategy)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function BorrowerAttacker.borrowed(address) (*)
		Expression: _totalBorrowed[token]
		IRs:
			REF_3144(uint256) -> _totalBorrowed[token]
			RETURN REF_3144
	Function BorrowerAttacker.flashme(address,uint256) (*)
		Expression: require(bool)(IERC20(token).approve(flashLenderA(),amount))
		IRs:
			TMP_11025 = CONVERT token to IERC20
			TMP_11026(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_11027(bool) = HIGH_LEVEL_CALL, dest:TMP_11025(IERC20), function:approve, arguments:['TMP_11026', 'amount']  
			TMP_11028(None) = SOLIDITY_CALL require(bool)(TMP_11027)
		Expression: flashLender().flashLoan(this,token,amount,0x)
		IRs:
			TMP_11029(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_11030(bool) = HIGH_LEVEL_CALL, dest:TMP_11029(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['this', 'token', 'amount', '0x']  
	Function BorrowerAttacker.onFlashLoan(address,address,uint256,uint256,bytes) (*)
		Expression: IERC3156FlashBorrowerUpgradeable(strategyA()).onFlashLoan(strategyA(),token,amount,0,0x0)
		IRs:
			TMP_11031(address) = INTERNAL_CALL, UseStrategy.strategyA()()
			TMP_11032 = CONVERT TMP_11031 to IERC3156FlashBorrowerUpgradeable
			TMP_11033(address) = INTERNAL_CALL, UseStrategy.strategyA()()
			TMP_11034(bytes32) = HIGH_LEVEL_CALL, dest:TMP_11032(IERC3156FlashBorrowerUpgradeable), function:onFlashLoan, arguments:['TMP_11033', 'token', 'amount', '0', '0x0']  
		Expression: CALLBACK_SUCCESS
		IRs:
			RETURN CALLBACK_SUCCESS
	Function BorrowerAttacker.slitherConstructorConstantVariables() (*)
		Expression: FLASH_LOAN_FEE_PRECISION = 100000
		IRs:
			FLASH_LOAN_FEE_PRECISION(uint256) := 100000(uint256)
		Expression: FLASH_LOAN_FEE = 100
		IRs:
			FLASH_LOAN_FEE(uint256) := 100(uint256)
		Expression: CALLBACK_SUCCESS = keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
		IRs:
			TMP_11035(bytes32) = SOLIDITY_CALL keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
			CALLBACK_SUCCESS(bytes32) := TMP_11035(bytes32)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_11036 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_11036(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_11037(bool) = _initialized < 1
			TMP_11038(bool) = isTopLevelCall && TMP_11037
			TMP_11039 = CONVERT this to address
			TMP_11040(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_11039'] 
			TMP_11041 = UnaryType.BANG TMP_11040 
			TMP_11042(bool) = _initialized == 1
			TMP_11043(bool) = TMP_11041 && TMP_11042
			TMP_11044(bool) = TMP_11038 || TMP_11043
			TMP_11045(None) = SOLIDITY_CALL require(bool,string)(TMP_11044,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_11047 = UnaryType.BANG _initializing 
			TMP_11048(bool) = _initialized < version
			TMP_11049(bool) = TMP_11047 && TMP_11048
			TMP_11050(None) = SOLIDITY_CALL require(bool,string)(TMP_11049,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_11052(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract ChainLinkAggregatorMock
	Function IChainlinkAggregator.decimals() 
	Function IChainlinkAggregator.latestAnswer() 
	Function IChainlinkAggregator.latestTimestamp() 
	Function IChainlinkAggregator.latestRound() 
	Function IChainlinkAggregator.getAnswer(uint256) 
	Function IChainlinkAggregator.getTimestamp(uint256) 
	Function IChainlinkAggregator.latestRoundData() 
	Function ChainLinkAggregatorMock.constructor() (*)
		Expression: _lastUpdate = block.timestamp
		IRs:
			_lastUpdate(uint256) := block.timestamp(uint256)
		Expression: _exchangeRate = 3500 * (10 ** _decimals)
		IRs:
			TMP_11053(uint256) = 10 (c)** _decimals
			TMP_11054(uint256) = 3500 (c)* TMP_11053
			_exchangeRate(uint256) := TMP_11054(uint256)
	Function ChainLinkAggregatorMock.setLatestPrice(uint256) (*)
		Expression: _exchangeRate = exchangeRate
		IRs:
			_exchangeRate(uint256) := exchangeRate(uint256)
		Expression: _lastUpdate = block.timestamp
		IRs:
			_lastUpdate(uint256) := block.timestamp(uint256)
	Function ChainLinkAggregatorMock.setDecimals(uint8) (*)
		Expression: _decimals = ldecimals
		IRs:
			_decimals(uint8) := ldecimals(uint8)
	Function ChainLinkAggregatorMock.decimals() (*)
		Expression: _decimals
		IRs:
			RETURN _decimals
	Function ChainLinkAggregatorMock.latestAnswer() (*)
		Expression: int256(_exchangeRate)
		IRs:
			TMP_11055 = CONVERT _exchangeRate to int256
			RETURN TMP_11055
	Function ChainLinkAggregatorMock.latestTimestamp() (*)
		Expression: _lastUpdate
		IRs:
			RETURN _lastUpdate
	Function ChainLinkAggregatorMock.latestRound() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ChainLinkAggregatorMock.getAnswer(uint256) (*)
		Expression: int256(_exchangeRate)
		IRs:
			TMP_11056 = CONVERT _exchangeRate to int256
			RETURN TMP_11056
	Function ChainLinkAggregatorMock.getTimestamp(uint256) (*)
		Expression: _lastUpdate
		IRs:
			RETURN _lastUpdate
	Function ChainLinkAggregatorMock.latestRoundData() (*)
		Expression: (0,int256(_exchangeRate),_lastUpdate,_lastUpdate,0)
		IRs:
			TMP_11057 = CONVERT _exchangeRate to int256
			RETURN 0,TMP_11057,_lastUpdate,_lastUpdate,0
	Function ChainLinkAggregatorMock.slitherConstructorVariables() (*)
		Expression: _decimals = 6
		IRs:
			_decimals(uint8) := 6(uint256)
Contract CommandMock
	Function CommandMock.pullInputParam(uint256[],uint256,uint64,uint8) (*)
		Expression: Commands.pullInputParam(callStack,value,inputMapping,position)
		IRs:
			TMP_11058(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'value', 'inputMapping', 'position'] 
			RETURN TMP_11058
	Function CommandMock.pushOutputParam(uint256[],uint256,uint64,uint8) (*)
		Expression: Commands.pushOutputParam(callStack,value,outputMapping,position)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'value', 'outputMapping', 'position'] 
		Expression: callStack
		IRs:
			RETURN callStack
Contract ERC20Mock
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_11060(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_11060)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_11062(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_11063(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_11064(bool) = TMP_11062 == TMP_11063
			TMP_11065(None) = SOLIDITY_CALL require(bool,string)(TMP_11064,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_11066 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_11066)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_11069 = CONVERT 0 to address
			TMP_11070(bool) = newOwner != TMP_11069
			TMP_11071(None) = SOLIDITY_CALL require(bool,string)(TMP_11070,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function ERC20Permit.constructor(string) (*)
		Expression: EIP712(name,1)
		IRs:
			INTERNAL_CALL, EIP712.constructor(string,string)(name,1)
	Function ERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)
		Expression: require(bool,string)(block.timestamp <= deadline,ERC20Permit: expired deadline)
		IRs:
			TMP_11076(bool) = block.timestamp <= deadline
			TMP_11077(None) = SOLIDITY_CALL require(bool,string)(TMP_11076,ERC20Permit: expired deadline)
		Expression: structHash = keccak256(bytes)(abi.encode(_PERMIT_TYPEHASH,owner,spender,value,_useNonce(owner),deadline))
		IRs:
			TMP_11078(uint256) = INTERNAL_CALL, ERC20Permit._useNonce(address)(owner)
			TMP_11079(bytes) = SOLIDITY_CALL abi.encode()(_PERMIT_TYPEHASH,owner,spender,value,TMP_11078,deadline)
			TMP_11080(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11079)
			structHash(bytes32) := TMP_11080(bytes32)
		Expression: hash = _hashTypedDataV4(structHash)
		IRs:
			TMP_11081(bytes32) = INTERNAL_CALL, EIP712._hashTypedDataV4(bytes32)(structHash)
			hash(bytes32) := TMP_11081(bytes32)
		Expression: signer = ECDSA.recover(hash,v,r,s)
		IRs:
			TMP_11082(address) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.recover(bytes32,uint8,bytes32,bytes32), arguments:['hash', 'v', 'r', 's'] 
			signer(address) := TMP_11082(address)
		Expression: require(bool,string)(signer == owner,ERC20Permit: invalid signature)
		IRs:
			TMP_11083(bool) = signer == owner
			TMP_11084(None) = SOLIDITY_CALL require(bool,string)(TMP_11083,ERC20Permit: invalid signature)
		Expression: _approve(owner,spender,value)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,value)
	Function ERC20Permit.nonces(address) (*)
		Expression: _nonces[owner].current()
		IRs:
			REF_3153(Counters.Counter) -> _nonces[owner]
			TMP_11086(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['REF_3153'] 
			RETURN TMP_11086
	Function ERC20Permit.DOMAIN_SEPARATOR() (*)
		Expression: _domainSeparatorV4()
		IRs:
			TMP_11087(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			RETURN TMP_11087
	Function ERC20Permit._useNonce(address) (*)
		Expression: nonce = _nonces[owner]
		IRs:
			REF_3155(Counters.Counter) -> _nonces[owner]
			nonce(Counters.Counter) := REF_3155(Counters.Counter)
		Expression: current = nonce.current()
		IRs:
			TMP_11088(uint256) = LIBRARY_CALL, dest:Counters, function:Counters.current(Counters.Counter), arguments:['nonce'] 
			current(uint256) := TMP_11088(uint256)
		Expression: nonce.increment()
		IRs:
			LIBRARY_CALL, dest:Counters, function:Counters.increment(Counters.Counter), arguments:['nonce'] 
	Function EIP712.constructor(string,string) (*)
		Expression: _name = name.toShortStringWithFallback(_nameFallback)
		IRs:
			TMP_11090(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['name', '_nameFallback'] 
			_name(ShortString) := TMP_11090(ShortString)
		Expression: _version = version.toShortStringWithFallback(_versionFallback)
		IRs:
			TMP_11091(ShortString) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toShortStringWithFallback(string,string), arguments:['version', '_versionFallback'] 
			_version(ShortString) := TMP_11091(ShortString)
		Expression: _hashedName = keccak256(bytes)(bytes(name))
		IRs:
			TMP_11092 = CONVERT name to bytes
			TMP_11093(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11092)
			_hashedName(bytes32) := TMP_11093(bytes32)
		Expression: _hashedVersion = keccak256(bytes)(bytes(version))
		IRs:
			TMP_11094 = CONVERT version to bytes
			TMP_11095(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11094)
			_hashedVersion(bytes32) := TMP_11095(bytes32)
		Expression: _cachedChainId = block.chainid
		IRs:
			_cachedChainId(uint256) := block.chainid(uint256)
		Expression: _cachedDomainSeparator = _buildDomainSeparator()
		IRs:
			TMP_11096(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			_cachedDomainSeparator(bytes32) := TMP_11096(bytes32)
		Expression: _cachedThis = address(this)
		IRs:
			TMP_11097 = CONVERT this to address
			_cachedThis(address) := TMP_11097(address)
	Function EIP712._domainSeparatorV4() (*)
		Expression: address(this) == _cachedThis && block.chainid == _cachedChainId
		IRs:
			TMP_11098 = CONVERT this to address
			TMP_11099(bool) = TMP_11098 == _cachedThis
			TMP_11100(bool) = block.chainid == _cachedChainId
			TMP_11101(bool) = TMP_11099 && TMP_11100
			CONDITION TMP_11101
		Expression: _cachedDomainSeparator
		IRs:
			RETURN _cachedDomainSeparator
		Expression: _buildDomainSeparator()
		IRs:
			TMP_11102(bytes32) = INTERNAL_CALL, EIP712._buildDomainSeparator()()
			RETURN TMP_11102
	Function EIP712._buildDomainSeparator() (*)
		Expression: keccak256(bytes)(abi.encode(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,address(this)))
		IRs:
			TMP_11103 = CONVERT this to address
			TMP_11104(bytes) = SOLIDITY_CALL abi.encode()(_TYPE_HASH,_hashedName,_hashedVersion,block.chainid,TMP_11103)
			TMP_11105(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11104)
			RETURN TMP_11105
	Function EIP712._hashTypedDataV4(bytes32) (*)
		Expression: ECDSA.toTypedDataHash(_domainSeparatorV4(),structHash)
		IRs:
			TMP_11106(bytes32) = INTERNAL_CALL, EIP712._domainSeparatorV4()()
			TMP_11107(bytes32) = LIBRARY_CALL, dest:ECDSA, function:ECDSA.toTypedDataHash(bytes32,bytes32), arguments:['TMP_11106', 'structHash'] 
			RETURN TMP_11107
	Function EIP712.eip712Domain() (*)
		Expression: (,_name.toStringWithFallback(_nameFallback),_version.toStringWithFallback(_versionFallback),block.chainid,address(this),bytes32(0),new uint256[](0))
		IRs:
			TMP_11108(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_name', '_nameFallback'] 
			TMP_11109(string) = LIBRARY_CALL, dest:ShortStrings, function:ShortStrings.toStringWithFallback(ShortString,string), arguments:['_version', '_versionFallback'] 
			TMP_11110 = CONVERT this to address
			TMP_11111 = CONVERT 0 to bytes32
			TMP_11113(uint256[])  = new uint256[](0)
			RETURN ,TMP_11108,TMP_11109,block.chainid,TMP_11110,TMP_11111,TMP_11113
	Function IERC5267.eip712Domain() 
	Function IERC20Permit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) 
	Function IERC20Permit.nonces(address) 
	Function IERC20Permit.DOMAIN_SEPARATOR() 
	Function ERC20.constructor(string,string) 
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_3164(uint256) -> _balances[account]
			RETURN REF_3164
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11114(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11114(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_3165(mapping(address => uint256)) -> _allowances[owner]
			REF_3166(uint256) -> REF_3165[spender]
			RETURN REF_3166
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11116(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11116(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_11118(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_11118(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11121(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11121(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_11122(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_11123(uint256) = TMP_11122 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11123)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11125(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11125(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_11126(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_11126(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_11127(bool) = currentAllowance >= subtractedValue
			TMP_11128(None) = SOLIDITY_CALL require(bool,string)(TMP_11127,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_11129(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11129)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_11131 = CONVERT 0 to address
			TMP_11132(bool) = from != TMP_11131
			TMP_11133(None) = SOLIDITY_CALL require(bool,string)(TMP_11132,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_11134 = CONVERT 0 to address
			TMP_11135(bool) = to != TMP_11134
			TMP_11136(None) = SOLIDITY_CALL require(bool,string)(TMP_11135,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_3167(uint256) -> _balances[from]
			fromBalance(uint256) := REF_3167(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_11138(bool) = fromBalance >= amount
			TMP_11139(None) = SOLIDITY_CALL require(bool,string)(TMP_11138,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_3168(uint256) -> _balances[from]
			TMP_11140(uint256) = fromBalance - amount
			REF_3168(uint256) (->_balances) := TMP_11140(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_3169(uint256) -> _balances[to]
			REF_3169(-> _balances) = REF_3169 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_11143 = CONVERT 0 to address
			TMP_11144(bool) = account != TMP_11143
			TMP_11145(None) = SOLIDITY_CALL require(bool,string)(TMP_11144,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_11146 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_11146,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_3170(uint256) -> _balances[account]
			REF_3170(-> _balances) = REF_3170 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_11148 = CONVERT 0 to address
			Emit Transfer(TMP_11148,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_11150 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_11150,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_11152 = CONVERT 0 to address
			TMP_11153(bool) = account != TMP_11152
			TMP_11154(None) = SOLIDITY_CALL require(bool,string)(TMP_11153,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_11155 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_11155,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_3171(uint256) -> _balances[account]
			accountBalance(uint256) := REF_3171(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_11157(bool) = accountBalance >= amount
			TMP_11158(None) = SOLIDITY_CALL require(bool,string)(TMP_11157,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_3172(uint256) -> _balances[account]
			TMP_11159(uint256) = accountBalance - amount
			REF_3172(uint256) (->_balances) := TMP_11159(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_11160 = CONVERT 0 to address
			Emit Transfer(account,TMP_11160,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_11162 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_11162,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_11164 = CONVERT 0 to address
			TMP_11165(bool) = owner != TMP_11164
			TMP_11166(None) = SOLIDITY_CALL require(bool,string)(TMP_11165,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_11167 = CONVERT 0 to address
			TMP_11168(bool) = spender != TMP_11167
			TMP_11169(None) = SOLIDITY_CALL require(bool,string)(TMP_11168,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_3173(mapping(address => uint256)) -> _allowances[owner]
			REF_3174(uint256) -> REF_3173[spender]
			REF_3174(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_11171(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_11171(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_11173(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_11174(bool) = currentAllowance != TMP_11173
			CONDITION TMP_11174
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_11175(bool) = currentAllowance >= amount
			TMP_11176(None) = SOLIDITY_CALL require(bool,string)(TMP_11175,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_11177(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11177)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function ERC20Mock.constructor(string,string,uint256,address) (*)
		Expression: _mint(owner,_cap)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(owner,_cap)
		Expression: _transferOwnership(owner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(owner)
		Expression: ERC20(name,symbol)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(name,symbol)
		Expression: ERC20Permit(name)
		IRs:
			INTERNAL_CALL, ERC20Permit.constructor(string)(name)
		Expression: Ownable()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract FlashBorrowerMock
	Function UseFlashLender._initUseFlashLender(address) (*)
		Expression: _fLender = IERC3156FlashLenderUpgradeable(iflashLender)
		IRs:
			TMP_11185 = CONVERT iflashLender to IERC3156FlashLenderUpgradeable
			_fLender(IERC3156FlashLenderUpgradeable) := TMP_11185(IERC3156FlashLenderUpgradeable)
		Expression: address(_fLender) == address(0)
		IRs:
			TMP_11186 = CONVERT _fLender to address
			TMP_11187 = CONVERT 0 to address
			TMP_11188(bool) = TMP_11186 == TMP_11187
			CONDITION TMP_11188
		Expression: revert InvalidFlashLenderContract()()
		IRs:
			TMP_11189(None) = SOLIDITY_CALL revert InvalidFlashLenderContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseFlashLender.flashLender() (*)
		Expression: _fLender
		IRs:
			RETURN _fLender
	Function UseFlashLender.flashLenderA() (*)
		Expression: address(_fLender)
		IRs:
			TMP_11191 = CONVERT _fLender to address
			RETURN TMP_11191
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_11192 = UnaryType.BANG _initializing 
			TMP_11193(None) = SOLIDITY_CALL require(bool,string)(TMP_11192,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_11195(uint8) := 255(uint8)
			TMP_11196(bool) = _initialized != TMP_11195
			CONDITION TMP_11196
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_11198(uint8) := 255(uint8)
			_initialized(uint8) := TMP_11198(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_11200(uint8) := 255(uint8)
			Emit Initialized(TMP_11200)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function IERC3156FlashBorrowerUpgradeable.onFlashLoan(address,address,uint256,uint256,bytes) 
	Function FlashBorrowerMock.initialize(address) (*)
		Expression: _initUseFlashLender(flashLender)
		IRs:
			INTERNAL_CALL, UseFlashLender._initUseFlashLender(address)(flashLender)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function FlashBorrowerMock.borrowed(address) (*)
		Expression: _totalBorrowed[token]
		IRs:
			REF_3175(uint256) -> _totalBorrowed[token]
			RETURN REF_3175
	Function FlashBorrowerMock.flashme(address,uint256) (*)
		Expression: require(bool)(IERC20(token).approve(flashLenderA(),amount))
		IRs:
			TMP_11204 = CONVERT token to IERC20
			TMP_11205(address) = INTERNAL_CALL, UseFlashLender.flashLenderA()()
			TMP_11206(bool) = HIGH_LEVEL_CALL, dest:TMP_11204(IERC20), function:approve, arguments:['TMP_11205', 'amount']  
			TMP_11207(None) = SOLIDITY_CALL require(bool)(TMP_11206)
		Expression: flashLender().flashLoan(this,token,amount,0x)
		IRs:
			TMP_11208(IERC3156FlashLenderUpgradeable) = INTERNAL_CALL, UseFlashLender.flashLender()()
			TMP_11209(bool) = HIGH_LEVEL_CALL, dest:TMP_11208(IERC3156FlashLenderUpgradeable), function:flashLoan, arguments:['this', 'token', 'amount', '0x']  
	Function FlashBorrowerMock.onFlashLoan(address,address,uint256,uint256,bytes) (*)
		Expression: _totalBorrowed[token] += amount
		IRs:
			REF_3178(uint256) -> _totalBorrowed[token]
			REF_3178(-> _totalBorrowed) = REF_3178 (c)+ amount
		Expression: CALLBACK_SUCCESS
		IRs:
			RETURN CALLBACK_SUCCESS
	Function FlashBorrowerMock.slitherConstructorConstantVariables() (*)
		Expression: FLASH_LOAN_FEE_PRECISION = 100000
		IRs:
			FLASH_LOAN_FEE_PRECISION(uint256) := 100000(uint256)
		Expression: FLASH_LOAN_FEE = 100
		IRs:
			FLASH_LOAN_FEE(uint256) := 100(uint256)
		Expression: CALLBACK_SUCCESS = keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
		IRs:
			TMP_11210(bytes32) = SOLIDITY_CALL keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
			CALLBACK_SUCCESS(bytes32) := TMP_11210(bytes32)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_11211 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_11211(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_11212(bool) = _initialized < 1
			TMP_11213(bool) = isTopLevelCall && TMP_11212
			TMP_11214 = CONVERT this to address
			TMP_11215(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_11214'] 
			TMP_11216 = UnaryType.BANG TMP_11215 
			TMP_11217(bool) = _initialized == 1
			TMP_11218(bool) = TMP_11216 && TMP_11217
			TMP_11219(bool) = TMP_11213 || TMP_11218
			TMP_11220(None) = SOLIDITY_CALL require(bool,string)(TMP_11219,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_11222 = UnaryType.BANG _initializing 
			TMP_11223(bool) = _initialized < version
			TMP_11224(bool) = TMP_11222 && TMP_11223
			TMP_11225(None) = SOLIDITY_CALL require(bool,string)(TMP_11224,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_11227(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract MockFlashLender
	Function IERC3156FlashLender.maxFlashLoan(address) 
	Function IERC3156FlashLender.flashFee(address,uint256) 
	Function IERC3156FlashLender.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) 
	Function MockFlashLender.constructor(IERC20) (*)
		Expression: _asset = asset
		IRs:
			_asset(IERC20) := asset(IERC20)
	Function MockFlashLender.getFlashLoanFee() (*)
		Expression: _flashLoanFee
		IRs:
			RETURN _flashLoanFee
	Function MockFlashLender.setFlashLoanFee(uint256) (*)
		Expression: _flashLoanFee = fee
		IRs:
			_flashLoanFee(uint256) := fee(uint256)
	Function MockFlashLender.maxFlashLoan(address) (*)
		Expression: _asset.balanceOf(address(this))
		IRs:
			TMP_11228 = CONVERT this to address
			TMP_11229(uint256) = HIGH_LEVEL_CALL, dest:_asset(IERC20), function:balanceOf, arguments:['TMP_11228']  
			RETURN TMP_11229
	Function MockFlashLender.flashFee(address,uint256) (*)
		Expression: (amount * _flashLoanFee) / PERCENTAGE_PRECISION
		IRs:
			TMP_11230(uint256) = amount (c)* _flashLoanFee
			TMP_11231(uint256) = TMP_11230 (c)/ PERCENTAGE_PRECISION
			RETURN TMP_11231
	Function MockFlashLender.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (*)
		Expression: fee = (amount * _flashLoanFee) / PERCENTAGE_PRECISION
		IRs:
			TMP_11232(uint256) = amount (c)* _flashLoanFee
			TMP_11233(uint256) = TMP_11232 (c)/ PERCENTAGE_PRECISION
			fee(uint256) := TMP_11233(uint256)
		Expression: balanceBefore = _asset.balanceOf(address(this))
		IRs:
			TMP_11234 = CONVERT this to address
			TMP_11235(uint256) = HIGH_LEVEL_CALL, dest:_asset(IERC20), function:balanceOf, arguments:['TMP_11234']  
			balanceBefore(uint256) := TMP_11235(uint256)
		Expression: require(bool,string)(balanceBefore >= amount,No Balance available for flash load)
		IRs:
			TMP_11236(bool) = balanceBefore >= amount
			TMP_11237(None) = SOLIDITY_CALL require(bool,string)(TMP_11236,No Balance available for flash load)
		Expression: _asset.safeTransfer(address(borrower),amount)
		IRs:
			TMP_11238 = CONVERT borrower to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['_asset', 'TMP_11238', 'amount'] 
		Expression: require(bool,string)(borrower.onFlashLoan(msg.sender,token,amount,fee,data) == CALLBACK_SUCCESS,FlashBorrower: Callback failed)
		IRs:
			TMP_11240(bytes32) = HIGH_LEVEL_CALL, dest:borrower(IERC3156FlashBorrower), function:onFlashLoan, arguments:['msg.sender', 'token', 'amount', 'fee', 'data']  
			TMP_11241(bool) = TMP_11240 == CALLBACK_SUCCESS
			TMP_11242(None) = SOLIDITY_CALL require(bool,string)(TMP_11241,FlashBorrower: Callback failed)
		Expression: require(bool)(_asset.allowance(address(borrower),address(this)) >= fee + amount)
		IRs:
			TMP_11243 = CONVERT borrower to address
			TMP_11244 = CONVERT this to address
			TMP_11245(uint256) = HIGH_LEVEL_CALL, dest:_asset(IERC20), function:allowance, arguments:['TMP_11243', 'TMP_11244']  
			TMP_11246(uint256) = fee (c)+ amount
			TMP_11247(bool) = TMP_11245 >= TMP_11246
			TMP_11248(None) = SOLIDITY_CALL require(bool)(TMP_11247)
		Expression: _asset.safeTransferFrom(address(borrower),address(this),amount + fee)
		IRs:
			TMP_11249 = CONVERT borrower to address
			TMP_11250 = CONVERT this to address
			TMP_11251(uint256) = amount (c)+ fee
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['_asset', 'TMP_11249', 'TMP_11250', 'TMP_11251'] 
		Expression: true
		IRs:
			RETURN True
	Function MockFlashLender.slitherConstructorVariables() (*)
		Expression: _flashLoanFee = 1e6
		IRs:
			_flashLoanFee(uint256) := 1000000(uint256)
	Function MockFlashLender.slitherConstructorConstantVariables() (*)
		Expression: CALLBACK_SUCCESS = keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
		IRs:
			TMP_11253(bytes32) = SOLIDITY_CALL keccak256(bytes)(ERC3156FlashBorrower.onFlashLoan)
			CALLBACK_SUCCESS(bytes32) := TMP_11253(bytes32)
Contract ERC4626VaultMock
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_3186(uint256) -> _balances[account]
			RETURN REF_3186
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11254(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11254(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_3187(mapping(address => uint256)) -> _allowances[owner]
			REF_3188(uint256) -> REF_3187[spender]
			RETURN REF_3188
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11256(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11256(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_11258(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_11258(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11261(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11261(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_11262(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_11263(uint256) = TMP_11262 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11263)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_11265(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_11265(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_11266(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_11266(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_11267(bool) = currentAllowance >= subtractedValue
			TMP_11268(None) = SOLIDITY_CALL require(bool,string)(TMP_11267,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_11269(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11269)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_11271 = CONVERT 0 to address
			TMP_11272(bool) = from != TMP_11271
			TMP_11273(None) = SOLIDITY_CALL require(bool,string)(TMP_11272,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_11274 = CONVERT 0 to address
			TMP_11275(bool) = to != TMP_11274
			TMP_11276(None) = SOLIDITY_CALL require(bool,string)(TMP_11275,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_3189(uint256) -> _balances[from]
			fromBalance(uint256) := REF_3189(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_11278(bool) = fromBalance >= amount
			TMP_11279(None) = SOLIDITY_CALL require(bool,string)(TMP_11278,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_3190(uint256) -> _balances[from]
			TMP_11280(uint256) = fromBalance - amount
			REF_3190(uint256) (->_balances) := TMP_11280(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_3191(uint256) -> _balances[to]
			REF_3191(-> _balances) = REF_3191 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_11283 = CONVERT 0 to address
			TMP_11284(bool) = account != TMP_11283
			TMP_11285(None) = SOLIDITY_CALL require(bool,string)(TMP_11284,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_11286 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_11286,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_3192(uint256) -> _balances[account]
			REF_3192(-> _balances) = REF_3192 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_11288 = CONVERT 0 to address
			Emit Transfer(TMP_11288,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_11290 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_11290,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_11292 = CONVERT 0 to address
			TMP_11293(bool) = account != TMP_11292
			TMP_11294(None) = SOLIDITY_CALL require(bool,string)(TMP_11293,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_11295 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_11295,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_3193(uint256) -> _balances[account]
			accountBalance(uint256) := REF_3193(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_11297(bool) = accountBalance >= amount
			TMP_11298(None) = SOLIDITY_CALL require(bool,string)(TMP_11297,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_3194(uint256) -> _balances[account]
			TMP_11299(uint256) = accountBalance - amount
			REF_3194(uint256) (->_balances) := TMP_11299(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_11300 = CONVERT 0 to address
			Emit Transfer(account,TMP_11300,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_11302 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_11302,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_11304 = CONVERT 0 to address
			TMP_11305(bool) = owner != TMP_11304
			TMP_11306(None) = SOLIDITY_CALL require(bool,string)(TMP_11305,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_11307 = CONVERT 0 to address
			TMP_11308(bool) = spender != TMP_11307
			TMP_11309(None) = SOLIDITY_CALL require(bool,string)(TMP_11308,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_3195(mapping(address => uint256)) -> _allowances[owner]
			REF_3196(uint256) -> REF_3195[spender]
			REF_3196(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_11311(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_11311(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_11313(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_11314(bool) = currentAllowance != TMP_11313
			CONDITION TMP_11314
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_11315(bool) = currentAllowance >= amount
			TMP_11316(None) = SOLIDITY_CALL require(bool,string)(TMP_11315,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_11317(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_11317)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IERC4626.asset() 
	Function IERC4626.totalAssets() 
	Function IERC4626.convertToShares(uint256) 
	Function IERC4626.convertToAssets(uint256) 
	Function IERC4626.maxDeposit(address) 
	Function IERC4626.previewDeposit(uint256) 
	Function IERC4626.deposit(uint256,address) 
	Function IERC4626.maxMint(address) 
	Function IERC4626.previewMint(uint256) 
	Function IERC4626.mint(uint256,address) 
	Function IERC4626.maxWithdraw(address) 
	Function IERC4626.previewWithdraw(uint256) 
	Function IERC4626.withdraw(uint256,address,address) 
	Function IERC4626.maxRedeem(address) 
	Function IERC4626.previewRedeem(uint256) 
	Function IERC4626.redeem(uint256,address,address) 
	Function ERC4626VaultMock.constructor(address) (*)
		Expression: _asset = IERC20(vaultAsset)
		IRs:
			TMP_11319 = CONVERT vaultAsset to IERC20
			_asset(IERC20) := TMP_11319(IERC20)
		Expression: ERC20(Mock Vault Share,MVS)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(Mock Vault Share,MVS)
	Function ERC4626VaultMock.mint(uint256,address) (*)
		Expression: require(bool,string)(shares > 0,Cannot mint 0 shares)
		IRs:
			TMP_11321(bool) = shares > 0
			TMP_11322(None) = SOLIDITY_CALL require(bool,string)(TMP_11321,Cannot mint 0 shares)
		Expression: _asset.safeTransferFrom(msg.sender,address(this),shares)
		IRs:
			TMP_11323 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['_asset', 'msg.sender', 'TMP_11323', 'shares'] 
		Expression: assets = shares
		IRs:
			assets(uint256) := shares(uint256)
		Expression: _mint(receiver,shares)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(receiver,shares)
		Expression: _totalAssets += assets
		IRs:
			_totalAssets(uint256) = _totalAssets (c)+ assets
		Expression: Deposit(msg.sender,receiver,assets,shares)
		IRs:
			Emit Deposit(msg.sender,receiver,assets,shares)
	Function ERC4626VaultMock.withdraw(uint256,address,address) (*)
		Expression: require(bool,string)(assets > 0,Cannot withdraw 0)
		IRs:
			TMP_11327(bool) = assets > 0
			TMP_11328(None) = SOLIDITY_CALL require(bool,string)(TMP_11327,Cannot withdraw 0)
		Expression: msg.sender != owner
		IRs:
			TMP_11329(bool) = msg.sender != owner
			CONDITION TMP_11329
		Expression: _spendAllowance(owner,msg.sender,assets)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(owner,msg.sender,assets)
		Expression: _burn(owner,assets)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(owner,assets)
		Expression: shares = assets
		IRs:
			shares(uint256) := assets(uint256)
		Expression: _asset.safeTransfer(receiver,assets)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['_asset', 'receiver', 'assets'] 
		Expression: _totalAssets -= assets
		IRs:
			_totalAssets(uint256) = _totalAssets (c)- assets
		Expression: Withdraw(msg.sender,receiver,owner,assets,shares)
		IRs:
			Emit Withdraw(msg.sender,receiver,owner,assets,shares)
	Function ERC4626VaultMock.deposit(uint256,address) (*)
		Expression: require(bool,string)(assets > 0,Cannot deposit 0)
		IRs:
			TMP_11334(bool) = assets > 0
			TMP_11335(None) = SOLIDITY_CALL require(bool,string)(TMP_11334,Cannot deposit 0)
		Expression: _asset.safeTransferFrom(msg.sender,address(this),assets)
		IRs:
			TMP_11336 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['_asset', 'msg.sender', 'TMP_11336', 'assets'] 
		Expression: shares = assets
		IRs:
			shares(uint256) := assets(uint256)
		Expression: _mint(receiver,shares)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(receiver,shares)
		Expression: _totalAssets += assets
		IRs:
			_totalAssets(uint256) = _totalAssets (c)+ assets
		Expression: Deposit(msg.sender,receiver,assets,shares)
		IRs:
			Emit Deposit(msg.sender,receiver,assets,shares)
	Function ERC4626VaultMock.redeem(uint256,address,address) (*)
		Expression: require(bool,string)(shares > 0,Cannot redeem 0)
		IRs:
			TMP_11340(bool) = shares > 0
			TMP_11341(None) = SOLIDITY_CALL require(bool,string)(TMP_11340,Cannot redeem 0)
		Expression: msg.sender != owner
		IRs:
			TMP_11342(bool) = msg.sender != owner
			CONDITION TMP_11342
		Expression: _spendAllowance(owner,msg.sender,shares)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(owner,msg.sender,shares)
		Expression: _burn(owner,shares)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(owner,shares)
		Expression: assets = shares
		IRs:
			assets(uint256) := shares(uint256)
		Expression: _asset.safeTransfer(receiver,assets)
		IRs:
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['_asset', 'receiver', 'assets'] 
		Expression: _totalAssets -= assets
		IRs:
			_totalAssets(uint256) = _totalAssets (c)- assets
		Expression: Withdraw(msg.sender,receiver,owner,assets,shares)
		IRs:
			Emit Withdraw(msg.sender,receiver,owner,assets,shares)
	Function ERC4626VaultMock.previewDeposit(uint256) (*)
		Expression: assets
		IRs:
			RETURN assets
	Function ERC4626VaultMock.previewRedeem(uint256) (*)
		Expression: shares
		IRs:
			RETURN shares
	Function ERC4626VaultMock.totalAssets() (*)
		Expression: _totalAssets
		IRs:
			RETURN _totalAssets
	Function ERC4626VaultMock.maxDeposit(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_11348(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_11348
	Function ERC4626VaultMock.maxMint(address) (*)
		Expression: type()(uint256).max
		IRs:
			TMP_11350(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			RETURN TMP_11350
	Function ERC4626VaultMock.maxWithdraw(address) (*)
		Expression: balanceOf(owner)
		IRs:
			TMP_11351(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(owner)
			RETURN TMP_11351
	Function ERC4626VaultMock.maxRedeem(address) (*)
		Expression: balanceOf(owner)
		IRs:
			TMP_11352(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(owner)
			RETURN TMP_11352
	Function ERC4626VaultMock.convertToShares(uint256) (*)
		Expression: assets
		IRs:
			RETURN assets
	Function ERC4626VaultMock.convertToAssets(uint256) (*)
		Expression: shares
		IRs:
			RETURN shares
	Function ERC4626VaultMock.asset() (*)
		Expression: address(_asset)
		IRs:
			TMP_11353 = CONVERT _asset to address
			RETURN TMP_11353
	Function ERC4626VaultMock.previewMint(uint256) (*)
		Expression: shares
		IRs:
			RETURN shares
	Function ERC4626VaultMock.previewWithdraw(uint256) (*)
		Expression: assets
		IRs:
			RETURN assets
Contract MathLibraryWrapper
	Function MathLibraryWrapper.mulDivUp(uint256,uint256,uint256) (*)
		Expression: MathLibrary.mulDivUp(x,y,denominator)
		IRs:
			TMP_11354(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivUp(uint256,uint256,uint256), arguments:['x', 'y', 'denominator'] 
			RETURN TMP_11354
	Function MathLibraryWrapper.toDecimals(uint256,uint8,uint8) (*)
		Expression: MathLibrary.toDecimals(value,from,to)
		IRs:
			TMP_11355(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['value', 'from', 'to'] 
			RETURN TMP_11355
	Function MathLibraryWrapper.mulDivDown(uint256,uint256,uint256) (*)
		Expression: MathLibrary.mulDivDown(x,y,denominator)
		IRs:
			TMP_11356(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDivDown(uint256,uint256,uint256), arguments:['x', 'y', 'denominator'] 
			RETURN TMP_11356
	Function MathLibraryWrapper.mulDiv(uint256,uint256,uint256,bool) (*)
		Expression: MathLibrary.mulDiv(x,y,denominator,roundUp)
		IRs:
			TMP_11357(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.mulDiv(uint256,uint256,uint256,bool), arguments:['x', 'y', 'denominator', 'roundUp'] 
			RETURN TMP_11357
Contract OracleMock
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function OracleMock.constructor() (*)
		Expression: _lastUpdate = block.timestamp
		IRs:
			_lastUpdate(uint256) := block.timestamp(uint256)
	Function OracleMock.getPrecision() (*)
		Expression: 10 ** _decimals
		IRs:
			TMP_11358(uint256) = 10 (c)** _decimals
			RETURN TMP_11358
	Function OracleMock.setDecimals(uint8) (*)
		Expression: _decimals = decimals
		IRs:
			_decimals(uint256) := decimals(uint8)
	Function OracleMock.getLatestPrice() (*)
		Expression: price.price = _exchangeRate
		IRs:
			REF_3205(uint256) -> price.price
			REF_3205(uint256) (->price) := _exchangeRate(uint256)
		Expression: price.lastUpdate = _lastUpdate
		IRs:
			REF_3206(uint256) -> price.lastUpdate
			REF_3206(uint256) (->price) := _lastUpdate(uint256)
	Function OracleMock.setLatestPrice(uint256) (*)
		Expression: _exchangeRate = exchangeRate
		IRs:
			_exchangeRate(uint256) := exchangeRate(uint256)
		Expression: _lastUpdate = block.timestamp
		IRs:
			_lastUpdate(uint256) := block.timestamp(uint256)
	Function OracleMock.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price.price = _exchangeRate
		IRs:
			REF_3207(uint256) -> price.price
			REF_3207(uint256) (->price) := _exchangeRate(uint256)
		Expression: price.lastUpdate = _lastUpdate
		IRs:
			REF_3208(uint256) -> price.lastUpdate
			REF_3208(uint256) (->price) := _lastUpdate(uint256)
		Expression: (block.timestamp - price.lastUpdate) > options.maxAge && (options.maxAge > 0)
		IRs:
			REF_3209(uint256) -> price.lastUpdate
			TMP_11359(uint256) = block.timestamp (c)- REF_3209
			REF_3210(uint256) -> options.maxAge
			TMP_11360(bool) = TMP_11359 > REF_3210
			REF_3211(uint256) -> options.maxAge
			TMP_11361(bool) = REF_3211 > 0
			TMP_11362(bool) = TMP_11360 && TMP_11361
			CONDITION TMP_11362
		Expression: revert PriceOutdated()()
		IRs:
			TMP_11363(None) = SOLIDITY_CALL revert PriceOutdated()()
	Function OracleMock.slitherConstructorVariables() (*)
		Expression: _exchangeRate = 1130 * (1e6)
		IRs:
			TMP_11364(uint256) = 1130 (c)* 1000000
			_exchangeRate(uint256) := TMP_11364(uint256)
		Expression: _decimals = 9
		IRs:
			_decimals(uint256) := 9(uint256)
Contract PythMock
	Function IPyth.getValidTimePeriod() 
	Function IPyth.getPrice(bytes32) 
	Function IPyth.getEmaPrice(bytes32) 
	Function IPyth.getPriceUnsafe(bytes32) 
	Function IPyth.getPriceNoOlderThan(bytes32,uint256) 
	Function IPyth.getEmaPriceUnsafe(bytes32) 
	Function IPyth.getEmaPriceNoOlderThan(bytes32,uint256) 
	Function IPyth.updatePriceFeeds(bytes[]) 
	Function IPyth.updatePriceFeedsIfNecessary(bytes[],bytes32[],uint64[]) 
	Function IPyth.getUpdateFee(bytes[]) 
	Function IPyth.parsePriceFeedUpdates(bytes[],bytes32[],uint64,uint64) 
	Function IPyth.parsePriceFeedUpdatesUnique(bytes[],bytes32[],uint64,uint64) 
	Function PythMock.constructor() (*)
		Expression: wstETHOracle = _prices[WSTETH_USD_ORACLE_FEED_ID]
		IRs:
			REF_3212(PythStructs.Price) -> _prices[WSTETH_USD_ORACLE_FEED_ID]
			wstETHOracle(PythStructs.Price) := REF_3212(PythStructs.Price)
		Expression: wstETHOracle.price = 267451
		IRs:
			REF_3213(int64) -> wstETHOracle.price
			REF_3213(int64) (->wstETHOracle) := 267451(int64)
		Expression: wstETHOracle.expo = - 2
		IRs:
			REF_3214(int32) -> wstETHOracle.expo
			TMP_11365(int32) = 0 (c)- 2
			REF_3214(int32) (->wstETHOracle) := TMP_11365(int32)
		Expression: wstETHOracle.conf = 0
		IRs:
			REF_3215(uint64) -> wstETHOracle.conf
			REF_3215(uint64) (->wstETHOracle) := 0(uint256)
		Expression: wstETHOracle.publishTime = block.timestamp
		IRs:
			REF_3216(uint256) -> wstETHOracle.publishTime
			REF_3216(uint256) (->wstETHOracle) := block.timestamp(uint256)
		Expression: wETHOracle = _prices[WETH_USD_ORACLE_FEED_ID]
		IRs:
			REF_3217(PythStructs.Price) -> _prices[WETH_USD_ORACLE_FEED_ID]
			wETHOracle(PythStructs.Price) := REF_3217(PythStructs.Price)
		Expression: wETHOracle.price = 231542
		IRs:
			REF_3218(int64) -> wETHOracle.price
			REF_3218(int64) (->wETHOracle) := 231542(int64)
		Expression: wETHOracle.expo = - 2
		IRs:
			REF_3219(int32) -> wETHOracle.expo
			TMP_11366(int32) = 0 (c)- 2
			REF_3219(int32) (->wETHOracle) := TMP_11366(int32)
		Expression: wETHOracle.conf = 0
		IRs:
			REF_3220(uint64) -> wETHOracle.conf
			REF_3220(uint64) (->wETHOracle) := 0(uint256)
		Expression: wETHOracle.publishTime = block.timestamp
		IRs:
			REF_3221(uint256) -> wETHOracle.publishTime
			REF_3221(uint256) (->wETHOracle) := block.timestamp(uint256)
		Expression: cbETHOracle = _prices[CBETH_USD_ORACLE_FEED_ID]
		IRs:
			REF_3222(PythStructs.Price) -> _prices[CBETH_USD_ORACLE_FEED_ID]
			cbETHOracle(PythStructs.Price) := REF_3222(PythStructs.Price)
		Expression: cbETHOracle.price = 244991
		IRs:
			REF_3223(int64) -> cbETHOracle.price
			REF_3223(int64) (->cbETHOracle) := 244991(int64)
		Expression: cbETHOracle.expo = - 2
		IRs:
			REF_3224(int32) -> cbETHOracle.expo
			TMP_11367(int32) = 0 (c)- 2
			REF_3224(int32) (->cbETHOracle) := TMP_11367(int32)
		Expression: cbETHOracle.conf = 0
		IRs:
			REF_3225(uint64) -> cbETHOracle.conf
			REF_3225(uint64) (->cbETHOracle) := 0(uint256)
		Expression: cbETHOracle.publishTime = block.timestamp
		IRs:
			REF_3226(uint256) -> cbETHOracle.publishTime
			REF_3226(uint256) (->cbETHOracle) := block.timestamp(uint256)
	Function PythMock.getValidTimePeriod() (*)
		Expression: block.timestamp
		IRs:
			RETURN block.timestamp
	Function PythMock.getPrice(bytes32) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3227(PythStructs.Price) -> _prices[id]
			REF_3228(int64) -> REF_3227.price
			TMP_11368(bool) = REF_3228 >= 0
			TMP_11369(None) = SOLIDITY_CALL require(bool,string)(TMP_11368,Invalid Price Feed)
		Expression: _prices[id]
		IRs:
			REF_3229(PythStructs.Price) -> _prices[id]
			RETURN REF_3229
	Function PythMock.getEmaPrice(bytes32) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3230(PythStructs.Price) -> _prices[id]
			REF_3231(int64) -> REF_3230.price
			TMP_11370(bool) = REF_3231 >= 0
			TMP_11371(None) = SOLIDITY_CALL require(bool,string)(TMP_11370,Invalid Price Feed)
		Expression: _prices[id]
		IRs:
			REF_3232(PythStructs.Price) -> _prices[id]
			RETURN REF_3232
	Function PythMock.getPriceUnsafe(bytes32) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3233(PythStructs.Price) -> _prices[id]
			REF_3234(int64) -> REF_3233.price
			TMP_11372(bool) = REF_3234 >= 0
			TMP_11373(None) = SOLIDITY_CALL require(bool,string)(TMP_11372,Invalid Price Feed)
		Expression: _prices[id]
		IRs:
			REF_3235(PythStructs.Price) -> _prices[id]
			RETURN REF_3235
	Function PythMock.getPriceNoOlderThan(bytes32,uint256) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3236(PythStructs.Price) -> _prices[id]
			REF_3237(int64) -> REF_3236.price
			TMP_11374(bool) = REF_3237 >= 0
			TMP_11375(None) = SOLIDITY_CALL require(bool,string)(TMP_11374,Invalid Price Feed)
		Expression: require(bool,string)(block.timestamp - _prices[id].publishTime <= age,Old Price)
		IRs:
			REF_3238(PythStructs.Price) -> _prices[id]
			REF_3239(uint256) -> REF_3238.publishTime
			TMP_11376(uint256) = block.timestamp (c)- REF_3239
			TMP_11377(bool) = TMP_11376 <= age
			TMP_11378(None) = SOLIDITY_CALL require(bool,string)(TMP_11377,Old Price)
		Expression: _prices[id]
		IRs:
			REF_3240(PythStructs.Price) -> _prices[id]
			RETURN REF_3240
	Function PythMock.getEmaPriceUnsafe(bytes32) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3241(PythStructs.Price) -> _prices[id]
			REF_3242(int64) -> REF_3241.price
			TMP_11379(bool) = REF_3242 >= 0
			TMP_11380(None) = SOLIDITY_CALL require(bool,string)(TMP_11379,Invalid Price Feed)
		Expression: _prices[id]
		IRs:
			REF_3243(PythStructs.Price) -> _prices[id]
			RETURN REF_3243
	Function PythMock.getEmaPriceNoOlderThan(bytes32,uint256) (*)
		Expression: require(bool,string)(_prices[id].price >= 0,Invalid Price Feed)
		IRs:
			REF_3244(PythStructs.Price) -> _prices[id]
			REF_3245(int64) -> REF_3244.price
			TMP_11381(bool) = REF_3245 >= 0
			TMP_11382(None) = SOLIDITY_CALL require(bool,string)(TMP_11381,Invalid Price Feed)
		Expression: require(bool,string)(_prices[id].publishTime >= age,Old Price)
		IRs:
			REF_3246(PythStructs.Price) -> _prices[id]
			REF_3247(uint256) -> REF_3246.publishTime
			TMP_11383(bool) = REF_3247 >= age
			TMP_11384(None) = SOLIDITY_CALL require(bool,string)(TMP_11383,Old Price)
		Expression: _prices[id]
		IRs:
			REF_3248(PythStructs.Price) -> _prices[id]
			RETURN REF_3248
	Function PythMock.updatePriceFeeds(bytes[]) (*)
		Expression: _parseUpdatesInternal(updateData)
		IRs:
			TMP_11385(PythStructs.PriceFeed[]) = INTERNAL_CALL, PythMock._parseUpdatesInternal(bytes[])(updateData)
	Function PythMock.updatePriceFeedsIfNecessary(bytes[],bytes32[],uint64[]) (*)
		Expression: _parseUpdatesInternal(updateData)
		IRs:
			TMP_11386(PythStructs.PriceFeed[]) = INTERNAL_CALL, PythMock._parseUpdatesInternal(bytes[])(updateData)
	Function PythMock.getUpdateFee(bytes[]) (*)
		Expression: uint256(_updateFee)
		IRs:
			TMP_11387 = CONVERT _updateFee to uint256
			RETURN TMP_11387
	Function PythMock.parsePriceFeedUpdates(bytes[],bytes32[],uint64,uint64) (*)
		Expression: _parseUpdatesInternal(updateData)
		IRs:
			TMP_11388(PythStructs.PriceFeed[]) = INTERNAL_CALL, PythMock._parseUpdatesInternal(bytes[])(updateData)
			RETURN TMP_11388
	Function PythMock.parsePriceFeedUpdatesUnique(bytes[],bytes32[],uint64,uint64) (*)
		Expression: _parseUpdatesInternal(updateData)
		IRs:
			TMP_11389(PythStructs.PriceFeed[]) = INTERNAL_CALL, PythMock._parseUpdatesInternal(bytes[])(updateData)
			RETURN TMP_11389
	Function PythMock._parseUpdatesInternal(bytes[]) (*)
		Expression: feeds = new PythStructs.PriceFeed[](updateData.length)
		IRs:
			REF_3249 -> LENGTH updateData
			TMP_11391(PythStructs.PriceFeed[])  = new PythStructs.PriceFeed[](REF_3249)
			feeds(PythStructs.PriceFeed[]) = ['TMP_11391(PythStructs.PriceFeed[])']
		Expression: require(bool,string)(msg.value >= _updateFee,No Fee)
		IRs:
			TMP_11392(bool) = msg.value >= _updateFee
			TMP_11393(None) = SOLIDITY_CALL require(bool,string)(TMP_11392,No Fee)
		Expression: i = 0
		IRs:
			i(uint256) := 0(uint256)
		Expression: i < updateData.length
		IRs:
			REF_3250 -> LENGTH updateData
			TMP_11394(bool) = i < REF_3250
			CONDITION TMP_11394
		Expression: (feeds[i]) = abi.decode(updateData[i],(PythStructs.PriceFeed))
		IRs:
			REF_3251(PythStructs.PriceFeed) -> feeds[i]
			REF_3253(bytes) -> updateData[i]
			REF_3254(None) -> PythStructs.PriceFeed
			TMP_11395(None) = SOLIDITY_CALL abi.decode()(REF_3253,REF_3254)
			REF_3251(PythStructs.PriceFeed) (->feeds) := TMP_11395(None)
		Expression: _prices[feeds[i].id].price != 0
		IRs:
			REF_3255(PythStructs.PriceFeed) -> feeds[i]
			REF_3256(bytes32) -> REF_3255.id
			REF_3257(PythStructs.Price) -> _prices[REF_3256]
			REF_3258(int64) -> REF_3257.price
			TMP_11396(bool) = REF_3258 != 0
			CONDITION TMP_11396
		Expression: _prices[feeds[i].id].price = feeds[i].price.price
		IRs:
			REF_3259(PythStructs.PriceFeed) -> feeds[i]
			REF_3260(bytes32) -> REF_3259.id
			REF_3261(PythStructs.Price) -> _prices[REF_3260]
			REF_3262(int64) -> REF_3261.price
			REF_3263(PythStructs.PriceFeed) -> feeds[i]
			REF_3264(PythStructs.Price) -> REF_3263.price
			REF_3265(int64) -> REF_3264.price
			REF_3262(int64) (->_prices) := REF_3265(int64)
		Expression: _prices[feeds[i].id].expo = feeds[i].price.expo
		IRs:
			REF_3266(PythStructs.PriceFeed) -> feeds[i]
			REF_3267(bytes32) -> REF_3266.id
			REF_3268(PythStructs.Price) -> _prices[REF_3267]
			REF_3269(int32) -> REF_3268.expo
			REF_3270(PythStructs.PriceFeed) -> feeds[i]
			REF_3271(PythStructs.Price) -> REF_3270.price
			REF_3272(int32) -> REF_3271.expo
			REF_3269(int32) (->_prices) := REF_3272(int32)
		Expression: _prices[feeds[i].id].conf = feeds[i].price.conf
		IRs:
			REF_3273(PythStructs.PriceFeed) -> feeds[i]
			REF_3274(bytes32) -> REF_3273.id
			REF_3275(PythStructs.Price) -> _prices[REF_3274]
			REF_3276(uint64) -> REF_3275.conf
			REF_3277(PythStructs.PriceFeed) -> feeds[i]
			REF_3278(PythStructs.Price) -> REF_3277.price
			REF_3279(uint64) -> REF_3278.conf
			REF_3276(uint64) (->_prices) := REF_3279(uint64)
		Expression: _prices[feeds[i].id].publishTime = block.timestamp
		IRs:
			REF_3280(PythStructs.PriceFeed) -> feeds[i]
			REF_3281(bytes32) -> REF_3280.id
			REF_3282(PythStructs.Price) -> _prices[REF_3281]
			REF_3283(uint256) -> REF_3282.publishTime
			REF_3283(uint256) (->_prices) := block.timestamp(uint256)
		Expression: PriceFeedUpdate(feeds[i].id,uint64(feeds[i].price.publishTime),feeds[i].price.price,feeds[i].price.conf)
		IRs:
			REF_3284(PythStructs.PriceFeed) -> feeds[i]
			REF_3285(bytes32) -> REF_3284.id
			REF_3286(PythStructs.PriceFeed) -> feeds[i]
			REF_3287(PythStructs.Price) -> REF_3286.price
			REF_3288(uint256) -> REF_3287.publishTime
			TMP_11397 = CONVERT REF_3288 to uint64
			REF_3289(PythStructs.PriceFeed) -> feeds[i]
			REF_3290(PythStructs.Price) -> REF_3289.price
			REF_3291(int64) -> REF_3290.price
			REF_3292(PythStructs.PriceFeed) -> feeds[i]
			REF_3293(PythStructs.Price) -> REF_3292.price
			REF_3294(uint64) -> REF_3293.conf
			Emit PriceFeedUpdate(REF_3285,TMP_11397,REF_3291,REF_3294)
		Expression: i ++
		IRs:
			TMP_11399(uint256) := i(uint256)
			i(uint256) = i (c)+ 1
	Function PythMock.slitherConstructorConstantVariables() (*)
		Expression: WSTETH_USD_ORACLE_FEED_ID = bytes32(0x6df640f3b8963d8f8358f791f352b8364513f6ab1cca5ed3f1f7b5448980e784)
		IRs:
			TMP_11400 = CONVERT 0x6df640f3b8963d8f8358f791f352b8364513f6ab1cca5ed3f1f7b5448980e784 to bytes32
			WSTETH_USD_ORACLE_FEED_ID(bytes32) := TMP_11400(bytes32)
		Expression: WETH_USD_ORACLE_FEED_ID = bytes32(0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace)
		IRs:
			TMP_11401 = CONVERT 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace to bytes32
			WETH_USD_ORACLE_FEED_ID(bytes32) := TMP_11401(bytes32)
		Expression: CBETH_USD_ORACLE_FEED_ID = bytes32(0x15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717)
		IRs:
			TMP_11402 = CONVERT 0x15ecddd26d49e1a8f1de9376ebebc03916ede873447c1255d2d5891b92ce5717 to bytes32
			CBETH_USD_ORACLE_FEED_ID(bytes32) := TMP_11402(bytes32)
Contract QuoterV2Mock
	Function IQuoterV2.quoteExactInput(bytes,uint256) 
	Function IQuoterV2.quoteExactInputSingle(IQuoterV2.QuoteExactInputSingleParams) 
	Function IQuoterV2.quoteExactOutput(bytes,uint256) 
	Function IQuoterV2.quoteExactOutputSingle(IQuoterV2.QuoteExactOutputSingleParams) 
	Function QuoterV2Mock.setRatio(uint256) (*)
		Expression: _ratio = ratio
		IRs:
			_ratio(uint256) := ratio(uint256)
	Function QuoterV2Mock.quoteExactInput(bytes,uint256) (*)
	Function QuoterV2Mock.quoteExactInputSingle(IQuoterV2.QuoteExactInputSingleParams) (*)
		Expression: amountOut = (params.amountIn * RATIO_PRECISION) / _ratio
		IRs:
			REF_3295(uint256) -> params.amountIn
			TMP_11403(uint256) = REF_3295 (c)* RATIO_PRECISION
			TMP_11404(uint256) = TMP_11403 (c)/ _ratio
			amountOut(uint256) := TMP_11404(uint256)
		Expression: (amountOut,0,0,0)
		IRs:
			RETURN amountOut,0,0,0
	Function QuoterV2Mock.quoteExactOutput(bytes,uint256) (*)
	Function QuoterV2Mock.quoteExactOutputSingle(IQuoterV2.QuoteExactOutputSingleParams) (*)
		Expression: amountIn = (params.amount * _ratio) / RATIO_PRECISION
		IRs:
			REF_3296(uint256) -> params.amount
			TMP_11405(uint256) = REF_3296 (c)* _ratio
			TMP_11406(uint256) = TMP_11405 (c)/ RATIO_PRECISION
			amountIn(uint256) := TMP_11406(uint256)
		Expression: (amountIn,0,0,0)
		IRs:
			RETURN amountIn,0,0,0
	Function QuoterV2Mock.slitherConstructorVariables() (*)
		Expression: RATIO_PRECISION = 1e9
		IRs:
			RATIO_PRECISION(uint256) := 1000000000(uint256)
		Expression: _ratio = 1e9
		IRs:
			_ratio(uint256) := 1000000000(uint256)
Contract StrategyLeverageSettingsMock
	Function StrategyLeverageSettings._initLeverageSettings(address,address) (*)
		Expression: _initializeGovernableOwnable(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._initializeGovernableOwnable(address,address)(initialOwner,initialGovernor)
		Expression: _initializeStrategySettings()
		IRs:
			INTERNAL_CALL, StrategySettings._initializeStrategySettings()()
		Expression: _loanToValue = 800 * 1e6
		IRs:
			TMP_11409(uint256) = 800 (c)* 1000000
			_loanToValue(uint256) := TMP_11409(uint256)
		Expression: _maxLoanToValue = 850 * 1e6
		IRs:
			TMP_11410(uint256) = 850 (c)* 1000000
			_maxLoanToValue(uint256) := TMP_11410(uint256)
		Expression: _nrLoops = 10
		IRs:
			_nrLoops(uint8) := 10(uint256)
		Expression: _maxSlippage = 0
		IRs:
			_maxSlippage(uint256) := 0(uint256)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function StrategyLeverageSettings.setMaxLoanToValue(uint256) (*)
		Expression: maxLoanToValue == 0
		IRs:
			TMP_11412(bool) = maxLoanToValue == 0
			CONDITION TMP_11412
		Expression: revert InvalidValue()()
		IRs:
			TMP_11413(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: maxLoanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_11414(bool) = maxLoanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_11414
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_11415(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: maxLoanToValue < _loanToValue
		IRs:
			TMP_11416(bool) = maxLoanToValue < _loanToValue
			CONDITION TMP_11416
		Expression: revert InvalidMaxLoanToValue()()
		IRs:
			TMP_11417(None) = SOLIDITY_CALL revert InvalidMaxLoanToValue()()
		Expression: _maxLoanToValue = maxLoanToValue
		IRs:
			_maxLoanToValue(uint256) := maxLoanToValue(uint256)
		Expression: MaxLoanToValueChanged(_maxLoanToValue)
		IRs:
			Emit MaxLoanToValueChanged(_maxLoanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxLoanToValue() (*)
		Expression: _maxLoanToValue
		IRs:
			RETURN _maxLoanToValue
	Function StrategyLeverageSettings.setLoanToValue(uint256) (*)
		Expression: loanToValue > _maxLoanToValue
		IRs:
			TMP_11420(bool) = loanToValue > _maxLoanToValue
			CONDITION TMP_11420
		Expression: revert InvalidValue()()
		IRs:
			TMP_11421(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_11422(bool) = loanToValue > PERCENTAGE_PRECISION
			CONDITION TMP_11422
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_11423(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: loanToValue == 0
		IRs:
			TMP_11424(bool) = loanToValue == 0
			CONDITION TMP_11424
		Expression: revert InvalidValue()()
		IRs:
			TMP_11425(None) = SOLIDITY_CALL revert InvalidValue()()
		Expression: _loanToValue = loanToValue
		IRs:
			_loanToValue(uint256) := loanToValue(uint256)
		Expression: LoanToValueChanged(_loanToValue)
		IRs:
			Emit LoanToValueChanged(_loanToValue)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getLoanToValue() (*)
		Expression: _loanToValue
		IRs:
			RETURN _loanToValue
	Function StrategyLeverageSettings.getNrLoops() (*)
		Expression: _nrLoops
		IRs:
			RETURN _nrLoops
	Function StrategyLeverageSettings.setNrLoops(uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_11428(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_11428
		Expression: revert InvalidLoopCount()()
		IRs:
			TMP_11429(None) = SOLIDITY_CALL revert InvalidLoopCount()()
		Expression: _nrLoops = nrLoops
		IRs:
			_nrLoops(uint8) := nrLoops(uint8)
		Expression: NrLoopsChanged(_nrLoops)
		IRs:
			Emit NrLoopsChanged(_nrLoops)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategyLeverageSettings.getMaxSlippage() (*)
		Expression: _maxSlippage
		IRs:
			RETURN _maxSlippage
	Function StrategyLeverageSettings.setMaxSlippage(uint256) (*)
		Expression: slippage > PERCENTAGE_PRECISION
		IRs:
			TMP_11432(bool) = slippage > PERCENTAGE_PRECISION
			CONDITION TMP_11432
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_11433(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _maxSlippage = slippage
		IRs:
			_maxSlippage(uint256) := slippage(uint256)
		Expression: MaxSlippageChanged(slippage)
		IRs:
			Emit MaxSlippageChanged(slippage)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.constructor() (*)
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function StrategySettings._initializeStrategySettings() (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,3600)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,3600)
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,0)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,0)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function StrategySettings.setPriceMaxAge(uint256) (*)
		Expression: _setUint256(PRICE_MAX_AGE_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_AGE_SLOT,value)
		Expression: PriceMaxAgeChanged(value)
		IRs:
			Emit PriceMaxAgeChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxAge() (*)
		Expression: _getUint256(PRICE_MAX_AGE_SLOT)
		IRs:
			TMP_11443(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_AGE_SLOT)
			RETURN TMP_11443
	Function StrategySettings.setPriceMaxConf(uint256) (*)
		Expression: value > PERCENTAGE_PRECISION
		IRs:
			TMP_11444(bool) = value > PERCENTAGE_PRECISION
			CONDITION TMP_11444
		Expression: revert InvalidPercentage()()
		IRs:
			TMP_11445(None) = SOLIDITY_CALL revert InvalidPercentage()()
		Expression: _setUint256(PRICE_MAX_CONF_SLOT,value)
		IRs:
			INTERNAL_CALL, StrategySettings._setUint256(bytes32,uint256)(PRICE_MAX_CONF_SLOT,value)
		Expression: PriceMaxConfChanged(value)
		IRs:
			Emit PriceMaxConfChanged(value)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function StrategySettings.getPriceMaxConf() (*)
		Expression: _getUint256(PRICE_MAX_CONF_SLOT)
		IRs:
			TMP_11449(uint256) = INTERNAL_CALL, StrategySettings._getUint256(bytes32)(PRICE_MAX_CONF_SLOT)
			RETURN TMP_11449
	Function StrategySettings._setUint256(bytes32,uint256) (*)
		Expression: sstore(uint256,uint256)(slot,value)
		IRs:
			TMP_11450(None) = SOLIDITY_CALL sstore(uint256,uint256)(slot,value)
	Function StrategySettings._getUint256(bytes32) (*)
		Expression: value = sload(uint256)(slot)
		IRs:
			TMP_11451(uint256) = SOLIDITY_CALL sload(uint256)(slot)
			value(uint256) := TMP_11451(uint256)
	Function IStrategySettings.setPriceMaxAge(uint256) 
	Function IStrategySettings.getPriceMaxAge() 
	Function IStrategySettings.setPriceMaxConf(uint256) 
	Function IStrategySettings.getPriceMaxConf() 
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_11455 = CONVERT 0 to address
			TMP_11456(bool) = _newGovernor == TMP_11455
			CONDITION TMP_11456
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_11457(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_11463(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_11463)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_11466(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_11467(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_11468(bool) = TMP_11466 == TMP_11467
			TMP_11469(None) = SOLIDITY_CALL require(bool,string)(TMP_11468,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_11470 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_11470)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_11473 = CONVERT 0 to address
			TMP_11474(bool) = newOwner != TMP_11473
			TMP_11475(None) = SOLIDITY_CALL require(bool,string)(TMP_11474,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_11481 = UnaryType.BANG _initializing 
			TMP_11482(None) = SOLIDITY_CALL require(bool,string)(TMP_11481,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_11484(uint8) := 255(uint8)
			TMP_11485(bool) = _initialized != TMP_11484
			CONDITION TMP_11485
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_11487(uint8) := 255(uint8)
			_initialized(uint8) := TMP_11487(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_11489(uint8) := 255(uint8)
			Emit Initialized(TMP_11489)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function StrategyLeverageSettingsMock.initialize(address,address) (*)
		Expression: _initLeverageSettings(initialOwner,initialGovernor)
		IRs:
			INTERNAL_CALL, StrategyLeverageSettings._initLeverageSettings(address,address)(initialOwner,initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_11493(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_11494(bool) = msg.sender != TMP_11493
			CONDITION TMP_11494
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_11495(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_11497 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_11497(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_11498(bool) = _initialized < 1
			TMP_11499(bool) = isTopLevelCall && TMP_11498
			TMP_11500 = CONVERT this to address
			TMP_11501(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_11500'] 
			TMP_11502 = UnaryType.BANG TMP_11501 
			TMP_11503(bool) = _initialized == 1
			TMP_11504(bool) = TMP_11502 && TMP_11503
			TMP_11505(bool) = TMP_11499 || TMP_11504
			TMP_11506(None) = SOLIDITY_CALL require(bool,string)(TMP_11505,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_11508 = UnaryType.BANG _initializing 
			TMP_11509(bool) = _initialized < version
			TMP_11510(bool) = TMP_11508 && TMP_11509
			TMP_11511(None) = SOLIDITY_CALL require(bool,string)(TMP_11510,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_11513(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
Contract StrategyMock
	Function IStrategy.deploy(uint256) 
	Function IStrategy.harvest() 
	Function IStrategy.undeploy(uint256) 
	Function IStrategy.totalAssets() 
	Function IStrategy.asset() 
	Function StrategyMock.constructor(address) (*)
		Expression: _asset = assetSt
		IRs:
			_asset(address) := assetSt(address)
	Function StrategyMock.deploy(uint256) (*)
		Expression: StrategyAmountUpdate(amount)
		IRs:
			Emit StrategyAmountUpdate(amount)
		Expression: IERC20Upgradeable(_asset).transferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_11515 = CONVERT _asset to IERC20Upgradeable
			TMP_11516 = CONVERT this to address
			TMP_11517(bool) = HIGH_LEVEL_CALL, dest:TMP_11515(IERC20Upgradeable), function:transferFrom, arguments:['msg.sender', 'TMP_11516', 'amount']  
		Expression: amount
		IRs:
			RETURN amount
	Function StrategyMock.harvest() (*)
		Expression: _havestPerCall
		IRs:
			RETURN _havestPerCall
	Function StrategyMock.undeploy(uint256) (*)
		Expression: IERC20Upgradeable(_asset).balanceOf(address(this)) < amount
		IRs:
			TMP_11518 = CONVERT _asset to IERC20Upgradeable
			TMP_11519 = CONVERT this to address
			TMP_11520(uint256) = HIGH_LEVEL_CALL, dest:TMP_11518(IERC20Upgradeable), function:balanceOf, arguments:['TMP_11519']  
			TMP_11521(bool) = TMP_11520 < amount
			CONDITION TMP_11521
		Expression: revert NoBalance()()
		IRs:
			TMP_11522(None) = SOLIDITY_CALL revert NoBalance()()
		Expression: IERC20Upgradeable(_asset).transfer(msg.sender,amount)
		IRs:
			TMP_11523 = CONVERT _asset to IERC20Upgradeable
			TMP_11524(bool) = HIGH_LEVEL_CALL, dest:TMP_11523(IERC20Upgradeable), function:transfer, arguments:['msg.sender', 'amount']  
		Expression: StrategyAmountUpdate(address(this).balance - amount)
		IRs:
			TMP_11525 = CONVERT this to address
			TMP_11526(uint256) = SOLIDITY_CALL balance(address)(TMP_11525)
			TMP_11527(uint256) = TMP_11526 (c)- amount
			Emit StrategyAmountUpdate(TMP_11527)
		Expression: amount
		IRs:
			RETURN amount
	Function StrategyMock.totalAssets() (*)
		Expression: col = IERC20Upgradeable(_asset).balanceOf(address(this))
		IRs:
			TMP_11529 = CONVERT _asset to IERC20Upgradeable
			TMP_11530 = CONVERT this to address
			TMP_11531(uint256) = HIGH_LEVEL_CALL, dest:TMP_11529(IERC20Upgradeable), function:balanceOf, arguments:['TMP_11530']  
			col(uint256) := TMP_11531(uint256)
		Expression: deb = (col * _debRatio) / 100
		IRs:
			TMP_11532(uint256) = col (c)* _debRatio
			TMP_11533(uint256) = TMP_11532 (c)/ 100
			deb(uint256) := TMP_11533(uint256)
		Expression: col >= deb
		IRs:
			TMP_11534(bool) = col >= deb
			CONDITION TMP_11534
		Expression: actualAmount = col - deb
		IRs:
			TMP_11535(uint256) = col (c)- deb
			actualAmount(uint256) := TMP_11535(uint256)
		Expression: actualAmount = 0
		IRs:
			actualAmount(uint256) := 0(uint256)
	Function StrategyMock.getPosition() (*)
		Expression: balance = IERC20Upgradeable(_asset).balanceOf(address(this))
		IRs:
			TMP_11536 = CONVERT _asset to IERC20Upgradeable
			TMP_11537 = CONVERT this to address
			TMP_11538(uint256) = HIGH_LEVEL_CALL, dest:TMP_11536(IERC20Upgradeable), function:balanceOf, arguments:['TMP_11537']  
			balance(uint256) := TMP_11538(uint256)
		Expression: (balance,(balance * _debRatio) / 100,1e9)
		IRs:
			TMP_11539(uint256) = balance (c)* _debRatio
			TMP_11540(uint256) = TMP_11539 (c)/ 100
			RETURN balance,TMP_11540,1000000000
	Function StrategyMock.setRatio(uint256) (*)
		Expression: _debRatio = ratio
		IRs:
			_debRatio(uint256) := ratio(uint256)
	Function StrategyMock.setHarvestPerCall(int256) (*)
		Expression: _havestPerCall = havestPerCall
		IRs:
			_havestPerCall(int256) := havestPerCall(int256)
	Function StrategyMock.asset() (*)
		Expression: _asset
		IRs:
			RETURN _asset
	Function StrategyMock.slitherConstructorVariables() (*)
		Expression: _debRatio = 50
		IRs:
			_debRatio(uint256) := 50(uint256)
		Expression: _havestPerCall = 0
		IRs:
			_havestPerCall(int256) := 0(int256)
Contract UniV3RouterMock
	Function IV3SwapRouter.exactInputSingle(IV3SwapRouter.ExactInputSingleParams) 
	Function IV3SwapRouter.exactInput(IV3SwapRouter.ExactInputParams) 
	Function IV3SwapRouter.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams) 
	Function IV3SwapRouter.exactOutput(IV3SwapRouter.ExactOutputParams) 
	Function IUniswapV3SwapCallback.uniswapV3SwapCallback(int256,int256,bytes) 
	Function UniV3RouterMock.constructor(IERC20,IERC20) (*)
		Expression: _asset0 = asset0
		IRs:
			_asset0(IERC20) := asset0(IERC20)
		Expression: _asset1 = asset1
		IRs:
			_asset1(IERC20) := asset1(IERC20)
	Function UniV3RouterMock.uniswapV3SwapCallback(int256,int256,bytes) (*)
	Function UniV3RouterMock.exactInputSingle(IV3SwapRouter.ExactInputSingleParams) (*)
		Expression: require(bool,string)(IERC20(params.tokenIn).allowance(msg.sender,address(this)) >= amountOut,No Enough Allowance)
		IRs:
			REF_3303(address) -> params.tokenIn
			TMP_11541 = CONVERT REF_3303 to IERC20
			TMP_11542 = CONVERT this to address
			TMP_11543(uint256) = HIGH_LEVEL_CALL, dest:TMP_11541(IERC20), function:allowance, arguments:['msg.sender', 'TMP_11542']  
			TMP_11544(bool) = TMP_11543 >= amountOut
			TMP_11545(None) = SOLIDITY_CALL require(bool,string)(TMP_11544,No Enough Allowance)
		Expression: IERC20(params.tokenIn).safeTransferFrom(msg.sender,address(this),params.amountIn)
		IRs:
			REF_3305(address) -> params.tokenIn
			TMP_11546 = CONVERT REF_3305 to IERC20
			TMP_11547 = CONVERT this to address
			REF_3307(uint256) -> params.amountIn
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11546', 'msg.sender', 'TMP_11547', 'REF_3307'] 
		Expression: params.tokenIn == address(_asset1)
		IRs:
			REF_3308(address) -> params.tokenIn
			TMP_11549 = CONVERT _asset1 to address
			TMP_11550(bool) = REF_3308 == TMP_11549
			CONDITION TMP_11550
		Expression: amountOut = (params.amountIn * PRICE_PRECISION) / _price
		IRs:
			REF_3309(uint256) -> params.amountIn
			TMP_11551(uint256) = REF_3309 (c)* PRICE_PRECISION
			TMP_11552(uint256) = TMP_11551 (c)/ _price
			amountOut(uint256) := TMP_11552(uint256)
		Expression: amountOut = (params.amountIn * _price) / PRICE_PRECISION
		IRs:
			REF_3310(uint256) -> params.amountIn
			TMP_11553(uint256) = REF_3310 (c)* _price
			TMP_11554(uint256) = TMP_11553 (c)/ PRICE_PRECISION
			amountOut(uint256) := TMP_11554(uint256)
		Expression: require(bool,string)(IERC20(params.tokenOut).balanceOf(address(this)) >= amountOut,No Enough Liquidity)
		IRs:
			REF_3311(address) -> params.tokenOut
			TMP_11555 = CONVERT REF_3311 to IERC20
			TMP_11556 = CONVERT this to address
			TMP_11557(uint256) = HIGH_LEVEL_CALL, dest:TMP_11555(IERC20), function:balanceOf, arguments:['TMP_11556']  
			TMP_11558(bool) = TMP_11557 >= amountOut
			TMP_11559(None) = SOLIDITY_CALL require(bool,string)(TMP_11558,No Enough Liquidity)
		Expression: require(bool,string)(amountOut >= params.amountOutMinimum,Mininum Out not reached)
		IRs:
			REF_3313(uint256) -> params.amountOutMinimum
			TMP_11560(bool) = amountOut >= REF_3313
			TMP_11561(None) = SOLIDITY_CALL require(bool,string)(TMP_11560,Mininum Out not reached)
		Expression: IERC20(params.tokenOut).safeTransfer(params.recipient,amountOut)
		IRs:
			REF_3314(address) -> params.tokenOut
			TMP_11562 = CONVERT REF_3314 to IERC20
			REF_3316(address) -> params.recipient
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_11562', 'REF_3316', 'amountOut'] 
	Function UniV3RouterMock.exactInput(IV3SwapRouter.ExactInputParams) (*)
	Function UniV3RouterMock.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams) (*)
		Expression: require(bool,string)(IERC20(params.tokenOut).balanceOf(address(this)) >= params.amountOut,No enough liquidity)
		IRs:
			REF_3317(address) -> params.tokenOut
			TMP_11564 = CONVERT REF_3317 to IERC20
			TMP_11565 = CONVERT this to address
			TMP_11566(uint256) = HIGH_LEVEL_CALL, dest:TMP_11564(IERC20), function:balanceOf, arguments:['TMP_11565']  
			REF_3319(uint256) -> params.amountOut
			TMP_11567(bool) = TMP_11566 >= REF_3319
			TMP_11568(None) = SOLIDITY_CALL require(bool,string)(TMP_11567,No enough liquidity)
		Expression: params.tokenIn == address(_asset0)
		IRs:
			REF_3320(address) -> params.tokenIn
			TMP_11569 = CONVERT _asset0 to address
			TMP_11570(bool) = REF_3320 == TMP_11569
			CONDITION TMP_11570
		Expression: amountIn = (params.amountOut * PRICE_PRECISION) / _price
		IRs:
			REF_3321(uint256) -> params.amountOut
			TMP_11571(uint256) = REF_3321 (c)* PRICE_PRECISION
			TMP_11572(uint256) = TMP_11571 (c)/ _price
			amountIn(uint256) := TMP_11572(uint256)
		Expression: amountIn = (params.amountOut * _price) / PRICE_PRECISION
		IRs:
			REF_3322(uint256) -> params.amountOut
			TMP_11573(uint256) = REF_3322 (c)* _price
			TMP_11574(uint256) = TMP_11573 (c)/ PRICE_PRECISION
			amountIn(uint256) := TMP_11574(uint256)
		Expression: require(bool,string)(amountIn <= params.amountInMaximum,Max Input Reached)
		IRs:
			REF_3323(uint256) -> params.amountInMaximum
			TMP_11575(bool) = amountIn <= REF_3323
			TMP_11576(None) = SOLIDITY_CALL require(bool,string)(TMP_11575,Max Input Reached)
		Expression: require(bool,string)(IERC20(params.tokenIn).allowance(msg.sender,address(this)) >= amountIn,Not allowed to move input )
		IRs:
			REF_3324(address) -> params.tokenIn
			TMP_11577 = CONVERT REF_3324 to IERC20
			TMP_11578 = CONVERT this to address
			TMP_11579(uint256) = HIGH_LEVEL_CALL, dest:TMP_11577(IERC20), function:allowance, arguments:['msg.sender', 'TMP_11578']  
			TMP_11580(bool) = TMP_11579 >= amountIn
			TMP_11581(None) = SOLIDITY_CALL require(bool,string)(TMP_11580,Not allowed to move input )
		Expression: IERC20(params.tokenIn).safeTransferFrom(msg.sender,address(this),amountIn)
		IRs:
			REF_3326(address) -> params.tokenIn
			TMP_11582 = CONVERT REF_3326 to IERC20
			TMP_11583 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11582', 'msg.sender', 'TMP_11583', 'amountIn'] 
		Expression: IERC20(params.tokenOut).safeTransfer(params.recipient,params.amountOut)
		IRs:
			REF_3328(address) -> params.tokenOut
			TMP_11585 = CONVERT REF_3328 to IERC20
			REF_3330(address) -> params.recipient
			REF_3331(uint256) -> params.amountOut
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_11585', 'REF_3330', 'REF_3331'] 
	Function UniV3RouterMock.exactOutput(IV3SwapRouter.ExactOutputParams) (*)
	Function UniV3RouterMock.setPrice(uint256) (*)
		Expression: _price = price
		IRs:
			_price(uint256) := price(uint256)
	Function UniV3RouterMock.getPrice() (*)
		Expression: _price
		IRs:
			RETURN _price
	Function UniV3RouterMock.slitherConstructorVariables() (*)
		Expression: PRICE_PRECISION = 1e9
		IRs:
			PRICE_PRECISION(uint256) := 1000000000(uint256)
		Expression: _price = 1e9
		IRs:
			_price(uint256) := 1000000000(uint256)
Contract VaultRouterMock
	Function VaultRouter.constructor() 
		Expression: _disableInitializers()
		IRs:
			INTERNAL_CALL, Initializable._disableInitializers()()
	Function VaultRouter.initialize(address,IWETH) (*)
		Expression: initializeUseIERC4626(initialOwner)
		IRs:
			INTERNAL_CALL, UseIERC4626.initializeUseIERC4626(address)(initialOwner)
		Expression: _initUseWETH(address(weth))
		IRs:
			TMP_11589 = CONVERT weth to address
			INTERNAL_CALL, UseWETH._initUseWETH(address)(TMP_11589)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function VaultRouter.dispatch(uint256,bytes,uint256[]) (*)
		Expression: success = true
		IRs:
			success(bool) := True(bool)
		Expression: actionToExecute = uint32(action & Commands.THIRTY_TWO_BITS_MASK)
		IRs:
			REF_3332(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_11592(uint256) = action & REF_3332
			TMP_11593 = CONVERT TMP_11592 to uint32
			actionToExecute(uint32) := TMP_11593(uint32)
		Expression: inputMapping = uint16((action >> 32) & Commands.THIRTY_TWO_BITS_MASK)
		IRs:
			TMP_11594(uint256) = action >> 32
			REF_3333(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_11595(uint256) = TMP_11594 & REF_3333
			TMP_11596 = CONVERT TMP_11595 to uint16
			inputMapping(uint32) := TMP_11596(uint16)
		Expression: outputMapping = uint16(((action >> 64) & Commands.THIRTY_TWO_BITS_MASK))
		IRs:
			TMP_11597(uint256) = action >> 64
			REF_3334(uint32) -> Commands.THIRTY_TWO_BITS_MASK
			TMP_11598(uint256) = TMP_11597 & REF_3334
			TMP_11599 = CONVERT TMP_11598 to uint16
			outputMapping(uint32) := TMP_11599(uint16)
		Expression: actionToExecute == Commands.V3_UNISWAP_SWAP || actionToExecute == Commands.AERODROME_SWAP || actionToExecute == Commands.V2_UNISWAP_SWAP
		IRs:
			REF_3335(uint8) -> Commands.V3_UNISWAP_SWAP
			TMP_11600(bool) = actionToExecute == REF_3335
			REF_3336(uint8) -> Commands.AERODROME_SWAP
			TMP_11601(bool) = actionToExecute == REF_3336
			TMP_11602(bool) = TMP_11600 || TMP_11601
			REF_3337(uint8) -> Commands.V2_UNISWAP_SWAP
			TMP_11603(bool) = actionToExecute == REF_3337
			TMP_11604(bool) = TMP_11602 || TMP_11603
			CONDITION TMP_11604
		Expression: output = _handleSwap(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11605(bytes) = INTERNAL_CALL, VaultRouter._handleSwap(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11605(bytes)
		Expression: action == Commands.PULL_TOKEN
		IRs:
			REF_3338(uint8) -> Commands.PULL_TOKEN
			TMP_11606(bool) = action == REF_3338
			CONDITION TMP_11606
		Expression: output = _handlePullToken(data,callStack,inputMapping)
		IRs:
			TMP_11607(bytes) = INTERNAL_CALL, VaultRouter._handlePullToken(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11607(bytes)
		Expression: actionToExecute == Commands.PULL_TOKEN_FROM
		IRs:
			REF_3339(uint8) -> Commands.PULL_TOKEN_FROM
			TMP_11608(bool) = actionToExecute == REF_3339
			CONDITION TMP_11608
		Expression: output = _handlePullTokenFrom(data,callStack,inputMapping)
		IRs:
			TMP_11609(bytes) = INTERNAL_CALL, VaultRouter._handlePullTokenFrom(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11609(bytes)
		Expression: actionToExecute == Commands.PUSH_TOKEN
		IRs:
			REF_3340(uint8) -> Commands.PUSH_TOKEN
			TMP_11610(bool) = actionToExecute == REF_3340
			CONDITION TMP_11610
		Expression: output = _handlePushToken(data,callStack,inputMapping)
		IRs:
			TMP_11611(bytes) = INTERNAL_CALL, VaultRouter._handlePushToken(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11611(bytes)
		Expression: actionToExecute == Commands.PUSH_TOKEN_FROM
		IRs:
			REF_3341(uint8) -> Commands.PUSH_TOKEN_FROM
			TMP_11612(bool) = actionToExecute == REF_3341
			CONDITION TMP_11612
		Expression: output = _handlePushTokenFrom(data,callStack,inputMapping)
		IRs:
			TMP_11613(bytes) = INTERNAL_CALL, VaultRouter._handlePushTokenFrom(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11613(bytes)
		Expression: actionToExecute == Commands.SWEEP_TOKENS
		IRs:
			REF_3342(uint8) -> Commands.SWEEP_TOKENS
			TMP_11614(bool) = actionToExecute == REF_3342
			CONDITION TMP_11614
		Expression: output = _handleSweepTokens(data,callStack,outputMapping)
		IRs:
			TMP_11615(bytes) = INTERNAL_CALL, VaultRouter._handleSweepTokens(bytes,uint256[],uint32)(data,callStack,outputMapping)
			output(bytes) := TMP_11615(bytes)
		Expression: actionToExecute == Commands.WRAP_ETH
		IRs:
			REF_3343(uint8) -> Commands.WRAP_ETH
			TMP_11616(bool) = actionToExecute == REF_3343
			CONDITION TMP_11616
		Expression: output = _handleWrapETH(data,callStack,inputMapping)
		IRs:
			TMP_11617(bytes) = INTERNAL_CALL, VaultRouter._handleWrapETH(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11617(bytes)
		Expression: actionToExecute == Commands.UNWRAP_ETH
		IRs:
			REF_3344(uint8) -> Commands.UNWRAP_ETH
			TMP_11618(bool) = actionToExecute == REF_3344
			CONDITION TMP_11618
		Expression: output = _handleUnwrapETH(data,callStack,inputMapping)
		IRs:
			TMP_11619(bytes) = INTERNAL_CALL, VaultRouter._handleUnwrapETH(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11619(bytes)
		Expression: actionToExecute == Commands.PULL_TOKEN_WITH_PERMIT
		IRs:
			REF_3345(uint8) -> Commands.PULL_TOKEN_WITH_PERMIT
			TMP_11620(bool) = actionToExecute == REF_3345
			CONDITION TMP_11620
		Expression: output = _handlePullTokenWithPermit(data,callStack,inputMapping)
		IRs:
			TMP_11621(bytes) = INTERNAL_CALL, VaultRouter._handlePullTokenWithPermit(bytes,uint256[],uint32)(data,callStack,inputMapping)
			output(bytes) := TMP_11621(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_DEPOSIT
		IRs:
			REF_3346(uint8) -> Commands.ERC4626_VAULT_DEPOSIT
			TMP_11622(bool) = actionToExecute == REF_3346
			CONDITION TMP_11622
		Expression: output = _handleVaultDeposit(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11623(bytes) = INTERNAL_CALL, VaultRouter._handleVaultDeposit(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11623(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_MINT
		IRs:
			REF_3347(uint8) -> Commands.ERC4626_VAULT_MINT
			TMP_11624(bool) = actionToExecute == REF_3347
			CONDITION TMP_11624
		Expression: output = _handleVaultMint(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11625(bytes) = INTERNAL_CALL, VaultRouter._handleVaultMint(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11625(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_REDEEM
		IRs:
			REF_3348(uint8) -> Commands.ERC4626_VAULT_REDEEM
			TMP_11626(bool) = actionToExecute == REF_3348
			CONDITION TMP_11626
		Expression: output = _handleVaultRedeem(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11627(bytes) = INTERNAL_CALL, VaultRouter._handleVaultRedeem(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11627(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_WITHDRAW
		IRs:
			REF_3349(uint8) -> Commands.ERC4626_VAULT_WITHDRAW
			TMP_11628(bool) = actionToExecute == REF_3349
			CONDITION TMP_11628
		Expression: output = _handleVaultWithdraw(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11629(bytes) = INTERNAL_CALL, VaultRouter._handleVaultWithdraw(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11629(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_CONVERT_TO_SHARES
		IRs:
			REF_3350(uint8) -> Commands.ERC4626_VAULT_CONVERT_TO_SHARES
			TMP_11630(bool) = actionToExecute == REF_3350
			CONDITION TMP_11630
		Expression: output = _handleVaultConvertToShares(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11631(bytes) = INTERNAL_CALL, VaultRouter._handleVaultConvertToShares(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11631(bytes)
		Expression: actionToExecute == Commands.ERC4626_VAULT_CONVERT_TO_ASSETS
		IRs:
			REF_3351(uint8) -> Commands.ERC4626_VAULT_CONVERT_TO_ASSETS
			TMP_11632(bool) = actionToExecute == REF_3351
			CONDITION TMP_11632
		Expression: output = _handleVaultConvertToAssets(data,callStack,inputMapping,outputMapping)
		IRs:
			TMP_11633(bytes) = INTERNAL_CALL, VaultRouter._handleVaultConvertToAssets(bytes,uint256[],uint32,uint32)(data,callStack,inputMapping,outputMapping)
			output(bytes) := TMP_11633(bytes)
		Expression: revert InvalidCommand(uint256)({action:action})
		IRs:
			TMP_11634(None) = SOLIDITY_CALL revert InvalidCommand(uint256)(action)
	Function VaultRouter._handleSwap(bytes,uint256[],uint32,uint32) (*)
		Expression: params = abi.decode(data,(ISwapHandler.SwapParams))
		IRs:
			REF_3353(None) -> ISwapHandler.SwapParams
			TMP_11635(None) = SOLIDITY_CALL abi.decode()(data,REF_3353)
			params(ISwapHandler.SwapParams) := TMP_11635(None)
		Expression: params.amountIn = Commands.pullInputParam(callStack,params.amountIn,inputMapping,1)
		IRs:
			REF_3354(uint256) -> params.amountIn
			REF_3356(uint256) -> params.amountIn
			TMP_11636(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'REF_3356', 'inputMapping', '1'] 
			REF_3354(uint256) (->params) := TMP_11636(uint256)
		Expression: params.amountOut = Commands.pullInputParam(callStack,params.amountOut,inputMapping,2)
		IRs:
			REF_3357(uint256) -> params.amountOut
			REF_3359(uint256) -> params.amountOut
			TMP_11637(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'REF_3359', 'inputMapping', '2'] 
			REF_3357(uint256) (->params) := TMP_11637(uint256)
		Expression: (amountIn,amountOut) = swap(params)
		IRs:
			TUPLE_154(uint256,uint256) = INTERNAL_CALL, VaultRouterMock.swap(ISwapHandler.SwapParams)(params)
			amountIn(uint256)= UNPACK TUPLE_154 index: 0 
			amountOut(uint256)= UNPACK TUPLE_154 index: 1 
		Expression: Commands.pushOutputParam(callStack,amountIn,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amountIn', 'outputMapping', '1'] 
		Expression: Commands.pushOutputParam(callStack,amountOut,outputMapping,2)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amountOut', 'outputMapping', '2'] 
		Expression: abi.encodePacked(amountIn,amountOut)
		IRs:
			TMP_11640(bytes) = SOLIDITY_CALL abi.encodePacked()(amountIn,amountOut)
			RETURN TMP_11640
	Function VaultRouter._handlePullToken(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11641(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_11641(uint256)
		Expression: amount = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11642(bytes) = data + 32
			TMP_11643(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11642)
			amount(uint256) := TMP_11643(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11644(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11644(uint256)
		Expression: pullToken(token,amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.pullToken(IERC20,uint256)(token,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePullTokenFrom(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11646(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_11646(uint256)
		Expression: from = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11647(bytes) = data + 32
			TMP_11648(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11647)
			from(address) := TMP_11648(uint256)
		Expression: amount = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11649(bytes) = data + 64
			TMP_11650(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11649)
			amount(uint256) := TMP_11650(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11651(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11651(uint256)
		Expression: pullTokenFrom(token,from,amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.pullTokenFrom(IERC20,address,uint256)(token,from,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePushToken(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11653(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_11653(uint256)
		Expression: to = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11654(bytes) = data + 32
			TMP_11655(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11654)
			to(address) := TMP_11655(uint256)
		Expression: amount = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11656(bytes) = data + 64
			TMP_11657(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11656)
			amount(uint256) := TMP_11657(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11658(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11658(uint256)
		Expression: pushToken(token,to,amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.pushToken(IERC20,address,uint256)(token,to,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePushTokenFrom(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11660(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_11660(uint256)
		Expression: from = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11661(bytes) = data + 32
			TMP_11662(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11661)
			from(address) := TMP_11662(uint256)
		Expression: to = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11663(bytes) = data + 64
			TMP_11664(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11663)
			to(address) := TMP_11664(uint256)
		Expression: amount = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_11665(bytes) = data + 96
			TMP_11666(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11665)
			amount(uint256) := TMP_11666(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11667(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11667(uint256)
		Expression: pushTokenFrom(token,from,to,amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.pushTokenFrom(IERC20,address,address,uint256)(token,from,to,amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleSweepTokens(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11669(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20) := TMP_11669(uint256)
		Expression: to = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11670(bytes) = data + 32
			TMP_11671(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11670)
			to(address) := TMP_11671(uint256)
		Expression: sweptAmount = sweepTokens(token,to)
		IRs:
			TMP_11672(uint256) = INTERNAL_CALL, VaultRouterMock.sweepTokens(IERC20,address)(token,to)
			sweptAmount(uint256) := TMP_11672(uint256)
		Expression: Commands.pushOutputParam(callStack,sweptAmount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'sweptAmount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(sweptAmount)
		IRs:
			TMP_11674(bytes) = SOLIDITY_CALL abi.encodePacked()(sweptAmount)
			RETURN TMP_11674
	Function VaultRouter._handleWrapETH(bytes,uint256[],uint32) (*)
		Expression: amount = calldataload(uint256)(data)
		IRs:
			TMP_11675(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			amount(uint256) := TMP_11675(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11676(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11676(uint256)
		Expression: wrapETH(amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.wrapETH(uint256)(amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleUnwrapETH(bytes,uint256[],uint32) (*)
		Expression: amount = calldataload(uint256)(data)
		IRs:
			TMP_11678(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			amount(uint256) := TMP_11678(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11679(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11679(uint256)
		Expression: unwrapETH(amount)
		IRs:
			INTERNAL_CALL, VaultRouterMock.unwrapETH(uint256)(amount)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handlePullTokenWithPermit(bytes,uint256[],uint32) (*)
		Expression: token = calldataload(uint256)(data)
		IRs:
			TMP_11681(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			token(IERC20Permit) := TMP_11681(uint256)
		Expression: amount = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11682(bytes) = data + 32
			TMP_11683(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11682)
			amount(uint256) := TMP_11683(uint256)
		Expression: owner = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11684(bytes) = data + 64
			TMP_11685(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11684)
			owner(address) := TMP_11685(uint256)
		Expression: deadline = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_11686(bytes) = data + 96
			TMP_11687(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11686)
			deadline(uint256) := TMP_11687(uint256)
		Expression: v = calldataload(uint256)(data + 0x80)
		IRs:
			TMP_11688(bytes) = data + 128
			TMP_11689(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11688)
			v(uint8) := TMP_11689(uint256)
		Expression: r = calldataload(uint256)(data + 0xa0)
		IRs:
			TMP_11690(bytes) = data + 160
			TMP_11691(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11690)
			r(bytes32) := TMP_11691(uint256)
		Expression: s = calldataload(uint256)(data + 0xc0)
		IRs:
			TMP_11692(bytes) = data + 192
			TMP_11693(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11692)
			s(bytes32) := TMP_11693(uint256)
		Expression: amount = Commands.pullInputParam(callStack,amount,inputMapping,1)
		IRs:
			TMP_11694(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'inputMapping', '1'] 
			amount(uint256) := TMP_11694(uint256)
		Expression: pullTokensWithPermit(token,amount,owner,deadline,v,r,s)
		IRs:
			INTERNAL_CALL, VaultRouterMock.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32)(token,amount,owner,deadline,v,r,s)
		Expression: 
		IRs:
			RETURN 
	Function VaultRouter._handleVaultDeposit(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11696(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11696(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11697(bytes) = data + 32
			TMP_11698(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11697)
			assets(uint256) := TMP_11698(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11699(bytes) = data + 64
			TMP_11700(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11699)
			receiver(address) := TMP_11700(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_11701(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_11701(uint256)
		Expression: shares = depositVault(vault,assets,receiver)
		IRs:
			TMP_11702(uint256) = INTERNAL_CALL, VaultRouterMock.depositVault(IERC4626,uint256,address)(vault,assets,receiver)
			shares(uint256) := TMP_11702(uint256)
		Expression: Commands.pushOutputParam(callStack,shares,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'outputMapping', '1'] 
		Expression: abi.encodePacked(shares)
		IRs:
			TMP_11704(bytes) = SOLIDITY_CALL abi.encodePacked()(shares)
			RETURN TMP_11704
	Function VaultRouter._handleVaultMint(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11705(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11705(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11706(bytes) = data + 32
			TMP_11707(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11706)
			shares(uint256) := TMP_11707(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11708(bytes) = data + 64
			TMP_11709(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11708)
			receiver(address) := TMP_11709(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_11710(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_11710(uint256)
		Expression: assets = mintVault(vault,shares,receiver)
		IRs:
			TMP_11711(uint256) = INTERNAL_CALL, VaultRouterMock.mintVault(IERC4626,uint256,address)(vault,shares,receiver)
			assets(uint256) := TMP_11711(uint256)
		Expression: Commands.pushOutputParam(callStack,assets,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'outputMapping', '1'] 
		Expression: abi.encodePacked(assets)
		IRs:
			TMP_11713(bytes) = SOLIDITY_CALL abi.encodePacked()(assets)
			RETURN TMP_11713
	Function VaultRouter._handleVaultRedeem(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11714(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11714(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11715(bytes) = data + 32
			TMP_11716(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11715)
			shares(uint256) := TMP_11716(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11717(bytes) = data + 64
			TMP_11718(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11717)
			receiver(address) := TMP_11718(uint256)
		Expression: owner = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_11719(bytes) = data + 96
			TMP_11720(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11719)
			owner(address) := TMP_11720(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_11721(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_11721(uint256)
		Expression: assets = redeemVault(vault,shares,receiver,owner)
		IRs:
			TMP_11722(uint256) = INTERNAL_CALL, VaultRouterMock.redeemVault(IERC4626,uint256,address,address)(vault,shares,receiver,owner)
			assets(uint256) := TMP_11722(uint256)
		Expression: Commands.pushOutputParam(callStack,assets,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'outputMapping', '1'] 
		Expression: abi.encodePacked(assets)
		IRs:
			TMP_11724(bytes) = SOLIDITY_CALL abi.encodePacked()(assets)
			RETURN TMP_11724
	Function VaultRouter._handleVaultWithdraw(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11725(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11725(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11726(bytes) = data + 32
			TMP_11727(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11726)
			assets(uint256) := TMP_11727(uint256)
		Expression: receiver = calldataload(uint256)(data + 0x40)
		IRs:
			TMP_11728(bytes) = data + 64
			TMP_11729(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11728)
			receiver(address) := TMP_11729(uint256)
		Expression: owner = calldataload(uint256)(data + 0x60)
		IRs:
			TMP_11730(bytes) = data + 96
			TMP_11731(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11730)
			owner(address) := TMP_11731(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_11732(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_11732(uint256)
		Expression: shares = withdrawVault(vault,assets,receiver,owner)
		IRs:
			TMP_11733(uint256) = INTERNAL_CALL, VaultRouterMock.withdrawVault(IERC4626,uint256,address,address)(vault,assets,receiver,owner)
			shares(uint256) := TMP_11733(uint256)
		Expression: Commands.pushOutputParam(callStack,shares,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'outputMapping', '1'] 
		Expression: abi.encodePacked(shares)
		IRs:
			TMP_11735(bytes) = SOLIDITY_CALL abi.encodePacked()(shares)
			RETURN TMP_11735
	Function VaultRouter._handleVaultConvertToShares(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11736(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11736(uint256)
		Expression: assets = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11737(bytes) = data + 32
			TMP_11738(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11737)
			assets(uint256) := TMP_11738(uint256)
		Expression: assets = Commands.pullInputParam(callStack,assets,inputMapping,1)
		IRs:
			TMP_11739(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'assets', 'inputMapping', '1'] 
			assets(uint256) := TMP_11739(uint256)
		Expression: amount = convertToVaultShares(vault,assets)
		IRs:
			TMP_11740(uint256) = INTERNAL_CALL, UseIERC4626.convertToVaultShares(IERC4626,uint256)(vault,assets)
			amount(uint256) := TMP_11740(uint256)
		Expression: Commands.pushOutputParam(callStack,amount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(amount)
		IRs:
			TMP_11742(bytes) = SOLIDITY_CALL abi.encodePacked()(amount)
			RETURN TMP_11742
	Function VaultRouter._handleVaultConvertToAssets(bytes,uint256[],uint32,uint32) (*)
		Expression: vault = calldataload(uint256)(data)
		IRs:
			TMP_11743(uint256) = SOLIDITY_CALL calldataload(uint256)(data)
			vault(IERC4626) := TMP_11743(uint256)
		Expression: shares = calldataload(uint256)(data + 0x20)
		IRs:
			TMP_11744(bytes) = data + 32
			TMP_11745(uint256) = SOLIDITY_CALL calldataload(uint256)(TMP_11744)
			shares(uint256) := TMP_11745(uint256)
		Expression: shares = Commands.pullInputParam(callStack,shares,inputMapping,1)
		IRs:
			TMP_11746(uint256) = LIBRARY_CALL, dest:Commands, function:Commands.pullInputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'shares', 'inputMapping', '1'] 
			shares(uint256) := TMP_11746(uint256)
		Expression: amount = convertToVaultAssets(vault,shares)
		IRs:
			TMP_11747(uint256) = INTERNAL_CALL, UseIERC4626.convertToVaultAssets(IERC4626,uint256)(vault,shares)
			amount(uint256) := TMP_11747(uint256)
		Expression: Commands.pushOutputParam(callStack,amount,outputMapping,1)
		IRs:
			LIBRARY_CALL, dest:Commands, function:Commands.pushOutputParam(uint256[],uint256,uint64,uint8), arguments:['callStack', 'amount', 'outputMapping', '1'] 
		Expression: abi.encodePacked(amount)
		IRs:
			TMP_11749(bytes) = SOLIDITY_CALL abi.encodePacked()(amount)
			RETURN TMP_11749
	Function MultiCommand.dispatch(uint256,bytes,uint256[]) 
	Function MultiCommand.execute(Command[]) (*)
		Expression: numCommands = commands.length
		IRs:
			REF_3390 -> LENGTH commands
			numCommands(uint256) := REF_3390(uint256)
		Expression: callStack = new uint256[](Commands.CALL_STACK_SIZE)
		IRs:
			REF_3391(uint256) -> Commands.CALL_STACK_SIZE
			TMP_11751(uint256[])  = new uint256[](REF_3391)
			callStack(uint256[]) = ['TMP_11751(uint256[])']
		Expression: commandIndex = 0
		IRs:
			commandIndex(uint256) := 0(uint256)
		Expression: commandIndex < numCommands
		IRs:
			TMP_11752(bool) = commandIndex < numCommands
			CONDITION TMP_11752
		Expression: (success,output) = dispatch(commands[commandIndex].action,commands[commandIndex].data,callStack)
		IRs:
			REF_3392(Command) -> commands[commandIndex]
			REF_3393(uint256) -> REF_3392.action
			REF_3394(Command) -> commands[commandIndex]
			REF_3395(bytes) -> REF_3394.data
			TUPLE_155(bool,bytes) = INTERNAL_CALL, VaultRouter.dispatch(uint256,bytes,uint256[])(REF_3393,REF_3395,callStack)
			success(bool)= UNPACK TUPLE_155 index: 0 
			output(bytes)= UNPACK TUPLE_155 index: 1 
		Expression: ! success
		IRs:
			TMP_11753 = UnaryType.BANG success 
			CONDITION TMP_11753
		Expression: revert ExecutionFailed(uint256,bytes)({commandIndex:commandIndex,message:output})
		IRs:
			TMP_11754(None) = SOLIDITY_CALL revert ExecutionFailed(uint256,bytes)(commandIndex,output)
		Expression: commandIndex ++
		IRs:
			TMP_11755(uint256) := commandIndex(uint256)
			commandIndex(uint256) = commandIndex + 1
	Function UseWETH._initUseWETH(address) (*)
		Expression: _wETH = IWETH(weth)
		IRs:
			TMP_11756 = CONVERT weth to IWETH
			_wETH(IWETH) := TMP_11756(IWETH)
		Expression: address(_wETH) == address(0)
		IRs:
			TMP_11757 = CONVERT _wETH to address
			TMP_11758 = CONVERT 0 to address
			TMP_11759(bool) = TMP_11757 == TMP_11758
			CONDITION TMP_11759
		Expression: revert InvalidWETHContract()()
		IRs:
			TMP_11760(None) = SOLIDITY_CALL revert InvalidWETHContract()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseWETH.receive() (*)
	Function UseWETH.wETH() (*)
		Expression: _wETH
		IRs:
			RETURN _wETH
	Function UseWETH.wETHA() (*)
		Expression: address(_wETH)
		IRs:
			TMP_11762 = CONVERT _wETH to address
			RETURN TMP_11762
	Function UseWETH.unwrapETH(uint256) 
		Expression: wETHAmount == 0
		IRs:
			TMP_11763(bool) = wETHAmount == 0
			CONDITION TMP_11763
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_11764(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETHBalance = _wETH.balanceOf(address(this))
		IRs:
			TMP_11765 = CONVERT this to address
			TMP_11766(uint256) = HIGH_LEVEL_CALL, dest:_wETH(IWETH), function:balanceOf, arguments:['TMP_11765']  
			wETHBalance(uint256) := TMP_11766(uint256)
		Expression: wETHBalance < wETHAmount
		IRs:
			TMP_11767(bool) = wETHBalance < wETHAmount
			CONDITION TMP_11767
		Expression: revert InsufficientWETHBalance()()
		IRs:
			TMP_11768(None) = SOLIDITY_CALL revert InsufficientWETHBalance()()
		Expression: wETH().withdraw(wETHAmount)
		IRs:
			TMP_11769(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_11769(IWETH), function:withdraw, arguments:['wETHAmount']  
	Function UseWETH.wrapETH(uint256) 
		Expression: address(this).balance < amount
		IRs:
			TMP_11771 = CONVERT this to address
			TMP_11772(uint256) = SOLIDITY_CALL balance(address)(TMP_11771)
			TMP_11773(bool) = TMP_11772 < amount
			CONDITION TMP_11773
		Expression: revert InvalidWETHAmount()()
		IRs:
			TMP_11774(None) = SOLIDITY_CALL revert InvalidWETHAmount()()
		Expression: wETH().deposit{value: amount}()
		IRs:
			TMP_11775(IWETH) = INTERNAL_CALL, UseWETH.wETH()()
			HIGH_LEVEL_CALL, dest:TMP_11775(IWETH), function:deposit, arguments:[] value:amount 
	Function Initializable._disableInitializers() (*)
		Expression: require(bool,string)(! _initializing,Initializable: contract is initializing)
		IRs:
			TMP_11777 = UnaryType.BANG _initializing 
			TMP_11778(None) = SOLIDITY_CALL require(bool,string)(TMP_11777,Initializable: contract is initializing)
		Expression: _initialized != type()(uint8).max
		IRs:
			TMP_11780(uint8) := 255(uint8)
			TMP_11781(bool) = _initialized != TMP_11780
			CONDITION TMP_11781
		Expression: _initialized = type()(uint8).max
		IRs:
			TMP_11783(uint8) := 255(uint8)
			_initialized(uint8) := TMP_11783(uint8)
		Expression: Initialized(type()(uint8).max)
		IRs:
			TMP_11785(uint8) := 255(uint8)
			Emit Initialized(TMP_11785)
	Function Initializable._getInitializedVersion() (*)
		Expression: _initialized
		IRs:
			RETURN _initialized
	Function Initializable._isInitializing() (*)
		Expression: _initializing
		IRs:
			RETURN _initializing
	Function UseIERC4626.initializeUseIERC4626(address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialOwner)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialOwner)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function UseIERC4626.approveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = true
		IRs:
			REF_3399(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_3400(bool) -> REF_3399[token]
			REF_3400(bool) (->_approvedVaults) := True(bool)
		Expression: ! IERC20(token).approve(address(vault),2 ** 256 - 1)
		IRs:
			TMP_11790 = CONVERT token to IERC20
			TMP_11791 = CONVERT vault to address
			TMP_11792(uint256) = 2 (c)** 256
			TMP_11793(uint256) = TMP_11792 (c)- 1
			TMP_11794(bool) = HIGH_LEVEL_CALL, dest:TMP_11790(IERC20), function:approve, arguments:['TMP_11791', 'TMP_11793']  
			TMP_11795 = UnaryType.BANG TMP_11794 
			CONDITION TMP_11795
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_11796(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.isTokenApprovedForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token]
		IRs:
			REF_3402(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_3403(bool) -> REF_3402[token]
			RETURN REF_3403
	Function UseIERC4626.unapproveTokenForVault(IERC4626,IERC20) (*)
		Expression: _approvedVaults[vault][token] = false
		IRs:
			REF_3404(mapping(IERC20 => bool)) -> _approvedVaults[vault]
			REF_3405(bool) -> REF_3404[token]
			REF_3405(bool) (->_approvedVaults) := False(bool)
		Expression: ! IERC20(token).approve(address(vault),0)
		IRs:
			TMP_11798 = CONVERT token to IERC20
			TMP_11799 = CONVERT vault to address
			TMP_11800(bool) = HIGH_LEVEL_CALL, dest:TMP_11798(IERC20), function:approve, arguments:['TMP_11799', '0']  
			TMP_11801 = UnaryType.BANG TMP_11800 
			CONDITION TMP_11801
		Expression: revert FailedToApproveAllowanceForVault()()
		IRs:
			TMP_11802(None) = SOLIDITY_CALL revert FailedToApproveAllowanceForVault()()
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function UseIERC4626.convertToVaultAssets(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_11804 = CONVERT vault to address
			TMP_11805 = CONVERT 0 to address
			TMP_11806(bool) = TMP_11804 == TMP_11805
			CONDITION TMP_11806
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11807(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToAssets(shares)
		IRs:
			TMP_11808(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToAssets, arguments:['shares']  
			RETURN TMP_11808
	Function UseIERC4626.convertToVaultShares(IERC4626,uint256) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_11809 = CONVERT vault to address
			TMP_11810 = CONVERT 0 to address
			TMP_11811(bool) = TMP_11809 == TMP_11810
			CONDITION TMP_11811
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11812(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.convertToShares(assets)
		IRs:
			TMP_11813(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:convertToShares, arguments:['assets']  
			RETURN TMP_11813
	Function UseIERC4626.totalVaultAssets(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_11814 = CONVERT vault to address
			TMP_11815 = CONVERT 0 to address
			TMP_11816(bool) = TMP_11814 == TMP_11815
			CONDITION TMP_11816
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11817(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.totalAssets()
		IRs:
			TMP_11818(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:totalAssets, arguments:[]  
			RETURN TMP_11818
	Function UseIERC4626.vaultAsset(IERC4626) (*)
		Expression: address(vault) == address(0)
		IRs:
			TMP_11819 = CONVERT vault to address
			TMP_11820 = CONVERT 0 to address
			TMP_11821(bool) = TMP_11819 == TMP_11820
			CONDITION TMP_11821
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11822(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: vault.asset()
		IRs:
			TMP_11823(address) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:asset, arguments:[]  
			RETURN TMP_11823
	Function UseIERC4626.depositVault(IERC4626,uint256,address) 
		Expression: address(vault) == address(0)
		IRs:
			TMP_11824 = CONVERT vault to address
			TMP_11825 = CONVERT 0 to address
			TMP_11826(bool) = TMP_11824 == TMP_11825
			CONDITION TMP_11826
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11827(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: shares = vault.deposit(assets,receiver)
		IRs:
			TMP_11828(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:deposit, arguments:['assets', 'receiver']  
			shares(uint256) := TMP_11828(uint256)
	Function UseIERC4626.mintVault(IERC4626,uint256,address) 
		Expression: address(vault) == address(0)
		IRs:
			TMP_11829 = CONVERT vault to address
			TMP_11830 = CONVERT 0 to address
			TMP_11831(bool) = TMP_11829 == TMP_11830
			CONDITION TMP_11831
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11832(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.mint(shares,receiver)
		IRs:
			TMP_11833(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:mint, arguments:['shares', 'receiver']  
			assets(uint256) := TMP_11833(uint256)
	Function UseIERC4626.withdrawVault(IERC4626,uint256,address,address) 
		Expression: shares = vault.withdraw(assets,receiver,owner)
		IRs:
			TMP_11834(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:withdraw, arguments:['assets', 'receiver', 'owner']  
			shares(uint256) := TMP_11834(uint256)
	Function UseIERC4626.redeemVault(IERC4626,uint256,address,address) 
		Expression: address(vault) == address(0)
		IRs:
			TMP_11835 = CONVERT vault to address
			TMP_11836 = CONVERT 0 to address
			TMP_11837(bool) = TMP_11835 == TMP_11836
			CONDITION TMP_11837
		Expression: revert InvalidVaultAddress()()
		IRs:
			TMP_11838(None) = SOLIDITY_CALL revert InvalidVaultAddress()()
		Expression: assets = vault.redeem(shares,receiver,owner)
		IRs:
			TMP_11839(uint256) = HIGH_LEVEL_CALL, dest:vault(IERC4626), function:redeem, arguments:['shares', 'receiver', 'owner']  
			assets(uint256) := TMP_11839(uint256)
	Function GovernableOwnable._initializeGovernableOwnable(address,address) (*)
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(initialOwner)
		Expression: _transferGovernorship(initialGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(initialGovernor)
		Expression: initializer()
		IRs:
			MODIFIER_CALL, Initializable.initializer()()
	Function GovernableOwnable.governor() (*)
		Expression: _governor
		IRs:
			RETURN _governor
	Function GovernableOwnable.transferGovernorship(address) (*)
		Expression: _newGovernor == address(0)
		IRs:
			TMP_11843 = CONVERT 0 to address
			TMP_11844(bool) = _newGovernor == TMP_11843
			CONDITION TMP_11844
		Expression: revert InvalidGovernorAddress()()
		IRs:
			TMP_11845(None) = SOLIDITY_CALL revert InvalidGovernorAddress()()
		Expression: _transferGovernorship(_newGovernor)
		IRs:
			INTERNAL_CALL, GovernableOwnable._transferGovernorship(address)(_newGovernor)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function GovernableOwnable._transferGovernorship(address) (*)
		Expression: GovernshipTransferred(_governor,newGovernor)
		IRs:
			Emit GovernshipTransferred(_governor,newGovernor)
		Expression: _governor = newGovernor
		IRs:
			_governor(address) := newGovernor(address)
	Function OwnableUpgradeable.__Ownable_init() (*)
		Expression: __Ownable_init_unchained()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable.__Ownable_init_unchained()()
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.__Ownable_init_unchained() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_11851(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_11851)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function OwnableUpgradeable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function OwnableUpgradeable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_11854(address) = INTERNAL_CALL, OwnableUpgradeable.owner()()
			TMP_11855(address) = INTERNAL_CALL, ContextUpgradeable._msgSender()()
			TMP_11856(bool) = TMP_11854 == TMP_11855
			TMP_11857(None) = SOLIDITY_CALL require(bool,string)(TMP_11856,Ownable: caller is not the owner)
	Function OwnableUpgradeable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_11858 = CONVERT 0 to address
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(TMP_11858)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_11861 = CONVERT 0 to address
			TMP_11862(bool) = newOwner != TMP_11861
			TMP_11863(None) = SOLIDITY_CALL require(bool,string)(TMP_11862,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, OwnableUpgradeable.onlyOwner()()
	Function OwnableUpgradeable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function ContextUpgradeable.__Context_init() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable.__Context_init_unchained() (*)
		Expression: onlyInitializing()
		IRs:
			MODIFIER_CALL, Initializable.onlyInitializing()()
	Function ContextUpgradeable._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function ContextUpgradeable._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function ContextUpgradeable._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function UsePermitTransfers.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) 
		Expression: IERC20Permit(token).permit(owner,address(this),amount,deadline,v,r,s)
		IRs:
			TMP_11869 = CONVERT token to IERC20Permit
			TMP_11870 = CONVERT this to address
			HIGH_LEVEL_CALL, dest:TMP_11869(IERC20Permit), function:permit, arguments:['owner', 'TMP_11870', 'amount', 'deadline', 'v', 'r', 's']  
		Expression: IERC20(address(token)).safeTransferFrom(owner,address(this),amount)
		IRs:
			TMP_11872 = CONVERT token to address
			TMP_11873 = CONVERT TMP_11872 to IERC20
			TMP_11874 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11873', 'owner', 'TMP_11874', 'amount'] 
	Function UseTokenActions.pullToken(IERC20,uint256) 
		Expression: address(token) == address(0)
		IRs:
			TMP_11876 = CONVERT token to address
			TMP_11877 = CONVERT 0 to address
			TMP_11878(bool) = TMP_11876 == TMP_11877
			CONDITION TMP_11878
		Expression: revert InvalidToken()()
		IRs:
			TMP_11879(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(msg.sender,address(this)) < amount
		IRs:
			TMP_11880 = CONVERT this to address
			TMP_11881(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['msg.sender', 'TMP_11880']  
			TMP_11882(bool) = TMP_11881 < amount
			CONDITION TMP_11882
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_11883(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(msg.sender,address(this),amount)
		IRs:
			TMP_11884 = CONVERT token to IERC20
			TMP_11885 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11884', 'msg.sender', 'TMP_11885', 'amount'] 
	Function UseTokenActions.pullTokenFrom(IERC20,address,uint256) 
		Expression: address(token) == address(0)
		IRs:
			TMP_11887 = CONVERT token to address
			TMP_11888 = CONVERT 0 to address
			TMP_11889(bool) = TMP_11887 == TMP_11888
			CONDITION TMP_11889
		Expression: revert InvalidToken()()
		IRs:
			TMP_11890(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_11891 = CONVERT this to address
			TMP_11892(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_11891']  
			TMP_11893(bool) = TMP_11892 < amount
			CONDITION TMP_11893
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_11894(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,address(this),amount)
		IRs:
			TMP_11895 = CONVERT token to IERC20
			TMP_11896 = CONVERT this to address
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11895', 'from', 'TMP_11896', 'amount'] 
	Function UseTokenActions.pushToken(IERC20,address,uint256) 
		Expression: address(token) == address(0)
		IRs:
			TMP_11898 = CONVERT token to address
			TMP_11899 = CONVERT 0 to address
			TMP_11900(bool) = TMP_11898 == TMP_11899
			CONDITION TMP_11900
		Expression: revert InvalidToken()()
		IRs:
			TMP_11901(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_11902 = CONVERT to to address
			TMP_11903 = CONVERT 0 to address
			TMP_11904(bool) = TMP_11902 == TMP_11903
			CONDITION TMP_11904
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_11905(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: IERC20(token).safeTransfer(to,amount)
		IRs:
			TMP_11906 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_11906', 'to', 'amount'] 
	Function UseTokenActions.pushTokenFrom(IERC20,address,address,uint256) 
		Expression: address(token) == address(0)
		IRs:
			TMP_11908 = CONVERT token to address
			TMP_11909 = CONVERT 0 to address
			TMP_11910(bool) = TMP_11908 == TMP_11909
			CONDITION TMP_11910
		Expression: revert InvalidToken()()
		IRs:
			TMP_11911(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_11912 = CONVERT to to address
			TMP_11913 = CONVERT 0 to address
			TMP_11914(bool) = TMP_11912 == TMP_11913
			CONDITION TMP_11914
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_11915(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: token.allowance(from,address(this)) < amount
		IRs:
			TMP_11916 = CONVERT this to address
			TMP_11917(uint256) = HIGH_LEVEL_CALL, dest:token(IERC20), function:allowance, arguments:['from', 'TMP_11916']  
			TMP_11918(bool) = TMP_11917 < amount
			CONDITION TMP_11918
		Expression: revert NotEnoughAllowance()()
		IRs:
			TMP_11919(None) = SOLIDITY_CALL revert NotEnoughAllowance()()
		Expression: IERC20(token).safeTransferFrom(from,to,amount)
		IRs:
			TMP_11920 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_11920', 'from', 'to', 'amount'] 
	Function UseTokenActions.sweepTokens(IERC20,address) 
		Expression: address(token) == address(0)
		IRs:
			TMP_11922 = CONVERT token to address
			TMP_11923 = CONVERT 0 to address
			TMP_11924(bool) = TMP_11922 == TMP_11923
			CONDITION TMP_11924
		Expression: revert InvalidToken()()
		IRs:
			TMP_11925(None) = SOLIDITY_CALL revert InvalidToken()()
		Expression: address(to) == address(0)
		IRs:
			TMP_11926 = CONVERT to to address
			TMP_11927 = CONVERT 0 to address
			TMP_11928(bool) = TMP_11926 == TMP_11927
			CONDITION TMP_11928
		Expression: revert InvalidRecipient()()
		IRs:
			TMP_11929(None) = SOLIDITY_CALL revert InvalidRecipient()()
		Expression: sweptAmount = IERC20(token).balanceOf(address(this))
		IRs:
			TMP_11930 = CONVERT token to IERC20
			TMP_11931 = CONVERT this to address
			TMP_11932(uint256) = HIGH_LEVEL_CALL, dest:TMP_11930(IERC20), function:balanceOf, arguments:['TMP_11931']  
			sweptAmount(uint256) := TMP_11932(uint256)
		Expression: IERC20(token).safeTransfer(to,sweptAmount)
		IRs:
			TMP_11933 = CONVERT token to IERC20
			LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_11933', 'to', 'sweptAmount'] 
	Function UseUnifiedSwapper._key(address,address) (*)
		Expression: tokenA < tokenB
		IRs:
			TMP_11935(bool) = tokenA < tokenB
			CONDITION TMP_11935
		Expression: keccak256(bytes)(abi.encode((tokenA,tokenB)))
		IRs:
			TMP_11936(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d9179110>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d9173a90>])
			TMP_11937(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11936)
			RETURN TMP_11937
		Expression: keccak256(bytes)(abi.encode((tokenB,tokenA)))
		IRs:
			TMP_11938(bytes) = SOLIDITY_CALL abi.encode()([<slither.core.variables.local_variable.LocalVariable object at 0x7339d9173a90>, <slither.core.variables.local_variable.LocalVariable object at 0x7339d9179110>])
			TMP_11939(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_11938)
			RETURN TMP_11939
	Function UseUnifiedSwapper.enableRoute(address,address,UseUnifiedSwapper.RouteInfo) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_11940(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_11940(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_3428(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3429(UseUnifiedSwapper.SwapProvider) -> REF_3428.provider
			REF_3430(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_11941(bool) = REF_3429 != REF_3430
			CONDITION TMP_11941
		Expression: revert RouteAlreadyAuthorized()()
		IRs:
			TMP_11942(None) = SOLIDITY_CALL revert RouteAlreadyAuthorized()()
		Expression: ! IERC20(tokenIn).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_11943 = CONVERT tokenIn to IERC20
			REF_3432(address) -> routeInfo.router
			TMP_11945(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_11946(uint256) = TMP_11945 (c)- 1
			TMP_11947(bool) = HIGH_LEVEL_CALL, dest:TMP_11943(IERC20), function:approve, arguments:['REF_3432', 'TMP_11946']  
			TMP_11948 = UnaryType.BANG TMP_11947 
			CONDITION TMP_11948
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_11949(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(routeInfo.router,type()(uint256).max - 1)
		IRs:
			TMP_11950 = CONVERT tokenOut to IERC20
			REF_3434(address) -> routeInfo.router
			TMP_11952(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_11953(uint256) = TMP_11952 (c)- 1
			TMP_11954(bool) = HIGH_LEVEL_CALL, dest:TMP_11950(IERC20), function:approve, arguments:['REF_3434', 'TMP_11953']  
			TMP_11955 = UnaryType.BANG TMP_11954 
			CONDITION TMP_11955
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_11956(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key] = routeInfo
		IRs:
			REF_3435(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3435(UseUnifiedSwapper.RouteInfo) (->_routes) := routeInfo(UseUnifiedSwapper.RouteInfo)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.disableRoute(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_11958(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_11958(bytes32)
		Expression: _routes[key].provider == SwapProvider.NONE
		IRs:
			REF_3436(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3437(UseUnifiedSwapper.SwapProvider) -> REF_3436.provider
			REF_3438(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_11959(bool) = REF_3437 == REF_3438
			CONDITION TMP_11959
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_11960(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: ! IERC20(tokenIn).approve(_routes[key].router,0)
		IRs:
			TMP_11961 = CONVERT tokenIn to IERC20
			REF_3440(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3441(address) -> REF_3440.router
			TMP_11962(bool) = HIGH_LEVEL_CALL, dest:TMP_11961(IERC20), function:approve, arguments:['REF_3441', '0']  
			TMP_11963 = UnaryType.BANG TMP_11962 
			CONDITION TMP_11963
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_11964(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: ! IERC20(tokenOut).approve(_routes[key].router,0)
		IRs:
			TMP_11965 = CONVERT tokenOut to IERC20
			REF_3443(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3444(address) -> REF_3443.router
			TMP_11966(bool) = HIGH_LEVEL_CALL, dest:TMP_11965(IERC20), function:approve, arguments:['REF_3444', '0']  
			TMP_11967 = UnaryType.BANG TMP_11966 
			CONDITION TMP_11967
		Expression: revert FailedToApproveAllowance()()
		IRs:
			TMP_11968(None) = SOLIDITY_CALL revert FailedToApproveAllowance()()
		Expression: _routes[key].provider = SwapProvider.NONE
		IRs:
			REF_3445(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3446(UseUnifiedSwapper.SwapProvider) -> REF_3445.provider
			REF_3447(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			REF_3446(UseUnifiedSwapper.SwapProvider) (->_routes) := REF_3447(UseUnifiedSwapper.SwapProvider)
		Expression: onlyGovernor()
		IRs:
			MODIFIER_CALL, GovernableOwnable.onlyGovernor()()
	Function UseUnifiedSwapper.isRouteEnabled(address,address) (*)
		Expression: key = _key(tokenIn,tokenOut)
		IRs:
			TMP_11970(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(tokenIn,tokenOut)
			key(bytes32) := TMP_11970(bytes32)
		Expression: _routes[key].provider != SwapProvider.NONE
		IRs:
			REF_3448(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			REF_3449(UseUnifiedSwapper.SwapProvider) -> REF_3448.provider
			REF_3450(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_11971(bool) = REF_3449 != REF_3450
			RETURN TMP_11971
	Function UseUnifiedSwapper.swap(ISwapHandler.SwapParams) 
		Expression: key = _key(params.underlyingIn,params.underlyingOut)
		IRs:
			REF_3451(address) -> params.underlyingIn
			REF_3452(address) -> params.underlyingOut
			TMP_11972(bytes32) = INTERNAL_CALL, UseUnifiedSwapper._key(address,address)(REF_3451,REF_3452)
			key(bytes32) := TMP_11972(bytes32)
		Expression: routeInfo = _routes[key]
		IRs:
			REF_3453(UseUnifiedSwapper.RouteInfo) -> _routes[key]
			routeInfo(UseUnifiedSwapper.RouteInfo) := REF_3453(UseUnifiedSwapper.RouteInfo)
		Expression: routeInfo.provider == SwapProvider.NONE
		IRs:
			REF_3454(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_3455(UseUnifiedSwapper.SwapProvider) -> SwapProvider.NONE
			TMP_11973(bool) = REF_3454 == REF_3455
			CONDITION TMP_11973
		Expression: revert RouteNotAuthorized()()
		IRs:
			TMP_11974(None) = SOLIDITY_CALL revert RouteNotAuthorized()()
		Expression: routeInfo.provider == SwapProvider.UNIV3
		IRs:
			REF_3456(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_3457(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV3
			TMP_11975(bool) = REF_3456 == REF_3457
			CONDITION TMP_11975
		Expression: params.payload = abi.encode(routeInfo.uniV3Tier)
		IRs:
			REF_3458(bytes) -> params.payload
			REF_3460(uint24) -> routeInfo.uniV3Tier
			TMP_11976(bytes) = SOLIDITY_CALL abi.encode()(REF_3460)
			REF_3458(bytes) (->params) := TMP_11976(bytes)
		Expression: UniV3Library.swapUniV3(IV3SwapRouter(routeInfo.router),params)
		IRs:
			REF_3462(address) -> routeInfo.router
			TMP_11977 = CONVERT REF_3462 to IV3SwapRouter
			TUPLE_156(uint256,uint256) = LIBRARY_CALL, dest:UniV3Library, function:UniV3Library.swapUniV3(IV3SwapRouter,ISwapHandler.SwapParams), arguments:['TMP_11977', 'params'] 
			RETURN TUPLE_156
		Expression: routeInfo.provider == SwapProvider.UNIV2
		IRs:
			REF_3463(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_3464(UseUnifiedSwapper.SwapProvider) -> SwapProvider.UNIV2
			TMP_11978(bool) = REF_3463 == REF_3464
			CONDITION TMP_11978
		Expression: UniV2Library.swapUniV2(IUniswapV2Router02(routeInfo.router),params)
		IRs:
			REF_3466(address) -> routeInfo.router
			TMP_11979 = CONVERT REF_3466 to IUniswapV2Router02
			TUPLE_157(uint256,uint256) = LIBRARY_CALL, dest:UniV2Library, function:UniV2Library.swapUniV2(IUniswapV2Router02,ISwapHandler.SwapParams), arguments:['TMP_11979', 'params'] 
			RETURN TUPLE_157
		Expression: routeInfo.provider == SwapProvider.AERODROME
		IRs:
			REF_3467(UseUnifiedSwapper.SwapProvider) -> routeInfo.provider
			REF_3468(UseUnifiedSwapper.SwapProvider) -> SwapProvider.AERODROME
			TMP_11980(bool) = REF_3467 == REF_3468
			CONDITION TMP_11980
		Expression: params.payload = abi.encode(routeInfo.tickSpacing)
		IRs:
			REF_3469(bytes) -> params.payload
			REF_3471(uint24) -> routeInfo.tickSpacing
			TMP_11981(bytes) = SOLIDITY_CALL abi.encode()(REF_3471)
			REF_3469(bytes) (->params) := TMP_11981(bytes)
		Expression: AerodromeLibrary.swapAerodrome(ISwapRouter(routeInfo.router),params)
		IRs:
			REF_3473(address) -> routeInfo.router
			TMP_11982 = CONVERT REF_3473 to ISwapRouter
			TUPLE_158(uint256,uint256) = LIBRARY_CALL, dest:AerodromeLibrary, function:AerodromeLibrary.swapAerodrome(ISwapRouter,ISwapHandler.SwapParams), arguments:['TMP_11982', 'params'] 
			RETURN TUPLE_158
		Expression: revert InvalidProvider()()
		IRs:
			TMP_11983(None) = SOLIDITY_CALL revert InvalidProvider()()
	Function ISwapHandler.swap(ISwapHandler.SwapParams) 
	Function VaultRouterMock.constructor() (*)
	Function VaultRouterMock.swap(ISwapHandler.SwapParams) (*)
		Expression: callInput = abi.encode(params.underlyingIn,params.underlyingOut,params.mode,params.amountIn,params.amountOut,params.payload)
		IRs:
			REF_3475(address) -> params.underlyingIn
			REF_3476(address) -> params.underlyingOut
			REF_3477(ISwapHandler.SwapType) -> params.mode
			REF_3478(uint256) -> params.amountIn
			REF_3479(uint256) -> params.amountOut
			REF_3480(bytes) -> params.payload
			TMP_11984(bytes) = SOLIDITY_CALL abi.encode()(REF_3475,REF_3476,REF_3477,REF_3478,REF_3479,REF_3480)
			callInput(bytes) := TMP_11984(bytes)
		Expression: (params.amountIn,params.amountOut)
		IRs:
			REF_3481(uint256) -> params.amountIn
			REF_3482(uint256) -> params.amountOut
			RETURN REF_3481,REF_3482
	Function VaultRouterMock.pullToken(IERC20,uint256) (*)
		Expression: callInput = abi.encode(token,amount)
		IRs:
			TMP_11985(bytes) = SOLIDITY_CALL abi.encode()(token,amount)
			callInput(bytes) := TMP_11985(bytes)
	Function VaultRouterMock.pushToken(IERC20,address,uint256) (*)
		Expression: callInput = abi.encode(token,to,amount)
		IRs:
			TMP_11986(bytes) = SOLIDITY_CALL abi.encode()(token,to,amount)
			callInput(bytes) := TMP_11986(bytes)
	Function VaultRouterMock.pullTokenFrom(IERC20,address,uint256) (*)
		Expression: callInput = abi.encode(token,from,amount)
		IRs:
			TMP_11987(bytes) = SOLIDITY_CALL abi.encode()(token,from,amount)
			callInput(bytes) := TMP_11987(bytes)
	Function VaultRouterMock.pushTokenFrom(IERC20,address,address,uint256) (*)
		Expression: callInput = abi.encode(token,from,to,amount)
		IRs:
			TMP_11988(bytes) = SOLIDITY_CALL abi.encode()(token,from,to,amount)
			callInput(bytes) := TMP_11988(bytes)
	Function VaultRouterMock.sweepTokens(IERC20,address) (*)
		Expression: callInput = abi.encode(token,to)
		IRs:
			TMP_11989(bytes) = SOLIDITY_CALL abi.encode()(token,to)
			callInput(bytes) := TMP_11989(bytes)
		Expression: amount
		IRs:
			RETURN amount
	Function VaultRouterMock.wrapETH(uint256) (*)
		Expression: callInput = abi.encode(amount)
		IRs:
			TMP_11990(bytes) = SOLIDITY_CALL abi.encode()(amount)
			callInput(bytes) := TMP_11990(bytes)
	Function VaultRouterMock.unwrapETH(uint256) (*)
		Expression: callInput = abi.encode(amount)
		IRs:
			TMP_11991(bytes) = SOLIDITY_CALL abi.encode()(amount)
			callInput(bytes) := TMP_11991(bytes)
	Function VaultRouterMock.depositVault(IERC4626,uint256,address) (*)
		Expression: callInput = abi.encode(vault,assets,receiver)
		IRs:
			TMP_11992(bytes) = SOLIDITY_CALL abi.encode()(vault,assets,receiver)
			callInput(bytes) := TMP_11992(bytes)
		Expression: shares
		IRs:
			RETURN shares
	Function VaultRouterMock.mintVault(IERC4626,uint256,address) (*)
		Expression: callInput = abi.encode(vault,shares,receiver)
		IRs:
			TMP_11993(bytes) = SOLIDITY_CALL abi.encode()(vault,shares,receiver)
			callInput(bytes) := TMP_11993(bytes)
		Expression: assets
		IRs:
			RETURN assets
	Function VaultRouterMock.redeemVault(IERC4626,uint256,address,address) (*)
		Expression: callInput = abi.encode(vault,shares,receiver,owner)
		IRs:
			TMP_11994(bytes) = SOLIDITY_CALL abi.encode()(vault,shares,receiver,owner)
			callInput(bytes) := TMP_11994(bytes)
		Expression: assets
		IRs:
			RETURN assets
	Function VaultRouterMock.withdrawVault(IERC4626,uint256,address,address) (*)
		Expression: callInput = abi.encode(vault,assets,receiver,owner)
		IRs:
			TMP_11995(bytes) = SOLIDITY_CALL abi.encode()(vault,assets,receiver,owner)
			callInput(bytes) := TMP_11995(bytes)
		Expression: shares
		IRs:
			RETURN shares
	Function VaultRouterMock.pullTokensWithPermit(IERC20Permit,uint256,address,uint256,uint8,bytes32,bytes32) (*)
		Expression: callInput = abi.encode(token,amount,owner,deadline,v,r,s)
		IRs:
			TMP_11996(bytes) = SOLIDITY_CALL abi.encode()(token,amount,owner,deadline,v,r,s)
			callInput(bytes) := TMP_11996(bytes)
	Modifier Initializable.initializer()
		Expression: isTopLevelCall = ! _initializing
		IRs:
			TMP_11997 = UnaryType.BANG _initializing 
			isTopLevelCall(bool) := TMP_11997(bool)
		Expression: require(bool,string)((isTopLevelCall && _initialized < 1) || (! AddressUpgradeable.isContract(address(this)) && _initialized == 1),Initializable: contract is already initialized)
		IRs:
			TMP_11998(bool) = _initialized < 1
			TMP_11999(bool) = isTopLevelCall && TMP_11998
			TMP_12000 = CONVERT this to address
			TMP_12001(bool) = LIBRARY_CALL, dest:AddressUpgradeable, function:AddressUpgradeable.isContract(address), arguments:['TMP_12000'] 
			TMP_12002 = UnaryType.BANG TMP_12001 
			TMP_12003(bool) = _initialized == 1
			TMP_12004(bool) = TMP_12002 && TMP_12003
			TMP_12005(bool) = TMP_11999 || TMP_12004
			TMP_12006(None) = SOLIDITY_CALL require(bool,string)(TMP_12005,Initializable: contract is already initialized)
		Expression: _initialized = 1
		IRs:
			_initialized(uint8) := 1(uint256)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: isTopLevelCall
		IRs:
			CONDITION isTopLevelCall
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(1)
		IRs:
			Emit Initialized(1)
	Modifier Initializable.reinitializer(uint8)
		Expression: require(bool,string)(! _initializing && _initialized < version,Initializable: contract is already initialized)
		IRs:
			TMP_12008 = UnaryType.BANG _initializing 
			TMP_12009(bool) = _initialized < version
			TMP_12010(bool) = TMP_12008 && TMP_12009
			TMP_12011(None) = SOLIDITY_CALL require(bool,string)(TMP_12010,Initializable: contract is already initialized)
		Expression: _initialized = version
		IRs:
			_initialized(uint8) := version(uint8)
		Expression: _initializing = true
		IRs:
			_initializing(bool) := True(bool)
		Expression: _initializing = false
		IRs:
			_initializing(bool) := False(bool)
		Expression: Initialized(version)
		IRs:
			Emit Initialized(version)
	Modifier Initializable.onlyInitializing()
		Expression: require(bool,string)(_initializing,Initializable: contract is not initializing)
		IRs:
			TMP_12013(None) = SOLIDITY_CALL require(bool,string)(_initializing,Initializable: contract is not initializing)
	Modifier GovernableOwnable.onlyGovernor()
		Expression: msg.sender != governor()
		IRs:
			TMP_12014(address) = INTERNAL_CALL, GovernableOwnable.governor()()
			TMP_12015(bool) = msg.sender != TMP_12014
			CONDITION TMP_12015
		Expression: revert CallerNotTheGovernor()()
		IRs:
			TMP_12016(None) = SOLIDITY_CALL revert CallerNotTheGovernor()()
	Modifier OwnableUpgradeable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, OwnableUpgradeable._checkOwner()()
Contract WETH
	Function WETH.receive() (*)
		Expression: deposit()
		IRs:
			INTERNAL_CALL, WETH.deposit()()
	Function WETH.deposit() (*)
		Expression: balanceOf[msg.sender] += msg.value
		IRs:
			REF_3496(uint256) -> balanceOf[msg.sender]
			REF_3496(-> balanceOf) = REF_3496 (c)+ msg.value
		Expression: Deposit(msg.sender,msg.value)
		IRs:
			Emit Deposit(msg.sender,msg.value)
	Function WETH.withdraw(uint256) (*)
		Expression: require(bool)(balanceOf[msg.sender] >= wad)
		IRs:
			REF_3497(uint256) -> balanceOf[msg.sender]
			TMP_12020(bool) = REF_3497 >= wad
			TMP_12021(None) = SOLIDITY_CALL require(bool)(TMP_12020)
		Expression: balanceOf[msg.sender] -= wad
		IRs:
			REF_3498(uint256) -> balanceOf[msg.sender]
			REF_3498(-> balanceOf) = REF_3498 (c)- wad
		Expression: address(msg.sender).transfer(wad)
		IRs:
			TMP_12022 = CONVERT msg.sender to address
			Transfer dest:TMP_12022 value:wad
		Expression: Withdrawal(msg.sender,wad)
		IRs:
			Emit Withdrawal(msg.sender,wad)
	Function WETH.totalSupply() (*)
		Expression: address(this).balance
		IRs:
			TMP_12025 = CONVERT this to address
			TMP_12026(uint256) = SOLIDITY_CALL balance(address)(TMP_12025)
			RETURN TMP_12026
	Function WETH.approve(address,uint256) (*)
		Expression: allowance[msg.sender][guy] = wad
		IRs:
			REF_3500(mapping(address => uint256)) -> allowance[msg.sender]
			REF_3501(uint256) -> REF_3500[guy]
			REF_3501(uint256) (->allowance) := wad(uint256)
		Expression: Approval(msg.sender,guy,wad)
		IRs:
			Emit Approval(msg.sender,guy,wad)
		Expression: true
		IRs:
			RETURN True
	Function WETH.transfer(address,uint256) (*)
		Expression: transferFrom(msg.sender,dst,wad)
		IRs:
			TMP_12028(bool) = INTERNAL_CALL, WETH.transferFrom(address,address,uint256)(msg.sender,dst,wad)
			RETURN TMP_12028
	Function WETH.transferFrom(address,address,uint256) (*)
		Expression: require(bool)(balanceOf[src] >= wad)
		IRs:
			REF_3502(uint256) -> balanceOf[src]
			TMP_12029(bool) = REF_3502 >= wad
			TMP_12030(None) = SOLIDITY_CALL require(bool)(TMP_12029)
		Expression: src != msg.sender && allowance[src][msg.sender] != type()(uint256).max
		IRs:
			TMP_12031(bool) = src != msg.sender
			REF_3503(mapping(address => uint256)) -> allowance[src]
			REF_3504(uint256) -> REF_3503[msg.sender]
			TMP_12033(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_12034(bool) = REF_3504 != TMP_12033
			TMP_12035(bool) = TMP_12031 && TMP_12034
			CONDITION TMP_12035
		Expression: require(bool)(allowance[src][msg.sender] >= wad)
		IRs:
			REF_3505(mapping(address => uint256)) -> allowance[src]
			REF_3506(uint256) -> REF_3505[msg.sender]
			TMP_12036(bool) = REF_3506 >= wad
			TMP_12037(None) = SOLIDITY_CALL require(bool)(TMP_12036)
		Expression: allowance[src][msg.sender] -= wad
		IRs:
			REF_3507(mapping(address => uint256)) -> allowance[src]
			REF_3508(uint256) -> REF_3507[msg.sender]
			REF_3508(-> allowance) = REF_3508 (c)- wad
		Expression: balanceOf[src] -= wad
		IRs:
			REF_3509(uint256) -> balanceOf[src]
			REF_3509(-> balanceOf) = REF_3509 (c)- wad
		Expression: balanceOf[dst] += wad
		IRs:
			REF_3510(uint256) -> balanceOf[dst]
			REF_3510(-> balanceOf) = REF_3510 (c)+ wad
		Expression: Transfer(src,dst,wad)
		IRs:
			Emit Transfer(src,dst,wad)
		Expression: true
		IRs:
			RETURN True
	Function WETH.slitherConstructorConstantVariables() (*)
		Expression: name = Wrapped Ether
		IRs:
			name(string) := Wrapped Ether(string)
		Expression: symbol = WETH
		IRs:
			symbol(string) := WETH(string)
		Expression: decimals = 18
		IRs:
			decimals(uint8) := 18(uint256)
Contract WstETHMock
	Function ERC20.constructor(string,string) (*)
		Expression: _name = name_
		IRs:
			_name(string) := name_(string)
		Expression: _symbol = symbol_
		IRs:
			_symbol(string) := symbol_(string)
	Function ERC20.name() (*)
		Expression: _name
		IRs:
			RETURN _name
	Function ERC20.symbol() (*)
		Expression: _symbol
		IRs:
			RETURN _symbol
	Function ERC20.decimals() (*)
		Expression: 18
		IRs:
			RETURN 18
	Function ERC20.totalSupply() (*)
		Expression: _totalSupply
		IRs:
			RETURN _totalSupply
	Function ERC20.balanceOf(address) (*)
		Expression: _balances[account]
		IRs:
			REF_3511(uint256) -> _balances[account]
			RETURN REF_3511
	Function ERC20.transfer(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_12039(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_12039(address)
		Expression: _transfer(owner,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(owner,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.allowance(address,address) (*)
		Expression: _allowances[owner][spender]
		IRs:
			REF_3512(mapping(address => uint256)) -> _allowances[owner]
			REF_3513(uint256) -> REF_3512[spender]
			RETURN REF_3513
	Function ERC20.approve(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_12041(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_12041(address)
		Expression: _approve(owner,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.transferFrom(address,address,uint256) (*)
		Expression: spender = _msgSender()
		IRs:
			TMP_12043(address) = INTERNAL_CALL, Context._msgSender()()
			spender(address) := TMP_12043(address)
		Expression: _spendAllowance(from,spender,amount)
		IRs:
			INTERNAL_CALL, ERC20._spendAllowance(address,address,uint256)(from,spender,amount)
		Expression: _transfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,amount)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.increaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_12046(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_12046(address)
		Expression: _approve(owner,spender,allowance(owner,spender) + addedValue)
		IRs:
			TMP_12047(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			TMP_12048(uint256) = TMP_12047 (c)+ addedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_12048)
		Expression: true
		IRs:
			RETURN True
	Function ERC20.decreaseAllowance(address,uint256) (*)
		Expression: owner = _msgSender()
		IRs:
			TMP_12050(address) = INTERNAL_CALL, Context._msgSender()()
			owner(address) := TMP_12050(address)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_12051(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_12051(uint256)
		Expression: require(bool,string)(currentAllowance >= subtractedValue,ERC20: decreased allowance below zero)
		IRs:
			TMP_12052(bool) = currentAllowance >= subtractedValue
			TMP_12053(None) = SOLIDITY_CALL require(bool,string)(TMP_12052,ERC20: decreased allowance below zero)
		Expression: _approve(owner,spender,currentAllowance - subtractedValue)
		IRs:
			TMP_12054(uint256) = currentAllowance - subtractedValue
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_12054)
		Expression: true
		IRs:
			RETURN True
	Function ERC20._transfer(address,address,uint256) (*)
		Expression: require(bool,string)(from != address(0),ERC20: transfer from the zero address)
		IRs:
			TMP_12056 = CONVERT 0 to address
			TMP_12057(bool) = from != TMP_12056
			TMP_12058(None) = SOLIDITY_CALL require(bool,string)(TMP_12057,ERC20: transfer from the zero address)
		Expression: require(bool,string)(to != address(0),ERC20: transfer to the zero address)
		IRs:
			TMP_12059 = CONVERT 0 to address
			TMP_12060(bool) = to != TMP_12059
			TMP_12061(None) = SOLIDITY_CALL require(bool,string)(TMP_12060,ERC20: transfer to the zero address)
		Expression: _beforeTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(from,to,amount)
		Expression: fromBalance = _balances[from]
		IRs:
			REF_3514(uint256) -> _balances[from]
			fromBalance(uint256) := REF_3514(uint256)
		Expression: require(bool,string)(fromBalance >= amount,ERC20: transfer amount exceeds balance)
		IRs:
			TMP_12063(bool) = fromBalance >= amount
			TMP_12064(None) = SOLIDITY_CALL require(bool,string)(TMP_12063,ERC20: transfer amount exceeds balance)
		Expression: _balances[from] = fromBalance - amount
		IRs:
			REF_3515(uint256) -> _balances[from]
			TMP_12065(uint256) = fromBalance - amount
			REF_3515(uint256) (->_balances) := TMP_12065(uint256)
		Expression: _balances[to] += amount
		IRs:
			REF_3516(uint256) -> _balances[to]
			REF_3516(-> _balances) = REF_3516 + amount
		Expression: Transfer(from,to,amount)
		IRs:
			Emit Transfer(from,to,amount)
		Expression: _afterTokenTransfer(from,to,amount)
		IRs:
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(from,to,amount)
	Function ERC20._mint(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: mint to the zero address)
		IRs:
			TMP_12068 = CONVERT 0 to address
			TMP_12069(bool) = account != TMP_12068
			TMP_12070(None) = SOLIDITY_CALL require(bool,string)(TMP_12069,ERC20: mint to the zero address)
		Expression: _beforeTokenTransfer(address(0),account,amount)
		IRs:
			TMP_12071 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(TMP_12071,account,amount)
		Expression: _totalSupply += amount
		IRs:
			_totalSupply(uint256) = _totalSupply (c)+ amount
		Expression: _balances[account] += amount
		IRs:
			REF_3517(uint256) -> _balances[account]
			REF_3517(-> _balances) = REF_3517 + amount
		Expression: Transfer(address(0),account,amount)
		IRs:
			TMP_12073 = CONVERT 0 to address
			Emit Transfer(TMP_12073,account,amount)
		Expression: _afterTokenTransfer(address(0),account,amount)
		IRs:
			TMP_12075 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(TMP_12075,account,amount)
	Function ERC20._burn(address,uint256) (*)
		Expression: require(bool,string)(account != address(0),ERC20: burn from the zero address)
		IRs:
			TMP_12077 = CONVERT 0 to address
			TMP_12078(bool) = account != TMP_12077
			TMP_12079(None) = SOLIDITY_CALL require(bool,string)(TMP_12078,ERC20: burn from the zero address)
		Expression: _beforeTokenTransfer(account,address(0),amount)
		IRs:
			TMP_12080 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._beforeTokenTransfer(address,address,uint256)(account,TMP_12080,amount)
		Expression: accountBalance = _balances[account]
		IRs:
			REF_3518(uint256) -> _balances[account]
			accountBalance(uint256) := REF_3518(uint256)
		Expression: require(bool,string)(accountBalance >= amount,ERC20: burn amount exceeds balance)
		IRs:
			TMP_12082(bool) = accountBalance >= amount
			TMP_12083(None) = SOLIDITY_CALL require(bool,string)(TMP_12082,ERC20: burn amount exceeds balance)
		Expression: _balances[account] = accountBalance - amount
		IRs:
			REF_3519(uint256) -> _balances[account]
			TMP_12084(uint256) = accountBalance - amount
			REF_3519(uint256) (->_balances) := TMP_12084(uint256)
		Expression: _totalSupply -= amount
		IRs:
			_totalSupply(uint256) = _totalSupply - amount
		Expression: Transfer(account,address(0),amount)
		IRs:
			TMP_12085 = CONVERT 0 to address
			Emit Transfer(account,TMP_12085,amount)
		Expression: _afterTokenTransfer(account,address(0),amount)
		IRs:
			TMP_12087 = CONVERT 0 to address
			INTERNAL_CALL, ERC20._afterTokenTransfer(address,address,uint256)(account,TMP_12087,amount)
	Function ERC20._approve(address,address,uint256) (*)
		Expression: require(bool,string)(owner != address(0),ERC20: approve from the zero address)
		IRs:
			TMP_12089 = CONVERT 0 to address
			TMP_12090(bool) = owner != TMP_12089
			TMP_12091(None) = SOLIDITY_CALL require(bool,string)(TMP_12090,ERC20: approve from the zero address)
		Expression: require(bool,string)(spender != address(0),ERC20: approve to the zero address)
		IRs:
			TMP_12092 = CONVERT 0 to address
			TMP_12093(bool) = spender != TMP_12092
			TMP_12094(None) = SOLIDITY_CALL require(bool,string)(TMP_12093,ERC20: approve to the zero address)
		Expression: _allowances[owner][spender] = amount
		IRs:
			REF_3520(mapping(address => uint256)) -> _allowances[owner]
			REF_3521(uint256) -> REF_3520[spender]
			REF_3521(uint256) (->_allowances) := amount(uint256)
		Expression: Approval(owner,spender,amount)
		IRs:
			Emit Approval(owner,spender,amount)
	Function ERC20._spendAllowance(address,address,uint256) (*)
		Expression: currentAllowance = allowance(owner,spender)
		IRs:
			TMP_12096(uint256) = INTERNAL_CALL, ERC20.allowance(address,address)(owner,spender)
			currentAllowance(uint256) := TMP_12096(uint256)
		Expression: currentAllowance != type()(uint256).max
		IRs:
			TMP_12098(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)
			TMP_12099(bool) = currentAllowance != TMP_12098
			CONDITION TMP_12099
		Expression: require(bool,string)(currentAllowance >= amount,ERC20: insufficient allowance)
		IRs:
			TMP_12100(bool) = currentAllowance >= amount
			TMP_12101(None) = SOLIDITY_CALL require(bool,string)(TMP_12100,ERC20: insufficient allowance)
		Expression: _approve(owner,spender,currentAllowance - amount)
		IRs:
			TMP_12102(uint256) = currentAllowance - amount
			INTERNAL_CALL, ERC20._approve(address,address,uint256)(owner,spender,TMP_12102)
	Function ERC20._beforeTokenTransfer(address,address,uint256) (*)
	Function ERC20._afterTokenTransfer(address,address,uint256) (*)
	Function IERC20Metadata.name() 
	Function IERC20Metadata.symbol() 
	Function IERC20Metadata.decimals() 
	Function IERC20.totalSupply() 
	Function IERC20.balanceOf(address) 
	Function IERC20.transfer(address,uint256) 
	Function IERC20.allowance(address,address) 
	Function IERC20.approve(address,uint256) 
	Function IERC20.transferFrom(address,address,uint256) 
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function IWStETH.wrap(uint256) 
	Function IWStETH.unwrap(uint256) 
	Function IWStETH.stETH() 
	Function IWStETH.stEthPerToken() 
	Function WstETHMock.constructor(IERC20) (*)
		Expression: _stETH = stETHToken
		IRs:
			_stETH(IERC20) := stETHToken(IERC20)
		Expression: ERC20(Wrapped liquid staked Ether 2.0,wstETH)
		IRs:
			INTERNAL_CALL, ERC20.constructor(string,string)(Wrapped liquid staked Ether 2.0,wstETH)
	Function WstETHMock.receive() (*)
		Expression: wstETHAmount = (stEthPerToken() * msg.value) / PRICE_PRECISION
		IRs:
			TMP_12105(uint256) = INTERNAL_CALL, WstETHMock.stEthPerToken()()
			TMP_12106(uint256) = TMP_12105 (c)* msg.value
			TMP_12107(uint256) = TMP_12106 (c)/ PRICE_PRECISION
			wstETHAmount(uint256) := TMP_12107(uint256)
		Expression: _mint(msg.sender,wstETHAmount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(msg.sender,wstETHAmount)
	Function WstETHMock.wrap(uint256) (*)
		Expression: require(bool,string)(_stETHAmount > 0,wstETH: can't wrap zero stETH)
		IRs:
			TMP_12109(bool) = _stETHAmount > 0
			TMP_12110(None) = SOLIDITY_CALL require(bool,string)(TMP_12109,wstETH: can't wrap zero stETH)
		Expression: wstETHAmount = (stEthPerToken() * _stETHAmount) / PRICE_PRECISION
		IRs:
			TMP_12111(uint256) = INTERNAL_CALL, WstETHMock.stEthPerToken()()
			TMP_12112(uint256) = TMP_12111 (c)* _stETHAmount
			TMP_12113(uint256) = TMP_12112 (c)/ PRICE_PRECISION
			wstETHAmount(uint256) := TMP_12113(uint256)
		Expression: _mint(msg.sender,wstETHAmount)
		IRs:
			INTERNAL_CALL, ERC20._mint(address,uint256)(msg.sender,wstETHAmount)
		Expression: _stETH.transferFrom(msg.sender,address(this),_stETHAmount)
		IRs:
			TMP_12115 = CONVERT this to address
			TMP_12116(bool) = HIGH_LEVEL_CALL, dest:_stETH(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_12115', '_stETHAmount']  
		Expression: wstETHAmount
		IRs:
			RETURN wstETHAmount
	Function WstETHMock.unwrap(uint256) (*)
		Expression: require(bool,string)(_wstETHAmount > 0,wstETH: zero amount unwrap not allowed)
		IRs:
			TMP_12117(bool) = _wstETHAmount > 0
			TMP_12118(None) = SOLIDITY_CALL require(bool,string)(TMP_12117,wstETH: zero amount unwrap not allowed)
		Expression: stETHAmount = (_wstETHAmount / stEthPerToken()) * PRICE_PRECISION
		IRs:
			TMP_12119(uint256) = INTERNAL_CALL, WstETHMock.stEthPerToken()()
			TMP_12120(uint256) = _wstETHAmount (c)/ TMP_12119
			TMP_12121(uint256) = TMP_12120 (c)* PRICE_PRECISION
			stETHAmount(uint256) := TMP_12121(uint256)
		Expression: _burn(msg.sender,_wstETHAmount)
		IRs:
			INTERNAL_CALL, ERC20._burn(address,uint256)(msg.sender,_wstETHAmount)
		Expression: _stETH.transfer(msg.sender,stETHAmount)
		IRs:
			TMP_12123(bool) = HIGH_LEVEL_CALL, dest:_stETH(IERC20), function:transfer, arguments:['msg.sender', 'stETHAmount']  
		Expression: stETHAmount
		IRs:
			RETURN stETHAmount
	Function WstETHMock.stETH() (*)
		Expression: address(_stETH)
		IRs:
			TMP_12124 = CONVERT _stETH to address
			RETURN TMP_12124
	Function WstETHMock.stEthPerToken() (*)
		Expression: _exchangeRate
		IRs:
			RETURN _exchangeRate
	Function WstETHMock.setExchangeRate(uint256) (*)
		Expression: _exchangeRate = rate
		IRs:
			_exchangeRate(uint256) := rate(uint256)
	Function WstETHMock.slitherConstructorVariables() (*)
		Expression: _exchangeRate = 8665 * (1e5)
		IRs:
			TMP_12125(uint256) = 8665 (c)* 100000
			_exchangeRate(uint256) := TMP_12125(uint256)
		Expression: PRICE_PRECISION = 1000 * (1e6)
		IRs:
			TMP_12126(uint256) = 1000 (c)* 1000000
			PRICE_PRECISION(uint256) := TMP_12126(uint256)
Contract ChainLinkExRateOracle
	Function ExRateOracle.constructor(IOracle) (*)
		Expression: _baseOracle = baseOracle
		IRs:
			_baseOracle(IOracle) := baseOracle(IOracle)
		Expression: _basePrecision = _baseOracle.getPrecision()
		IRs:
			TMP_12127(uint256) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getPrecision, arguments:[]  
			_basePrecision(uint256) := TMP_12127(uint256)
	Function ExRateOracle.getPrecision() (*)
		Expression: _PRECISION
		IRs:
			RETURN _PRECISION
	Function ExRateOracle._getPriceInternal(IOracle.PriceOptions) (*)
		Expression: ratio = getRatio()
		IRs:
			TMP_12128(IOracle.Price) = INTERNAL_CALL, ChainLinkExRateOracle.getRatio()()
			ratio(IOracle.Price) := TMP_12128(IOracle.Price)
		Expression: outPrice.price = (ratio.price * basePrice.price) / _basePrecision
		IRs:
			REF_3525(uint256) -> outPrice.price
			REF_3526(uint256) -> ratio.price
			REF_3527(uint256) -> basePrice.price
			TMP_12129(uint256) = REF_3526 (c)* REF_3527
			TMP_12130(uint256) = TMP_12129 (c)/ _basePrecision
			REF_3525(uint256) (->outPrice) := TMP_12130(uint256)
		Expression: priceOptions.maxAge == 0
		IRs:
			REF_3528(uint256) -> priceOptions.maxAge
			TMP_12131(bool) = REF_3528 == 0
			CONDITION TMP_12131
		Expression: basePrice = _baseOracle.getLatestPrice()
		IRs:
			TMP_12132(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getLatestPrice, arguments:[]  
			basePrice(IOracle.Price) := TMP_12132(IOracle.Price)
		Expression: basePrice = _baseOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_12133(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			basePrice(IOracle.Price) := TMP_12133(IOracle.Price)
		Expression: basePrice.lastUpdate > ratio.lastUpdate
		IRs:
			REF_3531(uint256) -> basePrice.lastUpdate
			REF_3532(uint256) -> ratio.lastUpdate
			TMP_12134(bool) = REF_3531 > REF_3532
			CONDITION TMP_12134
		Expression: outPrice.lastUpdate = basePrice.lastUpdate
		IRs:
			REF_3533(uint256) -> outPrice.lastUpdate
			REF_3534(uint256) -> basePrice.lastUpdate
			REF_3533(uint256) (->outPrice) := REF_3534(uint256)
		Expression: outPrice.lastUpdate = ratio.lastUpdate
		IRs:
			REF_3535(uint256) -> outPrice.lastUpdate
			REF_3536(uint256) -> ratio.lastUpdate
			REF_3535(uint256) (->outPrice) := REF_3536(uint256)
	Function ExRateOracle.getLatestPrice() (*)
		Expression: _getPriceInternal(PriceOptions({maxAge:0,maxConf:0}))
		IRs:
			TMP_12135(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_12136(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(TMP_12135)
			RETURN TMP_12136
	Function ExRateOracle.getRatio() 
	Function ExRateOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price = _getPriceInternal(priceOptions)
		IRs:
			TMP_12137(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(priceOptions)
			price(IOracle.Price) := TMP_12137(IOracle.Price)
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function ChainLinkExRateOracle.constructor(IOracle,IChainlinkAggregator) (*)
		Expression: _ratioFeed = IChainlinkAggregator(ratioFeed)
		IRs:
			TMP_12138 = CONVERT ratioFeed to IChainlinkAggregator
			_ratioFeed(IChainlinkAggregator) := TMP_12138(IChainlinkAggregator)
		Expression: _ratioPriceDecimals = _ratioFeed.decimals()
		IRs:
			TMP_12139(uint8) = HIGH_LEVEL_CALL, dest:_ratioFeed(IChainlinkAggregator), function:decimals, arguments:[]  
			_ratioPriceDecimals(uint8) := TMP_12139(uint8)
		Expression: ExRateOracle(baseOracle)
		IRs:
			INTERNAL_CALL, ExRateOracle.constructor(IOracle)(baseOracle)
	Function ChainLinkExRateOracle.getRatio() (*)
		Expression: (answer,startedAt,updatedAt) = _ratioFeed.latestRoundData()
		IRs:
			TUPLE_159(uint80,int256,uint256,uint256,uint80) = HIGH_LEVEL_CALL, dest:_ratioFeed(IChainlinkAggregator), function:latestRoundData, arguments:[]  
			answer(int256)= UNPACK TUPLE_159 index: 1 
			startedAt(uint256)= UNPACK TUPLE_159 index: 2 
			updatedAt(uint256)= UNPACK TUPLE_159 index: 3 
		Expression: answer <= 0
		IRs:
			TMP_12141(bool) = answer <= 0
			CONDITION TMP_12141
		Expression: revert InvalidPriceFromOracle()()
		IRs:
			TMP_12142(None) = SOLIDITY_CALL revert InvalidPriceFromOracle()()
		Expression: startedAt == 0 || updatedAt == 0
		IRs:
			TMP_12143(bool) = startedAt == 0
			TMP_12144(bool) = updatedAt == 0
			TMP_12145(bool) = TMP_12143 || TMP_12144
			CONDITION TMP_12145
		Expression: revert InvalidPriceUpdatedAt()()
		IRs:
			TMP_12146(None) = SOLIDITY_CALL revert InvalidPriceUpdatedAt()()
		Expression: ratio.price = uint256(answer).toDecimals(_ratioPriceDecimals,_DECIMALS)
		IRs:
			REF_3539(uint256) -> ratio.price
			TMP_12147 = CONVERT answer to uint256
			TMP_12148(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['TMP_12147', '_ratioPriceDecimals', '_DECIMALS'] 
			REF_3539(uint256) (->ratio) := TMP_12148(uint256)
		Expression: ratio.lastUpdate = updatedAt
		IRs:
			REF_3541(uint256) -> ratio.lastUpdate
			REF_3541(uint256) (->ratio) := updatedAt(uint256)
	Function ChainLinkExRateOracle.slitherConstructorConstantVariables() (*)
		Expression: _PRECISION = 1e18
		IRs:
			_PRECISION(uint256) := 1000000000000000000(uint256)
		Expression: _DECIMALS = 18
		IRs:
			_DECIMALS(uint8) := 18(uint256)
Contract ChainLinkOracle
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function ChainLinkOracle.constructor(address,uint256,uint256) (*)
		Expression: _priceFeed = IChainlinkAggregator(priceFeed)
		IRs:
			TMP_12149 = CONVERT priceFeed to IChainlinkAggregator
			_priceFeed(IChainlinkAggregator) := TMP_12149(IChainlinkAggregator)
		Expression: _minPrice = minPrice
		IRs:
			_minPrice(uint256) := minPrice(uint256)
		Expression: _maxPrice = maxPrice
		IRs:
			_maxPrice(uint256) := maxPrice(uint256)
		Expression: _extPriceDecimals = _priceFeed.decimals()
		IRs:
			TMP_12150(uint8) = HIGH_LEVEL_CALL, dest:_priceFeed(IChainlinkAggregator), function:decimals, arguments:[]  
			_extPriceDecimals(uint8) := TMP_12150(uint8)
	Function ChainLinkOracle.getPrecision() (*)
		Expression: _PRECISION
		IRs:
			RETURN _PRECISION
	Function ChainLinkOracle.getLatestPrice() (*)
		Expression: (answer,startedAt,updatedAt) = _priceFeed.latestRoundData()
		IRs:
			TUPLE_160(uint80,int256,uint256,uint256,uint80) = HIGH_LEVEL_CALL, dest:_priceFeed(IChainlinkAggregator), function:latestRoundData, arguments:[]  
			answer(int256)= UNPACK TUPLE_160 index: 1 
			startedAt(uint256)= UNPACK TUPLE_160 index: 2 
			updatedAt(uint256)= UNPACK TUPLE_160 index: 3 
		Expression: answer <= 0
		IRs:
			TMP_12151(bool) = answer <= 0
			CONDITION TMP_12151
		Expression: revert InvalidPriceFromOracle()()
		IRs:
			TMP_12152(None) = SOLIDITY_CALL revert InvalidPriceFromOracle()()
		Expression: startedAt == 0 || updatedAt == 0
		IRs:
			TMP_12153(bool) = startedAt == 0
			TMP_12154(bool) = updatedAt == 0
			TMP_12155(bool) = TMP_12153 || TMP_12154
			CONDITION TMP_12155
		Expression: revert InvalidPriceUpdatedAt()()
		IRs:
			TMP_12156(None) = SOLIDITY_CALL revert InvalidPriceUpdatedAt()()
		Expression: price.price = uint256(answer) * (10 ** (_PRICE_DECIMALS - _extPriceDecimals))
		IRs:
			REF_3544(uint256) -> price.price
			TMP_12157 = CONVERT answer to uint256
			TMP_12158(uint8) = _PRICE_DECIMALS (c)- _extPriceDecimals
			TMP_12159(uint256) = 10 (c)** TMP_12158
			TMP_12160(uint256) = TMP_12157 (c)* TMP_12159
			REF_3544(uint256) (->price) := TMP_12160(uint256)
		Expression: price.lastUpdate = updatedAt
		IRs:
			REF_3545(uint256) -> price.lastUpdate
			REF_3545(uint256) (->price) := updatedAt(uint256)
	Function ChainLinkOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price = getLatestPrice()
		IRs:
			TMP_12161(IOracle.Price) = INTERNAL_CALL, ChainLinkOracle.getLatestPrice()()
			price(IOracle.Price) := TMP_12161(IOracle.Price)
		Expression: priceOptions.maxAge != 0 && (block.timestamp - price.lastUpdate) > priceOptions.maxAge
		IRs:
			REF_3546(uint256) -> priceOptions.maxAge
			TMP_12162(bool) = REF_3546 != 0
			REF_3547(uint256) -> price.lastUpdate
			TMP_12163(uint256) = block.timestamp (c)- REF_3547
			REF_3548(uint256) -> priceOptions.maxAge
			TMP_12164(bool) = TMP_12163 > REF_3548
			TMP_12165(bool) = TMP_12162 && TMP_12164
			CONDITION TMP_12165
		Expression: revert PriceOutdated()()
		IRs:
			TMP_12166(None) = SOLIDITY_CALL revert PriceOutdated()()
		Expression: _minPrice > 0 && price.price <= _minPrice
		IRs:
			TMP_12167(bool) = _minPrice > 0
			REF_3549(uint256) -> price.price
			TMP_12168(bool) = REF_3549 <= _minPrice
			TMP_12169(bool) = TMP_12167 && TMP_12168
			CONDITION TMP_12169
		Expression: revert InvalidPriceFromOracle()()
		IRs:
			TMP_12170(None) = SOLIDITY_CALL revert InvalidPriceFromOracle()()
		Expression: _maxPrice > 0 && price.price >= _maxPrice
		IRs:
			TMP_12171(bool) = _maxPrice > 0
			REF_3550(uint256) -> price.price
			TMP_12172(bool) = REF_3550 >= _maxPrice
			TMP_12173(bool) = TMP_12171 && TMP_12172
			CONDITION TMP_12173
		Expression: revert InvalidPriceFromOracle()()
		IRs:
			TMP_12174(None) = SOLIDITY_CALL revert InvalidPriceFromOracle()()
	Function ChainLinkOracle.slitherConstructorVariables() (*)
		Expression: _minPrice = 0
		IRs:
			_minPrice(uint256) := 0(uint256)
		Expression: _maxPrice = 0
		IRs:
			_maxPrice(uint256) := 0(uint256)
	Function ChainLinkOracle.slitherConstructorConstantVariables() (*)
		Expression: _PRICE_DECIMALS = 18
		IRs:
			_PRICE_DECIMALS(uint8) := 18(uint256)
		Expression: _PRECISION = 10 ** _PRICE_DECIMALS
		IRs:
			TMP_12175(uint256) = 10 (c)** _PRICE_DECIMALS
			_PRECISION(uint256) := TMP_12175(uint256)
Contract CustomExRateOracle
	Function ExRateOracle.constructor(IOracle) (*)
		Expression: _baseOracle = baseOracle
		IRs:
			_baseOracle(IOracle) := baseOracle(IOracle)
		Expression: _basePrecision = _baseOracle.getPrecision()
		IRs:
			TMP_12176(uint256) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getPrecision, arguments:[]  
			_basePrecision(uint256) := TMP_12176(uint256)
	Function ExRateOracle.getPrecision() (*)
		Expression: _PRECISION
		IRs:
			RETURN _PRECISION
	Function ExRateOracle._getPriceInternal(IOracle.PriceOptions) (*)
		Expression: ratio = getRatio()
		IRs:
			TMP_12177(IOracle.Price) = INTERNAL_CALL, CustomExRateOracle.getRatio()()
			ratio(IOracle.Price) := TMP_12177(IOracle.Price)
		Expression: outPrice.price = (ratio.price * basePrice.price) / _basePrecision
		IRs:
			REF_3552(uint256) -> outPrice.price
			REF_3553(uint256) -> ratio.price
			REF_3554(uint256) -> basePrice.price
			TMP_12178(uint256) = REF_3553 (c)* REF_3554
			TMP_12179(uint256) = TMP_12178 (c)/ _basePrecision
			REF_3552(uint256) (->outPrice) := TMP_12179(uint256)
		Expression: priceOptions.maxAge == 0
		IRs:
			REF_3555(uint256) -> priceOptions.maxAge
			TMP_12180(bool) = REF_3555 == 0
			CONDITION TMP_12180
		Expression: basePrice = _baseOracle.getLatestPrice()
		IRs:
			TMP_12181(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getLatestPrice, arguments:[]  
			basePrice(IOracle.Price) := TMP_12181(IOracle.Price)
		Expression: basePrice = _baseOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_12182(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			basePrice(IOracle.Price) := TMP_12182(IOracle.Price)
		Expression: basePrice.lastUpdate > ratio.lastUpdate
		IRs:
			REF_3558(uint256) -> basePrice.lastUpdate
			REF_3559(uint256) -> ratio.lastUpdate
			TMP_12183(bool) = REF_3558 > REF_3559
			CONDITION TMP_12183
		Expression: outPrice.lastUpdate = basePrice.lastUpdate
		IRs:
			REF_3560(uint256) -> outPrice.lastUpdate
			REF_3561(uint256) -> basePrice.lastUpdate
			REF_3560(uint256) (->outPrice) := REF_3561(uint256)
		Expression: outPrice.lastUpdate = ratio.lastUpdate
		IRs:
			REF_3562(uint256) -> outPrice.lastUpdate
			REF_3563(uint256) -> ratio.lastUpdate
			REF_3562(uint256) (->outPrice) := REF_3563(uint256)
	Function ExRateOracle.getLatestPrice() (*)
		Expression: _getPriceInternal(PriceOptions({maxAge:0,maxConf:0}))
		IRs:
			TMP_12184(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_12185(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(TMP_12184)
			RETURN TMP_12185
	Function ExRateOracle.getRatio() 
	Function ExRateOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price = _getPriceInternal(priceOptions)
		IRs:
			TMP_12186(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(priceOptions)
			price(IOracle.Price) := TMP_12186(IOracle.Price)
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function CustomExRateOracle.constructor(IOracle,CustomExRateOracle.Call,uint8) (*)
		Expression: _call.target = call.target
		IRs:
			REF_3564(address) -> _call.target
			REF_3565(address) -> call.target
			REF_3564(address) (->_call) := REF_3565(address)
		Expression: _resultDecimals = resultDecimals
		IRs:
			_resultDecimals(uint8) := resultDecimals(uint8)
		Expression: _call.callData = call.callData
		IRs:
			REF_3566(bytes) -> _call.callData
			REF_3567(bytes) -> call.callData
			REF_3566(bytes) (->_call) := REF_3567(bytes)
		Expression: ExRateOracle(baseOracle)
		IRs:
			INTERNAL_CALL, ExRateOracle.constructor(IOracle)(baseOracle)
	Function CustomExRateOracle.getRatio() (*)
		Expression: (success,result) = _call.target.staticcall(_call.callData)
		IRs:
			REF_3568(address) -> _call.target
			REF_3570(bytes) -> _call.callData
			TUPLE_161(bool,bytes) = LOW_LEVEL_CALL, dest:REF_3568, function:staticcall, arguments:['REF_3570']  
			success(bool)= UNPACK TUPLE_161 index: 0 
			result(bytes)= UNPACK TUPLE_161 index: 1 
		Expression: ! success
		IRs:
			TMP_12188 = UnaryType.BANG success 
			CONDITION TMP_12188
		Expression: revert InvalidPriceFromOracle()()
		IRs:
			TMP_12189(None) = SOLIDITY_CALL revert InvalidPriceFromOracle()()
		Expression: price = abi.decode(result,(uint256))
		IRs:
			TMP_12190(uint256) = SOLIDITY_CALL abi.decode()(result,uint256)
			price(uint256) := TMP_12190(uint256)
		Expression: ratio.price = price.toDecimals(_resultDecimals,_DECIMALS)
		IRs:
			REF_3572(uint256) -> ratio.price
			TMP_12191(uint256) = LIBRARY_CALL, dest:MathLibrary, function:MathLibrary.toDecimals(uint256,uint8,uint8), arguments:['price', '_resultDecimals', '_DECIMALS'] 
			REF_3572(uint256) (->ratio) := TMP_12191(uint256)
		Expression: ratio.lastUpdate = 0
		IRs:
			REF_3574(uint256) -> ratio.lastUpdate
			REF_3574(uint256) (->ratio) := 0(uint256)
	Function CustomExRateOracle.slitherConstructorConstantVariables() (*)
		Expression: _PRECISION = 1e18
		IRs:
			_PRECISION(uint256) := 1000000000000000000(uint256)
		Expression: _DECIMALS = 18
		IRs:
			_DECIMALS(uint8) := 18(uint256)
Contract ExRateOracle
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function ExRateOracle.constructor(IOracle) (*)
		Expression: _baseOracle = baseOracle
		IRs:
			_baseOracle(IOracle) := baseOracle(IOracle)
		Expression: _basePrecision = _baseOracle.getPrecision()
		IRs:
			TMP_12192(uint256) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getPrecision, arguments:[]  
			_basePrecision(uint256) := TMP_12192(uint256)
	Function ExRateOracle.getPrecision() (*)
		Expression: _PRECISION
		IRs:
			RETURN _PRECISION
	Function ExRateOracle._getPriceInternal(IOracle.PriceOptions) (*)
		Expression: ratio = getRatio()
		IRs:
			TMP_12193(IOracle.Price) = INTERNAL_CALL, ExRateOracle.getRatio()()
			ratio(IOracle.Price) := TMP_12193(IOracle.Price)
		Expression: outPrice.price = (ratio.price * basePrice.price) / _basePrecision
		IRs:
			REF_3576(uint256) -> outPrice.price
			REF_3577(uint256) -> ratio.price
			REF_3578(uint256) -> basePrice.price
			TMP_12194(uint256) = REF_3577 (c)* REF_3578
			TMP_12195(uint256) = TMP_12194 (c)/ _basePrecision
			REF_3576(uint256) (->outPrice) := TMP_12195(uint256)
		Expression: priceOptions.maxAge == 0
		IRs:
			REF_3579(uint256) -> priceOptions.maxAge
			TMP_12196(bool) = REF_3579 == 0
			CONDITION TMP_12196
		Expression: basePrice = _baseOracle.getLatestPrice()
		IRs:
			TMP_12197(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getLatestPrice, arguments:[]  
			basePrice(IOracle.Price) := TMP_12197(IOracle.Price)
		Expression: basePrice = _baseOracle.getSafeLatestPrice(priceOptions)
		IRs:
			TMP_12198(IOracle.Price) = HIGH_LEVEL_CALL, dest:_baseOracle(IOracle), function:getSafeLatestPrice, arguments:['priceOptions']  
			basePrice(IOracle.Price) := TMP_12198(IOracle.Price)
		Expression: basePrice.lastUpdate > ratio.lastUpdate
		IRs:
			REF_3582(uint256) -> basePrice.lastUpdate
			REF_3583(uint256) -> ratio.lastUpdate
			TMP_12199(bool) = REF_3582 > REF_3583
			CONDITION TMP_12199
		Expression: outPrice.lastUpdate = basePrice.lastUpdate
		IRs:
			REF_3584(uint256) -> outPrice.lastUpdate
			REF_3585(uint256) -> basePrice.lastUpdate
			REF_3584(uint256) (->outPrice) := REF_3585(uint256)
		Expression: outPrice.lastUpdate = ratio.lastUpdate
		IRs:
			REF_3586(uint256) -> outPrice.lastUpdate
			REF_3587(uint256) -> ratio.lastUpdate
			REF_3586(uint256) (->outPrice) := REF_3587(uint256)
	Function ExRateOracle.getLatestPrice() (*)
		Expression: _getPriceInternal(PriceOptions({maxAge:0,maxConf:0}))
		IRs:
			TMP_12200(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_12201(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(TMP_12200)
			RETURN TMP_12201
	Function ExRateOracle.getRatio() (*)
	Function ExRateOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price = _getPriceInternal(priceOptions)
		IRs:
			TMP_12202(IOracle.Price) = INTERNAL_CALL, ExRateOracle._getPriceInternal(IOracle.PriceOptions)(priceOptions)
			price(IOracle.Price) := TMP_12202(IOracle.Price)
	Function ExRateOracle.slitherConstructorConstantVariables() (*)
		Expression: _PRECISION = 1e18
		IRs:
			_PRECISION(uint256) := 1000000000000000000(uint256)
		Expression: _DECIMALS = 18
		IRs:
			_DECIMALS(uint8) := 18(uint256)
Contract PythOracle
	Function IOracle.getPrecision() 
	Function IOracle.getLatestPrice() 
	Function IOracle.getSafeLatestPrice(IOracle.PriceOptions) 
	Function PythOracle.constructor(bytes32,address) (*)
		Expression: _pyth = IPyth(pythContract)
		IRs:
			TMP_12203 = CONVERT pythContract to IPyth
			_pyth(IPyth) := TMP_12203(IPyth)
		Expression: _priceID = priceID
		IRs:
			_priceID(bytes32) := priceID(bytes32)
	Function PythOracle.getPrecision() (*)
		Expression: _PRECISION
		IRs:
			RETURN _PRECISION
	Function PythOracle._getPriceInternal(IOracle.PriceOptions) (*)
		Expression: price.price < 0 || (priceOptions.maxConf != 0 && price.conf > 0 && price.conf > (uint64(price.price) * priceOptions.maxConf) / PERCENTAGE_PRECISION) || price.expo > _MAX_EXPONENT || price.expo < _MIN_EXPONENT
		IRs:
			REF_3588(int64) -> price.price
			TMP_12204(bool) = REF_3588 < 0
			REF_3589(uint256) -> priceOptions.maxConf
			TMP_12205(bool) = REF_3589 != 0
			REF_3590(uint64) -> price.conf
			TMP_12206(bool) = REF_3590 > 0
			TMP_12207(bool) = TMP_12205 && TMP_12206
			REF_3591(uint64) -> price.conf
			REF_3592(int64) -> price.price
			TMP_12208 = CONVERT REF_3592 to uint64
			REF_3593(uint256) -> priceOptions.maxConf
			TMP_12209(uint64) = TMP_12208 (c)* REF_3593
			TMP_12210(uint64) = TMP_12209 (c)/ PERCENTAGE_PRECISION
			TMP_12211(bool) = REF_3591 > TMP_12210
			TMP_12212(bool) = TMP_12207 && TMP_12211
			TMP_12213(bool) = TMP_12204 || TMP_12212
			REF_3594(int32) -> price.expo
			TMP_12214(bool) = REF_3594 > _MAX_EXPONENT
			TMP_12215(bool) = TMP_12213 || TMP_12214
			REF_3595(int32) -> price.expo
			TMP_12216(bool) = REF_3595 < _MIN_EXPONENT
			TMP_12217(bool) = TMP_12215 || TMP_12216
			CONDITION TMP_12217
		Expression: revert InvalidPriceAnswer()()
		IRs:
			TMP_12218(None) = SOLIDITY_CALL revert InvalidPriceAnswer()()
		Expression: price.expo >= 0
		IRs:
			REF_3596(int32) -> price.expo
			TMP_12219(bool) = REF_3596 >= 0
			CONDITION TMP_12219
		Expression: outPrice.price = uint64(price.price) * uint256(10 ** (_DECIMALS + uint32(price.expo)))
		IRs:
			REF_3597(uint256) -> outPrice.price
			REF_3598(int64) -> price.price
			TMP_12220 = CONVERT REF_3598 to uint64
			REF_3599(int32) -> price.expo
			TMP_12221 = CONVERT REF_3599 to uint32
			TMP_12222(uint256) = _DECIMALS (c)+ TMP_12221
			TMP_12223(uint256) = 10 (c)** TMP_12222
			TMP_12224 = CONVERT TMP_12223 to uint256
			TMP_12225(uint64) = TMP_12220 (c)* TMP_12224
			REF_3597(uint256) (->outPrice) := TMP_12225(uint64)
		Expression: outPrice.price = uint64(price.price) * uint256(10 ** (_DECIMALS - uint32(- price.expo)))
		IRs:
			REF_3600(uint256) -> outPrice.price
			REF_3601(int64) -> price.price
			TMP_12226 = CONVERT REF_3601 to uint64
			REF_3602(int32) -> price.expo
			TMP_12227(uint256) = 0 (c)- REF_3602
			TMP_12228 = CONVERT TMP_12227 to uint32
			TMP_12229(uint256) = _DECIMALS (c)- TMP_12228
			TMP_12230(uint256) = 10 (c)** TMP_12229
			TMP_12231 = CONVERT TMP_12230 to uint256
			TMP_12232(uint64) = TMP_12226 (c)* TMP_12231
			REF_3600(uint256) (->outPrice) := TMP_12232(uint64)
		Expression: outPrice.lastUpdate = price.publishTime
		IRs:
			REF_3603(uint256) -> outPrice.lastUpdate
			REF_3604(uint256) -> price.publishTime
			REF_3603(uint256) (->outPrice) := REF_3604(uint256)
		Expression: priceOptions.maxAge == 0
		IRs:
			REF_3605(uint256) -> priceOptions.maxAge
			TMP_12233(bool) = REF_3605 == 0
			CONDITION TMP_12233
		Expression: price = _pyth.getPriceUnsafe(_priceID)
		IRs:
			TMP_12234(PythStructs.Price) = HIGH_LEVEL_CALL, dest:_pyth(IPyth), function:getPriceUnsafe, arguments:['_priceID']  
			price(PythStructs.Price) := TMP_12234(PythStructs.Price)
		Expression: price = _pyth.getPriceNoOlderThan(_priceID,priceOptions.maxAge)
		IRs:
			REF_3608(uint256) -> priceOptions.maxAge
			TMP_12235(PythStructs.Price) = HIGH_LEVEL_CALL, dest:_pyth(IPyth), function:getPriceNoOlderThan, arguments:['_priceID', 'REF_3608']  
			price(PythStructs.Price) := TMP_12235(PythStructs.Price)
	Function PythOracle.getAndUpdatePrice(bytes) (*)
		Expression: priceUpdateData.length == 0
		IRs:
			REF_3609 -> LENGTH priceUpdateData
			TMP_12236(bool) = REF_3609 == 0
			CONDITION TMP_12236
		Expression: revert InvalidPriceUpdate()()
		IRs:
			TMP_12237(None) = SOLIDITY_CALL revert InvalidPriceUpdate()()
		Expression: priceUpdates = new bytes[](1)
		IRs:
			TMP_12239(bytes[])  = new bytes[](1)
			priceUpdates(bytes[]) = ['TMP_12239(bytes[])']
		Expression: priceUpdates[0] = priceUpdateData
		IRs:
			REF_3610(bytes) -> priceUpdates[0]
			REF_3610(bytes) (->priceUpdates) := priceUpdateData(bytes)
		Expression: fee = _pyth.getUpdateFee(priceUpdates)
		IRs:
			TMP_12240(uint256) = HIGH_LEVEL_CALL, dest:_pyth(IPyth), function:getUpdateFee, arguments:['priceUpdates']  
			fee(uint256) := TMP_12240(uint256)
		Expression: msg.value < fee
		IRs:
			TMP_12241(bool) = msg.value < fee
			CONDITION TMP_12241
		Expression: revert NoEnoughFee()()
		IRs:
			TMP_12242(None) = SOLIDITY_CALL revert NoEnoughFee()()
		Expression: _pyth.updatePriceFeeds{value: fee}(priceUpdates)
		IRs:
			HIGH_LEVEL_CALL, dest:_pyth(IPyth), function:updatePriceFeeds, arguments:['priceUpdates'] value:fee 
		Expression: excessETH = msg.value - fee
		IRs:
			TMP_12244(uint256) = msg.value (c)- fee
			excessETH(uint256) := TMP_12244(uint256)
		Expression: excessETH != 0
		IRs:
			TMP_12245(bool) = excessETH != 0
			CONDITION TMP_12245
		Expression: address(msg.sender).transfer(excessETH)
		IRs:
			TMP_12246 = CONVERT msg.sender to address
			Transfer dest:TMP_12246 value:excessETH
		Expression: _getPriceInternal(PriceOptions({maxAge:0,maxConf:0}))
		IRs:
			TMP_12248(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_12249(IOracle.Price) = INTERNAL_CALL, PythOracle._getPriceInternal(IOracle.PriceOptions)(TMP_12248)
			RETURN TMP_12249
	Function PythOracle.getLatestPrice() (*)
		Expression: _getPriceInternal(PriceOptions({maxAge:0,maxConf:0}))
		IRs:
			TMP_12250(IOracle.PriceOptions) = new PriceOptions(0,0)
			TMP_12251(IOracle.Price) = INTERNAL_CALL, PythOracle._getPriceInternal(IOracle.PriceOptions)(TMP_12250)
			RETURN TMP_12251
	Function PythOracle.getSafeLatestPrice(IOracle.PriceOptions) (*)
		Expression: price = _getPriceInternal(priceOptions)
		IRs:
			TMP_12252(IOracle.Price) = INTERNAL_CALL, PythOracle._getPriceInternal(IOracle.PriceOptions)(priceOptions)
			price(IOracle.Price) := TMP_12252(IOracle.Price)
	Function PythOracle.slitherConstructorConstantVariables() (*)
		Expression: _PRECISION = 1e18
		IRs:
			_PRECISION(uint256) := 1000000000000000000(uint256)
		Expression: _DECIMALS = 18
		IRs:
			_DECIMALS(uint256) := 18(uint256)
		Expression: _MIN_EXPONENT = - 20
		IRs:
			TMP_12253(int256) = 0 (c)- 20
			_MIN_EXPONENT(int256) := TMP_12253(int256)
		Expression: _MAX_EXPONENT = 20
		IRs:
			_MAX_EXPONENT(int256) := 20(int256)
Contract BakerFiProxy
	Function TransparentUpgradeableProxy.constructor(address,address,bytes) 
		Expression: _changeAdmin(admin_)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._changeAdmin(address)(admin_)
		Expression: ERC1967Proxy(_logic,_data)
		IRs:
			INTERNAL_CALL, ERC1967Proxy.constructor(address,bytes)(_logic,_data)
	Function TransparentUpgradeableProxy._fallback() (*)
		Expression: msg.sender == _getAdmin()
		IRs:
			TMP_12256(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			TMP_12257(bool) = msg.sender == TMP_12256
			CONDITION TMP_12257
		Expression: selector = msg.sig
		IRs:
			selector(bytes4) := msg.sig(bytes4)
		Expression: selector == ITransparentUpgradeableProxy.upgradeTo.selector
		IRs:
			REF_3615(bytes4) (->None) := 911855590(uint256)
			TMP_12258(bool) = selector == REF_3615
			CONDITION TMP_12258
		Expression: ret = _dispatchUpgradeTo()
		IRs:
			TMP_12259(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchUpgradeTo()()
			ret(bytes) := TMP_12259(bytes)
		Expression: selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector
		IRs:
			REF_3617(bytes4) (->None) := 1327428230(uint256)
			TMP_12260(bool) = selector == REF_3617
			CONDITION TMP_12260
		Expression: ret = _dispatchUpgradeToAndCall()
		IRs:
			TMP_12261(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchUpgradeToAndCall()()
			ret(bytes) := TMP_12261(bytes)
		Expression: selector == ITransparentUpgradeableProxy.changeAdmin.selector
		IRs:
			REF_3619(bytes4) (->None) := 2401778032(uint256)
			TMP_12262(bool) = selector == REF_3619
			CONDITION TMP_12262
		Expression: ret = _dispatchChangeAdmin()
		IRs:
			TMP_12263(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchChangeAdmin()()
			ret(bytes) := TMP_12263(bytes)
		Expression: selector == ITransparentUpgradeableProxy.admin.selector
		IRs:
			REF_3621(bytes4) (->None) := 4166100032(uint256)
			TMP_12264(bool) = selector == REF_3621
			CONDITION TMP_12264
		Expression: ret = _dispatchAdmin()
		IRs:
			TMP_12265(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchAdmin()()
			ret(bytes) := TMP_12265(bytes)
		Expression: selector == ITransparentUpgradeableProxy.implementation.selector
		IRs:
			REF_3623(bytes4) (->None) := 1549851163(uint256)
			TMP_12266(bool) = selector == REF_3623
			CONDITION TMP_12266
		Expression: ret = _dispatchImplementation()
		IRs:
			TMP_12267(bytes) = INTERNAL_CALL, TransparentUpgradeableProxy._dispatchImplementation()()
			ret(bytes) := TMP_12267(bytes)
		Expression: revert(string)(TransparentUpgradeableProxy: admin cannot fallback to proxy target)
		IRs:
			TMP_12268(None) = SOLIDITY_CALL revert(string)(TransparentUpgradeableProxy: admin cannot fallback to proxy target)
		Expression: return(uint256,uint256)(ret + 0x20,mload(uint256)(ret))
		IRs:
			TMP_12269(bytes) = ret + 32
			TMP_12270(uint256) = SOLIDITY_CALL mload(uint256)(ret)
			TMP_12271(None) = SOLIDITY_CALL return(uint256,uint256)(TMP_12269,TMP_12270)
		Expression: super._fallback()
		IRs:
			INTERNAL_CALL, Proxy._fallback()()
	Function TransparentUpgradeableProxy._dispatchAdmin() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: admin = _getAdmin()
		IRs:
			TMP_12274(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			admin(address) := TMP_12274(address)
		Expression: abi.encode(admin)
		IRs:
			TMP_12275(bytes) = SOLIDITY_CALL abi.encode()(admin)
			RETURN TMP_12275
	Function TransparentUpgradeableProxy._dispatchImplementation() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: implementation = _implementation()
		IRs:
			TMP_12277(address) = INTERNAL_CALL, ERC1967Proxy._implementation()()
			implementation(address) := TMP_12277(address)
		Expression: abi.encode(implementation)
		IRs:
			TMP_12278(bytes) = SOLIDITY_CALL abi.encode()(implementation)
			RETURN TMP_12278
	Function TransparentUpgradeableProxy._dispatchChangeAdmin() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: newAdmin = abi.decode(msg.data,(address))
		IRs:
			TMP_12280(address) = SOLIDITY_CALL abi.decode()(msg.data,address)
			newAdmin(address) := TMP_12280(address)
		Expression: _changeAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._changeAdmin(address)(newAdmin)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._dispatchUpgradeTo() (*)
		Expression: _requireZeroValue()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._requireZeroValue()()
		Expression: newImplementation = abi.decode(msg.data,(address))
		IRs:
			TMP_12283(address) = SOLIDITY_CALL abi.decode()(msg.data,address)
			newImplementation(address) := TMP_12283(address)
		Expression: _upgradeToAndCall(newImplementation,bytes(),false)
		IRs:
			TMP_12284 = CONVERT  to bytes
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,TMP_12284,False)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._dispatchUpgradeToAndCall() (*)
		Expression: (newImplementation,data) = abi.decode(msg.data,(address,bytes))
		IRs:
			TUPLE_162(address,bytes) = SOLIDITY_CALL abi.decode()(msg.data(address,bytes))
			newImplementation(address)= UNPACK TUPLE_162 index: 0 
			data(bytes)= UNPACK TUPLE_162 index: 1 
		Expression: _upgradeToAndCall(newImplementation,data,true)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,True)
		Expression: 
		IRs:
			RETURN 
	Function TransparentUpgradeableProxy._admin() (*)
		Expression: _getAdmin()
		IRs:
			TMP_12287(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			RETURN TMP_12287
	Function TransparentUpgradeableProxy._requireZeroValue() (*)
		Expression: require(bool)(msg.value == 0)
		IRs:
			TMP_12288(bool) = msg.value == 0
			TMP_12289(None) = SOLIDITY_CALL require(bool)(TMP_12288)
	Function ERC1967Proxy.constructor(address,bytes) (*)
		Expression: _upgradeToAndCall(_logic,_data,false)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(_logic,_data,False)
	Function ERC1967Proxy._implementation() (*)
		Expression: ERC1967Upgrade._getImplementation()
		IRs:
			TMP_12291(address) = INTERNAL_CALL, ERC1967Upgrade._getImplementation()()
			RETURN TMP_12291
	Function ERC1967Upgrade._getImplementation() (*)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value
		IRs:
			TMP_12292(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_3631(address) -> TMP_12292.value
			RETURN REF_3631
	Function ERC1967Upgrade._setImplementation(address) (*)
		Expression: require(bool,string)(Address.isContract(newImplementation),ERC1967: new implementation is not a contract)
		IRs:
			TMP_12293(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newImplementation'] 
			TMP_12294(None) = SOLIDITY_CALL require(bool,string)(TMP_12293,ERC1967: new implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation
		IRs:
			TMP_12295(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_IMPLEMENTATION_SLOT'] 
			REF_3634(address) -> TMP_12295.value
			REF_3634(address) (->TMP_12295) := newImplementation(address)
	Function ERC1967Upgrade._upgradeTo(address) (*)
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: Upgraded(newImplementation)
		IRs:
			Emit Upgraded(newImplementation)
	Function ERC1967Upgrade._upgradeToAndCall(address,bytes,bool) (*)
		Expression: _upgradeTo(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeTo(address)(newImplementation)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_3635 -> LENGTH data
			TMP_12299(bool) = REF_3635 > 0
			TMP_12300(bool) = TMP_12299 || forceCall
			CONDITION TMP_12300
		Expression: Address.functionDelegateCall(newImplementation,data)
		IRs:
			TMP_12301(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['newImplementation', 'data'] 
	Function ERC1967Upgrade._upgradeToAndCallUUPS(address,bytes,bool) (*)
		Expression: StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value
		IRs:
			TMP_12302(StorageSlot.BooleanSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getBooleanSlot(bytes32), arguments:['_ROLLBACK_SLOT'] 
			REF_3638(bool) -> TMP_12302.value
			CONDITION REF_3638
		Expression: _setImplementation(newImplementation)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setImplementation(address)(newImplementation)
		Expression: slot = IERC1822Proxiable(newImplementation).proxiableUUID()
		IRs:
			TMP_12304 = CONVERT newImplementation to IERC1822Proxiable
			TMP_12305(bytes32) = HIGH_LEVEL_CALL, dest:TMP_12304(IERC1822Proxiable), function:proxiableUUID, arguments:[]  
			slot(bytes32) := TMP_12305(bytes32)
		Expression: require(bool,string)(slot == _IMPLEMENTATION_SLOT,ERC1967Upgrade: unsupported proxiableUUID)
		IRs:
			TMP_12306(bool) = slot == _IMPLEMENTATION_SLOT
			TMP_12307(None) = SOLIDITY_CALL require(bool,string)(TMP_12306,ERC1967Upgrade: unsupported proxiableUUID)
		Expression: revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		IRs:
			TMP_12308(None) = SOLIDITY_CALL revert(string)(ERC1967Upgrade: new implementation is not UUPS)
		Expression: _upgradeToAndCall(newImplementation,data,forceCall)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._upgradeToAndCall(address,bytes,bool)(newImplementation,data,forceCall)
	Function ERC1967Upgrade._getAdmin() (*)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value
		IRs:
			TMP_12310(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_3641(address) -> TMP_12310.value
			RETURN REF_3641
	Function ERC1967Upgrade._setAdmin(address) (*)
		Expression: require(bool,string)(newAdmin != address(0),ERC1967: new admin is the zero address)
		IRs:
			TMP_12311 = CONVERT 0 to address
			TMP_12312(bool) = newAdmin != TMP_12311
			TMP_12313(None) = SOLIDITY_CALL require(bool,string)(TMP_12312,ERC1967: new admin is the zero address)
		Expression: StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin
		IRs:
			TMP_12314(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_ADMIN_SLOT'] 
			REF_3643(address) -> TMP_12314.value
			REF_3643(address) (->TMP_12314) := newAdmin(address)
	Function ERC1967Upgrade._changeAdmin(address) (*)
		Expression: AdminChanged(_getAdmin(),newAdmin)
		IRs:
			TMP_12315(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			Emit AdminChanged(TMP_12315,newAdmin)
		Expression: _setAdmin(newAdmin)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setAdmin(address)(newAdmin)
	Function ERC1967Upgrade._getBeacon() (*)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value
		IRs:
			TMP_12318(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_3645(address) -> TMP_12318.value
			RETURN REF_3645
	Function ERC1967Upgrade._setBeacon(address) (*)
		Expression: require(bool,string)(Address.isContract(newBeacon),ERC1967: new beacon is not a contract)
		IRs:
			TMP_12319(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['newBeacon'] 
			TMP_12320(None) = SOLIDITY_CALL require(bool,string)(TMP_12319,ERC1967: new beacon is not a contract)
		Expression: require(bool,string)(Address.isContract(IBeacon(newBeacon).implementation()),ERC1967: beacon implementation is not a contract)
		IRs:
			TMP_12321 = CONVERT newBeacon to IBeacon
			TMP_12322(address) = HIGH_LEVEL_CALL, dest:TMP_12321(IBeacon), function:implementation, arguments:[]  
			TMP_12323(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['TMP_12322'] 
			TMP_12324(None) = SOLIDITY_CALL require(bool,string)(TMP_12323,ERC1967: beacon implementation is not a contract)
		Expression: StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon
		IRs:
			TMP_12325(StorageSlot.AddressSlot) = LIBRARY_CALL, dest:StorageSlot, function:StorageSlot.getAddressSlot(bytes32), arguments:['_BEACON_SLOT'] 
			REF_3650(address) -> TMP_12325.value
			REF_3650(address) (->TMP_12325) := newBeacon(address)
	Function ERC1967Upgrade._upgradeBeaconToAndCall(address,bytes,bool) (*)
		Expression: _setBeacon(newBeacon)
		IRs:
			INTERNAL_CALL, ERC1967Upgrade._setBeacon(address)(newBeacon)
		Expression: BeaconUpgraded(newBeacon)
		IRs:
			Emit BeaconUpgraded(newBeacon)
		Expression: data.length > 0 || forceCall
		IRs:
			REF_3651 -> LENGTH data
			TMP_12328(bool) = REF_3651 > 0
			TMP_12329(bool) = TMP_12328 || forceCall
			CONDITION TMP_12329
		Expression: Address.functionDelegateCall(IBeacon(newBeacon).implementation(),data)
		IRs:
			TMP_12330 = CONVERT newBeacon to IBeacon
			TMP_12331(address) = HIGH_LEVEL_CALL, dest:TMP_12330(IBeacon), function:implementation, arguments:[]  
			TMP_12332(bytes) = LIBRARY_CALL, dest:Address, function:Address.functionDelegateCall(address,bytes), arguments:['TMP_12331', 'data'] 
	Function Proxy._delegate(address) (*)
		Expression: calldatacopy(uint256,uint256,uint256)(0,0,calldatasize()())
		IRs:
			TMP_12333(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_12334(None) = SOLIDITY_CALL calldatacopy(uint256,uint256,uint256)(0,0,TMP_12333)
		Expression: result__delegate_asm_0 = delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),implementation,0,calldatasize()(),0,0)
		IRs:
			TMP_12335(uint256) = SOLIDITY_CALL gas()()
			TMP_12336(uint256) = SOLIDITY_CALL calldatasize()()
			TMP_12337(uint256) = SOLIDITY_CALL delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_12335,implementation,0,TMP_12336,0,0)
			result__delegate_asm_0(uint256) := TMP_12337(uint256)
		Expression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())
		IRs:
			TMP_12338(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_12339(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_12338)
		Expression: switch_expr_1607_220_63__delegate_asm_0 = result__delegate_asm_0
		IRs:
			switch_expr_1607_220_63__delegate_asm_0(uint256) := result__delegate_asm_0(uint256)
		Expression: switch_expr_1607_220_63__delegate_asm_0 == 0
		IRs:
			TMP_12340(bool) = switch_expr_1607_220_63__delegate_asm_0 == 0
			CONDITION TMP_12340
		Expression: revert(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_12341(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_12342(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_12341)
		Expression: return(uint256,uint256)(0,returndatasize()())
		IRs:
			TMP_12343(uint256) = SOLIDITY_CALL returndatasize()()
			TMP_12344(None) = SOLIDITY_CALL return(uint256,uint256)(0,TMP_12343)
	Function Proxy._implementation() 
	Function Proxy._fallback() 
		Expression: _beforeFallback()
		IRs:
			INTERNAL_CALL, Proxy._beforeFallback()()
		Expression: _delegate(_implementation())
		IRs:
			TMP_12346(address) = INTERNAL_CALL, ERC1967Proxy._implementation()()
			INTERNAL_CALL, Proxy._delegate(address)(TMP_12346)
	Function Proxy.fallback() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
	Function Proxy.receive() (*)
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
	Function Proxy._beforeFallback() (*)
	Function BakerFiProxy.constructor(address,address,bytes) (*)
		Expression: TransparentUpgradeableProxy(_logic,admin_,_data)
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy.constructor(address,address,bytes)(_logic,admin_,_data)
	Function BakerFiProxy.slitherConstructorConstantVariables() (*)
		Expression: _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc
		IRs:
			_IMPLEMENTATION_SLOT(bytes32) := 24440054405305269366569402256811496959409073762505157381672968839269610695612(uint256)
		Expression: _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103
		IRs:
			_ADMIN_SLOT(bytes32) := 81955473079516046949633743016697847541294818689821282749996681496272635257091(uint256)
		Expression: _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50
		IRs:
			_BEACON_SLOT(bytes32) := 74152234768234802001998023604048924213078445070507226371336425913862612794704(uint256)
	Modifier TransparentUpgradeableProxy.ifAdmin()
		Expression: msg.sender == _getAdmin()
		IRs:
			TMP_12351(address) = INTERNAL_CALL, ERC1967Upgrade._getAdmin()()
			TMP_12352(bool) = msg.sender == TMP_12351
			CONDITION TMP_12352
		Expression: _fallback()
		IRs:
			INTERNAL_CALL, TransparentUpgradeableProxy._fallback()()
Contract BakerFiProxyAdmin
	Function ProxyAdmin.getProxyImplementation(ITransparentUpgradeableProxy) (*)
		Expression: (success,returndata) = address(proxy).staticcall(0x5c60da1b)
		IRs:
			TMP_12354 = CONVERT proxy to address
			TUPLE_163(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_12354, function:staticcall, arguments:['0x5c60da1b']  
			success(bool)= UNPACK TUPLE_163 index: 0 
			returndata(bytes)= UNPACK TUPLE_163 index: 1 
		Expression: require(bool)(success)
		IRs:
			TMP_12355(None) = SOLIDITY_CALL require(bool)(success)
		Expression: abi.decode(returndata,(address))
		IRs:
			TMP_12356(address) = SOLIDITY_CALL abi.decode()(returndata,address)
			RETURN TMP_12356
	Function ProxyAdmin.getProxyAdmin(ITransparentUpgradeableProxy) (*)
		Expression: (success,returndata) = address(proxy).staticcall(0xf851a440)
		IRs:
			TMP_12357 = CONVERT proxy to address
			TUPLE_164(bool,bytes) = LOW_LEVEL_CALL, dest:TMP_12357, function:staticcall, arguments:['0xf851a440']  
			success(bool)= UNPACK TUPLE_164 index: 0 
			returndata(bytes)= UNPACK TUPLE_164 index: 1 
		Expression: require(bool)(success)
		IRs:
			TMP_12358(None) = SOLIDITY_CALL require(bool)(success)
		Expression: abi.decode(returndata,(address))
		IRs:
			TMP_12359(address) = SOLIDITY_CALL abi.decode()(returndata,address)
			RETURN TMP_12359
	Function ProxyAdmin.changeProxyAdmin(ITransparentUpgradeableProxy,address) (*)
		Expression: proxy.changeAdmin(newAdmin)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:changeAdmin, arguments:['newAdmin']  
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function ProxyAdmin.upgrade(ITransparentUpgradeableProxy,address) (*)
		Expression: proxy.upgradeTo(implementation)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:upgradeTo, arguments:['implementation']  
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function ProxyAdmin.upgradeAndCall(ITransparentUpgradeableProxy,address,bytes) (*)
		Expression: proxy.upgradeToAndCall{value: msg.value}(implementation,data)
		IRs:
			HIGH_LEVEL_CALL, dest:proxy(ITransparentUpgradeableProxy), function:upgradeToAndCall, arguments:['implementation', 'data'] value:msg.value 
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.constructor() (*)
		Expression: _transferOwnership(_msgSender())
		IRs:
			TMP_12366(address) = INTERNAL_CALL, Context._msgSender()()
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_12366)
	Function Ownable.owner() (*)
		Expression: _owner
		IRs:
			RETURN _owner
	Function Ownable._checkOwner() (*)
		Expression: require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)
		IRs:
			TMP_12368(address) = INTERNAL_CALL, Ownable.owner()()
			TMP_12369(address) = INTERNAL_CALL, Context._msgSender()()
			TMP_12370(bool) = TMP_12368 == TMP_12369
			TMP_12371(None) = SOLIDITY_CALL require(bool,string)(TMP_12370,Ownable: caller is not the owner)
	Function Ownable.renounceOwnership() (*)
		Expression: _transferOwnership(address(0))
		IRs:
			TMP_12372 = CONVERT 0 to address
			INTERNAL_CALL, Ownable._transferOwnership(address)(TMP_12372)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable.transferOwnership(address) (*)
		Expression: require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)
		IRs:
			TMP_12375 = CONVERT 0 to address
			TMP_12376(bool) = newOwner != TMP_12375
			TMP_12377(None) = SOLIDITY_CALL require(bool,string)(TMP_12376,Ownable: new owner is the zero address)
		Expression: _transferOwnership(newOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(newOwner)
		Expression: onlyOwner()
		IRs:
			MODIFIER_CALL, Ownable.onlyOwner()()
	Function Ownable._transferOwnership(address) (*)
		Expression: oldOwner = _owner
		IRs:
			oldOwner(address) := _owner(address)
		Expression: _owner = newOwner
		IRs:
			_owner(address) := newOwner(address)
		Expression: OwnershipTransferred(oldOwner,newOwner)
		IRs:
			Emit OwnershipTransferred(oldOwner,newOwner)
	Function Context._msgSender() (*)
		Expression: msg.sender
		IRs:
			RETURN msg.sender
	Function Context._msgData() (*)
		Expression: msg.data
		IRs:
			RETURN msg.data
	Function Context._contextSuffixLength() (*)
		Expression: 0
		IRs:
			RETURN 0
	Function BakerFiProxyAdmin.constructor(address) (*)
		Expression: initialOwner == address(0)
		IRs:
			TMP_12381 = CONVERT 0 to address
			TMP_12382(bool) = initialOwner == TMP_12381
			CONDITION TMP_12382
		Expression: revert InvalidOwner()()
		IRs:
			TMP_12383(None) = SOLIDITY_CALL revert InvalidOwner()()
		Expression: _transferOwnership(initialOwner)
		IRs:
			INTERNAL_CALL, Ownable._transferOwnership(address)(initialOwner)
		Expression: ProxyAdmin()
		IRs:
			INTERNAL_CALL, Ownable.constructor()()
	Modifier Ownable.onlyOwner()
		Expression: _checkOwner()
		IRs:
			INTERNAL_CALL, Ownable._checkOwner()()
Contract TestRebaseLibrary
	Function TestRebaseLibrary.toBase(Rebase,uint256,bool) (*)
		Expression: total.toBase(elastic,roundUp)
		IRs:
			TMP_12387(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'elastic', 'roundUp'] 
			RETURN TMP_12387
	Function TestRebaseLibrary.toElastic(Rebase,uint256,bool) (*)
		Expression: total.toElastic(base,roundUp)
		IRs:
			TMP_12388(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toElastic(Rebase,uint256,bool), arguments:['total', 'base', 'roundUp'] 
			RETURN TMP_12388
Contract LeverageTest
	Function UseLeverage._calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: nrLoops > MAX_LOOPS
		IRs:
			TMP_12389(bool) = nrLoops > MAX_LOOPS
			CONDITION TMP_12389
		Expression: revert InvalidNumberOfLoops()()
		IRs:
			TMP_12390(None) = SOLIDITY_CALL revert InvalidNumberOfLoops()()
		Expression: loanToValue == 0 || loanToValue > PERCENTAGE_PRECISION
		IRs:
			TMP_12391(bool) = loanToValue == 0
			TMP_12392(bool) = loanToValue > PERCENTAGE_PRECISION
			TMP_12393(bool) = TMP_12391 || TMP_12392
			CONDITION TMP_12393
		Expression: revert InvalidLoanToValue()()
		IRs:
			TMP_12394(None) = SOLIDITY_CALL revert InvalidLoanToValue()()
		Expression: leverage = baseValue
		IRs:
			leverage(uint256) := baseValue(uint256)
		Expression: prev = baseValue
		IRs:
			prev(uint256) := baseValue(uint256)
		Expression: i = 1
		IRs:
			i(uint8) := 1(uint256)
		Expression: i <= nrLoops
		IRs:
			TMP_12395(bool) = i <= nrLoops
			CONDITION TMP_12395
		Expression: inc = (prev * loanToValue) / PERCENTAGE_PRECISION
		IRs:
			TMP_12396(uint256) = prev (c)* loanToValue
			TMP_12397(uint256) = TMP_12396 (c)/ PERCENTAGE_PRECISION
			inc(uint256) := TMP_12397(uint256)
		Expression: leverage += inc
		IRs:
			leverage(uint256) = leverage (c)+ inc
		Expression: prev = inc
		IRs:
			prev(uint256) := inc(uint256)
		Expression: ++ i
		IRs:
			i(uint8) = i + 1
		Expression: leverage
		IRs:
			RETURN leverage
	Function UseLeverage._calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: percentageToBurn == 0 || percentageToBurn > PERCENTAGE_PRECISION
		IRs:
			TMP_12398(bool) = percentageToBurn == 0
			TMP_12399(bool) = percentageToBurn > PERCENTAGE_PRECISION
			TMP_12400(bool) = TMP_12398 || TMP_12399
			CONDITION TMP_12400
		Expression: revert InvalidPercentageValue()()
		IRs:
			TMP_12401(None) = SOLIDITY_CALL revert InvalidPercentageValue()()
		Expression: deltaDebtInETH = (totalDebtBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_12402(uint256) = totalDebtBaseInEth (c)* percentageToBurn
			TMP_12403(uint256) = TMP_12402 (c)/ PERCENTAGE_PRECISION
			deltaDebtInETH(uint256) := TMP_12403(uint256)
		Expression: deltaCollateralInETH = (totalCollateralBaseInEth * percentageToBurn) / PERCENTAGE_PRECISION
		IRs:
			TMP_12404(uint256) = totalCollateralBaseInEth (c)* percentageToBurn
			TMP_12405(uint256) = TMP_12404 (c)/ PERCENTAGE_PRECISION
			deltaCollateralInETH(uint256) := TMP_12405(uint256)
	Function UseLeverage._calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: colValue = ((targetLoanToValue * collateral) / PERCENTAGE_PRECISION)
		IRs:
			TMP_12406(uint256) = targetLoanToValue (c)* collateral
			TMP_12407(uint256) = TMP_12406 (c)/ PERCENTAGE_PRECISION
			colValue(uint256) := TMP_12407(uint256)
		Expression: colValue >= debt
		IRs:
			TMP_12408(bool) = colValue >= debt
			CONDITION TMP_12408
		Expression: revert InvalidTargetValue()()
		IRs:
			TMP_12409(None) = SOLIDITY_CALL revert InvalidTargetValue()()
		Expression: numerator = debt - colValue
		IRs:
			TMP_12410(uint256) = debt (c)- colValue
			numerator(uint256) := TMP_12410(uint256)
		Expression: divisor = (PERCENTAGE_PRECISION - targetLoanToValue)
		IRs:
			TMP_12411(uint256) = PERCENTAGE_PRECISION (c)- targetLoanToValue
			divisor(uint256) := TMP_12411(uint256)
		Expression: divisor == 0
		IRs:
			TMP_12412(bool) = divisor == 0
			CONDITION TMP_12412
		Expression: revert InvalidDivisor()()
		IRs:
			TMP_12413(None) = SOLIDITY_CALL revert InvalidDivisor()()
		Expression: delta = (numerator * PERCENTAGE_PRECISION) / divisor
		IRs:
			TMP_12414(uint256) = numerator (c)* PERCENTAGE_PRECISION
			TMP_12415(uint256) = TMP_12414 (c)/ divisor
			delta(uint256) := TMP_12415(uint256)
	Function LeverageTest.calculateLeverageRatio(uint256,uint256,uint8) (*)
		Expression: _calculateLeverageRatio(baseValue,loanToValue,nrLoops)
		IRs:
			TMP_12416(uint256) = INTERNAL_CALL, UseLeverage._calculateLeverageRatio(uint256,uint256,uint8)(baseValue,loanToValue,nrLoops)
			RETURN TMP_12416
	Function LeverageTest.calcDeltaPosition(uint256,uint256,uint256) (*)
		Expression: _calcDeltaPosition(percentageToBurn,totalCollateralBaseInEth,totalDebtBaseInEth)
		IRs:
			TUPLE_165(uint256,uint256) = INTERNAL_CALL, UseLeverage._calcDeltaPosition(uint256,uint256,uint256)(percentageToBurn,totalCollateralBaseInEth,totalDebtBaseInEth)
			RETURN TUPLE_165
	Function LeverageTest.calculateDebtToPay(uint256,uint256,uint256) (*)
		Expression: _calculateDebtToPay(targetLoanToValue,collateral,debt)
		IRs:
			TMP_12417(uint256) = INTERNAL_CALL, UseLeverage._calculateDebtToPay(uint256,uint256,uint256)(targetLoanToValue,collateral,debt)
			RETURN TMP_12417
Contract RebaseLibraryTest
	Function RebaseLibraryTest.toBase(Rebase,uint256,bool) (*)
		Expression: total.toBase(elastic,roundUp)
		IRs:
			TMP_12418(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toBase(Rebase,uint256,bool), arguments:['total', 'elastic', 'roundUp'] 
			RETURN TMP_12418
	Function RebaseLibraryTest.toElastic(Rebase,uint256,bool) (*)
		Expression: total.toElastic(base,roundUp)
		IRs:
			TMP_12419(uint256) = LIBRARY_CALL, dest:RebaseLibrary, function:RebaseLibrary.toElastic(Rebase,uint256,bool), arguments:['total', 'base', 'roundUp'] 
			RETURN TMP_12419
Contract console
	Function console._sendLogPayloadImplementation(bytes) (*)
		Expression: consoleAddress = CONSOLE_ADDRESS
		IRs:
			consoleAddress(address) := CONSOLE_ADDRESS(address)
		Expression: pop(uint256)(staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),consoleAddress,payload + 32,mload(uint256)(payload),0,0))
		IRs:
			TMP_12420(uint256) = SOLIDITY_CALL gas()()
			TMP_12421(bytes) = payload + 32
			TMP_12422(uint256) = SOLIDITY_CALL mload(uint256)(payload)
			TMP_12423(uint256) = SOLIDITY_CALL staticcall(uint256,uint256,uint256,uint256,uint256,uint256)(TMP_12420,consoleAddress,TMP_12421,TMP_12422,0,0)
			TMP_12424(None) = SOLIDITY_CALL pop(uint256)(TMP_12423)
	Function console._castToPure(function(bytes)) (*)
		Expression: fnOut = fnIn
		IRs:
			fnOut(function(bytes)) := fnIn(function(bytes))
	Function console._sendLogPayload(bytes) (*)
		Expression: _castToPure(_sendLogPayloadImplementation)(payload)
		IRs:
			TMP_12425(function(bytes)) = INTERNAL_CALL, console._castToPure(function(bytes))(_sendLogPayloadImplementation)
			INTERNAL_DYNAMIC_CALL TMP_12425(payload)  
	Function console.log() (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log()))
		IRs:
			TMP_12427(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log())
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12427)
	Function console.logInt(int256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(int256),p0))
		IRs:
			TMP_12429(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(int256),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12429)
	Function console.logUint(uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256),p0))
		IRs:
			TMP_12431(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12431)
	Function console.logString(string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string),p0))
		IRs:
			TMP_12433(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12433)
	Function console.logBool(bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool),p0))
		IRs:
			TMP_12435(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12435)
	Function console.logAddress(address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address),p0))
		IRs:
			TMP_12437(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12437)
	Function console.logBytes(bytes) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes),p0))
		IRs:
			TMP_12439(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12439)
	Function console.logBytes1(bytes1) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes1),p0))
		IRs:
			TMP_12441(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes1),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12441)
	Function console.logBytes2(bytes2) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes2),p0))
		IRs:
			TMP_12443(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes2),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12443)
	Function console.logBytes3(bytes3) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes3),p0))
		IRs:
			TMP_12445(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes3),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12445)
	Function console.logBytes4(bytes4) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes4),p0))
		IRs:
			TMP_12447(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes4),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12447)
	Function console.logBytes5(bytes5) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes5),p0))
		IRs:
			TMP_12449(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes5),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12449)
	Function console.logBytes6(bytes6) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes6),p0))
		IRs:
			TMP_12451(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes6),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12451)
	Function console.logBytes7(bytes7) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes7),p0))
		IRs:
			TMP_12453(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes7),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12453)
	Function console.logBytes8(bytes8) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes8),p0))
		IRs:
			TMP_12455(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes8),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12455)
	Function console.logBytes9(bytes9) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes9),p0))
		IRs:
			TMP_12457(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes9),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12457)
	Function console.logBytes10(bytes10) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes10),p0))
		IRs:
			TMP_12459(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes10),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12459)
	Function console.logBytes11(bytes11) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes11),p0))
		IRs:
			TMP_12461(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes11),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12461)
	Function console.logBytes12(bytes12) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes12),p0))
		IRs:
			TMP_12463(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes12),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12463)
	Function console.logBytes13(bytes13) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes13),p0))
		IRs:
			TMP_12465(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes13),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12465)
	Function console.logBytes14(bytes14) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes14),p0))
		IRs:
			TMP_12467(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes14),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12467)
	Function console.logBytes15(bytes15) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes15),p0))
		IRs:
			TMP_12469(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes15),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12469)
	Function console.logBytes16(bytes16) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes16),p0))
		IRs:
			TMP_12471(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes16),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12471)
	Function console.logBytes17(bytes17) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes17),p0))
		IRs:
			TMP_12473(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes17),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12473)
	Function console.logBytes18(bytes18) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes18),p0))
		IRs:
			TMP_12475(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes18),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12475)
	Function console.logBytes19(bytes19) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes19),p0))
		IRs:
			TMP_12477(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes19),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12477)
	Function console.logBytes20(bytes20) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes20),p0))
		IRs:
			TMP_12479(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes20),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12479)
	Function console.logBytes21(bytes21) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes21),p0))
		IRs:
			TMP_12481(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes21),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12481)
	Function console.logBytes22(bytes22) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes22),p0))
		IRs:
			TMP_12483(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes22),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12483)
	Function console.logBytes23(bytes23) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes23),p0))
		IRs:
			TMP_12485(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes23),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12485)
	Function console.logBytes24(bytes24) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes24),p0))
		IRs:
			TMP_12487(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes24),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12487)
	Function console.logBytes25(bytes25) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes25),p0))
		IRs:
			TMP_12489(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes25),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12489)
	Function console.logBytes26(bytes26) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes26),p0))
		IRs:
			TMP_12491(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes26),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12491)
	Function console.logBytes27(bytes27) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes27),p0))
		IRs:
			TMP_12493(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes27),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12493)
	Function console.logBytes28(bytes28) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes28),p0))
		IRs:
			TMP_12495(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes28),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12495)
	Function console.logBytes29(bytes29) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes29),p0))
		IRs:
			TMP_12497(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes29),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12497)
	Function console.logBytes30(bytes30) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes30),p0))
		IRs:
			TMP_12499(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes30),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12499)
	Function console.logBytes31(bytes31) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes31),p0))
		IRs:
			TMP_12501(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes31),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12501)
	Function console.logBytes32(bytes32) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bytes32),p0))
		IRs:
			TMP_12503(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bytes32),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12503)
	Function console.log(uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256),p0))
		IRs:
			TMP_12505(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12505)
	Function console.log(string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string),p0))
		IRs:
			TMP_12507(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12507)
	Function console.log(bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool),p0))
		IRs:
			TMP_12509(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12509)
	Function console.log(address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address),p0))
		IRs:
			TMP_12511(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address),p0)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12511)
	Function console.log(uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256),p0,p1))
		IRs:
			TMP_12513(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12513)
	Function console.log(uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string),p0,p1))
		IRs:
			TMP_12515(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12515)
	Function console.log(uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool),p0,p1))
		IRs:
			TMP_12517(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12517)
	Function console.log(uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address),p0,p1))
		IRs:
			TMP_12519(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12519)
	Function console.log(string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256),p0,p1))
		IRs:
			TMP_12521(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12521)
	Function console.log(string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string),p0,p1))
		IRs:
			TMP_12523(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12523)
	Function console.log(string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool),p0,p1))
		IRs:
			TMP_12525(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12525)
	Function console.log(string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address),p0,p1))
		IRs:
			TMP_12527(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12527)
	Function console.log(bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256),p0,p1))
		IRs:
			TMP_12529(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12529)
	Function console.log(bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string),p0,p1))
		IRs:
			TMP_12531(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12531)
	Function console.log(bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool),p0,p1))
		IRs:
			TMP_12533(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12533)
	Function console.log(bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address),p0,p1))
		IRs:
			TMP_12535(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12535)
	Function console.log(address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256),p0,p1))
		IRs:
			TMP_12537(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12537)
	Function console.log(address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string),p0,p1))
		IRs:
			TMP_12539(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12539)
	Function console.log(address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool),p0,p1))
		IRs:
			TMP_12541(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12541)
	Function console.log(address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address),p0,p1))
		IRs:
			TMP_12543(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address),p0,p1)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12543)
	Function console.log(uint256,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,uint256),p0,p1,p2))
		IRs:
			TMP_12545(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12545)
	Function console.log(uint256,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,string),p0,p1,p2))
		IRs:
			TMP_12547(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12547)
	Function console.log(uint256,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,bool),p0,p1,p2))
		IRs:
			TMP_12549(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12549)
	Function console.log(uint256,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,address),p0,p1,p2))
		IRs:
			TMP_12551(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12551)
	Function console.log(uint256,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,uint256),p0,p1,p2))
		IRs:
			TMP_12553(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12553)
	Function console.log(uint256,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,string),p0,p1,p2))
		IRs:
			TMP_12555(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12555)
	Function console.log(uint256,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,bool),p0,p1,p2))
		IRs:
			TMP_12557(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12557)
	Function console.log(uint256,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,address),p0,p1,p2))
		IRs:
			TMP_12559(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12559)
	Function console.log(uint256,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,uint256),p0,p1,p2))
		IRs:
			TMP_12561(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12561)
	Function console.log(uint256,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,string),p0,p1,p2))
		IRs:
			TMP_12563(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12563)
	Function console.log(uint256,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,bool),p0,p1,p2))
		IRs:
			TMP_12565(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12565)
	Function console.log(uint256,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,address),p0,p1,p2))
		IRs:
			TMP_12567(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12567)
	Function console.log(uint256,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,uint256),p0,p1,p2))
		IRs:
			TMP_12569(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12569)
	Function console.log(uint256,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,string),p0,p1,p2))
		IRs:
			TMP_12571(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12571)
	Function console.log(uint256,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,bool),p0,p1,p2))
		IRs:
			TMP_12573(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12573)
	Function console.log(uint256,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,address),p0,p1,p2))
		IRs:
			TMP_12575(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12575)
	Function console.log(string,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,uint256),p0,p1,p2))
		IRs:
			TMP_12577(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12577)
	Function console.log(string,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,string),p0,p1,p2))
		IRs:
			TMP_12579(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12579)
	Function console.log(string,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,bool),p0,p1,p2))
		IRs:
			TMP_12581(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12581)
	Function console.log(string,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,address),p0,p1,p2))
		IRs:
			TMP_12583(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12583)
	Function console.log(string,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,uint256),p0,p1,p2))
		IRs:
			TMP_12585(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12585)
	Function console.log(string,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,string),p0,p1,p2))
		IRs:
			TMP_12587(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12587)
	Function console.log(string,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,bool),p0,p1,p2))
		IRs:
			TMP_12589(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12589)
	Function console.log(string,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,address),p0,p1,p2))
		IRs:
			TMP_12591(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12591)
	Function console.log(string,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,uint256),p0,p1,p2))
		IRs:
			TMP_12593(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12593)
	Function console.log(string,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,string),p0,p1,p2))
		IRs:
			TMP_12595(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12595)
	Function console.log(string,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,bool),p0,p1,p2))
		IRs:
			TMP_12597(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12597)
	Function console.log(string,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,address),p0,p1,p2))
		IRs:
			TMP_12599(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12599)
	Function console.log(string,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,uint256),p0,p1,p2))
		IRs:
			TMP_12601(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12601)
	Function console.log(string,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,string),p0,p1,p2))
		IRs:
			TMP_12603(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12603)
	Function console.log(string,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,bool),p0,p1,p2))
		IRs:
			TMP_12605(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12605)
	Function console.log(string,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,address),p0,p1,p2))
		IRs:
			TMP_12607(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12607)
	Function console.log(bool,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,uint256),p0,p1,p2))
		IRs:
			TMP_12609(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12609)
	Function console.log(bool,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,string),p0,p1,p2))
		IRs:
			TMP_12611(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12611)
	Function console.log(bool,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,bool),p0,p1,p2))
		IRs:
			TMP_12613(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12613)
	Function console.log(bool,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,address),p0,p1,p2))
		IRs:
			TMP_12615(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12615)
	Function console.log(bool,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,uint256),p0,p1,p2))
		IRs:
			TMP_12617(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12617)
	Function console.log(bool,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,string),p0,p1,p2))
		IRs:
			TMP_12619(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12619)
	Function console.log(bool,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,bool),p0,p1,p2))
		IRs:
			TMP_12621(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12621)
	Function console.log(bool,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,address),p0,p1,p2))
		IRs:
			TMP_12623(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12623)
	Function console.log(bool,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,uint256),p0,p1,p2))
		IRs:
			TMP_12625(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12625)
	Function console.log(bool,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,string),p0,p1,p2))
		IRs:
			TMP_12627(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12627)
	Function console.log(bool,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,bool),p0,p1,p2))
		IRs:
			TMP_12629(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12629)
	Function console.log(bool,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,address),p0,p1,p2))
		IRs:
			TMP_12631(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12631)
	Function console.log(bool,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,uint256),p0,p1,p2))
		IRs:
			TMP_12633(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12633)
	Function console.log(bool,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,string),p0,p1,p2))
		IRs:
			TMP_12635(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12635)
	Function console.log(bool,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,bool),p0,p1,p2))
		IRs:
			TMP_12637(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12637)
	Function console.log(bool,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,address),p0,p1,p2))
		IRs:
			TMP_12639(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12639)
	Function console.log(address,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,uint256),p0,p1,p2))
		IRs:
			TMP_12641(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12641)
	Function console.log(address,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,string),p0,p1,p2))
		IRs:
			TMP_12643(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12643)
	Function console.log(address,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,bool),p0,p1,p2))
		IRs:
			TMP_12645(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12645)
	Function console.log(address,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,address),p0,p1,p2))
		IRs:
			TMP_12647(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12647)
	Function console.log(address,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,uint256),p0,p1,p2))
		IRs:
			TMP_12649(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12649)
	Function console.log(address,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,string),p0,p1,p2))
		IRs:
			TMP_12651(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12651)
	Function console.log(address,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,bool),p0,p1,p2))
		IRs:
			TMP_12653(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12653)
	Function console.log(address,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,address),p0,p1,p2))
		IRs:
			TMP_12655(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12655)
	Function console.log(address,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,uint256),p0,p1,p2))
		IRs:
			TMP_12657(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12657)
	Function console.log(address,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,string),p0,p1,p2))
		IRs:
			TMP_12659(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12659)
	Function console.log(address,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,bool),p0,p1,p2))
		IRs:
			TMP_12661(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12661)
	Function console.log(address,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,address),p0,p1,p2))
		IRs:
			TMP_12663(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12663)
	Function console.log(address,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,uint256),p0,p1,p2))
		IRs:
			TMP_12665(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,uint256),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12665)
	Function console.log(address,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,string),p0,p1,p2))
		IRs:
			TMP_12667(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,string),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12667)
	Function console.log(address,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,bool),p0,p1,p2))
		IRs:
			TMP_12669(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,bool),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12669)
	Function console.log(address,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,address),p0,p1,p2))
		IRs:
			TMP_12671(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,address),p0,p1,p2)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12671)
	Function console.log(uint256,uint256,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12673(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12673)
	Function console.log(uint256,uint256,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12675(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12675)
	Function console.log(uint256,uint256,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12677(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12677)
	Function console.log(uint256,uint256,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12679(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12679)
	Function console.log(uint256,uint256,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12681(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12681)
	Function console.log(uint256,uint256,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12683(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12683)
	Function console.log(uint256,uint256,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12685(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12685)
	Function console.log(uint256,uint256,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12687(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12687)
	Function console.log(uint256,uint256,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12689(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12689)
	Function console.log(uint256,uint256,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12691(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12691)
	Function console.log(uint256,uint256,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12693(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12693)
	Function console.log(uint256,uint256,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12695(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12695)
	Function console.log(uint256,uint256,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12697(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12697)
	Function console.log(uint256,uint256,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12699(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12699)
	Function console.log(uint256,uint256,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12701(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12701)
	Function console.log(uint256,uint256,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,uint256,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12703(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,uint256,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12703)
	Function console.log(uint256,string,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12705(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12705)
	Function console.log(uint256,string,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12707(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12707)
	Function console.log(uint256,string,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12709(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12709)
	Function console.log(uint256,string,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12711(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12711)
	Function console.log(uint256,string,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12713(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12713)
	Function console.log(uint256,string,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12715(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12715)
	Function console.log(uint256,string,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12717(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12717)
	Function console.log(uint256,string,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12719(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12719)
	Function console.log(uint256,string,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12721(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12721)
	Function console.log(uint256,string,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12723(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12723)
	Function console.log(uint256,string,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12725(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12725)
	Function console.log(uint256,string,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12727(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12727)
	Function console.log(uint256,string,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12729(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12729)
	Function console.log(uint256,string,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12731(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12731)
	Function console.log(uint256,string,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12733(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12733)
	Function console.log(uint256,string,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,string,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12735(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,string,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12735)
	Function console.log(uint256,bool,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12737(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12737)
	Function console.log(uint256,bool,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12739(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12739)
	Function console.log(uint256,bool,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12741(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12741)
	Function console.log(uint256,bool,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12743(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12743)
	Function console.log(uint256,bool,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12745(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12745)
	Function console.log(uint256,bool,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12747(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12747)
	Function console.log(uint256,bool,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12749(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12749)
	Function console.log(uint256,bool,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12751(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12751)
	Function console.log(uint256,bool,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12753(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12753)
	Function console.log(uint256,bool,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12755(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12755)
	Function console.log(uint256,bool,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12757(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12757)
	Function console.log(uint256,bool,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12759(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12759)
	Function console.log(uint256,bool,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12761(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12761)
	Function console.log(uint256,bool,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12763(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12763)
	Function console.log(uint256,bool,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12765(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12765)
	Function console.log(uint256,bool,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,bool,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12767(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,bool,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12767)
	Function console.log(uint256,address,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12769(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12769)
	Function console.log(uint256,address,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12771(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12771)
	Function console.log(uint256,address,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12773(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12773)
	Function console.log(uint256,address,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12775(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12775)
	Function console.log(uint256,address,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12777(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12777)
	Function console.log(uint256,address,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12779(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12779)
	Function console.log(uint256,address,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12781(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12781)
	Function console.log(uint256,address,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12783(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12783)
	Function console.log(uint256,address,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12785(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12785)
	Function console.log(uint256,address,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12787(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12787)
	Function console.log(uint256,address,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12789(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12789)
	Function console.log(uint256,address,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12791(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12791)
	Function console.log(uint256,address,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12793(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12793)
	Function console.log(uint256,address,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12795(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12795)
	Function console.log(uint256,address,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12797(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12797)
	Function console.log(uint256,address,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(uint256,address,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12799(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(uint256,address,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12799)
	Function console.log(string,uint256,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12801(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12801)
	Function console.log(string,uint256,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12803(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12803)
	Function console.log(string,uint256,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12805(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12805)
	Function console.log(string,uint256,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12807(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12807)
	Function console.log(string,uint256,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12809(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12809)
	Function console.log(string,uint256,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12811(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12811)
	Function console.log(string,uint256,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12813(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12813)
	Function console.log(string,uint256,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12815(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12815)
	Function console.log(string,uint256,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12817(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12817)
	Function console.log(string,uint256,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12819(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12819)
	Function console.log(string,uint256,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12821(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12821)
	Function console.log(string,uint256,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12823(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12823)
	Function console.log(string,uint256,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12825(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12825)
	Function console.log(string,uint256,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12827(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12827)
	Function console.log(string,uint256,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12829(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12829)
	Function console.log(string,uint256,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,uint256,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12831(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,uint256,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12831)
	Function console.log(string,string,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12833(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12833)
	Function console.log(string,string,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12835(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12835)
	Function console.log(string,string,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12837(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12837)
	Function console.log(string,string,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12839(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12839)
	Function console.log(string,string,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12841(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12841)
	Function console.log(string,string,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12843(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12843)
	Function console.log(string,string,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12845(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12845)
	Function console.log(string,string,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12847(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12847)
	Function console.log(string,string,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12849(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12849)
	Function console.log(string,string,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12851(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12851)
	Function console.log(string,string,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12853(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12853)
	Function console.log(string,string,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12855(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12855)
	Function console.log(string,string,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12857(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12857)
	Function console.log(string,string,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12859(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12859)
	Function console.log(string,string,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12861(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12861)
	Function console.log(string,string,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,string,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12863(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,string,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12863)
	Function console.log(string,bool,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12865(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12865)
	Function console.log(string,bool,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12867(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12867)
	Function console.log(string,bool,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12869(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12869)
	Function console.log(string,bool,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12871(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12871)
	Function console.log(string,bool,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12873(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12873)
	Function console.log(string,bool,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12875(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12875)
	Function console.log(string,bool,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12877(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12877)
	Function console.log(string,bool,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12879(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12879)
	Function console.log(string,bool,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12881(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12881)
	Function console.log(string,bool,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12883(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12883)
	Function console.log(string,bool,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12885(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12885)
	Function console.log(string,bool,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12887(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12887)
	Function console.log(string,bool,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12889(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12889)
	Function console.log(string,bool,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12891(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12891)
	Function console.log(string,bool,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12893(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12893)
	Function console.log(string,bool,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,bool,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12895(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,bool,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12895)
	Function console.log(string,address,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12897(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12897)
	Function console.log(string,address,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12899(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12899)
	Function console.log(string,address,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12901(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12901)
	Function console.log(string,address,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12903(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12903)
	Function console.log(string,address,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12905(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12905)
	Function console.log(string,address,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12907(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12907)
	Function console.log(string,address,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12909(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12909)
	Function console.log(string,address,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12911(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12911)
	Function console.log(string,address,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12913(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12913)
	Function console.log(string,address,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12915(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12915)
	Function console.log(string,address,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12917(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12917)
	Function console.log(string,address,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12919(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12919)
	Function console.log(string,address,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12921(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12921)
	Function console.log(string,address,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12923(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12923)
	Function console.log(string,address,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12925(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12925)
	Function console.log(string,address,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(string,address,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12927(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(string,address,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12927)
	Function console.log(bool,uint256,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12929(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12929)
	Function console.log(bool,uint256,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12931(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12931)
	Function console.log(bool,uint256,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12933(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12933)
	Function console.log(bool,uint256,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12935(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12935)
	Function console.log(bool,uint256,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12937(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12937)
	Function console.log(bool,uint256,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12939(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12939)
	Function console.log(bool,uint256,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12941(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12941)
	Function console.log(bool,uint256,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12943(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12943)
	Function console.log(bool,uint256,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12945(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12945)
	Function console.log(bool,uint256,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12947(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12947)
	Function console.log(bool,uint256,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12949(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12949)
	Function console.log(bool,uint256,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12951(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12951)
	Function console.log(bool,uint256,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12953(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12953)
	Function console.log(bool,uint256,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12955(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12955)
	Function console.log(bool,uint256,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12957(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12957)
	Function console.log(bool,uint256,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,uint256,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12959(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,uint256,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12959)
	Function console.log(bool,string,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12961(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12961)
	Function console.log(bool,string,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12963(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12963)
	Function console.log(bool,string,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12965(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12965)
	Function console.log(bool,string,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12967(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12967)
	Function console.log(bool,string,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12969(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12969)
	Function console.log(bool,string,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,string,string),p0,p1,p2,p3))
		IRs:
			TMP_12971(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12971)
	Function console.log(bool,string,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_12973(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12973)
	Function console.log(bool,string,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,string,address),p0,p1,p2,p3))
		IRs:
			TMP_12975(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12975)
	Function console.log(bool,string,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12977(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12977)
	Function console.log(bool,string,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_12979(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12979)
	Function console.log(bool,string,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_12981(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12981)
	Function console.log(bool,string,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_12983(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12983)
	Function console.log(bool,string,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12985(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12985)
	Function console.log(bool,string,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,address,string),p0,p1,p2,p3))
		IRs:
			TMP_12987(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12987)
	Function console.log(bool,string,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_12989(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12989)
	Function console.log(bool,string,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,string,address,address),p0,p1,p2,p3))
		IRs:
			TMP_12991(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,string,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12991)
	Function console.log(bool,bool,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_12993(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12993)
	Function console.log(bool,bool,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_12995(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12995)
	Function console.log(bool,bool,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_12997(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12997)
	Function console.log(bool,bool,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_12999(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_12999)
	Function console.log(bool,bool,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13001(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13001)
	Function console.log(bool,bool,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13003(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13003)
	Function console.log(bool,bool,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13005(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13005)
	Function console.log(bool,bool,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13007(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13007)
	Function console.log(bool,bool,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13009(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13009)
	Function console.log(bool,bool,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13011(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13011)
	Function console.log(bool,bool,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13013(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13013)
	Function console.log(bool,bool,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13015(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13015)
	Function console.log(bool,bool,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13017(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13017)
	Function console.log(bool,bool,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13019(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13019)
	Function console.log(bool,bool,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13021(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13021)
	Function console.log(bool,bool,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,bool,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13023(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,bool,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13023)
	Function console.log(bool,address,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13025(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13025)
	Function console.log(bool,address,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_13027(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13027)
	Function console.log(bool,address,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_13029(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13029)
	Function console.log(bool,address,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_13031(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13031)
	Function console.log(bool,address,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13033(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13033)
	Function console.log(bool,address,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13035(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13035)
	Function console.log(bool,address,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13037(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13037)
	Function console.log(bool,address,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13039(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13039)
	Function console.log(bool,address,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13041(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13041)
	Function console.log(bool,address,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13043(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13043)
	Function console.log(bool,address,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13045(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13045)
	Function console.log(bool,address,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13047(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13047)
	Function console.log(bool,address,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13049(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13049)
	Function console.log(bool,address,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13051(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13051)
	Function console.log(bool,address,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13053(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13053)
	Function console.log(bool,address,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(bool,address,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13055(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(bool,address,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13055)
	Function console.log(address,uint256,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13057(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13057)
	Function console.log(address,uint256,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_13059(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13059)
	Function console.log(address,uint256,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_13061(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13061)
	Function console.log(address,uint256,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_13063(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13063)
	Function console.log(address,uint256,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13065(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13065)
	Function console.log(address,uint256,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13067(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13067)
	Function console.log(address,uint256,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13069(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13069)
	Function console.log(address,uint256,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13071(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13071)
	Function console.log(address,uint256,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13073(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13073)
	Function console.log(address,uint256,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13075(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13075)
	Function console.log(address,uint256,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13077(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13077)
	Function console.log(address,uint256,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13079(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13079)
	Function console.log(address,uint256,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13081(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13081)
	Function console.log(address,uint256,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13083(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13083)
	Function console.log(address,uint256,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13085(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13085)
	Function console.log(address,uint256,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,uint256,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13087(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,uint256,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13087)
	Function console.log(address,string,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13089(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13089)
	Function console.log(address,string,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_13091(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13091)
	Function console.log(address,string,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_13093(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13093)
	Function console.log(address,string,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_13095(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13095)
	Function console.log(address,string,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13097(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13097)
	Function console.log(address,string,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13099(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13099)
	Function console.log(address,string,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13101(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13101)
	Function console.log(address,string,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13103(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13103)
	Function console.log(address,string,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13105(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13105)
	Function console.log(address,string,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13107(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13107)
	Function console.log(address,string,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13109(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13109)
	Function console.log(address,string,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13111(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13111)
	Function console.log(address,string,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13113(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13113)
	Function console.log(address,string,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13115(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13115)
	Function console.log(address,string,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13117(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13117)
	Function console.log(address,string,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,string,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13119(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,string,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13119)
	Function console.log(address,bool,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13121(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13121)
	Function console.log(address,bool,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_13123(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13123)
	Function console.log(address,bool,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_13125(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13125)
	Function console.log(address,bool,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_13127(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13127)
	Function console.log(address,bool,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13129(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13129)
	Function console.log(address,bool,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13131(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13131)
	Function console.log(address,bool,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13133(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13133)
	Function console.log(address,bool,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13135(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13135)
	Function console.log(address,bool,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13137(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13137)
	Function console.log(address,bool,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13139(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13139)
	Function console.log(address,bool,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13141(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13141)
	Function console.log(address,bool,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13143(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13143)
	Function console.log(address,bool,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13145(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13145)
	Function console.log(address,bool,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13147(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13147)
	Function console.log(address,bool,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13149(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13149)
	Function console.log(address,bool,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,bool,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13151(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,bool,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13151)
	Function console.log(address,address,uint256,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,uint256,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13153(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,uint256,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13153)
	Function console.log(address,address,uint256,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,uint256,string),p0,p1,p2,p3))
		IRs:
			TMP_13155(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,uint256,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13155)
	Function console.log(address,address,uint256,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,uint256,bool),p0,p1,p2,p3))
		IRs:
			TMP_13157(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,uint256,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13157)
	Function console.log(address,address,uint256,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,uint256,address),p0,p1,p2,p3))
		IRs:
			TMP_13159(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,uint256,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13159)
	Function console.log(address,address,string,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,string,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13161(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,string,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13161)
	Function console.log(address,address,string,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,string,string),p0,p1,p2,p3))
		IRs:
			TMP_13163(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,string,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13163)
	Function console.log(address,address,string,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,string,bool),p0,p1,p2,p3))
		IRs:
			TMP_13165(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,string,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13165)
	Function console.log(address,address,string,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,string,address),p0,p1,p2,p3))
		IRs:
			TMP_13167(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,string,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13167)
	Function console.log(address,address,bool,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,bool,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13169(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,bool,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13169)
	Function console.log(address,address,bool,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,bool,string),p0,p1,p2,p3))
		IRs:
			TMP_13171(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,bool,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13171)
	Function console.log(address,address,bool,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,bool,bool),p0,p1,p2,p3))
		IRs:
			TMP_13173(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,bool,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13173)
	Function console.log(address,address,bool,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,bool,address),p0,p1,p2,p3))
		IRs:
			TMP_13175(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,bool,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13175)
	Function console.log(address,address,address,uint256) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,address,uint256),p0,p1,p2,p3))
		IRs:
			TMP_13177(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,address,uint256),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13177)
	Function console.log(address,address,address,string) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,address,string),p0,p1,p2,p3))
		IRs:
			TMP_13179(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,address,string),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13179)
	Function console.log(address,address,address,bool) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,address,bool),p0,p1,p2,p3))
		IRs:
			TMP_13181(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,address,bool),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13181)
	Function console.log(address,address,address,address) (*)
		Expression: _sendLogPayload(abi.encodeWithSignature(log(address,address,address,address),p0,p1,p2,p3))
		IRs:
			TMP_13183(bytes) = SOLIDITY_CALL abi.encodeWithSignature()(log(address,address,address,address),p0,p1,p2,p3)
			INTERNAL_CALL, console._sendLogPayload(bytes)(TMP_13183)
	Function console.slitherConstructorConstantVariables() (*)
		Expression: CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67
		IRs:
			CONSOLE_ADDRESS(address) := 120209876281281145568259943(address)

INFO:Slither:. analyzed (215 contracts)
