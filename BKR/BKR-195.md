# BKR-195 分析报告

## 基本信息
- **编号**: BKR-195
- **标题**: _deployedAmount not updated on StrategySupplyBase.undeploy, preventing performance fees from being collected - F6
- **发现时间**: 2025-01-09
- **修复时间**: 2025-01-09 (f99edb1)
- **性质**: **安全漏洞** (通过模糊测试F6发现)
- **严重程度**: **高** - 影响性能费用收集

## 漏洞描述
BKR-195 是一个严重的安全漏洞，在StrategySupplyBase.undeploy函数中，`_deployedAmount`状态变量没有正确更新，导致性能费用无法正确计算和收集。

## 在81485a9中的漏洞状态
### 漏洞位置
在 `b-pre-mitigation (81485a9)` 版本中，StrategySupplyAAVEv3.sol的undeploy函数存在漏洞：

```solidity
// 81485a9版本中的漏洞代码
function undeploy(uint256 amount) external nonReentrant onlyOwner returns (uint256 undeployedAmount) {
  if (amount == 0) revert ZeroAmount();
  
  // Get Balance
  uint256 balance = getBalance();
  if (amount > balance) revert InsufficientBalance();
  
  // Transfer assets back to caller
  uint256 withdrawalValue = _aavev3.withdraw(_asset, amount, address(this));
  
  // Check withdrawal value matches the initial amount
  if (withdrawalValue != amount) revert WithdrawalValueMismatch();
  
  // Transfer assets to user
  ERC20(_asset).safeTransfer(msg.sender, amount);
  
  balance -= amount;
  emit StrategyUndeploy(msg.sender, amount);
  emit StrategyAmountUpdate(balance);
  
  return amount;
  // ❌ 缺少: _deployedAmount -= withdrawalValue;
}
```

### 漏洞影响
1. **性能费用计算错误**: `_deployedAmount`没有减少，导致性能费用计算基于错误的基数
2. **状态不一致**: 内部状态与实际部署金额不匹配
3. **费用收集问题**: 可能导致性能费用无法正确收集
4. **会计错误**: 策略的账面价值与实际价值不符

### 漏洞根因
- **状态更新缺失**: undeploy函数没有更新`_deployedAmount`状态变量
- **设计缺陷**: 在提取资产后没有相应减少已部署金额的跟踪

## 修复方案 (f99edb1)
### 1. 创建StrategySupplyBase基类
- **新增文件**: `contracts/core/strategies/StrategySupplyBase.sol`
- **功能**: 提供供应策略的通用基类，包含正确的状态管理

### 2. 修复undeploy函数
```solidity
// 修复后的代码 (f99edb1)
function undeploy(uint256 amount) external nonReentrant onlyOwner returns (uint256 undeployedAmount) {
  if (amount == 0) revert ZeroAmount();
  
  // Get Balance
  uint256 balance = getBalance();
  if (amount > balance) revert InsufficientBalance();
  
  // Transfer assets back to caller
  uint256 withdrawalValue = _undeploy(amount);
  
  // ✅ 修复: Update the deployed amount
  _deployedAmount -= withdrawalValue;
  
  // Check withdrawal value matches the initial amount
  // Transfer assets to user
  ERC20(_asset).safeTransfer(msg.sender, withdrawalValue);
  
  balance -= withdrawalValue;
  emit StrategyUndeploy(msg.sender, withdrawalValue);
  emit StrategyAmountUpdate(balance);
  
  return withdrawalValue;
}
```

### 3. 重构StrategySupplyAAVEv3
- **改进**: 从独立实现改为继承StrategySupplyBase
- **修复**: 使用基类的正确状态管理
- **统一**: 与其他供应策略保持一致的架构

## 修复提交详情
- **提交哈希**: 1662f58
- **PR**: #12
- **作者**: Chef Kenji, thesilph
- **文件变更**: 1个文件，+3行

### 具体修复
```diff
// Transfer assets back to caller
uint256 withdrawalValue = _undeploy(amount);

+// Update the deployed amount
+_deployedAmount -= withdrawalValue;

// Check withdrawal value matches the initial amount
// Transfer assets to user
ERC20(_asset).safeTransfer(msg.sender, withdrawalValue);
```

## 技术实现细节

### 漏洞机制分析
```solidity
// 漏洞场景示例
// 1. 用户部署 1000 USDC
_deployedAmount = 1000;

// 2. 用户提取 500 USDC
// ❌ 漏洞: _deployedAmount 仍然是 1000
// 正确应该是: _deployedAmount = 500

// 3. 性能费用计算
// ❌ 错误: 基于 1000 USDC 计算费用
// 正确: 应该基于 500 USDC 计算费用
```

### 修复后的正确流程
```solidity
// 修复后的正确流程
// 1. 用户部署 1000 USDC
_deployedAmount = 1000;

// 2. 用户提取 500 USDC
_deployedAmount -= 500; // ✅ 正确更新
_deployedAmount = 500;

// 3. 性能费用计算
// ✅ 正确: 基于 500 USDC 计算费用
```

## 影响评估
### 安全风险
- 🔴 **高严重性**: 影响性能费用收集机制
- 🔴 **财务影响**: 可能导致费用计算错误
- 🔴 **状态不一致**: 内部状态与实际状态不匹配
- 🔴 **用户损失**: 可能影响用户的收益计算

### 修复效果
- ✅ **状态一致性**: 正确更新`_deployedAmount`
- ✅ **费用计算**: 性能费用基于正确的基数计算
- ✅ **会计准确性**: 策略账面价值与实际价值一致
- ✅ **架构改进**: 通过基类统一状态管理

## 测试验证
### 模糊测试发现
- **测试工具**: F6 (模糊测试)
- **发现方式**: 通过随机输入发现状态不一致
- **测试场景**: 多次部署和提取操作

### 修复验证
```solidity
// 测试用例
function testUndeployUpdatesDeployedAmount() public {
  // 1. 部署资产
  strategy.deploy(1000);
  assertEq(strategy.deployedAmount(), 1000);
  
  // 2. 提取资产
  strategy.undeploy(500);
  assertEq(strategy.deployedAmount(), 500); // ✅ 修复后通过
  
  // 3. 验证性能费用计算
  // 应该基于 500 而不是 1000 计算
}
```

## 结论
BKR-195 是一个**严重的安全漏洞**，通过模糊测试F6发现。它影响性能费用的正确计算和收集，可能导致财务损失。修复通过正确更新`_deployedAmount`状态变量，确保了状态一致性和费用计算的准确性。

这个漏洞的修复体现了：
1. **状态管理的重要性**: 必须正确维护内部状态
2. **测试的价值**: 模糊测试能够发现边界情况
3. **架构设计**: 基类设计有助于统一状态管理
4. **代码审查**: 需要仔细检查状态更新逻辑

## 相关文件
- `contracts/core/strategies/StrategySupplyBase.sol` (新增基类)
- `contracts/core/strategies/StrategySupplyAAVEv3.sol` (重构)
- `contracts/core/strategies/StrategySupplyMorpho.sol` (相关)
- `contracts/core/strategies/StrategySupplyERC4626.sol` (相关)
