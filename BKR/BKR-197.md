# BKR-197 分析报告

## 基本信息
- **编号**: BKR-197
- **标题**: decimals conversions There are multiple issues with the decimal conversions between the vault and the strategy - F13
- **发现时间**: 2025-01-16
- **修复时间**: 2025-01-16 (f99edb1)
- **性质**: **安全漏洞** (通过模糊测试F13发现)
- **严重程度**: **高** - 影响精度计算和资金安全

## 漏洞描述
BKR-197 是一个严重的安全漏洞，涉及金库和策略之间的精度转换问题。硬编码的18位精度假设导致不同精度代币之间的计算错误，可能造成资金损失。

## 在81485a9中的漏洞状态
### 漏洞位置
在 `b-pre-mitigation (81485a9)` 版本中，存在以下精度转换问题：

#### 1. 硬编码精度问题
```solidity
// 81485a9版本中的漏洞代码
uint8 constant SYSTEM_DECIMALS = 18; // ❌ 硬编码18位精度

// StrategySupplyAAVEv3.sol中的问题
function getBalance() public view virtual returns (uint256) {
  DataTypes.ReserveData memory reserve = (_aavev3.getReserveData(_asset));
  uint8 reserveDecimals = ERC20(reserve.aTokenAddress).decimals();
  uint256 reserveBalance = ERC20(reserve.aTokenAddress).balanceOf(address(this));
  
  // ❌ 强制转换为18位精度
  reserveBalance = reserveBalance.toDecimals(reserveDecimals, SYSTEM_DECIMALS);
  return reserveBalance;
}
```

#### 2. 金库精度假设问题
```solidity
// 81485a9版本中假设所有代币都是18位精度
uint256 private constant _ONE = 1e18; // ❌ 硬编码18位精度

function tokenPerAsset() public view returns (uint256) {
  uint256 totalAssetsValue = totalAssets();
  
  if (totalSupply() == 0 || totalAssetsValue == 0) {
    return _ONE; // ❌ 使用硬编码的1e18
  }
  
  return (totalSupply() * _ONE) / totalAssetsValue; // ❌ 精度不匹配
}
```

### 漏洞影响
1. **精度损失**: 不同精度代币之间的转换导致精度损失
2. **计算错误**: 基于错误精度的计算可能导致资金损失
3. **代币兼容性**: 不支持非18位精度的代币（如USDC 6位精度）
4. **状态不一致**: 金库和策略之间的精度不匹配

### 漏洞根因
- **硬编码精度**: 假设所有代币都是18位精度
- **缺乏动态精度**: 没有根据实际代币精度进行动态调整
- **转换错误**: 强制转换到18位精度导致精度损失

## 修复方案 (f99edb1)
### 1. 移除硬编码精度常量
```solidity
// 修复前 (81485a9)
uint8 constant SYSTEM_DECIMALS = 18; // ❌ 硬编码

// 修复后 (f99edb1)
// ✅ 移除硬编码常量，使用动态精度
```

### 2. 动态精度计算
```solidity
// 修复后的VaultBase.sol
function decimals() public view override(ERC20Upgradeable, IERC20MetadataUpgradeable) returns (uint8) {
  return ERC20Upgradeable(_asset()).decimals(); // ✅ 动态获取代币精度
}

function _ONE() private view returns (uint256) {
  return 10 ** decimals(); // ✅ 基于实际精度计算
}

function tokenPerAsset() public view returns (uint256) {
  uint256 totalAssetsValue = totalAssets();
  
  if (totalSupply() == 0 || totalAssetsValue == 0) {
    return _ONE(); // ✅ 使用动态精度
  }
  
  return (totalSupply() * _ONE()) / totalAssetsValue; // ✅ 精度匹配
}
```

### 3. 策略精度修复
```solidity
// 修复后的StrategySupplyAAVEv3.sol
function _getBalance() internal view virtual override returns (uint256) {
  DataTypes.ReserveData memory reserve = (_aavev3.getReserveData(_asset));
  return ERC20(reserve.aTokenAddress).balanceOf(address(this)); // ✅ 直接返回，不强制转换
}
```

### 4. 架构重构
- **创建VaultBase基类**: 统一精度处理逻辑
- **策略基类**: StrategySupplyBase提供统一的精度管理
- **动态精度**: 所有计算基于实际代币精度

## 修复提交详情
- **提交哈希**: 0a356c2
- **PR**: #24
- **作者**: Chef Kenji
- **文件变更**: 11个文件，+303行，-33行

### 核心文件变更
```
contracts/core/Constants.sol                       | 移除SYSTEM_DECIMALS
contracts/core/VaultBase.sol                       | 添加动态精度支持
contracts/core/strategies/StrategySupplyAAVEv3.sol | 移除强制精度转换
contracts/core/strategies/StrategyLeverage.sol     | 精度修复
contracts/core/strategies/StrategySwapAnd.sol      | 精度修复
```

## 技术实现细节

### 漏洞场景示例
```solidity
// 漏洞场景：USDC (6位精度) 与 ETH (18位精度) 混合
// 1. 用户存入 1000 USDC (6位精度)
uint256 usdcAmount = 1000 * 10**6; // 1000000000

// 2. 错误转换到18位精度
uint256 convertedAmount = usdcAmount.toDecimals(6, 18); // 1000000000000000000000
// ❌ 错误：实际应该是 1000 USDC，但被转换为 1000 ETH 等值

// 3. 计算错误
uint256 tokenPerAsset = (totalSupply() * 1e18) / totalAssetsValue;
// ❌ 基于错误精度计算，导致用户损失
```

### 修复后的正确流程
```solidity
// 修复后的正确流程
// 1. 用户存入 1000 USDC (6位精度)
uint256 usdcAmount = 1000 * 10**6; // 1000000000

// 2. 保持原始精度
uint256 balance = ERC20(usdcToken).balanceOf(address(this)); // 1000000000
// ✅ 正确：保持USDC的6位精度

// 3. 基于实际精度计算
uint256 tokenPerAsset = (totalSupply() * 10**decimals()) / totalAssetsValue;
// ✅ 正确：基于USDC的6位精度计算
```

## 影响评估
### 安全风险
- 🔴 **高严重性**: 影响资金计算和用户收益
- 🔴 **精度损失**: 可能导致用户资金损失
- 🔴 **代币兼容性**: 不支持非18位精度代币
- 🔴 **计算错误**: 基于错误精度的所有计算

### 修复效果
- ✅ **动态精度**: 支持任意精度的代币
- ✅ **计算准确性**: 基于实际代币精度计算
- ✅ **代币兼容性**: 支持USDC、USDT等非18位精度代币
- ✅ **架构统一**: 通过基类统一精度处理

## 测试验证
### 模糊测试发现
- **测试工具**: F13 (模糊测试)
- **发现方式**: 通过不同精度代币的随机操作发现计算错误
- **测试场景**: 混合精度代币的存款、提取、计算操作

### 修复验证
```solidity
// 测试用例
function testDecimalsConversion() public {
  // 1. 测试USDC (6位精度)
  vault.deposit(1000 * 10**6, user1);
  assertEq(vault.balanceOf(user1), 1000 * 10**6); // ✅ 保持6位精度
  
  // 2. 测试ETH (18位精度)
  vault.deposit(1 * 10**18, user2);
  assertEq(vault.balanceOf(user2), 1 * 10**18); // ✅ 保持18位精度
  
  // 3. 验证计算准确性
  uint256 tokenPerAsset = vault.tokenPerAsset();
  // 应该基于实际代币精度计算，而不是硬编码18位
}
```

## 结论
BKR-197 是一个**严重的安全漏洞**，通过模糊测试F13发现。它影响不同精度代币之间的计算准确性，可能导致用户资金损失。修复通过移除硬编码精度假设，实现动态精度计算，确保了计算的准确性和代币的兼容性。

这个漏洞的修复体现了：
1. **精度处理的重要性**: 必须正确处理不同精度代币
2. **硬编码的风险**: 避免硬编码假设，使用动态值
3. **测试的价值**: 模糊测试能够发现边界情况
4. **架构设计**: 基类设计有助于统一精度处理

## 相关文件
- `contracts/core/VaultBase.sol` (动态精度支持)
- `contracts/core/Constants.sol` (移除硬编码常量)
- `contracts/core/strategies/StrategySupplyAAVEv3.sol` (精度修复)
- `contracts/core/strategies/StrategySupplyBase.sol` (基类)
- `contracts/core/strategies/StrategyLeverage.sol` (相关修复)
